[
    {
        "title": "Group Anagrams",
        "question_content": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n&nbsp;\nExample 1:\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\nExample 2:\nInput: strs = [\"\"]\nOutput: [[\"\"]]\nExample 3:\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n&nbsp;\nConstraints:\n\n\t1 <= strs.length <= 104\n\t0 <= strs[i].length <= 100\n\tstrs[i] consists of lowercase English letters.",
        "solutions": [
            {
                "id": 19200,
                "title": "c-unordered-map-and-counting-sort",
                "content": "Use an `unordered_map` to group the strings by their sorted counterparts. Use the sorted string as the key and all anagram strings as the value.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for (string s : strs) {\\n            string t = s; \\n            sort(t.begin(), t.end());\\n            mp[t].push_back(s);\\n        }\\n        vector<vector<string>> anagrams;\\n        for (auto p : mp) { \\n            anagrams.push_back(p.second);\\n        }\\n        return anagrams;\\n    }\\n};\\n```\\n\\nMoreover, since the string only contains lower-case alphabets, we can sort them using counting sort to improve the time complexity.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for (string s : strs) {\\n            mp[strSort(s)].push_back(s);\\n        }\\n        vector<vector<string>> anagrams;\\n        for (auto p : mp) { \\n            anagrams.push_back(p.second);\\n        }\\n        return anagrams;\\n    }\\nprivate:\\n    string strSort(string s) {\\n        int counter[26] = {0};\\n        for (char c : s) {\\n            counter[c - \\'a\\']++;\\n        }\\n        string t;\\n        for (int c = 0; c < 26; c++) {\\n            t += string(counter[c], c + \\'a\\');\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for (string s : strs) {\\n            string t = s; \\n            sort(t.begin(), t.end());\\n            mp[t].push_back(s);\\n        }\\n        vector<vector<string>> anagrams;\\n        for (auto p : mp) { \\n            anagrams.push_back(p.second);\\n        }\\n        return anagrams;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for (string s : strs) {\\n            mp[strSort(s)].push_back(s);\\n        }\\n        vector<vector<string>> anagrams;\\n        for (auto p : mp) { \\n            anagrams.push_back(p.second);\\n        }\\n        return anagrams;\\n    }\\nprivate:\\n    string strSort(string s) {\\n        int counter[26] = {0};\\n        for (char c : s) {\\n            counter[c - \\'a\\']++;\\n        }\\n        string t;\\n        for (int c = 0; c < 26; c++) {\\n            t += string(counter[c], c + \\'a\\');\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19176,
                "title": "share-my-short-java-solution",
                "content": "```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs == null || strs.length == 0) return new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ca = s.toCharArray();\\n            Arrays.sort(ca);\\n            String keyStr = String.valueOf(ca);\\n            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n```\\n\\nInstead of sorting, we can also build the key string in this way. Thanks @davidluoyes for pointing this out.\\n\\n```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs == null || strs.length == 0) return new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ca = new char[26];\\n            for (char c : s.toCharArray()) ca[c - \\'a\\']++;\\n            String keyStr = String.valueOf(ca);\\n            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs == null || strs.length == 0) return new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ca = s.toCharArray();\\n            Arrays.sort(ca);\\n            String keyStr = String.valueOf(ca);\\n            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n```\n```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs == null || strs.length == 0) return new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ca = new char[26];\\n            for (char c : s.toCharArray()) ca[c - \\'a\\']++;\\n            String keyStr = String.valueOf(ca);\\n            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3687735,
                "title": "beats-100-c-java-python-beginner-friendly",
                "content": "\\n# Intuition:\\n\\nThe intuition is to group words that are anagrams of each other together. Anagrams are words that have the `same` characters but in a `different` order.\\n\\n# Explanation:\\n\\nLet\\'s go through the code step by step using the example input `[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]` to understand how it works.\\n\\n1. **Initializing Variables**\\n    - We start by initializing an empty unordered map called `mp` (short for map), which will store the groups of anagrams.\\n\\n2. **Grouping Anagrams**\\nWe iterate through each word in the input vector `strs`. Let\\'s take the first word, \"eat\", as an example.\\n\\n    - **Sorting the Word**\\nWe create a string variable called `word` and assign it the value of the current word (\"eat\" in this case). \\n\\n        Next, we sort the characters in `word` using the `sort()` function. After sorting, `word` becomes \"aet\". \\n\\n    - **Grouping the Anagram**\\nWe insert `word` as the key into the `mp` unordered map using `mp[word]`, and we push the original word (\"eat\") into the vector associated with that key using `mp[word].push_back(x)`, where `x` is the current word.\\n\\n        Since \"aet\" is a unique sorted representation of all the anagrams, it serves as the key in the `mp` map, and the associated vector holds all the anagrams. \\n\\nFor the given example, the `mp` map would look like this after processing all the words:\\n```\\n{\\n  \"aet\": [\"eat\", \"tea\", \"ate\"],\\n  \"ant\": [\"tan\", \"nat\"],\\n  \"abt\": [\"bat\"]\\n}\\n```\\n\\n3. **Creating the Result**\\nWe initialize an empty vector called `ans` (short for answer) to store the final result.\\n\\n    - We iterate through each key-value pair in the `mp` map using a range-based for loop. For each pair, we push the vector of anagrams (`x.second`) into the `ans` vector.\\n\\nFor the given example, the `ans` vector would look like this:\\n```\\n[\\n  [\"eat\", \"tea\", \"ate\"],\\n  [\"tan\", \"nat\"],\\n  [\"bat\"]\\n]\\n```\\n\\n4. **Returning the Result**\\nWe return the `ans` vector, which contains the groups of anagrams.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        \\n        for(auto x: strs){\\n            string word = x;\\n            sort(word.begin(), word.end());\\n            mp[word].push_back(x);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        for(auto x: mp){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        for (String word : strs) {\\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            String sortedWord = new String(chars);\\n            \\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }\\n            \\n            map.get(sortedWord).add(word);\\n        }\\n        \\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        anagram_map = defaultdict(list)\\n        \\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            anagram_map[sorted_word].append(word)\\n        \\n        return list(anagram_map.values())\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/86270fe9-da59-416b-a22e-21b787b13712_1687773427.3564198.png)\\n\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\n10. [Valid Anagram](https://leetcode.com/problems/valid-anagram/solutions/3687854/3-methods-c-java-python-beginner-friendly/)\\n11. [Group Anagrams](https://leetcode.com/problems/group-anagrams/solutions/3687735/beats-100-c-java-python-beginner-friendly/)\\n12. **Practice them in a row for better understanding and please Upvote for more questions.**\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n{\\n  \"aet\": [\"eat\", \"tea\", \"ate\"],\\n  \"ant\": [\"tan\", \"nat\"],\\n  \"abt\": [\"bat\"]\\n}\\n```\n```\\n[\\n  [\"eat\", \"tea\", \"ate\"],\\n  [\"tan\", \"nat\"],\\n  [\"bat\"]\\n]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        \\n        for(auto x: strs){\\n            string word = x;\\n            sort(word.begin(), word.end());\\n            mp[word].push_back(x);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        for(auto x: mp){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        for (String word : strs) {\\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            String sortedWord = new String(chars);\\n            \\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }\\n            \\n            map.get(sortedWord).add(word);\\n        }\\n        \\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        anagram_map = defaultdict(list)\\n        \\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            anagram_map[sorted_word].append(word)\\n        \\n        return list(anagram_map.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19202,
                "title": "5-line-python-solution-easy-to-understand",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        letters_to_words = defaultdict(list)\\n        for word in strs:\\n            letters_to_words[tuple(sorted(word))].append(word)\\n        return list(letters_to_words.values())\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        letters_to_words = defaultdict(list)\\n        for word in strs:\\n            letters_to_words[tuple(sorted(word))].append(word)\\n        return list(letters_to_words.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750590,
                "title": "simple-c-detailed-explanation-unordered-map-sorting",
                "content": "# \\t\\u2705 PLEASE UPVOTE IF YOU LIKE! \\u2705\\n```\\n\\t\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n       vector<vector<string>>ans;\\n        \\n       unordered_map<string, vector<string>>mp;\\n        \\n         /*\\n                Consider example 1 : strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\\n                \\n                After the below opeartion of for loop map will contain\\n                \\n                aet -- eat, tea, ate\\n                ant -- tan, nat\\n                abt -- bat\\n        */\\n        \\n        for(int i = 0 ; i < strs.size() ; i++)\\n        {\\n            string s = strs[i];\\n            sort(strs[i].begin(),strs[i].end());\\n            mp[strs[i]].push_back(s);\\n        }\\n        \\n        //now simply put the elements  of second column of map in ans\\n        \\n        for(auto i : mp)\\n        {\\n            ans.push_back(i.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\t\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n       vector<vector<string>>ans;\\n        \\n       unordered_map<string, vector<string>>mp;\\n        \\n         /*\\n                Consider example 1 : strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\\n                \\n                After the below opeartion of for loop map will contain\\n                \\n                aet -- eat, tea, ate\\n                ant -- tan, nat\\n                abt -- bat\\n        */\\n        \\n        for(int i = 0 ; i < strs.size() ; i++)\\n        {\\n            string s = strs[i];\\n            sort(strs[i].begin(),strs[i].end());\\n            mp[strs[i]].push_back(s);\\n        }\\n        \\n        //now simply put the elements  of second column of map in ans\\n        \\n        for(auto i : mp)\\n        {\\n            ans.push_back(i.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19233,
                "title": "o-m-n-algorithm-using-hash-without-sort",
                "content": "Assign a prime number for a to z, and then multiply all prime numbers together to form a hash value.\\n\\n\\n        \\n        private static final int[] PRIMES = new int[]{2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107};\\n        \\n        public List<String> anagrams(String[] strs) {\\n            List<String> list = new LinkedList<>();\\n            Map<Integer, List<String>> mapString = new HashMap<>();\\n            int result = -1;\\n            for (int i = 0; i < strs.length; i++){\\n                int mapping = 1;\\n                for (int j = 0, max = strs[i].length(); j < max; j++) {\\n                    mapping *= PRIMES[strs[i].charAt(j) - 'a'];\\n                }\\n                List<String> strings = mapString.get(mapping);\\n                if (strings == null) {\\n                    strings = new LinkedList<>();\\n                    mapString.put(mapping, strings);\\n                }\\n                strings.add(strs[i]);\\n            }\\n            for (List<String> mapList : mapString.values()){\\n                if (mapList.size() > 1)\\n                    list.addAll(mapList);\\n            }\\n            return list;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Assign a prime number for a to z, and then multiply all prime numbers together to form a hash value.\\n\\n\\n        \\n        private static final int[] PRIMES = new int[]{2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107};\\n        \\n        public List<String> anagrams(String[] strs) {\\n            List<String> list = new LinkedList<>();\\n            Map<Integer, List<String>> mapString = new HashMap<>();\\n            int result = -1;\\n            for (int i = 0; i < strs.length; i++){\\n                int mapping = 1;\\n                for (int j = 0, max = strs[i].length(); j < max; j++) {\\n                    mapping *= PRIMES[strs[i].charAt(j) - 'a'];\\n                }\\n                List<String> strings = mapString.get(mapping);\\n                if (strings == null) {\\n                    strings = new LinkedList<>();\\n                    mapString.put(mapping, strings);\\n                }\\n                strings.add(strs[i]);\\n            }\\n            for (List<String> mapList : mapString.values()){\\n                if (mapList.size() > 1)\\n                    list.addAll(mapList);\\n            }\\n            return list;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 834253,
                "title": "simple-and-short-c-solution-with-comments-beats-98-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        // Base case\\n\\t\\tif(strs.size() == 1)\\n            return {{strs[0]}};\\n        \\n        vector<vector<string>> ans;\\n        unordered_map<string, vector<string>> M;\\n        for(int  i = 0; i < strs.size(); i++)\\n        {\\n            string str = strs[i];\\n            sort(strs[i].begin(), strs[i].end()); // Sorting the string\\n            M[strs[i]].push_back(str);  // Sorted string is the key and the value is the initial string\\n        }\\n        for(auto i = M.begin(); i != M.end(); i++)\\n            ans.push_back(i -> second);  // Traversing the map and adding the vectors of string to ans\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        // Base case\\n\\t\\tif(strs.size() == 1)\\n            return {{strs[0]}};\\n        \\n        vector<vector<string>> ans;\\n        unordered_map<string, vector<string>> M;\\n        for(int  i = 0; i < strs.size(); i++)\\n        {\\n            string str = strs[i];\\n            sort(strs[i].begin(), strs[i].end()); // Sorting the string\\n            M[strs[i]].push_back(str);  // Sorted string is the key and the value is the initial string\\n        }\\n        for(auto i = M.begin(); i != M.end(); i++)\\n            ans.push_back(i -> second);  // Traversing the map and adding the vectors of string to ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384037,
                "title": "python-easily-understood-hash-table-fast-simple",
                "content": "**Appreciate if you could upvote this solution**\\n\\n\\nMethod: `Hash Table`\\n\\nSince the output needs to group the anagrams, it is suitable to use `dict` to store the different anagrams.\\nThus, we need to find a common `key` for those anagrams.\\nAnd one of the best choices is the `sorted string` as all the anagrams have the same anagrams.\\n\\n![image](https://assets.leetcode.com/users/images/69dc8218-5820-42a0-977c-d278e97b6dd1_1659719811.9147549.png)\\n\\n\\n\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        strs_table = {}\\n\\n        for string in strs:\\n            sorted_string = \\'\\'.join(sorted(string))\\n\\n            if sorted_string not in strs_table:\\n                strs_table[sorted_string] = []\\n\\n            strs_table[sorted_string].append(string)\\n\\n        return list(strs_table.values())\\n```\\nTime complexity: `O(m*nlogn))`\\nSpace complexity: `O(n)`\\n<br/>",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        strs_table = {}\\n\\n        for string in strs:\\n            sorted_string = \\'\\'.join(sorted(string))\\n\\n            if sorted_string not in strs_table:\\n                strs_table[sorted_string] = []\\n\\n            strs_table[sorted_string].append(string)\\n\\n        return list(strs_table.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 664252,
                "title": "python-3-solution-detailed-explanation-faster-than-97-5",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        h = {}\\n        for word in strs:\\n            sortedWord = \\'\\'.join(sorted(word))\\n            if sortedWord not in h:\\n                h[sortedWord] = [word]\\n            else:\\n                h[sortedWord].append(word)\\n        final = []\\n        for value in h.values():\\n            final.append(value)\\n        return final\\n```\\nWe recall that anagrams are strings which have identical counts of characters. So anagrams, when sorted, result in the same string. We take advantage of this last property.\\n\\nWe create a dictionary and for each word in the input array, we add a key to the dictionary if the **sorted version of the word** doesn\\'t already exist in the list of keys. The key then becomes the sorted version of the word, and the value for the key is an array that stores each anagram of the key. i.e. for every next word that is an anagram, **we would sort the word, find the key that is equal to the sorted form, and add the original word to the list of values for the key**.\\n\\nAt the end of it, we just add every value in the dictionary to the final array.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        h = {}\\n        for word in strs:\\n            sortedWord = \\'\\'.join(sorted(word))\\n            if sortedWord not in h:\\n                h[sortedWord] = [word]\\n            else:\\n                h[sortedWord].append(word)\\n        final = []\\n        for value in h.values():\\n            final.append(value)\\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718955,
                "title": "three-js-solutions",
                "content": "```\\nvar groupAnagrams = function(strs) {\\n    let obj = {};\\n    for (let str of strs) {\\n        let letters = str.split(\"\").sort().join(\"\");\\n        obj[letters] ? obj[letters].push(str) : obj[letters] = [str];\\n    }\\n    return Object.values(obj);\\n};\\n// Time Complexity: O(n*klog(k)) where n is the length of input array and k is the maximum length of a string in input array\\n// Space Complexity: O(n)\\n```\\n\\n```\\nvar groupAnagrams = function(strs) {\\n    let m = new Map();\\n    for (let str of strs) {\\n        let sorted = str.split(\"\").sort().join(\"\");\\n        if (m.has(sorted)) m.set(sorted, [...m.get(sorted), str]);\\n        else m.set(sorted, [str]);\\n    }\\n    return Array.from(m.values());\\n};\\n// Time Complexity: O(n*klog(k)) where n is the length of input array and k is the maximum length of a string in input array\\n// Space Complexity: O(n)\\n```\\n\\n```\\nvar groupAnagrams = function(strs) {\\n    let res = {};\\n    for (let str of strs) {\\n        let count = new Array(26).fill(0);\\n        for (let char of str) count[char.charCodeAt()-97]++;\\n        let key = count.join(\"#\");\\n        res[key] ? res[key].push(str) : res[key] = [str];\\n    }\\n    return Object.values(res);\\n};\\n// Time Complexity: O(n*k) where n is the size of input array and k is the maximum length of string in input array\\n// Space Complexity: O(n)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar groupAnagrams = function(strs) {\\n    let obj = {};\\n    for (let str of strs) {\\n        let letters = str.split(\"\").sort().join(\"\");\\n        obj[letters] ? obj[letters].push(str) : obj[letters] = [str];\\n    }\\n    return Object.values(obj);\\n};\\n// Time Complexity: O(n*klog(k)) where n is the length of input array and k is the maximum length of a string in input array\\n// Space Complexity: O(n)\\n```\n```\\nvar groupAnagrams = function(strs) {\\n    let m = new Map();\\n    for (let str of strs) {\\n        let sorted = str.split(\"\").sort().join(\"\");\\n        if (m.has(sorted)) m.set(sorted, [...m.get(sorted), str]);\\n        else m.set(sorted, [str]);\\n    }\\n    return Array.from(m.values());\\n};\\n// Time Complexity: O(n*klog(k)) where n is the length of input array and k is the maximum length of a string in input array\\n// Space Complexity: O(n)\\n```\n```\\nvar groupAnagrams = function(strs) {\\n    let res = {};\\n    for (let str of strs) {\\n        let count = new Array(26).fill(0);\\n        for (let char of str) count[char.charCodeAt()-97]++;\\n        let key = count.join(\"#\");\\n        res[key] ? res[key].push(str) : res[key] = [str];\\n    }\\n    return Object.values(res);\\n};\\n// Time Complexity: O(n*k) where n is the size of input array and k is the maximum length of string in input array\\n// Space Complexity: O(n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1333346,
                "title": "simple-java-solution-beats-99-05-5ms",
                "content": "\\n**Please upvote if you understood the solution**\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>> map=new HashMap<>();\\n        \\n        for(int i=0;i<strs.length;i++){\\n            String s1=strs[i];\\n            char[] arr=s1.toCharArray();\\n            Arrays.sort(arr);\\n            String str=new String(arr);\\n            \\n            if(map.containsKey(str)){\\n                map.get(str).add(s1); \\n            }else{\\n                map.put(str,new ArrayList<>());\\n                map.get(str).add(s1);\\n            }\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n\\nTime Complexity: O(n * klog(k)) since we are sorting k characters n times in the loop.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>> map=new HashMap<>();\\n        \\n        for(int i=0;i<strs.length;i++){\\n            String s1=strs[i];\\n            char[] arr=s1.toCharArray();\\n            Arrays.sort(arr);\\n            String str=new String(arr);\\n            \\n            if(map.containsKey(str)){\\n                map.get(str).add(s1); \\n            }else{\\n                map.put(str,new ArrayList<>());\\n                map.get(str).add(s1);\\n            }\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173284,
                "title": "clean-javascript-solution",
                "content": "```javascript\\nconst groupAnagrams = strs => {\\n    const map = {};\\n    \\n    for (let str of strs) {\\n        const key = [...str].sort().join(\\'\\');\\n\\n        if (!map[key]) {\\n            map[key] = [];\\n        }\\n\\n        map[key].push(str);\\n    }\\n    \\n    return Object.values(map);\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst groupAnagrams = strs => {\\n    const map = {};\\n    \\n    for (let str of strs) {\\n        const key = [...str].sort().join(\\'\\');\\n\\n        if (!map[key]) {\\n            map[key] = [];\\n        }\\n\\n        map[key].push(str);\\n    }\\n    \\n    return Object.values(map);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19335,
                "title": "beat-90-2-18ms-o-n-non-sort-solutions-with-hashmap",
                "content": "**we know each word can be represented by their counter array which counts every letter's occurrences, so we can use this counter array as an ID for the anagram, more specifically, use this counter array's hash code as the key, the anagram list as the value, we can distribute all the words into corresponding anagram group in O(n) time complexity.**\\n\\n```\\npublic int getID(String s){\\n        int[] counter   =   new int[26];\\n        for(char ch : s.toCharArray()){\\n            counter[ch - 'a']++;\\n        }\\n        \\n        return Arrays.hashCode(counter);    //use the counter array's hash code as this anagram's ID\\n    }\\n    \\n    //solution takes 18ms\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> groups   =   new ArrayList<>();\\n        Map<Integer, List<String>> anagramMap   =   new HashMap<>();\\n        \\n        for(String word : strs){\\n            int id   =   getID(word);   //unique for each anagram\\n            List<String> group  =   anagramMap.get(id);\\n            \\n            if(null == group){\\n                group  =   new ArrayList();\\n                anagramMap.put(id, group);\\n           \\n            }\\n            \\n            group.add(word);\\n        }\\n        \\n        groups.addAll(anagramMap.values());\\n        \\n        return groups;\\n    }\\n```\\n\\n***If u think it make sense, plz vote for me, thx : )***\\n\\nbtw, my code was also hosted on github:) https://github.com/Emilio66/leetcode/blob/master/P49_GroupAnagrams.java",
                "solutionTags": [],
                "code": "```\\npublic int getID(String s){\\n        int[] counter   =   new int[26];\\n        for(char ch : s.toCharArray()){\\n            counter[ch - 'a']++;\\n        }\\n        \\n        return Arrays.hashCode(counter);    //use the counter array's hash code as this anagram's ID\\n    }\\n    \\n    //solution takes 18ms\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> groups   =   new ArrayList<>();\\n        Map<Integer, List<String>> anagramMap   =   new HashMap<>();\\n        \\n        for(String word : strs){\\n            int id   =   getID(word);   //unique for each anagram\\n            List<String> group  =   anagramMap.get(id);\\n            \\n            if(null == group){\\n                group  =   new ArrayList();\\n                anagramMap.put(id, group);\\n           \\n            }\\n            \\n            group.add(word);\\n        }\\n        \\n        groups.addAll(anagramMap.values());\\n        \\n        return groups;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19203,
                "title": "2-line-python-solution-ac-with-350ms-some-useful-python-tricks",
                "content": "\\n\\n        def anagrams(self, strs):\\n            count = collections.Counter([tuple(sorted(s)) for s in strs])\\n            return filter(lambda x: count[tuple(sorted(x))]>1, strs)\\n\\n\\n - collections.Counter creates a counter object. A counter object is like a specific kind of dictionary where it is build for counting  (objects that hashes to same value)\\n - tuple(sorted(s)) is used here so that anagrams will be hashed to the same value. tuple is used because sorted returns a list which cannot be hashed but tuples can be hashed\\n - filter: selects some elements of the list based on given function (first argument - a lambda function is given here)\\n - lambda function defined here returns True if number of anagrams of that elements is greater than 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n        def anagrams(self, strs):\\n            count = collections.Counter([tuple(sorted(s)) for s in strs])\\n            return filter(lambda x: count[tuple(sorted(x))]>1, strs)\\n\\n\\n - collections.Counter creates a counter object. A counter object is like a specific kind of dictionary where it is build for counting  (objects that hashes to same value)\\n - tuple(sorted(s)) is used here so that anagrams will be hashed to the same value. tuple is used because sorted returns a list which cannot be hashed but tuples can be hashed\\n - filter: selects some elements of the list based on given function (first argument - a lambda function is given here)\\n - lambda function defined here returns True if number of anagrams of that elements is greater than 1",
                "codeTag": "Python3"
            },
            {
                "id": 19216,
                "title": "1-line-ruby-python-for-updated-problem",
                "content": "The problem just got updated, now asking for different results. Here are some solutions for the new version.\\n\\nAll of them use the sorted string as the group identifier, so for example the words \"leetcoder\" and \"electrode\" both have the group identifier \"cdeeelort\" (or rather an array version of it), which is how I know that they're anagrams of each other.\\n\\n---\\n\\n**Ruby solution 1**\\n\\nJust sort and group.\\n\\n    def group_anagrams(strs)\\n      strs.sort.group_by { |s| s.chars.sort }.values\\n    end\\n\\n---\\n\\n**Ruby solution 2**\\n\\nGroup first, then sort each group. Could be faster for big cases (though isn't for the OJ test cases).\\n\\n    def group_anagrams(strs)\\n      strs.group_by { |s| s.chars.sort }.values.map(&:sort)\\n    end\\n\\n---\\n\\n**Python solution 1**\\n\\nSort and group by group identifier, then sort each group normally.\\n\\n    def groupAnagrams(self, strs):\\n        return [sorted(g) for _, g in itertools.groupby(sorted(strs, key=sorted), sorted)]\\n\\nOr \"breaking it down\" to maybe make it more readable for beginners and because I just noticed that in Firefox it violates my self-imposed *\"no scrollbars\"* rule (I usually use Chrome and didn't think it differed):\\n\\n    def groupAnagrams(self, strs):\\n        groups = itertools.groupby(sorted(strs, key=sorted), sorted)\\n        return [sorted(members) for _, members in groups]\\n\\n---\\n\\n**Python solution 2**\\n\\nUsing defaultdict to collect the groups.\\n\\n    def groupAnagrams(self, strs):\\n        groups = collections.defaultdict(list)\\n        for s in strs:\\n            groups[tuple(sorted(s))].append(s)\\n        return map(sorted, groups.values())",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "The problem just got updated, now asking for different results. Here are some solutions for the new version.\\n\\nAll of them use the sorted string as the group identifier, so for example the words \"leetcoder\" and \"electrode\" both have the group identifier \"cdeeelort\" (or rather an array version of it), which is how I know that they're anagrams of each other.\\n\\n---\\n\\n**Ruby solution 1**\\n\\nJust sort and group.\\n\\n    def group_anagrams(strs)\\n      strs.sort.group_by { |s| s.chars.sort }.values\\n    end\\n\\n---\\n\\n**Ruby solution 2**\\n\\nGroup first, then sort each group. Could be faster for big cases (though isn't for the OJ test cases).\\n\\n    def group_anagrams(strs)\\n      strs.group_by { |s| s.chars.sort }.values.map(&:sort)\\n    end\\n\\n---\\n\\n**Python solution 1**\\n\\nSort and group by group identifier, then sort each group normally.\\n\\n    def groupAnagrams(self, strs):\\n        return [sorted(g) for _, g in itertools.groupby(sorted(strs, key=sorted), sorted)]\\n\\nOr \"breaking it down\" to maybe make it more readable for beginners and because I just noticed that in Firefox it violates my self-imposed *\"no scrollbars\"* rule (I usually use Chrome and didn't think it differed):\\n\\n    def groupAnagrams(self, strs):\\n        groups = itertools.groupby(sorted(strs, key=sorted), sorted)\\n        return [sorted(members) for _, members in groups]\\n\\n---\\n\\n**Python solution 2**\\n\\nUsing defaultdict to collect the groups.\\n\\n    def groupAnagrams(self, strs):\\n        groups = collections.defaultdict(list)\\n        for s in strs:\\n            groups[tuple(sorted(s))].append(s)\\n        return map(sorted, groups.values())",
                "codeTag": "Python3"
            },
            {
                "id": 3209086,
                "title": "java-o-n-k-solution-using-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to combine the strings into list of same values and keep track of each list. So the simple solution is to create a HashMap< String, List >.\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\nNow the main thing is to find a way to keep Key maintained and same for similar anagrams. One way is to do sorting of the elements.\\nLike -> \\n1. ate -> [\\'a\\',\\'t\\',\\'e\\'] -> after sorting and combining -> aet.\\n2. tae -> [\\'t\\',\\'a\\',\\'e\\'] -> after sorting and combining -> aet.\\n\\n# Complexity\\n- Time complexity: O(n * k * log(k) ), where\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- - n = length of array\\n- - k = length of string\\n\\n- Space complexity: O( n ) , size of map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, ArrayList<String>> map = new HashMap<>();\\n\\n        for( String s: strs ){\\n\\n            char[] valArr = s.toCharArray();\\n            Arrays.sort( valArr );\\n            String key = new String(valArr);\\n\\n            ArrayList<String> ll = map.getOrDefault( key,\\n                                     new ArrayList<String>() );\\n            ll.add(s);\\n            map.put( key, ll );\\n                                 \\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n        for( Map.Entry<String, ArrayList<String>> entry: map.entrySet() ){\\n            ans.add( entry.getValue() );\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\nNow we can optimise the Key identifying procedure by using Xor and Product of ASCII values of character in Strings. As sorting require extra k*log(k) time and we can reduce it to O(k) for linear traversal.\\n\\n# Complexity\\n- Time complexity: O(n * k), where\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- - n = length of array\\n- - k = length of string\\n\\n- Space complexity: O( n ) , size of map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, ArrayList<String>> map = new HashMap<>();\\n\\n        for( String s: strs ){\\n\\n            String key = getKey(s);\\n\\n            ArrayList<String> ll = map.getOrDefault( key,\\n                                     new ArrayList<String>() );\\n            ll.add(s);\\n            map.put( key, ll );\\n                                 \\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n        for( Map.Entry<String, ArrayList<String>> entry: map.entrySet() ){\\n            ans.add( entry.getValue() );\\n        }\\n\\n        return ans;\\n    }\\n\\n    private String getKey(String s){\\n        int prod = 1, xor = 0;\\n        for(int len=0; len<s.length(); len++){\\n            char i = s.charAt(len);\\n            prod *= i;\\n            xor = xor^i;\\n        }\\n        return String.valueOf(prod) + \\'_\\' + String.valueOf(xor);\\n    }\\n\\n}\\n```\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/70fb8114-54fb-46bb-8481-e676441046c7_1676881723.60565.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, ArrayList<String>> map = new HashMap<>();\\n\\n        for( String s: strs ){\\n\\n            char[] valArr = s.toCharArray();\\n            Arrays.sort( valArr );\\n            String key = new String(valArr);\\n\\n            ArrayList<String> ll = map.getOrDefault( key,\\n                                     new ArrayList<String>() );\\n            ll.add(s);\\n            map.put( key, ll );\\n                                 \\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n        for( Map.Entry<String, ArrayList<String>> entry: map.entrySet() ){\\n            ans.add( entry.getValue() );\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, ArrayList<String>> map = new HashMap<>();\\n\\n        for( String s: strs ){\\n\\n            String key = getKey(s);\\n\\n            ArrayList<String> ll = map.getOrDefault( key,\\n                                     new ArrayList<String>() );\\n            ll.add(s);\\n            map.put( key, ll );\\n                                 \\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n        for( Map.Entry<String, ArrayList<String>> entry: map.entrySet() ){\\n            ans.add( entry.getValue() );\\n        }\\n\\n        return ans;\\n    }\\n\\n    private String getKey(String s){\\n        int prod = 1, xor = 0;\\n        for(int len=0; len<s.length(); len++){\\n            char i = s.charAt(len);\\n            prod *= i;\\n            xor = xor^i;\\n        }\\n        return String.valueOf(prod) + \\'_\\' + String.valueOf(xor);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750704,
                "title": "java-easy-solution-hashmap-arraylist",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (strs == null || strs.length == 0) {\\n            return result;\\n        }\\n        if (strs.length == 1) {\\n            result.add(Arrays.asList(strs));\\n            return result;\\n        }\\n\\n        HashMap<String, List<String>> groups = new HashMap<>();\\n        for (String s : strs) {\\n            String signature = getSignature(s);\\n            groups.putIfAbsent(signature, new ArrayList<>());\\n        groups.get(signature).add(s);\\n        }\\n\\n        return new ArrayList<>(groups.values());\\n    }\\n\\n    private String getSignature(String s) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                sb.append((char) (\\'a\\' + i)).append(count[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (strs == null || strs.length == 0) {\\n            return result;\\n        }\\n        if (strs.length == 1) {\\n            result.add(Arrays.asList(strs));\\n            return result;\\n        }\\n\\n        HashMap<String, List<String>> groups = new HashMap<>();\\n        for (String s : strs) {\\n            String signature = getSignature(s);\\n            groups.putIfAbsent(signature, new ArrayList<>());\\n        groups.get(signature).add(s);\\n        }\\n\\n        return new ArrayList<>(groups.values());\\n    }\\n\\n    private String getSignature(String s) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                sb.append((char) (\\'a\\' + i)).append(count[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750601,
                "title": "python-c-java-rust-linear-time-hashable-keys-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs hashing of strings in linear-time. Time complexity is **O(N)**. Space complexity is **O(N)**. \\n\\n**Comment**. To group anagrams, we should use something (i.e., some hash) that:\\n* uniquely distinguishes one group from another;\\n* is the same for all members of each group.\\n\\nAmong the potential candidates are:\\n* list of letter frequencies in alphabetical order, that takes **O(N)** time to compute;\\n* sorted version of a string, that takes **O(N\\\\*logN)** time to compute.\\n\\nHere, we\\'ll go with the first option.\\n\\n<iframe src=\"https://leetcode.com/playground/Sfqzaf8u/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>\\n\\n",
                "solutionTags": [],
                "code": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs hashing of strings in linear-time. Time complexity is **O(N)**. Space complexity is **O(N)**. \\n\\n**Comment**. To group anagrams, we should use something (i.e., some hash) that:\\n* uniquely distinguishes one group from another;\\n* is the same for all members of each group.\\n\\nAmong the potential candidates are:\\n* list of letter frequencies in alphabetical order, that takes **O(N)** time to compute;\\n* sorted version of a string, that takes **O(N\\\\*logN)** time to compute.\\n\\nHere, we\\'ll go with the first option.\\n\\n<iframe src=\"https://leetcode.com/playground/Sfqzaf8u/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 19404,
                "title": "sharing-my-very-concise-solution-with-explanation",
                "content": "    vector<string> anagrams(vector<string> &strs) {\\n        vector<string> result;\\n        vector<string> sortedStrs = strs;\\n        unordered_map<string, vector<int>> map;\\n        for(int i = 0; i < strs.size(); i++){\\n            sort(sortedStrs[i].begin(), sortedStrs[i].end());\\n            map[sortedStrs[i]].push_back(i);\\n        }\\n        for(auto it = map.begin(); it != map.end(); it++){\\n            if(it->second.size() > 1){\\n                for(int i = 0; i < it->second.size(); i++){\\n                    result.push_back(strs[it->second[i]]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\nHere is basic idea for this problem.\\n\\nFirst, get a copy of \"strs\". Let's name this copy \"sortedStrs\".\\n\\nSecond, sort all strings in \"sortedStrs\".\\n\\nAnd we have a hash map `unordered_map<string, vector<int>> map`.\\n\\nEvery string in \"sortedStrs\" will be recorded in this hash map with its position.\\n\\nIn the second loop, we traverse this hash map. And find each value of which size is larger than 1. Then find the original string in \"strs\".\\n\\nDone.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "    vector<string> anagrams(vector<string> &strs) {\\n        vector<string> result;\\n        vector<string> sortedStrs = strs;\\n        unordered_map<string, vector<int>> map;\\n        for(int i = 0; i < strs.size(); i++){\\n            sort(sortedStrs[i].begin(), sortedStrs[i].end());\\n            map[sortedStrs[i]].push_back(i);\\n        }\\n        for(auto it = map.begin(); it != map.end(); it++){\\n            if(it->second.size() > 1){\\n                for(int i = 0; i < it->second.size(); i++){\\n                    result.push_back(strs[it->second[i]]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\nHere is basic idea for this problem.\\n\\nFirst, get a copy of \"strs\". Let's name this copy \"sortedStrs\".\\n\\nSecond, sort all strings in \"sortedStrs\".\\n\\nAnd we have a hash map `unordered_map<string, vector<int>> map`.\\n\\nEvery string in \"sortedStrs\" will be recorded in this hash map with its position.\\n\\nIn the second loop, we traverse this hash map. And find each value of which size is larger than 1. Then find the original string in \"strs\".\\n\\nDone.",
                "codeTag": "Unknown"
            },
            {
                "id": 3423036,
                "title": "4-best-swift-solutions-easy-to-understand",
                "content": "# First solution using Dictionary\\n\\n## Approach\\n\\nFirstly, the functions creates an empty dictionary with the key as a `String` and the value as an array of `String`. Then, it iterates over each string in the given array of strings `strs`. \\n\\nFor each string in `strs`, the function sorts the characters of the string using the `sorted()` method and creates a new string with the sorted characters. This sorted string is then used as the key to the dictionary. \\n\\nIf the dictionary already has the sorted string as the key, the given string is appended to the array of strings that correspond to the given key. Otherwise, a new key-value pair is added to the dictionary with the sorted string as the key and the given string as the value of a new array.\\n\\nFinally, the function returns an array of arrays of strings. Each array of strings represents a group of anagrams. It is done by using the `values` property of the dictionary to get an array of arrays.\\n\\n## Complexity\\n\\nThis approach has a *time complexity* of $$O(n \\\\cdot m \\\\cdot \\\\log m)$$, where $$n$$ is the number of strings in `strs` and $$m$$ is the maximum length of a string in `strs`.\\n\\nThe *space complexity* of the given solution is $$O(n \\\\cdot m)$$, where $$n$$ is the number of strings in the input array `strs` and $$m$$ is the maximum length of a string in `strs`. \\n\\n## Code\\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict = [String: [String]]()\\n\\n        for str in strs {\\n            let sortedStr = String(str.sorted())\\n            dict[sortedStr, default: []].append(str)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\\n\\n\\n---\\n\\n# Second solution using Dictionary\\n\\n## Approach\\n\\nFirst, a dictionary is created with keys as arrays of integers (count of characters in the string) and values as arrays of strings (the anagrams). \\n\\nThen, for each string in the input array, an array of `counts` of the characters in the string is created. The counts array is initialized with zeros for each of the `26` alphabets. \\n\\nNext, each character in the string is iterated over, and the corresponding `index` in the counts array is incremented. \\n\\nAfter counting the characters in the string, the `counts` array is used as a key in the dictionary. The string is then appended to the corresponding value array for that key. \\n\\nFinally, the values of the dictionary are returned as an array of grouped anagrams.\\n\\n## Complexity\\n\\nThis approach is efficient, as it only requires iterating over each string in the input array once, and the *time complexity* is $$O(n \\\\cdot k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the length of the longest string.\\n\\nThe *space complexity* of this approach is $$O(n \\\\cdot k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the length of the longest string.\\n\\n## Code\\n\\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict = [[Int]: [String]]()\\n\\n        for str in strs {\\n            var counts = Array(repeating: 0, count: 26)\\n            for char in str {\\n                let index = Int(char.asciiValue! - 97)\\n                counts[index] += 1\\n            }\\n            dict[counts, default: []].append(str)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\\n\\n---\\n\\n# Third solution using Dictionary(grouping:)\\n\\n## Approach\\n\\nThe approach to solving the problem involves using the built-in `Dictionary` function `grouping(_:by:)` and the `sorted()` method of strings to group the anagrams together.\\n\\nThe `grouping(_:by:)` function takes an array and a closure that returns a key for each element in the array. It groups the elements of the array by the returned key, and returns a dictionary with keys as the returned key and values as arrays of elements that have the same key.\\n\\nIn this case, the `strs` array is passed to the `grouping(_:by:)` function, and a closure is provided that sorts each string and converts it to a new string. The sorted string is used as the key for the dictionary.\\n\\nThe `sorted()` method on a string returns an array of characters sorted in ascending order. By converting the sorted array of characters back to a string, we obtain a canonical form of the input string, which is the same for all anagrams of that string.\\n\\nFinally, the `values` property of the dictionary is accessed, which returns an array of arrays of anagrams. The `map` function is used to extract the arrays of anagrams and return them as a 2D array.\\n\\n## Complexity\\n\\nThis approach has a *time complexity* of $$O(n \\\\cdot k \\\\cdot \\\\log k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the length of the longest string\\n\\nThe *space complexity* of the given solution is $$O(n \\\\cdot k)$$, as a dictionary is used to store the grouped anagrams.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        Dictionary(grouping: strs, by: { String($0.sorted()) }).values.map { $0 }\\n    }\\n}\\n```\\n\\n\\n---\\n\\n# Fourth solution using \\xABProduct of Primes\\xBB\\n\\n## Approach\\n\\nTo solve this problem, the approach used in the given Swift function is based on the idea of hashing. In this approach, each string is assigned a unique hash key based on the product of the prime numbers assigned to each character in the string. The prime numbers assigned to each character are chosen in such a way that the hash keys of two strings will be equal only if they are anagrams of each other. \\n\\nIn the code, a dictionary is used to store the hash keys as keys and the corresponding anagrams as values. For each string in the input array, the hash key is calculated by multiplying the prime numbers assigned to each character in the string. If the hash key is already present in the dictionary, the current string is appended to the list of anagrams for that key. Otherwise, a new key-value pair is added to the dictionary with the hash key and the current string.\\n\\nFinally, the function returns an array containing the values of the dictionary, which are the lists of anagrams grouped together. The order of the anagram groups in the output array can be arbitrary.\\n\\n## Complexity\\n\\nThe *time complexity* of this solution is $$O(n \\\\cdot k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the maximum length of a string in the input array.\\n\\nThe space complexity of this solution is $$O(n \\\\cdot k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the maximum length of a string in the input array.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        let mod = 1_000_000_007\\n        var dict = [Int: [String]]()\\n        let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]\\n\\n        for s in strs {\\n            var key = 1\\n            for ch in s {\\n                key = key * primes[Int(ch.asciiValue! - Character(\"a\").asciiValue!)] % mod\\n            }\\n            dict[key, default: []].append(s)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/9d031f2a-2935-4fde-bedc-c35de65d1beb_1681635981.4891484.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict = [String: [String]]()\\n\\n        for str in strs {\\n            let sortedStr = String(str.sorted())\\n            dict[sortedStr, default: []].append(str)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict = [[Int]: [String]]()\\n\\n        for str in strs {\\n            var counts = Array(repeating: 0, count: 26)\\n            for char in str {\\n                let index = Int(char.asciiValue! - 97)\\n                counts[index] += 1\\n            }\\n            dict[counts, default: []].append(str)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        Dictionary(grouping: strs, by: { String($0.sorted()) }).values.map { $0 }\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        let mod = 1_000_000_007\\n        var dict = [Int: [String]]()\\n        let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]\\n\\n        for s in strs {\\n            var key = 1\\n            for ch in s {\\n                key = key * primes[Int(ch.asciiValue! - Character(\"a\").asciiValue!)] % mod\\n            }\\n            dict[key, default: []].append(s)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434269,
                "title": "golang-17-lines-of-easy-to-understand-solution-without-using-sort",
                "content": "We can take advantage of anagram\\'s defination:\\n> An anagram is a word or phrase formed by rearranging the letters of a different word or phrase\\n\\nSo we can consider using a hashmap to store every letter\\'s frequency and group those who have the same frequency, but in Golang slice cannot be a key. \\nWe are told:\\n> All inputs will be in lowercase.\\nSo we can use array as a key, whose capacity is 26 since there are only 26 letters. \\n\\n* time complexity: O(nk), n is `len(strs)`, k is the length of the longest string in `strs`\\n* space complexity: O(nk), for we are using a hashmap\\n\\n```\\nfunc groupAnagrams(strs []string) [][]string {\\n\\tmp := map[[26]int][]string{}\\n\\tfor _, s := range strs {\\n\\t\\tk := [26]int{}\\n\\t\\tfor i := 0; i < len(s); i++ {\\n\\t\\t\\tk[s[i]-\\'a\\'] += 1\\n\\t\\t}\\n\\t\\tmp[k] = append(mp[k], s)\\n\\t}\\n\\tres := [][]string{}\\n\\tfor _, v := range mp {\\n\\t\\tres = append(res, v)\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n\\tmp := map[[26]int][]string{}\\n\\tfor _, s := range strs {\\n\\t\\tk := [26]int{}\\n\\t\\tfor i := 0; i < len(s); i++ {\\n\\t\\t\\tk[s[i]-\\'a\\'] += 1\\n\\t\\t}\\n\\t\\tmp[k] = append(mp[k], s)\\n\\t}\\n\\tres := [][]string{}\\n\\tfor _, v := range mp {\\n\\t\\tres = append(res, v)\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422306,
                "title": "using-hashtable-easy-to-understand",
                "content": "\\n\\n# Python Solution\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic={}\\n        for word in strs:\\n            sorted_word=\"\".join(sorted(word))\\n            if sorted_word not in dic:\\n                dic[sorted_word]=[word]\\n            else:\\n                dic[sorted_word].append(word)\\n        return dic.values()\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic={}\\n        for word in strs:\\n            sorted_word=\"\".join(sorted(word))\\n            if sorted_word not in dic:\\n                dic[sorted_word]=[word]\\n            else:\\n                dic[sorted_word].append(word)\\n        return dic.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107534,
                "title": "92-49-javascript-fast-very-easy-to-understand-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/nUfXklKCGTk\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {\\n    let map = {}\\n\\n    for(let str of strs){\\n        let s = str.split(\\'\\').sort().join(\\'\\')\\n        if(!map[s]) map[s] = []\\n        map[s].push(str)\\n    }\\n    return Object.values(map)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {\\n    let map = {}\\n\\n    for(let str of strs){\\n        let s = str.split(\\'\\').sort().join(\\'\\')\\n        if(!map[s]) map[s] = []\\n        map[s].push(str)\\n    }\\n    return Object.values(map)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327706,
                "title": "javascript-7-line-solution-using-primes-beats-99-8-without-sorting",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n *\\n * key point: \\n * prime multiply prime is unique, each char canbe represented by a prime\\n * since [a-z] to  [0-25]\\n * use `[charCodeAt() - 97]` to get unique index from the prime array\\n * the prodcut can be set to the key name \"prod\"\\n **/\\n    var groupAnagrams = function (strs) {\\n      const map = {};\\n      const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\\n      strs.forEach(str => {\\n        let prod = str.split(\"\").reduce((r, c) => r * primes[c.charCodeAt() - 97], 1);\\n        map[prod] ? map[prod].push(str) : map[prod] = [str];\\n      });\\n      return Object.values(map);\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n *\\n * key point: \\n * prime multiply prime is unique, each char canbe represented by a prime\\n * since [a-z] to  [0-25]\\n * use `[charCodeAt() - 97]` to get unique index from the prime array\\n * the prodcut can be set to the key name \"prod\"\\n **/\\n    var groupAnagrams = function (strs) {\\n      const map = {};\\n      const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\\n      strs.forEach(str => {\\n        let prod = str.split(\"\").reduce((r, c) => r * primes[c.charCodeAt() - 97], 1);\\n        map[prod] ? map[prod].push(str) : map[prod] = [str];\\n      });\\n      return Object.values(map);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 19224,
                "title": "a-clean-c-solution-with-unordered-map",
                "content": "\\tvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\t\\tunordered_map<string, vector<string>> count;\\n\\t\\tint i = 0;\\n\\t\\tfor (auto s : strs)\\n\\t\\t{\\n\\t\\t\\tsort(s.begin(), s.end());\\n\\t\\t\\tcount[s].push_back(strs[i++]);\\n\\t\\t}\\n\\t\\tvector<vector<string>> res;\\n\\t\\tfor (auto n : count){\\n\\t\\t\\tsort(n.second.begin(), n.second.end());\\n\\t\\t\\tres.push_back(n.second);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "solutionTags": [],
                "code": "\\tvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\t\\tunordered_map<string, vector<string>> count;\\n\\t\\tint i = 0;\\n\\t\\tfor (auto s : strs)\\n\\t\\t{\\n\\t\\t\\tsort(s.begin(), s.end());\\n\\t\\t\\tcount[s].push_back(strs[i++]);\\n\\t\\t}\\n\\t\\tvector<vector<string>> res;\\n\\t\\tfor (auto n : count){\\n\\t\\t\\tsort(n.second.begin(), n.second.end());\\n\\t\\t\\tres.push_back(n.second);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2838344,
                "title": "100-animation-to-the-hard-solution-and-easy-solution-explained",
                "content": "[https://youtu.be/3cAxlUsBfas]()\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "[https://youtu.be/3cAxlUsBfas]()\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2750734,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/UnfxY7Sm/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\nAnother Approach using Prime numbers\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int M = 1e9 + 9;\\n        vector<int> primes = {\\n            2, 3, 5, 7, 11,\\n            13, 17, 19, 23, 29,\\n            31, 37, 41, 43, 47,\\n            53, 59, 61, 67, 71,\\n            73, 79, 83, 89, 97, \\n            101\\n        };\\n\\t\\t// hacked by [\"djrw\", \"beisx\", \"ceflvx\", \"anp\"] :D\\n        // for (int i = 0; i < 26; i++)  primes[i] = i * i + i + 41;\\n        unordered_map<long long, vector<string>> m;\\n        for (int i = 0; i < strs.size(); i++) {\\n            long long k = 1;\\n            for (int j = 0; j < strs[i].size(); j++) {\\n                k *= 1LL * primes[strs[i][j] - \\'a\\'];\\n                k %= M;\\n            }\\n            m[k].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for (auto x : m) ans.push_back(x.second);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int M = 1e9 + 9;\\n        vector<int> primes = {\\n            2, 3, 5, 7, 11,\\n            13, 17, 19, 23, 29,\\n            31, 37, 41, 43, 47,\\n            53, 59, 61, 67, 71,\\n            73, 79, 83, 89, 97, \\n            101\\n        };\\n\\t\\t// hacked by [\"djrw\", \"beisx\", \"ceflvx\", \"anp\"] :D\\n        // for (int i = 0; i < 26; i++)  primes[i] = i * i + i + 41;\\n        unordered_map<long long, vector<string>> m;\\n        for (int i = 0; i < strs.size(); i++) {\\n            long long k = 1;\\n            for (int j = 0; j < strs[i].size(); j++) {\\n                k *= 1LL * primes[strs[i][j] - \\'a\\'];\\n                k %= M;\\n            }\\n            m[k].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for (auto x : m) ans.push_back(x.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399131,
                "title": "c-easy-clean-solution-using-sorting-and-map",
                "content": "**Solution:**\\n\\n**Approach**\\n1. We need to group all `anagrams` together.\\n2. An Anagram is a word or phrase formed by `rearranging the letters` of a different word or phrase, typically using all the original letters `exactly once`.\\n3. If we sort a particular string, we have one `unique string` which can be called as the `primary string` through which all anagrams were made(Just an imagination to understand the concept better).\\n4. For each sorted string, group it with its anagram(original string) using `map`.\\n5. Return the `result` in any order.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for(auto i: strs){\\n            string temp = i;\\n            sort(temp.begin(), temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for(auto i: mp){\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nTime Complexity: `O(n * (m * log(m)))`\\n* where n is the total number of strings present in the `vector` and m is the `maximum length` of a string in the vector. Here, sorting the strings causes `(m * log(m))` addition to the complexity.\\n\\nSpace Complexity: `O(n * m)`\\n\\n**Feel free to share your ideas or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for(auto i: strs){\\n            string temp = i;\\n            sort(temp.begin(), temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for(auto i: mp){\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241396,
                "title": "python-simple-solution-brute-force",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        ans = {}\\n        for i in strs:\\n            srt = str(sorted(i))\\n            if srt in ans:\\n                ans[srt].append(i)\\n            else:\\n                ans[srt] = [i]\\n        return list(ans.values())\\n```\\n**.\\n.\\n.\\n.\\n.\\n...Please Up-vote if you find this useful...**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        ans = {}\\n        for i in strs:\\n            srt = str(sorted(i))\\n            if srt in ans:\\n                ans[srt].append(i)\\n            else:\\n                ans[srt] = [i]\\n        return list(ans.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887227,
                "title": "python-3-90-faster-simple-approach",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nKey learnings for me:\\n1. parameter \"list\" in defaultdict is lowercase\\n2. sorted() returns iterable. We need to join the returned list to create a string\\n3. We can loop through dictionary to store the values in result list or we can directly use dic.values()\\n\\n```\\ndef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n\\tdic = collections.defaultdict(list)\\n\\tfor st in strs:\\n\\t\\ts = \\'\\'.join(sorted(st))\\n\\t\\tdic[s].append(st)\\n\\n\\treturn dic.values()\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n\\tdic = collections.defaultdict(list)\\n\\tfor st in strs:\\n\\t\\ts = \\'\\'.join(sorted(st))\\n\\t\\tdic[s].append(st)\\n\\n\\treturn dic.values()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1398912,
                "title": "python-2-solutions-o-nk-log-k-and-o-nk-26n-explained",
                "content": "#### Solution 1\\nFirst idea is to notice that if we have two anagrams, than when we sort symbols in each of them, then we will have exactly the same string. So we need for each string to sort it and then use defaultdict. \\n\\n#### Complexity\\nTime complexity will be `O(nk * log k)`, space complexity is `O(nk)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        t = defaultdict(list)\\n        for s in strs:\\n            t[\"\".join(sorted(s))].append(s)\\n        return t.values()\\n```\\n\\n#### Solution 2\\nTwo strings are anagrams if and only if their character counts, that is frequencies of each letter `a, b, ..., z` are the same. So it can be done with `defauldict(list)`, where key is 26-element list and values are strings, corresponding to this key.\\n\\n#### Complexity\\nTime complexity is `O(nk + 26n)`, where `n` is number of strings and `k` is the length of the biggest string. Space complexity is `O(26n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        ans = defaultdict(list)\\n        for s in strs:\\n            count = [0] * 26\\n            for c in s:\\n                count[ord(c) - ord(\\'a\\')] += 1\\n            ans[tuple(count)].append(s)\\n        return ans.values()\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        t = defaultdict(list)\\n        for s in strs:\\n            t[\"\".join(sorted(s))].append(s)\\n        return t.values()\\n```\n```python\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        ans = defaultdict(list)\\n        for s in strs:\\n            count = [0] * 26\\n            for c in s:\\n                count[ord(c) - ord(\\'a\\')] += 1\\n            ans[tuple(count)].append(s)\\n        return ans.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566272,
                "title": "simple-c-solution",
                "content": "Basically, just create a map keyed by all of the sorted and unique words, and its value corresponds with a vector consisting of all the strings that when sorted, results in the key.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> y;\\n        \\n        if(strs.size() == 0) return y;\\n        \\n        map<string,vector<string>> dict;\\n        for(string s: strs)\\n        {\\n            string sorted = s;\\n            sort(sorted.begin(),sorted.end());\\n            dict[sorted].push_back(s);\\n        }\\n        map<string,vector<string>>::iterator o = dict.begin();\\n        while(o != dict.end())\\n        {\\n            y.push_back(o->second);\\n            o++;\\n        }\\n    \\n        return y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> y;\\n        \\n        if(strs.size() == 0) return y;\\n        \\n        map<string,vector<string>> dict;\\n        for(string s: strs)\\n        {\\n            string sorted = s;\\n            sort(sorted.begin(),sorted.end());\\n            dict[sorted].push_back(s);\\n        }\\n        map<string,vector<string>>::iterator o = dict.begin();\\n        while(o != dict.end())\\n        {\\n            y.push_back(o->second);\\n            o++;\\n        }\\n    \\n        return y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751413,
                "title": "rust-hashmap-functional-style-with-comments",
                "content": "Strings are grouped by the histogram of letter frequencies. Use this as the key in a hash map, collecting the strings in the map values. I had hopes of making this a one-liner, but have not figured out a way to get around that we have to return the modified histogram/map in the `fold` body. :)\\n\\nImplementation notes:\\n* `N_LETTERS` instead of the magic value 26.\\n* `strs.into_iter` to take ownership of the provided strings and move them into the map.\\n* `or_default` for the most concise insertion of an empty vector if this is the first time we encounter a key.\\n* `into_values` to directly map the values to the output iterator, instead of `into_iter().map(...)`, and to take ownership of the hash map values => the string instances we get as input are the same instances that we return in the output.\\n\\n```\\nuse std::collections::HashMap;\\n\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\n\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        strs.into_iter().fold(HashMap::<[u8; N_LETTERS], Vec<String>>::new(), |mut map, s| {\\n            let freqs = s.bytes().map(|b| (b - b\\'a\\') as usize).fold([0; N_LETTERS], |mut freqs, bin| {\\n                freqs[bin] += 1;\\n                freqs\\n            });\\n            map.entry(freqs).or_default().push(s);\\n            map\\n        }).into_values().collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\n\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        strs.into_iter().fold(HashMap::<[u8; N_LETTERS], Vec<String>>::new(), |mut map, s| {\\n            let freqs = s.bytes().map(|b| (b - b\\'a\\') as usize).fold([0; N_LETTERS], |mut freqs, bin| {\\n                freqs[bin] += 1;\\n                freqs\\n            });\\n            map.entry(freqs).or_default().push(s);\\n            map\\n        }).into_values().collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2751397,
                "title": "easy-solution-c-java-python",
                "content": "**If You Liked the Solution Please Upvote**\\n\\n`The approach is based on the fact that on sorting all anagrams will result into the same string.`\\n`So we use a map with key= sorted string and value = vector containing all anagrams which on sorting will give the string in key.`\\n`Then we will iterate through the map and store all these vectors into an another vector and return it as answer.`\\n\\n`C++`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        \\n        for(auto x: strs){\\n            string temp = x;\\n            sort(temp.begin(), temp.end());\\n            \\n            m[temp].push_back(x);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        \\n        for(auto x: m){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`JAVA`\\n\\n```\\n public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String,List<String>> hm = new HashMap<>();\\n        for(String s : strs){\\n            \\n            char[] chars=s.toCharArray();\\n            Arrays.sort(chars);\\n            String key = String.valueOf(chars);\\n            \\n            if (!hm.containsKey(key)) {\\n                hm.put(key, new ArrayList<>());\\n            }\\n            hm.get(key).add(s);\\n            \\n        }\\n        return new ArrayList<>(hm.values());\\n    }\\n```\\n\\n`PYTHON`\\n\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        groupedWords = defaultdict(list)\\n        \\n        for word in strs:\\n            groupedWords[\"\".join(sorted(word))].append(word)\\n        \\n        result = []\\n        \\n        for valueSet in groupedWords.values():\\n            result.append(valueSet)\\n        \\n        return  result  \\n```\\n\\n**If You Liked the Solution Please Upvote**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        \\n        for(auto x: strs){\\n            string temp = x;\\n            sort(temp.begin(), temp.end());\\n            \\n            m[temp].push_back(x);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        \\n        for(auto x: m){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String,List<String>> hm = new HashMap<>();\\n        for(String s : strs){\\n            \\n            char[] chars=s.toCharArray();\\n            Arrays.sort(chars);\\n            String key = String.valueOf(chars);\\n            \\n            if (!hm.containsKey(key)) {\\n                hm.put(key, new ArrayList<>());\\n            }\\n            hm.get(key).add(s);\\n            \\n        }\\n        return new ArrayList<>(hm.values());\\n    }\\n```\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        groupedWords = defaultdict(list)\\n        \\n        for word in strs:\\n            groupedWords[\"\".join(sorted(word))].append(word)\\n        \\n        result = []\\n        \\n        for valueSet in groupedWords.values():\\n            result.append(valueSet)\\n        \\n        return  result  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749902,
                "title": "c-solution-using-soring-and-without-sorting-by-hashmap-with-time-complexity-analysis",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Solution using ***HashMap with sorting.***\\n- Here we store all same strings in a vector inside Hashmap.\\n- We\\u2019ll take every string from strs in temp then sort that by character. Push the main string to the map.\\n- Like these elements with the same character will push to the same vector of hashmap.\\n- Then push all the vectors from map to ans.\\n- **Time complexity:** O(n.klogk) /***k**\\xA0is the length of string and\\xA0**n**\\xA0is the total no. of strings*\\n\\n### Solution 02\\n\\n- Solution using ***Map without sorting.***\\n- Here we\\u2019ll do the same but this time we\\u2019ll take a map of map to skip the sorting part.\\n- If we could use an unordered map then time complexity could reduce to O(nk), but as it takes O(logn) time for any operations, so time takes same as solution 1.\\n- Here we count the characters in map and push it to main map.\\n- **Time complexity:** O(n.klogk) /*insertion into a map takes **logK** time*\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n = strs.size();\\n        unordered_map<string, vector<string>> mp;\\n        vector<vector<string>>ans;\\n        \\n        int i=0;\\n        while(i<n){\\n            string a = strs[i];\\n            sort(a.begin(), a.end());\\n            mp[a].push_back(strs[i]);\\n            i++;\\n        }\\n        for(auto i=mp.begin(); i!= mp.end(); i++){\\n            ans.push_back(i->second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n = strs.size();\\n        map<map<char, int>, vector<string>> mp;\\n        vector<vector<string>>ans;\\n        \\n        int i=0;\\n        while(i<n){\\n            map<char, int> a;\\n            for(int j=0; j<strs[i].size(); j++)\\n                a[strs[i][j]]++;\\n            mp[a].push_back(strs[i]);\\n            i++;\\n        }\\n        for(auto i=mp.begin(); i!= mp.end(); i++){\\n            ans.push_back(i->second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n = strs.size();\\n        unordered_map<string, vector<string>> mp;\\n        vector<vector<string>>ans;\\n        \\n        int i=0;\\n        while(i<n){\\n            string a = strs[i];\\n            sort(a.begin(), a.end());\\n            mp[a].push_back(strs[i]);\\n            i++;\\n        }\\n        for(auto i=mp.begin(); i!= mp.end(); i++){\\n            ans.push_back(i->second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n = strs.size();\\n        map<map<char, int>, vector<string>> mp;\\n        vector<vector<string>>ans;\\n        \\n        int i=0;\\n        while(i<n){\\n            map<char, int> a;\\n            for(int j=0; j<strs[i].size(); j++)\\n                a[strs[i][j]]++;\\n            mp[a].push_back(strs[i]);\\n            i++;\\n        }\\n        for(auto i=mp.begin(); i!= mp.end(); i++){\\n            ans.push_back(i->second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399451,
                "title": "group-anagrams-explanation-w-images-using-map-c-python-java",
                "content": "**Pre-requisite:**\\n*What is an Anagram?*\\nTwo strings are said to be anagrams of each other if they are made up of the same characters with same frequency. For example: the word `LISTEN` and `SILENT` are anagrams. They are composed of the letters `E, I, L, N, S, T`.\\n`Insight-` The input is only `lowercase aplhabets`\\n\\n**Algorithm:**\\n`Technique` - Group By Sorting\\n*SAMPLE CASE-*\\n![image](https://assets.leetcode.com/users/images/9e9dee48-ad03-4047-8a66-b11e8dbcac7f_1628753485.5853918.png)\\n*SORTED SAMPLE CASE-*\\n![image](https://assets.leetcode.com/users/images/12e377a3-1779-4e7c-ba97-f19fb5d390db_1628753533.013706.png)\\n* Once we have made this observation, we create a map for the same where the `key` will be the sorted string, and the `value` would be the list of all the strings that are anagrams.\\n* After iteration over all the strings, we get the desired group of anagrams\\n* The time complexity of this approach depends on the sorting technique you use to sort the strings.\\n\\n**Solution:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans ;\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<string> temp = strs ;\\n        map<string, vector<string>> mp;\\n        for(int i=0; i < temp.size() ; i++)\\n\\t\\t{\\n            string t = temp[i];\\n            sort(temp[i].begin(), temp[i].end());\\n            mp[temp[i]].push_back(t);\\n        }\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        map_dict = {}\\n        for i,string in enumerate(strs):\\n            tmp = (\"\").join(sorted(string))\\n            try:\\n                map_dict[tmp].append(strs[i])\\n            except:\\n                map_dict[tmp] = [strs[i]]\\n\\n        return list(map_dict.values())\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String ,List<String>> map = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char[] c = strs[i].toCharArray();\\n            Arrays.sort(c) ;\\n            String temp = String.valueOf(c);\\n            if(map.containsKey(temp))\\n            {\\n                List<String> list = map.get(temp);\\n                list.add(strs[i]);\\n                map.put(temp,list);\\n            }\\n            else\\n            { \\n                List<String> list = new ArrayList<>();\\n                list.add(strs[i]);\\n                map.put(temp, list);\\n            }            \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        ans.addAll(map.values());\\n        return ans;\\n    }\\n}\\n```\\n**TIME COMPLEXITY - O(N*KlogK)**, where k is the length of the largest string. \\n* This is because we are sorting string in every iteration.\\n* It would be **different for different sorting techniques** for e.g. `O(N*K) for Counting Sort`\\n\\n**SPACE COMPLEXITY - O(N*K)**\\n\\n\\n**SCRAP APPROACH:**\\n`Brute Force-` Will give TLE on Large Testcases\\n* Iterate over each string in the input array.\\n* For each string, check with each element of the array if they are anagrams.\\n* If it is an anagram, add it to a group.\\n* Else, move the string to a different group\\n\\n**Do Consider the post for upvotes if you liked it. If you find any mistakes do let me know.\\uD83D\\uDE0A\\nIf you are blindly downvoting I hope you get better and stop being jealous :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans ;\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<string> temp = strs ;\\n        map<string, vector<string>> mp;\\n        for(int i=0; i < temp.size() ; i++)\\n\\t\\t{\\n            string t = temp[i];\\n            sort(temp[i].begin(), temp[i].end());\\n            mp[temp[i]].push_back(t);\\n        }\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        map_dict = {}\\n        for i,string in enumerate(strs):\\n            tmp = (\"\").join(sorted(string))\\n            try:\\n                map_dict[tmp].append(strs[i])\\n            except:\\n                map_dict[tmp] = [strs[i]]\\n\\n        return list(map_dict.values())\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String ,List<String>> map = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char[] c = strs[i].toCharArray();\\n            Arrays.sort(c) ;\\n            String temp = String.valueOf(c);\\n            if(map.containsKey(temp))\\n            {\\n                List<String> list = map.get(temp);\\n                list.add(strs[i]);\\n                map.put(temp,list);\\n            }\\n            else\\n            { \\n                List<String> list = new ArrayList<>();\\n                list.add(strs[i]);\\n                map.put(temp, list);\\n            }            \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        ans.addAll(map.values());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566674,
                "title": "java-hashmap-solution-and-no-sorting-required",
                "content": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap();\\n        for (String s : strs) {\\n            int[] m = new int[26];\\n            for (char c : s.toCharArray()) m[c-\\'a\\']++;\\n            String key = Arrays.toString(m);\\n            map.putIfAbsent(key, new ArrayList());\\n            map.get(key).add(s);\\n        }\\n        return new ArrayList(map.values());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap();\\n        for (String s : strs) {\\n            int[] m = new int[26];\\n            for (char c : s.toCharArray()) m[c-\\'a\\']++;\\n            String key = Arrays.toString(m);\\n            map.putIfAbsent(key, new ArrayList());\\n            map.get(key).add(s);\\n        }\\n        return new ArrayList(map.values());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434805,
                "title": "concise-javascript-solution",
                "content": "```\\nvar groupAnagrams = function(strs) {\\n    /* sort each string, use that as key in map and when new sorted string matches a key we add it to that */\\n    const map = {};\\n    \\n    for (const str of strs) {\\n        const sorted = str.split(\\'\\').sort().join(\\'\\');\\n        \\n        if (!map[sorted]) {\\n            map[sorted] = [str];\\n        } else {\\n            map[sorted].push(str);\\n        }\\n    }\\n    \\n    return Object.values(map);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar groupAnagrams = function(strs) {\\n    /* sort each string, use that as key in map and when new sorted string matches a key we add it to that */\\n    const map = {};\\n    \\n    for (const str of strs) {\\n        const sorted = str.split(\\'\\').sort().join(\\'\\');\\n        \\n        if (!map[sorted]) {\\n            map[sorted] = [str];\\n        } else {\\n            map[sorted].push(str);\\n        }\\n    }\\n    \\n    return Object.values(map);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1889233,
                "title": "java-easy-hashmap",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String,ArrayList<String>> mpp = new HashMap<String,ArrayList<String>>();\\n\\n        for(String st:strs){\\n            char[] ch = st.toCharArray();\\n            Arrays.sort(ch);\\n            String ss = String.valueOf(ch);\\n            if(!mpp.containsKey(ss)) mpp.put(ss,new ArrayList<String>());\\n            mpp.get(ss).add(st);\\n        }\\n        return new ArrayList<>(mpp.values());\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String,ArrayList<String>> mpp = new HashMap<String,ArrayList<String>>();\\n\\n        for(String st:strs){\\n            char[] ch = st.toCharArray();\\n            Arrays.sort(ch);\\n            String ss = String.valueOf(ch);\\n            if(!mpp.containsKey(ss)) mpp.put(ss,new ArrayList<String>());\\n            mpp.get(ss).add(st);\\n        }\\n        return new ArrayList<>(mpp.values());\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566165,
                "title": "simple-python3-solution-using-dictionary-and-sorted-anagrams",
                "content": "The idea here is to use the sorted anagram as a key and the anagrams themselves as the values. In the end, after iterating through the list of words, you\\'ll return the values from the dictionary.\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n      anagrams = defaultdict(list)\\n      for word in strs:\\n        anagrams[\\'\\'.join(sorted(word))].append(word)\\n      return list(anagrams.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n      anagrams = defaultdict(list)\\n      for word in strs:\\n        anagrams[\\'\\'.join(sorted(word))].append(word)\\n      return list(anagrams.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412445,
                "title": "dictionary-sorting-python-easy-solution-with-explanation",
                "content": "# Intuition\\n**Find a way to associate similar words together.** \\nWe can utilize the **wo**rd **co**unt **ap**proach but I preferred the approach where you **so**rt the **wo**rd. This allows **an**agrams to be **so**rted and we can then **ma**tch the **wo**rds. \\nFor example, \\n\\n`\\'tan\\' and \\'nat\\' when sorted would become \\'ant\\' and \\'ant\\'`\\n\\n\\n\\n# Approach\\n1. Iterate over the \\'strs\\' and sort each word.\\n2. Check if the sorted word exists as key in the dictionary/hashmap\\n3. Because we are going to use the original word in the returned output,create a temp variable to store the sorted word.\\n4. Now check if the temporary sorted word exists in the dictionary/hashmap\\n5. If yes, append the word to the values list.\\n6. If no, add a new key-value pair in the dictionary/hashmap.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        # Create a dictionary to act as hashmap\\n        res = {}\\n        for word in strs:\\n            # We want to retain the original word to add to the dictionary\\n            # Therefore, create a temporary variable with the sorted word\\n            temp = \\'\\'.join(sorted(word))\\n            # If the sorted word exists in the dictionary, \\n            # append to the values list\\n            if temp in res:\\n                res[temp].append(word)\\n            # Else, add a new key-value pair to the dictionary\\n            else:\\n                res[temp] = [word]\\n        # We only require the values list to be returned\\n        return res.values()\\n\\n```\\n<br><br>\\nPlease **up**vote if you find the approach and **ex**planation **us**eful!\\n<br>",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        # Create a dictionary to act as hashmap\\n        res = {}\\n        for word in strs:\\n            # We want to retain the original word to add to the dictionary\\n            # Therefore, create a temporary variable with the sorted word\\n            temp = \\'\\'.join(sorted(word))\\n            # If the sorted word exists in the dictionary, \\n            # append to the values list\\n            if temp in res:\\n                res[temp].append(word)\\n            # Else, add a new key-value pair to the dictionary\\n            else:\\n                res[temp] = [word]\\n        # We only require the values list to be returned\\n        return res.values()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19178,
                "title": "c-clean-solution-beat-95-83-hash-map",
                "content": "```\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> h;\\n        for(int i = 0; i < strs.size(); i++){\\n            string temp = strs[i];\\n            sort(temp.begin(), temp.end());\\n            h[temp].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto m: h) ans.push_back(m.second);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> h;\\n        for(int i = 0; i < strs.size(); i++){\\n            string temp = strs[i];\\n            sort(temp.begin(), temp.end());\\n            h[temp].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto m: h) ans.push_back(m.second);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2920518,
                "title": "solution",
                "content": "```\\nvector<vector<string> > Anagrams(vector<string>& str) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,vector<string>> mp;\\n        \\n        for(auto x: str)\\n        {\\n            string temp = x;\\n            sort(x.begin(),x.end());\\n            mp[x].push_back(temp);\\n        }\\n        for(auto x: mp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n    \\n    // for this example the map will be\\n    // example:- N = 5\\n    // words[] = {act,god,cat,dog,tac}\\n    \\n    // The map will be:- \\n    // string     vector<string>\\n    // act        cat tac\\n    // god        dog\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<string> > Anagrams(vector<string>& str) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,vector<string>> mp;\\n        \\n        for(auto x: str)\\n        {\\n            string temp = x;\\n            sort(x.begin(),x.end());\\n            mp[x].push_back(temp);\\n        }\\n        for(auto x: mp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n    \\n    // for this example the map will be\\n    // example:- N = 5\\n    // words[] = {act,god,cat,dog,tac}\\n    \\n    // The map will be:- \\n    // string     vector<string>\\n    // act        cat tac\\n    // god        dog\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328466,
                "title": "c-one-pass-24ms-99-99-faster-and-15-5-mb-99-73-less-memory",
                "content": "The common idea is to use a hashmap (unordered_map) to group the strings. \\nThere are several ways to choose the key for this task.\\n\\n1. Use sorted string as key, e.g `eat` and `tea` produce the same key, `aet`.\\n2. Use a counter array and transform it to a key somehow, e.g `none` and `neon` have 2 `n`s, 1 `o` and 1 `e`.\\n3. Use a perfect (no collision) hash that produces a unique hash for each anagram.\\n\\nOption 1 is slow, because sorting takes time. Option 2 is better, but it takes more memory than necessary (`26 * sizeof(int)`), needs some transformation operation.\\n\\nFor Option 3, we could multiply each char, like `A` would become `1` and `Z` would become `26`. e.g `eat` -> `5 * 1 * 20` -> `100`, `tea` -> `20 * 5 * 1` -> `100`. Therefore, the hash is indifferent to the order of the chars.\\n\\nThe problem is these numbers are not primes, so their multiplication can cause collisions like `abebe` (not a word)-> `1 * 2 * 5 * 2 * 5` -> `100`. Actually since `A` is `1`, we can add infenitely many `A`s and still get the same hash!\\n\\nWe mentioned that these numbers were not primes, what we can do is instead of mapping `A...Z` to `1...26`, we can map each char to a different, preferably small primes. Thus, if we map each char to the first 26 primes, we can generate a unique hash for each anagram.\\n\\n\\n```\\nuint32_t hash(const string &word) {\\n\\tstatic int primes[26] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101 };\\n\\n\\tuint32_t hash = 1;\\n\\tfor (char c : word) {\\n\\t\\tint prime = primes[c - \\'a\\'];\\n\\t\\thash *= prime;\\n\\t}\\n\\treturn hash;\\n}\\n```\\n\\n**EDIT: There is a bug in this hashing function, thanks to @WillF for pointing out the overflow issue, please refer to the comments for the updated one.**\\n\\nNow for the rest, normally you\\'d see two passes for this task, one for grouping the strings and one for extracting all values of the `unorderd_map` like\\n```\\nunordered_map<uint32_t, vector<string>> mapping;\\n...\\nfor (string word : strs) { ... }\\n\\n// If only we could do `return mapping.values()`\\nvector<vector<string>> result;\\nfor (auto pair : mapping) {\\n  result.push_back(pair.second);\\n}\\n\\nreturn result;\\n```\\n\\nThis has the problem of a lot of unnecessary copying. `unordered_map` is a blackbox, what we can do is to force it to sequentially place each group by taking care of the allocation process. The key remains the same, but the value now becomes a pointer to the actual container. This way we can directly return the required container without additional passes. \\n\\n```\\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\tunordered_map<uint32_t, vector<string> *> mapping;\\n\\tvector<vector<string>> ans;\\n\\n\\t// Hack: \\n\\t//  If we reserve size beforehand, the vector will not grow \\n\\t//  during `push_back()` operations\\n\\t//  Thus, the pointers (vector<string> *) won\\'t become invalidated, i.e dangling pointers\\n\\tans.reserve(strs.size());\\n\\n\\t// Optional: \\n\\t//   Empirically, reserving 1/4th of the number of words \\n\\t//   gives the best performance\\n\\tmapping.reserve(strs.size() / 4);\\n\\n\\tfor (string word : strs) {\\n\\t\\tuint32_t h = hash(word);\\n\\n\\t\\tauto search = mapping.find(h);\\n\\t\\tif (search == mapping.end()) {\\n\\t\\t\\t// Create a new bucket for this new anagram\\n\\t\\t\\tvector<string> v { word };\\n\\t\\t\\tans.push_back(std::move(v));\\n\\n\\t\\t\\t// Note that we can\\'t also do &v because it will soon get deallocated\\n\\t\\t\\tmapping[h] = &ans.back();\\n\\t\\t} else {\\n\\t\\t\\tmapping[h]->push_back(word);\\n\\t\\t}\\n\\t\\t// This way we avoid copying the strings in the last step\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n\\nTo avoid the dangling pointer problem, instead of using references we can just store the index of the corresponding `vector<string>`, so if the `vector<vector<string>>` decides to grow, we will still access the correct container.\\n(indexes and pointers are very related concepts after all.)\\n\\n```\\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n    unordered_map<uint32_t, size_t> mapping;\\n    vector<vector<string>> ans;\\n    \\n    // Optional: Not mandatory anymore, but still helps with performance\\n    ans.reserve(strs.size());\\n    \\n    // Optional: \\n    //   Empirically, reserving 1/4th of the number of words \\n    //   gives the best performance\\n    mapping.reserve(strs.size() / 4);\\n    \\n    for (string word : strs) {\\n        uint32_t h = hash(word);\\n        \\n        auto search = mapping.find(h);\\n        if (search == mapping.end()) {\\n            // Create a new bucket for this new anagram\\n            vector<string> v { word };\\n            ans.push_back(std::move(v));\\n            \\n            // Store the corresponding vector index for this group\\n            mapping[h] = ans.size() - 1;\\n        } else {\\n            size_t index = mapping[h];\\n            ans[index].push_back(word);\\n        }\\n        // This way we avoid copying the strings in the last step\\n    }\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nuint32_t hash(const string &word) {\\n\\tstatic int primes[26] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101 };\\n\\n\\tuint32_t hash = 1;\\n\\tfor (char c : word) {\\n\\t\\tint prime = primes[c - \\'a\\'];\\n\\t\\thash *= prime;\\n\\t}\\n\\treturn hash;\\n}\\n```\n```\\nunordered_map<uint32_t, vector<string>> mapping;\\n...\\nfor (string word : strs) { ... }\\n\\n// If only we could do `return mapping.values()`\\nvector<vector<string>> result;\\nfor (auto pair : mapping) {\\n  result.push_back(pair.second);\\n}\\n\\nreturn result;\\n```\n```\\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\tunordered_map<uint32_t, vector<string> *> mapping;\\n\\tvector<vector<string>> ans;\\n\\n\\t// Hack: \\n\\t//  If we reserve size beforehand, the vector will not grow \\n\\t//  during `push_back()` operations\\n\\t//  Thus, the pointers (vector<string> *) won\\'t become invalidated, i.e dangling pointers\\n\\tans.reserve(strs.size());\\n\\n\\t// Optional: \\n\\t//   Empirically, reserving 1/4th of the number of words \\n\\t//   gives the best performance\\n\\tmapping.reserve(strs.size() / 4);\\n\\n\\tfor (string word : strs) {\\n\\t\\tuint32_t h = hash(word);\\n\\n\\t\\tauto search = mapping.find(h);\\n\\t\\tif (search == mapping.end()) {\\n\\t\\t\\t// Create a new bucket for this new anagram\\n\\t\\t\\tvector<string> v { word };\\n\\t\\t\\tans.push_back(std::move(v));\\n\\n\\t\\t\\t// Note that we can\\'t also do &v because it will soon get deallocated\\n\\t\\t\\tmapping[h] = &ans.back();\\n\\t\\t} else {\\n\\t\\t\\tmapping[h]->push_back(word);\\n\\t\\t}\\n\\t\\t// This way we avoid copying the strings in the last step\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\n```\\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n    unordered_map<uint32_t, size_t> mapping;\\n    vector<vector<string>> ans;\\n    \\n    // Optional: Not mandatory anymore, but still helps with performance\\n    ans.reserve(strs.size());\\n    \\n    // Optional: \\n    //   Empirically, reserving 1/4th of the number of words \\n    //   gives the best performance\\n    mapping.reserve(strs.size() / 4);\\n    \\n    for (string word : strs) {\\n        uint32_t h = hash(word);\\n        \\n        auto search = mapping.find(h);\\n        if (search == mapping.end()) {\\n            // Create a new bucket for this new anagram\\n            vector<string> v { word };\\n            ans.push_back(std::move(v));\\n            \\n            // Store the corresponding vector index for this group\\n            mapping[h] = ans.size() - 1;\\n        } else {\\n            size_t index = mapping[h];\\n            ans[index].push_back(word);\\n        }\\n        // This way we avoid copying the strings in the last step\\n    }\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2155441,
                "title": "rust-hashmap-solution-simple",
                "content": "```rs\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        let mut h = HashMap::new();\\n        \\n        for s in strs {\\n            let mut key: Vec<char> = s.chars().collect();\\n            key.sort();\\n            h.entry(key).or_insert(vec![]).push(s);\\n        }\\n        \\n        h.values().cloned().collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rs\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        let mut h = HashMap::new();\\n        \\n        for s in strs {\\n            let mut key: Vec<char> = s.chars().collect();\\n            key.sort();\\n            h.entry(key).or_insert(vec![]).push(s);\\n        }\\n        \\n        h.values().cloned().collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399196,
                "title": "easy-simple-concise-98-faster-well-explained",
                "content": "## IDEA :\\n* The main idea is to make the different groups for every different anagrams.\\n* Since Anagrams means to have same letters with different meanings.\\n* We can use the idea of sort to arrange them in group.\\n* Sorted word of Every Anagram words will be same.\\n****\\nEg: [\"tea\",\"eat\",\"ate] will have sorted word as **\"aet\"**. \\nHere \"aet\" can be key of dictionary and all others as values.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic=defaultdict(list)\\n        for s in strs:\\n            dic[\\'\\'.join(sorted(s))].append(s)\\n        \\n        return dic.values()\\n\\n****\\nThanks and support if you got helpful!! \\uD83E\\uDD17\\nPlease **Upvote** and feel free to ask if you have any doubt. \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA :\\n* The main idea is to make the different groups for every different anagrams.\\n* Since Anagrams means to have same letters with different meanings.\\n* We can use the idea of sort to arrange them in group.\\n* Sorted word of Every Anagram words will be same.\\n****\\nEg: [\"tea\",\"eat\",\"ate] will have sorted word as **\"aet\"**. \\nHere \"aet\" can be key of dictionary and all others as values.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic=defaultdict(list)\\n        for s in strs:\\n            dic[\\'\\'.join(sorted(s))].append(s)\\n        \\n        return dic.values()\\n\\n****\\nThanks and support if you got helpful!! \\uD83E\\uDD17\\nPlease **Upvote** and feel free to ask if you have any doubt. \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1340493,
                "title": "c-simple-short-and-easy-solution-o-nm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        string tmp_sorted;\\n        \\n        for (auto word : strs) {\\n            tmp_sorted = word;\\n            sort(tmp_sorted.begin(), tmp_sorted.end());\\n            m[tmp_sorted].push_back(word);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for (auto [word, list] : m) {\\n            res.push_back(list);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n****\\n**Faster solution, using Counting Sort, Time Complexity: O(nm)**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        string tmp_sorted;\\n        \\n        for (auto word : strs) {\\n            tmp_sorted = countSort(word);\\n            m[tmp_sorted].push_back(word);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for (auto [word, list] : m) {\\n            res.push_back(list);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    string countSort(string word) {\\n        vector<int> count(26);\\n        string res;\\n        \\n        for (auto ch : word) count[ch - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) res += string(count[i], i+\\'a\\');\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        string tmp_sorted;\\n        \\n        for (auto word : strs) {\\n            tmp_sorted = word;\\n            sort(tmp_sorted.begin(), tmp_sorted.end());\\n            m[tmp_sorted].push_back(word);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for (auto [word, list] : m) {\\n            res.push_back(list);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        string tmp_sorted;\\n        \\n        for (auto word : strs) {\\n            tmp_sorted = countSort(word);\\n            m[tmp_sorted].push_back(word);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for (auto [word, list] : m) {\\n            res.push_back(list);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    string countSort(string word) {\\n        vector<int> count(26);\\n        string res;\\n        \\n        for (auto ch : word) count[ch - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) res += string(count[i], i+\\'a\\');\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688150,
                "title": "5-line-js-solution-easy-to-understand",
                "content": "```javascript\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {\\n    let mappings = {};\\n    \\n    for(let word of strs) {\\n        // this will convert \\'eat\\' into \\'e\\',\\'a\\',\\'t\\' and then sort it to \\'a\\',\\'e\\',\\'t\\' and then join to \\'ate\\'\\n        // we do this so the sorted anagram key will always be the same. Other related anagrams will have the same key\\n        const anagramGroup = word.split(\"\").sort().join(\"\");\\n        \\n        // if we have a mapping that exists for the anagram group, push the item to that group, \\n        // else create a new array and append the word\\n        mappings[anagramGroup] ? mappings[anagramGroup].push(word) : mappings[anagramGroup] = [word];\\n    }\\n    // returns all the mappings as a unified array.\\n    return Object.values(mappings);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {\\n    let mappings = {};\\n    \\n    for(let word of strs) {\\n        // this will convert \\'eat\\' into \\'e\\',\\'a\\',\\'t\\' and then sort it to \\'a\\',\\'e\\',\\'t\\' and then join to \\'ate\\'\\n        // we do this so the sorted anagram key will always be the same. Other related anagrams will have the same key\\n        const anagramGroup = word.split(\"\").sort().join(\"\");\\n        \\n        // if we have a mapping that exists for the anagram group, push the item to that group, \\n        // else create a new array and append the word\\n        mappings[anagramGroup] ? mappings[anagramGroup].push(word) : mappings[anagramGroup] = [word];\\n    }\\n    // returns all the mappings as a unified array.\\n    return Object.values(mappings);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19338,
                "title": "sorting-python-solution-beats-100",
                "content": "Nothing fancy, just a straightforward solution using a dictionary.\\n```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        anas = {}\\n        for string in strs:\\n            s = ''.join(sorted(string))\\n            if s in anas:\\n                anas[s].append(string)\\n            else:\\n                anas[s] = [string]\\n        return [ anas[x] for x in anas ]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        anas = {}\\n        for string in strs:\\n            s = ''.join(sorted(string))\\n            if s in anas:\\n                anas[s].append(string)\\n            else:\\n                anas[s] = [string]\\n        return [ anas[x] for x in anas ]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 19329,
                "title": "simple-java-solution",
                "content": "\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\t\\tList<List<String>> res = new ArrayList<>();\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        \\n        Arrays.sort(strs);\\n        for (int i = 0; i < strs.length; i++) {\\n        \\tString temp = strs[i];\\n        \\tchar[] ch = temp.toCharArray();\\n        \\tArrays.sort(ch);\\n        \\tif (map.containsKey(String.valueOf(ch))) {\\n        \\t\\tmap.get(String.valueOf(ch)).add(strs[i]);\\n        \\t} else {\\n        \\t\\tList<String> each = new ArrayList<>();\\n        \\t\\teach.add(strs[i]);\\n        \\t\\tmap.put(String.valueOf(ch), each);\\n        \\t}\\n        }\\n        for (List<String> item: map.values()) {\\n        \\tres.add(item);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\t\\tList<List<String>> res = new ArrayList<>();\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        \\n        Arrays.sort(strs);\\n        for (int i = 0; i < strs.length; i++) {\\n        \\tString temp = strs[i];\\n        \\tchar[] ch = temp.toCharArray();\\n        \\tArrays.sort(ch);\\n        \\tif (map.containsKey(String.valueOf(ch))) {\\n        \\t\\tmap.get(String.valueOf(ch)).add(strs[i]);\\n        \\t} else {\\n        \\t\\tList<String> each = new ArrayList<>();\\n        \\t\\teach.add(strs[i]);\\n        \\t\\tmap.put(String.valueOf(ch), each);\\n        \\t}\\n        }\\n        for (List<String> item: map.values()) {\\n        \\tres.add(item);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1663675,
                "title": "solution-swift-group-anagrams-test-cases",
                "content": "```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict: [[Character]:[String]] = [:]\\n        for c in strs {\\n            let abc = c.sorted()\\n            dict[abc] == nil ? (dict[abc] = [c]) : (dict[abc]?.append(c))\\n        }\\n        return dict.map({$1})\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.022 (0.024) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.groupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"])\\n        let expected = [[\"nat\",\"tan\"],[\"bat\"],[\"ate\",\"eat\",\"tea\"]]\\n        XCTAssertEqual(value.count, expected.count)\\n        XCTAssertEqual(value.count, 3)\\n        value.forEach {\\n            XCTAssertTrue(expected.contains($0.sorted()))\\n        }\\n    }\\n    func test1() {\\n        let value = solution.groupAnagrams([\"\"])\\n        XCTAssertEqual(value, [[\"\"]])\\n    }\\n    func test2() {\\n        let value = solution.groupAnagrams([\"a\"])\\n        XCTAssertEqual(value, [[\"a\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict: [[Character]:[String]] = [:]\\n        for c in strs {\\n            let abc = c.sorted()\\n            dict[abc] == nil ? (dict[abc] = [c]) : (dict[abc]?.append(c))\\n        }\\n        return dict.map({$1})\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.groupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"])\\n        let expected = [[\"nat\",\"tan\"],[\"bat\"],[\"ate\",\"eat\",\"tea\"]]\\n        XCTAssertEqual(value.count, expected.count)\\n        XCTAssertEqual(value.count, 3)\\n        value.forEach {\\n            XCTAssertTrue(expected.contains($0.sorted()))\\n        }\\n    }\\n    func test1() {\\n        let value = solution.groupAnagrams([\"\"])\\n        XCTAssertEqual(value, [[\"\"]])\\n    }\\n    func test2() {\\n        let value = solution.groupAnagrams([\"a\"])\\n        XCTAssertEqual(value, [[\"a\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551701,
                "title": "java-tc-o-totalchars-n-sc-o-n-group-by-signature-of-each-string",
                "content": "```java\\n/**\\n * Categorize by Count of characters\\n *\\n * Time Complexity:\\n * - O(TotalChars + 26*11*2*N) -> To calculate the count of characters and create the signature using StringBuilder.\\n * - O(N) -> to generate final result List of groups.\\n * Total Time Complexity = O(TotalChars + N)\\n *\\n * Space Complexity:\\n * - O(26*11*N) -> To save signatures in HashMap.\\n *                 We do not need to count the space required for values in HashMap as they will be used in result.\\n * Total Space Complexity = O(N)\\n *\\n * N = Number of strings in strs array.\\n */\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (strs == null || strs.length == 0) {\\n            return result;\\n        }\\n        if (strs.length == 1) {\\n            result.add(Arrays.asList(strs));\\n            return result;\\n        }\\n\\n        HashMap<String, List<String>> groups = new HashMap<>();\\n        for (String s : strs) {\\n            String signature = getSignature(s);\\n            groups.putIfAbsent(signature, new ArrayList<>());\\n            groups.get(signature).add(s);\\n        }\\n\\n        return new ArrayList<>(groups.values());\\n    }\\n\\n    private String getSignature(String s) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                sb.append((char) (\\'a\\' + i)).append(count[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```java\\n/**\\n * Categorize by Count of characters\\n *\\n * Time Complexity:\\n * - O(TotalChars + 26*11*2*N) -> To calculate the count of characters and create the signature using StringBuilder.\\n * - O(N) -> to generate final result List of groups.\\n * Total Time Complexity = O(TotalChars + N)\\n *\\n * Space Complexity:\\n * - O(26*11*N) -> To save signatures in HashMap.\\n *                 We do not need to count the space required for values in HashMap as they will be used in result.\\n * Total Space Complexity = O(N)\\n *\\n * N = Number of strings in strs array.\\n */\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (strs == null || strs.length == 0) {\\n            return result;\\n        }\\n        if (strs.length == 1) {\\n            result.add(Arrays.asList(strs));\\n            return result;\\n        }\\n\\n        HashMap<String, List<String>> groups = new HashMap<>();\\n        for (String s : strs) {\\n            String signature = getSignature(s);\\n            groups.putIfAbsent(signature, new ArrayList<>());\\n            groups.get(signature).add(s);\\n        }\\n\\n        return new ArrayList<>(groups.values());\\n    }\\n\\n    private String getSignature(String s) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                sb.append((char) (\\'a\\' + i)).append(count[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19441,
                "title": "simple-javascript-solution",
                "content": "    var groupAnagrams = function(strs) {\\n        strs = strs.sort();\\n        var mapping = {};\\n        for (var i = 0; i < strs.length; i++) {\\n            var str = strs[i];\\n            var sorted = str.split('').sort().join('');\\n            \\n            if (mapping[sorted] === undefined) {\\n                mapping[sorted] = [str];\\n            } else {\\n                mapping[sorted].push(str);\\n            }\\n        }\\n        \\n        var output = [];\\n        for (var arr in mapping) {\\n            output.push(mapping[arr]);\\n        }\\n        \\n        return output;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var groupAnagrams = function(strs) {\\n        strs = strs.sort();\\n        var mapping = {};\\n        for (var i = 0; i < strs.length; i++) {\\n            var str = strs[i];\\n            var sorted = str.split('').sort().join('');\\n            \\n            if (mapping[sorted] === undefined) {\\n                mapping[sorted] = [str];\\n            } else {\\n                mapping[sorted].push(str);\\n            }\\n        }\\n        \\n        var output = [];\\n        for (var arr in mapping) {\\n            output.push(mapping[arr]);\\n        }\\n        \\n        return output;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 4055371,
                "title": "java-using-a-map-sorting-beats-98-95",
                "content": "# Intuition\\nThis problem is about grouping words that are anagrams of each other. An anagram is a word formed by rearranging the letters of another word.\\n\\n\\n# Approach\\nWe use a HashMap to efficiently group anagrams. The key is the sorted version of a word, and the value is a list of anagrams.\\n- We initialize an empty list called `result` to store the grouped anagrams.\\n- First, we check if the input `strs` is empty or null. If it is, we return an empty result.\\n- If `strs` contains only one word, we wrap it in a list and return it because there are no other words to group.\\n- We then go through each word in the `strs` array.\\n  - We convert each word into a character array (`charArray`).\\n  - We sort the character array, creating the sorted version of the word (`sortedWord`).\\n  - If `map` does not contain `sortedWord` as a key, we initialize an empty list for that key.\\n  - We add the word to the list corresponding to `sortedWord`.\\n- After processing all words, we have grouped the anagrams inside the `map`.\\n- We extract the lists of anagrams from the `map` values and add them to the `result` list.\\n- Finally, we return the grouped anagrams as the result.\\n\\n# Complexity\\n- Time complexity: O(N * K * log(K))\\n  - N represents the number of words in the `strs` array.\\n  - K represents the maximum length of a word.\\n  - The algorithm iterates through each word (N operations), sorts each word (K * log(K) time complexity), and performs constant-time operations. The dominant factor is the sorting step, resulting in a time complexity of O(N * K * log(K)).\\n\\n- Space complexity: O(N * K)\\n  - The algorithm uses a HashMap to store sorted words as keys and lists of anagrams as values. In the worst case, assuming each word is unique and has a length of K, the space complexity is O(N * K).\\n\\n\\n# Code\\n```\\nclass Solution {\\n  public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        HashMap<String,List<String>> map=new HashMap<>();\\n\\n        List<List<String>> result = new ArrayList<>();\\n\\n\\n        for (String word: strs\\n        ) {\\n            char[] charArray = word.toCharArray();\\n\\n\\n            Arrays.sort(charArray);\\n\\n            String sortedWord = String.valueOf(charArray);\\n\\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }\\n\\n\\n            map.get(sortedWord).add(word);\\n\\n\\n        }\\n        result.addAll(map.values());\\n\\n        return result;\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/4bcbbb97-7806-4680-af9a-63b251d79b5e_1694947233.8470142.webp)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        HashMap<String,List<String>> map=new HashMap<>();\\n\\n        List<List<String>> result = new ArrayList<>();\\n\\n\\n        for (String word: strs\\n        ) {\\n            char[] charArray = word.toCharArray();\\n\\n\\n            Arrays.sort(charArray);\\n\\n            String sortedWord = String.valueOf(charArray);\\n\\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }\\n\\n\\n            map.get(sortedWord).add(word);\\n\\n\\n        }\\n        result.addAll(map.values());\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665489,
                "title": "python-clean-with-dictionary",
                "content": "\\n```\\ndef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        anagrams = {}\\n        for word in strs:\\n            sortedWord = \"\".join(sorted(word))\\n            if sortedWord in anagrams:\\n                anagrams[sortedWord].append(word)\\n            else:\\n                anagrams[sortedWord] = [word]\\n        return list(anagrams.values())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        anagrams = {}\\n        for word in strs:\\n            sortedWord = \"\".join(sorted(word))\\n            if sortedWord in anagrams:\\n                anagrams[sortedWord].append(word)\\n            else:\\n                anagrams[sortedWord] = [word]\\n        return list(anagrams.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1334481,
                "title": "c-easy-to-understand-fast-and-efficient-code-using-hashtables",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string> > mp;\\n        string t;\\n        for(int i=0;i<strs.size();i++)\\n        {\\n             t=strs[i];\\n             sort(t.begin(),t.end());\\n             mp[t].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto pr:mp)\\n        {\\n            ans.push_back(pr.second);\\n        }\\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string> > mp;\\n        string t;\\n        for(int i=0;i<strs.size();i++)\\n        {\\n             t=strs[i];\\n             sort(t.begin(),t.end());\\n             mp[t].push_back(strs[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1083044,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        if (strs == null || strs.Length == 0)\\n            return new List<IList<string>>();\\n        \\n        List<IList<string>> res = new List<IList<string>>();\\n        Dictionary<string, List<string>> dict = new Dictionary<string, List<string>>();\\n        \\n        foreach (var str in strs)\\n        {\\n            string cur = new string(str.OrderBy(x => x).ToArray());\\n            \\n            if (!dict.ContainsKey(cur))\\n                dict.Add(cur, new List<string>());\\n            \\n            dict[cur].Add(str);\\n        }\\n        \\n        foreach (var item in dict.Values)\\n            res.Add(item);\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        if (strs == null || strs.Length == 0)\\n            return new List<IList<string>>();\\n        \\n        List<IList<string>> res = new List<IList<string>>();\\n        Dictionary<string, List<string>> dict = new Dictionary<string, List<string>>();\\n        \\n        foreach (var str in strs)\\n        {\\n            string cur = new string(str.OrderBy(x => x).ToArray());\\n            \\n            if (!dict.ContainsKey(cur))\\n                dict.Add(cur, new List<string>());\\n            \\n            dict[cur].Add(str);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3421522,
                "title": "c-optimized-o-nk-without-sorting-map-of-map-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmap of map technique. map inside map. the inner map should be of size 26.  (O(nk))\\n\\n`map<map<char,int>,vector<string>> mp`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nk)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        vector<vector<string>> ans;\\n\\n        map<map<char,int>, vector<string>> mp;\\n        int n = strs.size();\\n        string temp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            map<char,int> temp;\\n            for(char c:strs[i]){\\n                temp[c]++;\\n            }\\n\\n            mp[temp].push_back(strs[i]);\\n        }\\n\\n\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            ans.push_back(itr->second);\\n        }\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        vector<vector<string>> ans;\\n\\n        map<map<char,int>, vector<string>> mp;\\n        int n = strs.size();\\n        string temp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            map<char,int> temp;\\n            for(char c:strs[i]){\\n                temp[c]++;\\n            }\\n\\n            mp[temp].push_back(strs[i]);\\n        }\\n\\n\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            ans.push_back(itr->second);\\n        }\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750624,
                "title": "fastest-solution-possible-short-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic={}\\n        for a in(strs):\\n            t=list(a)\\n            t.sort()\\n            t=\"\".join(t)\\n            if(t in dic):\\n                dic[t].append(a)\\n            else:\\n                dic[t]=[a]\\n        ans=[]\\n        for a in dic:\\n            ans.append(dic[a])\\n        return(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic={}\\n        for a in(strs):\\n            t=list(a)\\n            t.sort()\\n            t=\"\".join(t)\\n            if(t in dic):\\n                dic[t].append(a)\\n            else:\\n                dic[t]=[a]\\n        ans=[]\\n        for a in dic:\\n            ans.append(dic[a])\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909435,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var map: [String: [String]] = [:]\\n        var res: [[String]] = []\\n\\n        \\n        func sort(_ str: String) -> String {\\n            var chars = Array(str)\\n            let sorted = chars.sorted()\\n            var string = \"\"\\n            for c in sorted { string += String(c) }\\n            return string\\n        }\\n\\n        for str in strs {\\n            let sorted_str = sort(str)\\n            if let _ = map[sorted_str] {\\n                map[sorted_str]?.append(str)\\n            } else {\\n                map[sorted_str] = [str]\\n            }\\n        }\\n        for (_, value) in map { res.append(value) }        \\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var map: [String: [String]] = [:]\\n        var res: [[String]] = []\\n\\n        \\n        func sort(_ str: String) -> String {\\n            var chars = Array(str)\\n            let sorted = chars.sorted()\\n            var string = \"\"\\n            for c in sorted { string += String(c) }\\n            return string\\n        }\\n\\n        for str in strs {\\n            let sorted_str = sort(str)\\n            if let _ = map[sorted_str] {\\n                map[sorted_str]?.append(str)\\n            } else {\\n                map[sorted_str] = [str]\\n            }\\n        }\\n        for (_, value) in map { res.append(value) }        \\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521631,
                "title": "in-c-what-a-pain",
                "content": "```\\nstruct word {\\n    char sorted[256];\\n    char s[256];\\n    UT_hash_handle hh;\\n};\\n\\nint comp(const void *aa, const void *bb)\\n{\\n    char a, b;\\n    a = *(char *)aa;\\n    b = *(char *)bb;\\n    \\n    if (a < b)\\n        return -1;\\n    else if (a > b)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nchar *sort_string(char *s)\\n{\\n    char *rs = malloc(strlen(s)+1);\\n    assert(rs);\\n    strcpy(rs, s);\\n    qsort((void *)rs, strlen(rs), 1, comp);\\n    return rs;\\n}\\n\\nint word_sort(struct word *a, struct word *b) {\\n    return strcmp(a->sorted,b->sorted);\\n}\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nchar *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){\\n    struct word *w, *tmp;\\n    int i;\\n    struct word *words = NULL;\\n    \\n    for (i = 0; i < strsSize; i++) {\\n        char *sorted = sort_string(strs[i]);\\n        w = (struct word *)malloc(sizeof *w);\\n        strncpy(w->sorted, sorted, 256);\\n        strncpy(w->s, strs[i], 256);\\n        HASH_ADD_STR( words, sorted, w );\\n        free(sorted);\\n    }\\n    \\n    char ***ret = malloc(strsSize * sizeof(char *));\\n    int *retcolsizes = malloc(strsSize * sizeof(int));\\n    *returnColumnSizes = retcolsizes;\\n    assert(*returnColumnSizes);\\n    assert(ret);\\n    \\n    *returnSize = -1;\\n    char *anagram = NULL;\\n    \\n    /* XXX: what we would like is something like (python):\\n     *      return dic.values();\\n     * I know its C, but there has to be a better way.\\n     */\\n    HASH_SORT(words, word_sort);\\n    HASH_ITER(hh, words, w, tmp) {\\n        if (anagram != NULL && strcmp(w->sorted, anagram) == 0) {\\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc\\'ed\\n            retcolsizes[*returnSize] += 1;\\n        } else {\\n            *returnSize += 1;\\n            ret[*returnSize] = malloc(strsSize * sizeof(char *));\\n            assert(ret[*returnSize]);\\n            retcolsizes[*returnSize] = 0;\\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc\\'ed\\n            retcolsizes[*returnSize] += 1;\\n            anagram = w->sorted;\\n        }\\n    }\\n    \\n    /* XXX: we are leaking a bunch of memory for the struct word\\'s*/\\n    *returnSize += 1;\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct word {\\n    char sorted[256];\\n    char s[256];\\n    UT_hash_handle hh;\\n};\\n\\nint comp(const void *aa, const void *bb)\\n{\\n    char a, b;\\n    a = *(char *)aa;\\n    b = *(char *)bb;\\n    \\n    if (a < b)\\n        return -1;\\n    else if (a > b)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nchar *sort_string(char *s)\\n{\\n    char *rs = malloc(strlen(s)+1);\\n    assert(rs);\\n    strcpy(rs, s);\\n    qsort((void *)rs, strlen(rs), 1, comp);\\n    return rs;\\n}\\n\\nint word_sort(struct word *a, struct word *b) {\\n    return strcmp(a->sorted,b->sorted);\\n}\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nchar *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){\\n    struct word *w, *tmp;\\n    int i;\\n    struct word *words = NULL;\\n    \\n    for (i = 0; i < strsSize; i++) {\\n        char *sorted = sort_string(strs[i]);\\n        w = (struct word *)malloc(sizeof *w);\\n        strncpy(w->sorted, sorted, 256);\\n        strncpy(w->s, strs[i], 256);\\n        HASH_ADD_STR( words, sorted, w );\\n        free(sorted);\\n    }\\n    \\n    char ***ret = malloc(strsSize * sizeof(char *));\\n    int *retcolsizes = malloc(strsSize * sizeof(int));\\n    *returnColumnSizes = retcolsizes;\\n    assert(*returnColumnSizes);\\n    assert(ret);\\n    \\n    *returnSize = -1;\\n    char *anagram = NULL;\\n    \\n    /* XXX: what we would like is something like (python):\\n     *      return dic.values();\\n     * I know its C, but there has to be a better way.\\n     */\\n    HASH_SORT(words, word_sort);\\n    HASH_ITER(hh, words, w, tmp) {\\n        if (anagram != NULL && strcmp(w->sorted, anagram) == 0) {\\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc\\'ed\\n            retcolsizes[*returnSize] += 1;\\n        } else {\\n            *returnSize += 1;\\n            ret[*returnSize] = malloc(strsSize * sizeof(char *));\\n            assert(ret[*returnSize]);\\n            retcolsizes[*returnSize] = 0;\\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc\\'ed\\n            retcolsizes[*returnSize] += 1;\\n            anagram = w->sorted;\\n        }\\n    }\\n    \\n    /* XXX: we are leaking a bunch of memory for the struct word\\'s*/\\n    *returnSize += 1;\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235518,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {  \\n    const m = new Map();\\n    \\n    for(const s of strs) {\\n        const keys = Array(26).fill(0);\\n        for(const c of s){\\n            ++keys[c.charCodeAt(0) - 97]\\n        }\\n        const key = keys.join(\"#\");\\n        let val = [];\\n        if(m.has(key)) {\\n            val = m.get(key)\\n        }  \\n        val.push(s);\\n        m.set(key, val);\\n    }\\n \\n    return Array.from(m.values());\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {  \\n    const m = new Map();\\n    \\n    for(const s of strs) {\\n        const keys = Array(26).fill(0);\\n        for(const c of s){\\n            ++keys[c.charCodeAt(0) - 97]\\n        }\\n        const key = keys.join(\"#\");\\n        let val = [];\\n        if(m.has(key)) {\\n            val = m.get(key)\\n        }  \\n        val.push(s);\\n        m.set(key, val);\\n    }\\n \\n    return Array.from(m.values());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043475,
                "title": "java-easy-to-understand-very-easy-solution-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs){\\n        List<List<String>>s=new ArrayList<>();\\n        Map<String,List<String>>map=new LinkedHashMap<>();\\n        \\n        for(String e:strs){\\n            char ch[]=e.toCharArray();\\n            Arrays.sort(ch);\\n            String str=new String(ch);\\n            \\n            if(!map.containsKey(str)){\\n                map.put(str,new ArrayList<>());\\n            }\\n            map.get(str).add(e);\\n        }\\n        s.addAll(map.values());\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs){\\n        List<List<String>>s=new ArrayList<>();\\n        Map<String,List<String>>map=new LinkedHashMap<>();\\n        \\n        for(String e:strs){\\n            char ch[]=e.toCharArray();\\n            Arrays.sort(ch);\\n            String str=new String(ch);\\n            \\n            if(!map.containsKey(str)){\\n                map.put(str,new ArrayList<>());\\n            }\\n            map.get(str).add(e);\\n        }\\n        s.addAll(map.values());\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750714,
                "title": "java-solution-using-hashmap-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] str) {\\n        int n=str.length;\\n        HashMap<String,ArrayList<String>> hm=new HashMap<>();\\n        List<List<String>> list=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            char [] ch=str[i].toCharArray();\\n            Arrays.sort(ch);\\n            String temp=new String(ch);\\n            if(hm.containsKey(temp)){\\n                hm.get(temp).add(str[i]);\\n            }\\n            else{\\n                ArrayList<String> t=new ArrayList<>();\\n                t.add(str[i]);\\n                hm.put(temp,t);\\n            }\\n        }\\n        \\n        for(String key:hm.keySet()){\\n            list.add(hm.get(key));\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] str) {\\n        int n=str.length;\\n        HashMap<String,ArrayList<String>> hm=new HashMap<>();\\n        List<List<String>> list=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            char [] ch=str[i].toCharArray();\\n            Arrays.sort(ch);\\n            String temp=new String(ch);\\n            if(hm.containsKey(temp)){\\n                hm.get(temp).add(str[i]);\\n            }\\n            else{\\n                ArrayList<String> t=new ArrayList<>();\\n                t.add(str[i]);\\n                hm.put(temp,t);\\n            }\\n        }\\n        \\n        for(String key:hm.keySet()){\\n            list.add(hm.get(key));\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190927,
                "title": "c-very-simple-solution",
                "content": "\\n\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n            Dictionary<string, IList<string>> dic = new Dictionary<string, IList<string>>();\\n            for (int i = 0; i < strs.Length; i++)\\n            {\\n                char[] arr=strs[i].ToCharArray();\\n                Array.Sort(arr);\\n                string sorted=new string(arr);\\n                if(dic.ContainsKey(sorted))\\n                {\\n                    dic[sorted].Add(strs[i]);\\n                }\\n                else\\n                {\\n                    dic.Add(sorted, new List<string>() {strs[i]});\\n                }\\n            }\\n            var result= dic.Values.ToList();\\n            return result;        \\n    }",
                "solutionTags": [
                    "C#"
                ],
                "code": "\\n\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n            Dictionary<string, IList<string>> dic = new Dictionary<string, IList<string>>();\\n            for (int i = 0; i < strs.Length; i++)\\n            {\\n                char[] arr=strs[i].ToCharArray();\\n                Array.Sort(arr);\\n                string sorted=new string(arr);\\n                if(dic.ContainsKey(sorted))\\n                {\\n                    dic[sorted].Add(strs[i]);\\n                }\\n                else\\n                {\\n                    dic.Add(sorted, new List<string>() {strs[i]});\\n                }\\n            }\\n            var result= dic.Values.ToList();\\n            return result;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1362905,
                "title": "javascript",
                "content": "*Runtime*: **136 ms**, faster than **67.24%** of JavaScript online submissions for Group Anagrams.\\n*Memory Usage*:** 49.7 MB**, less than **71.58%** of JavaScript online submissions for Group Anagrams.\\n\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nconst groupAnagrams = function(strs) {\\n    let groups = {}\\n    strs.forEach(str => {\\n        const sortedStr = str.split(\\'\\').sort().join(\\'\\')\\n        if (groups[sortedStr]) {\\n            groups[sortedStr].push(str)\\n        } else {\\n            groups[sortedStr] = [str]\\n        }\\n    })\\n    return Object.values(groups)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nconst groupAnagrams = function(strs) {\\n    let groups = {}\\n    strs.forEach(str => {\\n        const sortedStr = str.split(\\'\\').sort().join(\\'\\')\\n        if (groups[sortedStr]) {\\n            groups[sortedStr].push(str)\\n        } else {\\n            groups[sortedStr] = [str]\\n        }\\n    })\\n    return Object.values(groups)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 436097,
                "title": "concise-go-golang-solution",
                "content": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    hm := make(map[string][]string)\\n    for _, w := range strs {\\n        key := sortString(w)\\n        hm[key] = append(hm[key], w)\\n    }\\n    \\n    var ans [][]string\\n    for _, words := range hm {\\n        ans = append(ans, words)\\n    }\\n    return ans\\n}\\n\\nfunc sortString(str string) string {\\n    runes := []rune(str)\\n    sort.Slice(runes, func(a, b int) bool {\\n        return runes[a] < runes[b]\\n    })\\n    return string(runes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    hm := make(map[string][]string)\\n    for _, w := range strs {\\n        key := sortString(w)\\n        hm[key] = append(hm[key], w)\\n    }\\n    \\n    var ans [][]string\\n    for _, words := range hm {\\n        ans = append(ans, words)\\n    }\\n    return ans\\n}\\n\\nfunc sortString(str string) string {\\n    runes := []rune(str)\\n    sort.Slice(runes, func(a, b int) bool {\\n        return runes[a] < runes[b]\\n    })\\n    return string(runes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 267058,
                "title": "straightforward-python3-solution",
                "content": "```\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dict = {}        \\n        for str in strs:\\n            key_str = \\'\\'.join(sorted(str))\\n            if key_str in dict:\\n                dict[key_str].append(str)                \\n            else:\\n                dict[key_str] = [str]\\n\\n        return list(dict.values())\\n```",
                "solutionTags": [],
                "code": "```\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dict = {}        \\n        for str in strs:\\n            key_str = \\'\\'.join(sorted(str))\\n            if key_str in dict:\\n                dict[key_str].append(str)                \\n            else:\\n                dict[key_str] = [str]\\n\\n        return list(dict.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3579337,
                "title": "fastest-way-to-solve-this-question-beats-97-36",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires grouping anagrams together in a given array of strings. Two strings are considered anagrams if they have the same characters, but in a different order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an empty hash map, map, to store the grouped anagrams.\\n\\n2. Iterate through each string, str, in the input array strs:\\n\\n3. Convert str into a character array, chars.\\n\\n4. Sort chars in non-decreasing order.\\n\\n5. Convert chars back to a string, sortedStr.\\n\\n6. If sortedStr is not present in map, add it as a new key with an empty list as the value.\\n\\n7. Append str to the list associated with sortedStr in map.\\n\\n8. Return a new ArrayList containing all the values (lists of anagrams) from map.\\n\\n# Complexity\\n- Time complexity:O(n * m * log m), where n is the number of strings in the input array and m is the maximum length of a string. Sorting each string takes O(m * log m) time, and we do this for each of the n strings.\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m), the space used by the hash map map and the returned ArrayList, where n is the number of strings and m is the maximum length of a string.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs.length == 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        for (String i : strs) {\\n            char[] chars = i.toCharArray();\\n            Arrays.sort(chars);\\n            String sortedStr = String.valueOf(chars);\\n            \\n            if (!map.containsKey(sortedStr)) {\\n                map.put(sortedStr, new ArrayList<>());\\n            }\\n            \\n            map.get(sortedStr).add(i);\\n        }\\n        \\n        return new ArrayList<>(map.values());\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs.length == 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        for (String i : strs) {\\n            char[] chars = i.toCharArray();\\n            Arrays.sort(chars);\\n            String sortedStr = String.valueOf(chars);\\n            \\n            if (!map.containsKey(sortedStr)) {\\n                map.put(sortedStr, new ArrayList<>());\\n            }\\n            \\n            map.get(sortedStr).add(i);\\n        }\\n        \\n        return new ArrayList<>(map.values());\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753997,
                "title": "js-ts-solution-hashing-fast-simple-intuitive",
                "content": "# Code\\n```\\nfunction groupAnagrams(strs: string[]): string[][] {\\n    let map = new Map<string, string[]>();\\n    for (let s of strs) {\\n        let charFreq = Array.from({ length: 26 }, () => 0);\\n        for (let i = 0; i < s.length; i++)charFreq[s.charCodeAt(i) - 97]++;\\n        let keyStr = charFreq.toString();\\n        if (!map.has(keyStr)) map.set(keyStr, []);\\n        map.get(keyStr).push(s);\\n    }\\n    return Array.from(map.values());\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nfunction groupAnagrams(strs: string[]): string[][] {\\n    let map = new Map<string, string[]>();\\n    for (let s of strs) {\\n        let charFreq = Array.from({ length: 26 }, () => 0);\\n        for (let i = 0; i < s.length; i++)charFreq[s.charCodeAt(i) - 97]++;\\n        let keyStr = charFreq.toString();\\n        if (!map.has(keyStr)) map.set(keyStr, []);\\n        map.get(keyStr).push(s);\\n    }\\n    return Array.from(map.values());\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2750765,
                "title": "python3-5-lines-w-example-t-m-98-99",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\\n        \\n        anadict = defaultdict(list)     # Ex: [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]                     \\n        \\n        for s in strs:                  #  s   ana  anadict   \\n            ana = \\'\\'.join(sorted(s))    # \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\n            anadict[ana].append(s)      # eat  aet  {\\'aet\\': [\\'eat\\']}\\n                                        # tea  aet  {\\'aet\\': [\\'eat\\', \\'tea\\']}\\n                                        # tan  ant  {\\'aet\\': [\\'eat\\', \\'tea\\'], \\'ant\\': [\\'tan\\']}\\n                                        # ate  aet  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\']}\\n                                        # nat  ant  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\', \\'nat\\']}\\n                                        # bat  abt  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\', \\'nat\\'], \\'abt\\': [\\'bat\\']}\\n\\n        return list(anadict.values())   # [[\\'eat\\', \\'tea\\', \\'ate\\'], [\\'tan\\', \\'nat\\'], [\\'bat\\']]\\n```\\n\\n[https://leetcode.com/submissions/detail/583502656/](http://)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\\n        \\n        anadict = defaultdict(list)     # Ex: [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]                     \\n        \\n        for s in strs:                  #  s   ana  anadict   \\n            ana = \\'\\'.join(sorted(s))    # \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\n            anadict[ana].append(s)      # eat  aet  {\\'aet\\': [\\'eat\\']}\\n                                        # tea  aet  {\\'aet\\': [\\'eat\\', \\'tea\\']}\\n                                        # tan  ant  {\\'aet\\': [\\'eat\\', \\'tea\\'], \\'ant\\': [\\'tan\\']}\\n                                        # ate  aet  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\']}\\n                                        # nat  ant  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\', \\'nat\\']}\\n                                        # bat  abt  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\', \\'nat\\'], \\'abt\\': [\\'bat\\']}\\n\\n        return list(anadict.values())   # [[\\'eat\\', \\'tea\\', \\'ate\\'], [\\'tan\\', \\'nat\\'], [\\'bat\\']]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595584,
                "title": "solution",
                "content": "```\\nvector<vector<string> > Anagrams(vector<string>& str) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,vector<string>> mp;\\n        \\n        for(auto x: str)\\n        {\\n            string temp = x;\\n            sort(x.begin(),x.end());\\n            mp[x].push_back(temp);\\n        }\\n        for(auto x: mp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n    \\n    // for this example the map will be\\n    // example:- N = 5\\n    // words[] = {act,god,cat,dog,tac}\\n    \\n    // The map will be:- \\n    // string     vector<string>\\n    // act        cat tac\\n    // god        dog\\n\\t```",
                "solutionTags": [],
                "code": "```\\nvector<vector<string> > Anagrams(vector<string>& str) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,vector<string>> mp;\\n        \\n        for(auto x: str)\\n        {\\n            string temp = x;\\n            sort(x.begin(),x.end());\\n            mp[x].push_back(temp);\\n        }\\n        for(auto x: mp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n    \\n    // for this example the map will be\\n    // example:- N = 5\\n    // words[] = {act,god,cat,dog,tac}\\n    \\n    // The map will be:- \\n    // string     vector<string>\\n    // act        cat tac\\n    // god        dog\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 19264,
                "title": "map-lambda-list-comprehension-3-lines-of-python",
                "content": "    def anagrams(self, strs):\\n        dic = defaultdict(list)\\n        map(lambda item: dic[''.join(sorted(item))].append(item), strs)\\n        return [x for key in dic.keys() for x in dic[key] if len(dic[key]) > 1]\\n\\nEquivalent to:\\n\\n    def anagrams(self, strs):\\n        dic = defaultdict(list)\\n        for item in strs:\\n            after = ''.join(sorted(item))\\n            dic[after].append(item)\\n        ans = []\\n        for item in dic:\\n            values = dic[item]\\n            if len(values) > 1:\\n                ans.extend(values)\\n        return ans",
                "solutionTags": [],
                "code": "    def anagrams(self, strs):\\n        dic = defaultdict(list)\\n        map(lambda item: dic[''.join(sorted(item))].append(item), strs)\\n        return [x for key in dic.keys() for x in dic[key] if len(dic[key]) > 1]\\n\\nEquivalent to:\\n\\n    def anagrams(self, strs):\\n        dic = defaultdict(list)\\n        for item in strs:\\n            after = ''.join(sorted(item))\\n            dic[after].append(item)\\n        ans = []\\n        for item in dic:\\n            values = dic[item]\\n            if len(values) > 1:\\n                ans.extend(values)\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 4006990,
                "title": "three-simple-java-solutions-runtime-5ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# code1\\nRuntime 5ms\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n        HashMap<String , ArrayList<String>> hashmap = new HashMap<>();\\n\\n        for (String s : strs)\\n        {\\n            char chars[] = s.toCharArray();\\n            Arrays.sort(chars);\\n            String s2 = new String(chars);\\n            \\n            List<String> arr = hashmap.computeIfAbsent(s2, key -> new ArrayList<>());\\n            arr.add(s);\\n        }\\n\\n        return new ArrayList<>(hashmap.values());\\n    }\\n}\\n```\\n\\n# Code2\\nRuntime 9ms\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n        List<List<String>> list = new LinkedList<>();\\n\\n        HashMap<String , ArrayList<String>> hashmap = new HashMap<>();\\n\\n        for (String s : strs)\\n        {\\n            char c1[] = s.toCharArray();\\n            Arrays.sort(c1);\\n            StringBuilder s2 = new StringBuilder();\\n            for (char c : c1)\\n            {\\n                s2.append(c);\\n            }\\n            List<String> arr = hashmap.computeIfAbsent(s2.toString(), key -> new ArrayList<>());\\n            arr.add(s);\\n        }\\n\\n        for(Map.Entry<String, ArrayList<String>> entry : hashmap.entrySet()) {\\n            List<String> l1 = new LinkedList<>();\\n            for (String s : entry.getValue()){\\n                l1.add(s);\\n            }\\n            list.add(l1);\\n        }\\n\\n        return list;\\n    }\\n}\\n\\n```\\n\\n\\n# code3\\nRuntime 670ms\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n      List<List<String>> list = new LinkedList<>();\\n\\n        ArrayList<String> str1 = new ArrayList<>(strs.length);\\n\\n        for (int i = 0 ; i < strs.length ; i++)\\n        {\\n            char c1[] = strs[i].toCharArray();\\n            Arrays.sort(c1);\\n            StringBuilder s2 = new StringBuilder();\\n            for (char c : c1) {\\n                s2.append(c);\\n            }\\n            str1.add(s2.toString());\\n        }\\n\\n        for (int i = 0; i < str1.size() ; i++)\\n        {\\n            List<String> l1 = new LinkedList<>();\\n            String temp = str1.get(i).toString();\\n            if (temp != \"-1\") {\\n                int index = i;\\n                while (index != -1) {\\n                    str1.set(index, \"-1\");\\n                    l1.add(strs[index]);\\n                    index = str1.indexOf(temp);\\n                }\\n\\n                list.add(l1);\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/54abaa5f-db31-440b-9104-9e18facf6608_1693939907.7778165.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n        HashMap<String , ArrayList<String>> hashmap = new HashMap<>();\\n\\n        for (String s : strs)\\n        {\\n            char chars[] = s.toCharArray();\\n            Arrays.sort(chars);\\n            String s2 = new String(chars);\\n            \\n            List<String> arr = hashmap.computeIfAbsent(s2, key -> new ArrayList<>());\\n            arr.add(s);\\n        }\\n\\n        return new ArrayList<>(hashmap.values());\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n        List<List<String>> list = new LinkedList<>();\\n\\n        HashMap<String , ArrayList<String>> hashmap = new HashMap<>();\\n\\n        for (String s : strs)\\n        {\\n            char c1[] = s.toCharArray();\\n            Arrays.sort(c1);\\n            StringBuilder s2 = new StringBuilder();\\n            for (char c : c1)\\n            {\\n                s2.append(c);\\n            }\\n            List<String> arr = hashmap.computeIfAbsent(s2.toString(), key -> new ArrayList<>());\\n            arr.add(s);\\n        }\\n\\n        for(Map.Entry<String, ArrayList<String>> entry : hashmap.entrySet()) {\\n            List<String> l1 = new LinkedList<>();\\n            for (String s : entry.getValue()){\\n                l1.add(s);\\n            }\\n            list.add(l1);\\n        }\\n\\n        return list;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n      List<List<String>> list = new LinkedList<>();\\n\\n        ArrayList<String> str1 = new ArrayList<>(strs.length);\\n\\n        for (int i = 0 ; i < strs.length ; i++)\\n        {\\n            char c1[] = strs[i].toCharArray();\\n            Arrays.sort(c1);\\n            StringBuilder s2 = new StringBuilder();\\n            for (char c : c1) {\\n                s2.append(c);\\n            }\\n            str1.add(s2.toString());\\n        }\\n\\n        for (int i = 0; i < str1.size() ; i++)\\n        {\\n            List<String> l1 = new LinkedList<>();\\n            String temp = str1.get(i).toString();\\n            if (temp != \"-1\") {\\n                int index = i;\\n                while (index != -1) {\\n                    str1.set(index, \"-1\");\\n                    l1.add(strs[index]);\\n                    index = str1.indexOf(temp);\\n                }\\n\\n                list.add(l1);\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566051,
                "title": "anagram-grouping-using-hash-table",
                "content": "# Intuition\\nThis one took a bit of time. I first though about counting characters in individual strings and then lifting them out of the vector one-by-one by matching the character counts. After some trial and error I got that to work but realized that that took too much time, so I needed a new plan. I thought about sorting the characters in the string and then would\\'ve only needed to compare the string, not the characters, but for this method I needed to change the character counting method to a map. This turned out to be very time and space efficient compared to others, being in the top 5% of LeetCode submissions.\\n\\n# Approach\\n1. Create an unordered map called **groups**, where the keys will represent the sorted versions of the anagrams, and the values will be vectors of strings that belong to the same anagram group.\\n2. Iterate through each string in the input vector **strs**.\\n3. For each string, create a copy called **sortedStr** and sort its characters in ascending order using the **sort** function. This step ensures that anagrams have the same sorted representation.\\n4. Use the sorted string **sortedStr** as the key in the **groups** map. If the key doesn\\'t exist in the map, a new entry is automatically created with an empty vector as the value. If the key already exists, the corresponding vector is accessed.\\n5. Push the original unsorted string **str** into the vector associated with the key **sortedStr**. This step groups the anagrams together.\\n6. After iterating through all the strings, create a **vector<vector<string>>** called **result** to store the grouped anagrams.\\n7. Iterate through each key-value pair in the **groups** map. For each pair, access the vector of anagrams (the value) and push it into the **result** vector.\\n8. Return the **result** vector, which contains the anagram groups.\\n\\nThe main idea behind this approach is to use the sorted representation of each string as the key in an unordered map. By grouping the original unsorted strings together based on their sorted versions, you can efficiently group the anagrams. The final result is a vector of vectors, where each inner vector represents a group of anagrams.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N * K log K)$$, where N is the total number of strings in the input vector **strs** and K is the average length of the strings\\n\\n- Space complexity:\\n$$O(N * K)$$, where N is the number of strings and K is the average length of the strings\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> groups;\\n        for (const string& str : strs) {\\n            string sortedStr = str;\\n            sort(sortedStr.begin(), sortedStr.end());\\n            groups[sortedStr].push_back(str);\\n        }\\n\\n        vector<vector<string>> result;\\n        for (const auto& pair : groups) {\\n            result.push_back(pair.second);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> groups;\\n        for (const string& str : strs) {\\n            string sortedStr = str;\\n            sort(sortedStr.begin(), sortedStr.end());\\n            groups[sortedStr].push_back(str);\\n        }\\n\\n        vector<vector<string>> result;\\n        for (const auto& pair : groups) {\\n            result.push_back(pair.second);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884408,
                "title": "o-nk-time-o-n-space",
                "content": "# Intuition\\nA couple potential solutions that came to mind:\\n1. Same concept as [Valid Anagram](https://leetcode.com/problems/valid-anagram). You can see my solution [here](https://leetcode.com/problems/valid-anagram/solutions/2881883/o-n-time-o-26-o-1-space/).\\n    - Admittedly, this felt like a performance problem after we mapped every string to it\\'s int[] of occurrences\\n2. Sort each string and compare if the sorted string has occurred before\\n\\nWent with the second approach. Also, easier to code up in interview. Initially, I went with the standard string sort that I know of:\\n```\\nprivate string Sort(string s) {\\n    char[] input = s.ToArray();\\n    Array.Sort(input);\\n    return new string(input);\\n}\\n```\\n\\nHowever, we can improve on this by using counting sort since we are limited to 26 potential characters in the lowercase english alphabet.\\n\\n# Approach\\n1. Sort each string\\n2. Check in hashmap if we have seen the sorted version of the string before\\n    1. If we have, add the original string to the value of the hashmap\\n    2. If we haven\\'t, add the original string to a new entry in the hashmap\\n\\n# Complexity\\n- Time complexity:\\n$$O(nk)$$, where $$n$$ is the length of $$strs$$ and $$k$$ is the length of the longest string in $$strs$$. Our counting sort algorithm uses $$O(26)$$ space and runs in $$O(k+26)$$~$$O(k)$$ time\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        if (strs.Length == 0) {\\n            return new List<IList<string>>();\\n        }\\n\\n        Dictionary<string, List<string>> anagrams = new Dictionary<string, List<string>>();\\n\\n        foreach (string str in strs) {\\n            string sortedStr = CountSort(str);\\n            if (!anagrams.ContainsKey(sortedStr)) {\\n                anagrams.Add(sortedStr, new List<string>());\\n            }\\n\\n            anagrams[sortedStr].Add(str);\\n        }\\n\\n        IList<IList<string>> result = new List<IList<string>>();\\n        foreach (KeyValuePair<string, List<string>> kvp in anagrams) {\\n            result.Add(kvp.Value);\\n        }\\n        return result;\\n    }\\n\\n    private string CountSort(string s) {\\n        int[] counts = new int[26];\\n        foreach (char c in s) {\\n            counts[c - \\'a\\'] += 1;\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n        for (int i = 0; i < counts.Length; i++) {\\n            if (counts[i] > 0) {\\n                builder.Append((char)(\\'a\\' + i), counts[i]);\\n            }\\n        }\\n\\n        return builder.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nprivate string Sort(string s) {\\n    char[] input = s.ToArray();\\n    Array.Sort(input);\\n    return new string(input);\\n}\\n```\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        if (strs.Length == 0) {\\n            return new List<IList<string>>();\\n        }\\n\\n        Dictionary<string, List<string>> anagrams = new Dictionary<string, List<string>>();\\n\\n        foreach (string str in strs) {\\n            string sortedStr = CountSort(str);\\n            if (!anagrams.ContainsKey(sortedStr)) {\\n                anagrams.Add(sortedStr, new List<string>());\\n            }\\n\\n            anagrams[sortedStr].Add(str);\\n        }\\n\\n        IList<IList<string>> result = new List<IList<string>>();\\n        foreach (KeyValuePair<string, List<string>> kvp in anagrams) {\\n            result.Add(kvp.Value);\\n        }\\n        return result;\\n    }\\n\\n    private string CountSort(string s) {\\n        int[] counts = new int[26];\\n        foreach (char c in s) {\\n            counts[c - \\'a\\'] += 1;\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n        for (int i = 0; i < counts.Length; i++) {\\n            if (counts[i] > 0) {\\n                builder.Append((char)(\\'a\\' + i), counts[i]);\\n            }\\n        }\\n\\n        return builder.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750799,
                "title": "simple-c-code-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n       vector<vector<string>>res;\\n        unordered_map<string,vector<string>>mp;\\n        for(auto&i: strs)\\n            {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0string t=i;//created a copy\\n\\t\\t\\t\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0sort(t.begin(),t.end());//sorted to get the key\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0mp[t].push_back(i);//pushed the initial string in map\\n \\xA0 \\xA0 \\xA0 \\xA0}\\n        for(auto&i:mp)\\n            {\\n            res.push_back(i.second);\\n            }\\n        return res;\\n    }\\n};\\n```\\nWe created a map with string as key and vector of strings as value. As anagrams are just rearrangement of same set of letters , so if we sort them we will get a same string for all anagrams . So using that as a key we store the strings and then return them as answer.\\nAny suggestions are welcomed in the comments \\uD83D\\uDE03",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n       vector<vector<string>>res;\\n        unordered_map<string,vector<string>>mp;\\n        for(auto&i: strs)\\n            {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0string t=i;//created a copy\\n\\t\\t\\t\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0sort(t.begin(),t.end());//sorted to get the key\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0mp[t].push_back(i);//pushed the initial string in map\\n \\xA0 \\xA0 \\xA0 \\xA0}\\n        for(auto&i:mp)\\n            {\\n            res.push_back(i.second);\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750647,
                "title": "3-different-approaches-to-single-problem-java",
                "content": "## UPVOTE THE SOLUTION IF YOU LIKE IT\\n## 1st Approach\\n![image](https://assets.leetcode.com/users/images/b0c486a4-e6f2-46bb-97a3-8b18258275ae_1666922365.7035868.png)\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] s) {\\n        //edge case\\n        if (s.length == 1) {\\n            List<String> list = new ArrayList<>(1);\\n            list.add(s[0]);\\n            List<List<String>> res = new ArrayList<>(1);\\n            res.add(list);\\n            return res;\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : s) {\\n            byte[] alphabet = new byte[26];\\n            for (char c : word.toCharArray()) {\\n                alphabet[c - \\'a\\']++;\\n            }\\n            for (byte freq : alphabet) {\\n                sb.append(freq).append(\",\");\\n            }\\n            String key = sb.toString();\\n            if (map.containsKey(key)) {\\n                map.get(key).add(word);\\n            } else {\\n                List<String> list = new ArrayList<>();\\n                list.add(word);\\n                map.put(key,list);\\n            }\\n            sb.setLength(0);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n## 2nd Approach\\n![image](https://assets.leetcode.com/users/images/94dd7aa0-4153-495d-a65c-f3df3cb96a93_1666922593.1981628.png)\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n           List<List<String>> output = new ArrayList<List<String>>();\\n        Map<String, List<String>> hashmap= new HashMap<String, List<String>>();\\n        List<String> sortedStrings = new ArrayList<>();\\n        for(String str: strs){\\n            char[] charArray = str.toCharArray();\\n            Arrays.sort(charArray);\\n            String sorted = String.valueOf(charArray);\\n            if(hashmap.containsKey(sorted)){\\n                List<String> temp1 = hashmap.get(sorted);\\n                temp1.add(str);\\n                hashmap.put(sorted,temp1);\\n            }\\n            else{\\n                List<String> temp = new ArrayList<>();\\n                temp.add(str);\\n                hashmap.put(sorted, temp);\\n            }\\n        }\\n        return new ArrayList<>( hashmap.values());\\n    }\\n}\\n```\\n## 3rd Approach\\n![image](https://assets.leetcode.com/users/images/0b3ad927-a64d-4f7a-9340-a6790344eaae_1666922547.2861967.png)\\n```\\nimport java.util.AbstractList;\\nclass Solution {\\n    private List<List<String>> result;\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        return new AbstractList<List<String>>() {\\n\\n            public List<String> get(int index) {\\n                if (result == null)\\n                    init();\\n                return result.get(index);\\n            }\\n\\n            public int size() {\\n                if (result == null)\\n                    init();\\n                return result.size();\\n            }\\n\\n            private void init() {\\n                for (String s : strs) {\\n                    char[] count = new char[26];\\n                    \\n                    for (char c : s.toCharArray())\\n                        count[c - \\'a\\']++;\\n                    String key = String.valueOf(count);\\n                \\n                    if (!map.containsKey(key))\\n                        map.put(key, new ArrayList<String>());\\n                    \\n                    map.get(key).add(s);\\n                }\\n                \\n                result = new ArrayList<>(map.values());\\n            }\\n        };\\n    }\\n}\\n```\\n\\n## IF OU REACHED TILL HERE KINDLY UPVOTE THE SOLUTION",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] s) {\\n        //edge case\\n        if (s.length == 1) {\\n            List<String> list = new ArrayList<>(1);\\n            list.add(s[0]);\\n            List<List<String>> res = new ArrayList<>(1);\\n            res.add(list);\\n            return res;\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : s) {\\n            byte[] alphabet = new byte[26];\\n            for (char c : word.toCharArray()) {\\n                alphabet[c - \\'a\\']++;\\n            }\\n            for (byte freq : alphabet) {\\n                sb.append(freq).append(\",\");\\n            }\\n            String key = sb.toString();\\n            if (map.containsKey(key)) {\\n                map.get(key).add(word);\\n            } else {\\n                List<String> list = new ArrayList<>();\\n                list.add(word);\\n                map.put(key,list);\\n            }\\n            sb.setLength(0);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n           List<List<String>> output = new ArrayList<List<String>>();\\n        Map<String, List<String>> hashmap= new HashMap<String, List<String>>();\\n        List<String> sortedStrings = new ArrayList<>();\\n        for(String str: strs){\\n            char[] charArray = str.toCharArray();\\n            Arrays.sort(charArray);\\n            String sorted = String.valueOf(charArray);\\n            if(hashmap.containsKey(sorted)){\\n                List<String> temp1 = hashmap.get(sorted);\\n                temp1.add(str);\\n                hashmap.put(sorted,temp1);\\n            }\\n            else{\\n                List<String> temp = new ArrayList<>();\\n                temp.add(str);\\n                hashmap.put(sorted, temp);\\n            }\\n        }\\n        return new ArrayList<>( hashmap.values());\\n    }\\n}\\n```\n```\\nimport java.util.AbstractList;\\nclass Solution {\\n    private List<List<String>> result;\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        return new AbstractList<List<String>>() {\\n\\n            public List<String> get(int index) {\\n                if (result == null)\\n                    init();\\n                return result.get(index);\\n            }\\n\\n            public int size() {\\n                if (result == null)\\n                    init();\\n                return result.size();\\n            }\\n\\n            private void init() {\\n                for (String s : strs) {\\n                    char[] count = new char[26];\\n                    \\n                    for (char c : s.toCharArray())\\n                        count[c - \\'a\\']++;\\n                    String key = String.valueOf(count);\\n                \\n                    if (!map.containsKey(key))\\n                        map.put(key, new ArrayList<String>());\\n                    \\n                    map.get(key).add(s);\\n                }\\n                \\n                result = new ArrayList<>(map.values());\\n            }\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225057,
                "title": "super-simple-6ms-java-solution-readable",
                "content": "```\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n\\tMap<String, List<String>> map = new HashMap<>();\\n\\tfor(String str : strs) {\\n\\t\\tchar[] chars = str.toCharArray();\\n\\t\\tArrays.sort(chars);\\n\\n\\t\\tString sortedStr = new String(chars);\\n\\t\\tmap.putIfAbsent(sortedStr, new ArrayList<>());\\n\\t\\tmap.get(sortedStr).add(str);\\n\\t}\\n\\n\\treturn new ArrayList<>(map.values());\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n\\tMap<String, List<String>> map = new HashMap<>();\\n\\tfor(String str : strs) {\\n\\t\\tchar[] chars = str.toCharArray();\\n\\t\\tArrays.sort(chars);\\n\\n\\t\\tString sortedStr = new String(chars);\\n\\t\\tmap.putIfAbsent(sortedStr, new ArrayList<>());\\n\\t\\tmap.get(sortedStr).add(str);\\n\\t}\\n\\n\\treturn new ArrayList<>(map.values());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1384401,
                "title": "c-group-anagrams-sorting-and-hashmap",
                "content": "# **LeetCode + Todoist = Consistent Grind -- TRY [Code Task](https://codetask.vercel.app/)**\\n\\n**Using Sorting - Sort every string and push in appropriate bucket**\\n* **Time Complexcity : `O(n.klog(k))`** *where **k** is the length of string and **n** is total no. of strings*\\n* **Space Complexcity : `O(n)`** *if none of the strings are anagram*\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        unordered_map<string, vector<string>> sorted;\\n        \\n        for(int i = 0; i < strs.size(); i++){\\n            string temp = strs[i];\\n            sort(strs[i].begin(), strs[i].end());\\n            sorted[strs[i]].push_back(temp);\\n        }\\n        \\n        for(auto it = sorted.begin(); it != sorted.end(); it++){\\n            ans.push_back(it->second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        unordered_map<string, vector<string>> sorted;\\n        \\n        for(int i = 0; i < strs.size(); i++){\\n            string temp = strs[i];\\n            sort(strs[i].begin(), strs[i].end());\\n            sorted[strs[i]].push_back(temp);\\n        }\\n        \\n        for(auto it = sorted.begin(); it != sorted.end(); it++){\\n            ans.push_back(it->second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566237,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        let mut out = std::collections::HashMap::new();\\n        for v in strs {\\n            let mut k: Vec<u8> = v.bytes().collect();\\n            k.sort_unstable();\\n            out.entry(k).or_insert_with(|| vec![]).push(v)\\n        }\\n        out.into_iter().map(|(_, v)| v).collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        let mut out = std::collections::HashMap::new();\\n        for v in strs {\\n            let mut k: Vec<u8> = v.bytes().collect();\\n            k.sort_unstable();\\n            out.entry(k).or_insert_with(|| vec![]).push(v)\\n        }\\n        out.into_iter().map(|(_, v)| v).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 566236,
                "title": "javascript-5-lines-explained",
                "content": "The approach here is actually quite simple once accounted for.\\n- All we\\'re doing is creating a way to categorize each anagram.\\n- Which can easily be done by sorting in alphabetical order.\\n- Then as we loop through them, if they adhere to the sorted form, we know they belong.\\n- So, add them to the array under which their key or category exists, and finally we can...\\n- return these arrays by looping over the values for each category/key\\n```js\\nvar groupAnagrams = function(strs) {\\n    let map = {}\\n    \\n    for (let str of strs) {\\n        let key = [...str].sort()\\n        map[key] = map[key] ? [...map[key], str] : [str]\\n    }\\n    \\n    return Object.values(map)\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar groupAnagrams = function(strs) {\\n    let map = {}\\n    \\n    for (let str of strs) {\\n        let key = [...str].sort()\\n        map[key] = map[key] ? [...map[key], str] : [str]\\n    }\\n    \\n    return Object.values(map)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478474,
                "title": "javascript-most-common-technique-with-good-explanation",
                "content": "**Time complexity is 95.53%**\\n\\n**You can follow along with my numbered markers which are pointers to comments in the code block**\\n\\n1. Just general validations & checks\\n2. Using `Map()` because most of the operations I\\'ll be using are `O(1)`, you could opt for a dictionary using an object but you\\'ll see in step 5 we optimize for speed\\n3. We loop over every word\\n4. We create 2 variables, 1 is the word, 1 is the word but sorted alphabetically\\n\\t- worst `O(n^2)`\\n\\t- avg `O(n log(n))`\\n5. The magic of our `Map()` is here\\n\\t- If our sorted word matches any existing sorted word (which makes it an anagram) then we add it to our anagram list\\n\\t- If our sorted word doesn\\'t match anything, add a new entry to the map\\n\\t\\t- The key would be the sorted word\\n\\t\\t- The value would be an array of the word eg. `[\"word\"]`\\n\\t- `Map().size` is an `O(1)` solution of getting the length vs `Object.entries(...).length` is an `O(n)` because of converting an object to an array\\n\\t- `get()`, `has()`, `push()` and `set()` are all `O(1)`\\n\\t- The only added benefit of using this over a dictionary is readability and the `size` prototype from `Map()`\\n6. We\\'ll have all our results stored in our `Map()`, we just iterate over all our results and put them into 1 array then return that!\\n\\n```\\n// 1\\nif (strs.length === 0) return []\\nif (strs.length === 1) return [strs]\\n\\n// 2\\nconst words = new Map()\\n\\n// 3\\nfor (let i = 0; i < strs.length; i++) {\\n\\tconst word = strs[i]\\n\\tconst wordSorted = [...word].sort().join(\\'\\') // 4\\n\\n\\t// 5\\n\\tif (words.size > 0 && words.has(wordSorted)) {\\n\\t\\twords.get(wordSorted).push(word)\\n\\t} else {\\n\\t\\twords.set(wordSorted, [word])\\n\\t}\\n}\\n\\n// 6\\nconst result = []\\n\\nfor (const [_, list] of words.entries()) {\\n\\tresult.push(list)\\n}\\n\\nreturn result\\n```\\n\\nHope you guys enjoyed this!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// 1\\nif (strs.length === 0) return []\\nif (strs.length === 1) return [strs]\\n\\n// 2\\nconst words = new Map()\\n\\n// 3\\nfor (let i = 0; i < strs.length; i++) {\\n\\tconst word = strs[i]\\n\\tconst wordSorted = [...word].sort().join(\\'\\') // 4\\n\\n\\t// 5\\n\\tif (words.size > 0 && words.has(wordSorted)) {\\n\\t\\twords.get(wordSorted).push(word)\\n\\t} else {\\n\\t\\twords.set(wordSorted, [word])\\n\\t}\\n}\\n\\n// 6\\nconst result = []\\n\\nfor (const [_, list] of words.entries()) {\\n\\tresult.push(list)\\n}\\n\\nreturn result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19394,
                "title": "another-approach-hash-by-prime-numbers-java-16ms-defeating-97-53",
                "content": "   The key for this problem is to find a way of hashing. In this solution, the basic idea is to calculate a hash value for each string using prime number. For example, the 1st letter, 'a', represent the 1st prime number, 2. The 2nd letter 'b' for the 2nd prime number 3......After calculating hash values for each word, group them by hash value.\\n```\\npublic class Solution {\\n    private static final int[] primetable = primes(26);\\n    // private static final int[] primetable = new int[]{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<Integer, List<String>> map = new HashMap<>(strs.length);\\n        for(String s:strs){\\n            int hashcode = hash(s);\\n            map.putIfAbsent(hashcode, new ArrayList<String>());\\n            map.get(hashcode).add(s);\\n        }\\n        List<List<String>> res= new ArrayList<>();\\n        res.addAll(map.values());\\n        return res;\\n    }\\n    private int hash(String s){\\n        int hashcode = 1;\\n        for(char c:s.toCharArray()){\\n            hashcode *= primetable[c-97];\\n        }\\n        return hashcode;\\n    }\\n    private static int[] primes(int n){\\n        if(n<1){\\n            return null;\\n        }\\n        int[] res = new int[n];\\n        res[0] = 2;\\n        int counter = 1, cur = 3;\\n        while(counter<n){\\n            for(int num:res){\\n                // if visited all previous prime numbers\\n                if(num==0 || num*num >cur){\\n                    res[counter++] = cur++; \\n                    break;\\n                }\\n                // not a prime number\\n                if(cur%num==0){\\n                    ++cur;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    private static final int[] primetable = primes(26);\\n    // private static final int[] primetable = new int[]{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<Integer, List<String>> map = new HashMap<>(strs.length);\\n        for(String s:strs){\\n            int hashcode = hash(s);\\n            map.putIfAbsent(hashcode, new ArrayList<String>());\\n            map.get(hashcode).add(s);\\n        }\\n        List<List<String>> res= new ArrayList<>();\\n        res.addAll(map.values());\\n        return res;\\n    }\\n    private int hash(String s){\\n        int hashcode = 1;\\n        for(char c:s.toCharArray()){\\n            hashcode *= primetable[c-97];\\n        }\\n        return hashcode;\\n    }\\n    private static int[] primes(int n){\\n        if(n<1){\\n            return null;\\n        }\\n        int[] res = new int[n];\\n        res[0] = 2;\\n        int counter = 1, cur = 3;\\n        while(counter<n){\\n            for(int num:res){\\n                // if visited all previous prime numbers\\n                if(num==0 || num*num >cur){\\n                    res[counter++] = cur++; \\n                    break;\\n                }\\n                // not a prime number\\n                if(cur%num==0){\\n                    ++cur;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19443,
                "title": "i-solved-it-with-o-m-log-m-n-time-o-m-n-space-is-there-better-solution-accepted",
                "content": "m represents the mean length of String in strs. I sorted every String, and used HashMap to store the groups of strings that are anagrams.\\n\\n    public class Solution {\\n        public ArrayList<String> anagrams(String[] strs) {\\n            if(strs==null || strs.length==0) return null;\\n            ArrayList<String> ret = new ArrayList<String>();\\n            Map<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();\\n            for(String s:strs)\\n            {\\n                char[] temp = s.toCharArray();\\n                Arrays.sort(temp);\\n                ArrayList<String> array = map.get(new String(temp));\\n                if(array==null)\\n                {\\n                    array = new ArrayList<String>();\\n                    array.add(s);\\n                    map.put(new String(temp), array);\\n                }\\n                else array.add(s);\\n            }\\n            for(String s:map.keySet())\\n            {\\n                ArrayList<String> array = map.get(s);\\n                if(array.size()!=1) ret.addAll(array);\\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public ArrayList<String> anagrams(String[] strs) {\\n            if(strs==null || strs.length==0) return null;\\n            ArrayList<String> ret = new ArrayList<String>();\\n            Map<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();\\n            for(String s:strs)\\n            {\\n                char[] temp = s.toCharArray();\\n                Arrays.sort(temp);\\n                ArrayList<String> array = map.get(new String(temp));\\n                if(array==null)\\n                {\\n                    array = new ArrayList<String>();\\n                    array.add(s);\\n                    map.put(new String(temp), array);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3140613,
                "title": "c-map-sorting-all-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is to sort every string present in str and keeping the sorted string as key push all the strings which will match this osrted key string. And thise will be actually anagrams .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse sorting and hashing.\\nAlso we can do count sort becuase we have only 26 charcaters so we can direclty locate values which are present in the string in `O(n)` time so need to sort in $$nlogn $$\\n# Complexity\\n- Time complexity:O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Using Normal Stl Sort [$$n*k*logk$$]**\\n```\\nvector<vector<string>> groupAnagrams(vector<string>& str) {\\n\\n        map<string,vector<string>>mp;\\n        int k=0;\\n        for(auto x:str){\\n           string s=x;\\n           sort(begin(s),end(s));\\n           mp[s].push_back(x);\\n        }\\n        vector<vector<string>>res;\\n        for(auto x:mp)\\n         res.push_back(x.second);\\n\\n        return res;\\n    }\\n```\\n**Using Count Sort**\\n```\\nclass Solution {\\npublic:\\n    void count_sort(string& s){\\n        int n=s.size();\\n        vector<int>mp(26,0);\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            mp[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n          ans.append(mp[i],i+\\'a\\');\\n        }\\n        s=ans;\\n    }\\n    vector<vector<string>> groupAnagrams(vector<string>& str) {\\n\\n        map<string,vector<string>>mp;\\n        int k=0;\\n        for(auto x:str){\\n           string s=x;\\n           count_sort(s);\\n           mp[s].push_back(x);\\n        }\\n        vector<vector<string>>res;\\n        for(auto x:mp)\\n         res.push_back(x.second);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<string>> groupAnagrams(vector<string>& str) {\\n\\n        map<string,vector<string>>mp;\\n        int k=0;\\n        for(auto x:str){\\n           string s=x;\\n           sort(begin(s),end(s));\\n           mp[s].push_back(x);\\n        }\\n        vector<vector<string>>res;\\n        for(auto x:mp)\\n         res.push_back(x.second);\\n\\n        return res;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    void count_sort(string& s){\\n        int n=s.size();\\n        vector<int>mp(26,0);\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            mp[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n          ans.append(mp[i],i+\\'a\\');\\n        }\\n        s=ans;\\n    }\\n    vector<vector<string>> groupAnagrams(vector<string>& str) {\\n\\n        map<string,vector<string>>mp;\\n        int k=0;\\n        for(auto x:str){\\n           string s=x;\\n           count_sort(s);\\n           mp[s].push_back(x);\\n        }\\n        vector<vector<string>>res;\\n        for(auto x:mp)\\n         res.push_back(x.second);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751160,
                "title": "simple-solution-with-explanation-tc-o-n-length-of-largest-word-sc-o-n",
                "content": "* We have to just count the occurrence of each word and store it in a map of array having same frequency pattern.\\n* Lastly return all the values of hashmap\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dct=defaultdict(list)\\n        for i in range(len(strs)):\\n            st=[0 for _ in range(26)]\\n            for j in strs[i]:\\n                xi=ord(j)-97\\n                st[xi]+=1\\n            st=tuple(st)\\n            dct[st].append(strs[i])\\n        return dct.values()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dct=defaultdict(list)\\n        for i in range(len(strs)):\\n            st=[0 for _ in range(26)]\\n            for j in strs[i]:\\n                xi=ord(j)-97\\n                st[xi]+=1\\n            st=tuple(st)\\n            dct[st].append(strs[i])\\n        return dct.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750484,
                "title": "javascript-solution-using-hashmap",
                "content": "```\\nconst groupAnagrams = function(strs) {\\n    const groups = {};\\n    for(let str of strs) {\\n        const key = str.split(\"\").sort();\\n        if(key in groups) {\\n            groups[key].push(str);\\n        }\\n        else {\\n            groups[key] = [str];\\n        }\\n    }\\n    return Object.values(groups);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst groupAnagrams = function(strs) {\\n    const groups = {};\\n    for(let str of strs) {\\n        const key = str.split(\"\").sort();\\n        if(key in groups) {\\n            groups[key].push(str);\\n        }\\n        else {\\n            groups[key] = [str];\\n        }\\n    }\\n    return Object.values(groups);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1048422,
                "title": "2-solutions-in-c-one-using-sort-and-other-without-sort",
                "content": "1 . C++ Solution With Sort in O(N*KlogK) Time\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>> mpp;\\n        \\n        for(string str : strs)\\n        {\\n            string copy = str;\\n            sort(copy.begin(),copy.end());\\n            mpp[copy].push_back(str);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x : mpp)\\n        {     \\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n2 . C++ Solution Without Sort in O(N*K) Time\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        map<map<char,int>,vector<string>>mpp;  \\n        for(string s : strs)\\n        {\\n            map<char,int>mpp2;\\n            for(char ch : s)\\n                mpp2[ch]++;\\n            mpp[mpp2].push_back(s);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x : mpp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>> mpp;\\n        \\n        for(string str : strs)\\n        {\\n            string copy = str;\\n            sort(copy.begin(),copy.end());\\n            mpp[copy].push_back(str);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x : mpp)\\n        {     \\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        map<map<char,int>,vector<string>>mpp;  \\n        for(string s : strs)\\n        {\\n            map<char,int>mpp2;\\n            for(char ch : s)\\n                mpp2[ch]++;\\n            mpp[mpp2].push_back(s);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x : mpp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717546,
                "title": "swift-one-line",
                "content": "```swift\\nclass Solution {\\n  func groupAnagrams(_ strs: [String]) -> [[String]] {\\n    return Array(Dictionary(grouping: strs) { $0.sorted() }.values)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n  func groupAnagrams(_ strs: [String]) -> [[String]] {\\n    return Array(Dictionary(grouping: strs) { $0.sorted() }.values)\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548172,
                "title": "easy-python-solution-with-explanation",
                "content": "Basic Idea - If your sort anagrams they come same string. \\nUse this to create a disctionary with corted words as key and keep appending all anagrams to it. \\nIn the end, iterate over disctionary to get the answer in expected format. \\n\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        d = {}\\n        ans = []\\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            if sorted_word not in d:\\n                d[sorted_word] = [word]\\n            else:\\n                d[sorted_word].append(word)\\n            \\n        for key in d:\\n            ans.append(d[key])\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        d = {}\\n        ans = []\\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            if sorted_word not in d:\\n                d[sorted_word] = [word]\\n            else:\\n                d[sorted_word].append(word)\\n            \\n        for key in d:\\n            ans.append(d[key])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391010,
                "title": "very-simple-c-solution-faster-than-99-92-submissions",
                "content": "A very simple C# soluton using a HashTable / Dictionary. Feel free to suggest improvements.\\n\\n**Time Complexity:** O(n * mlogm)\\nwhere n is the number of items in the array and m is the length of each anagram \\n**Space Complexity:** O(n) \\n\\nRuntime: 280 ms, faster than 99.92% of C# online submissions for Group Anagrams.\\nMemory Usage: 37.3 MB, less than 23.53% of C# online submissions for Group Anagrams.\\n\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        IList<IList<string>> result = new List<IList<string>>();\\n        Dictionary<string, List<string>> map = new Dictionary<string, List<string>>();\\n        foreach(string anagram in strs){\\n            char[] tempArray = anagram.ToCharArray();\\n            Array.Sort(tempArray);\\n            string sorted = new string(tempArray);\\n            if(!map.ContainsKey(sorted)){\\n                map.Add(sorted, new List<string>(){ anagram });                \\n            }else{\\n                map[sorted].Add(anagram);   \\n            }\\n        }\\n        foreach(var pair in map){\\n            result.Add(pair.Value);\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "A very simple C# soluton using a HashTable / Dictionary. Feel free to suggest improvements.\\n\\n**Time Complexity:** O(n * mlogm)\\nwhere n is the number of items in the array and m is the length of each anagram \\n**Space Complexity:** O(n) \\n\\nRuntime: 280 ms, faster than 99.92% of C# online submissions for Group Anagrams.\\nMemory Usage: 37.3 MB, less than 23.53% of C# online submissions for Group Anagrams.\\n\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        IList<IList<string>> result = new List<IList<string>>();\\n        Dictionary<string, List<string>> map = new Dictionary<string, List<string>>();\\n        foreach(string anagram in strs){\\n            char[] tempArray = anagram.ToCharArray();\\n            Array.Sort(tempArray);\\n            string sorted = new string(tempArray);\\n            if(!map.ContainsKey(sorted)){\\n                map.Add(sorted, new List<string>(){ anagram });                \\n            }else{\\n                map[sorted].Add(anagram);   \\n            }\\n        }\\n        foreach(var pair in map){\\n            result.Add(pair.Value);\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 299592,
                "title": "go-beats-100",
                "content": "```\\nfunc groupAnagrams(words []string) [][]string {\\n\\tcache := make(map[[26]byte]int)\\n\\tresult := make([][]string, 0)\\n\\tfor i := range words {\\n\\t\\tlist := [26]byte{}\\n\\t\\tfor j := range words[i] {\\n\\t\\t\\tlist[words[i][j]-\\'a\\']++\\n\\t\\t}\\n\\t\\tif idx, ok := cache[list]; ok {\\n\\t\\t\\tresult[idx] = append(result[idx], words[i])\\n\\t\\t} else {\\n\\t\\t\\tresult = append(result, []string{words[i]})\\n\\t\\t\\tcache[list] = len(result) - 1\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc groupAnagrams(words []string) [][]string {\\n\\tcache := make(map[[26]byte]int)\\n\\tresult := make([][]string, 0)\\n\\tfor i := range words {\\n\\t\\tlist := [26]byte{}\\n\\t\\tfor j := range words[i] {\\n\\t\\t\\tlist[words[i][j]-\\'a\\']++\\n\\t\\t}\\n\\t\\tif idx, ok := cache[list]; ok {\\n\\t\\t\\tresult[idx] = append(result[idx], words[i])\\n\\t\\t} else {\\n\\t\\t\\tresult = append(result, []string{words[i]})\\n\\t\\t\\tcache[list] = len(result) - 1\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250264,
                "title": "java-solutions",
                "content": "**Solution 1: Group by Sorted String**\\n\\n> Two strings are `anagrams` if and only if their sorted strings are equal.\\n- We use `Map` to group the strings by their sorted counterparts. We use the sorted string as the key and List of anagram strings as the value. Each key `keyStr` is a sorted string, and each value is the list of strings from the initial input that when sorted, are equal to `keyStr`.\\n- The outer loop has complexity `O(n)` as we iterate through each string. Then, we sort each string in `O(k log k)` time.\\n\\nTime complexity: `O(n * k log k)` - where `n` is the length of input array `strs`, and `k` is the maximum length of a string in `strs` array. \\nSpace complexity: `O(n * k)` - the total information content stored in a `Map`. \\n\\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n\\t\\tMap<String, List<String>> map = new HashMap<>();\\n\\t\\t\\n        for(String s : strs)\\n\\t\\t{\\n            char[] ca = s.toCharArray();\\n            Arrays.sort(ca);\\n            String keyStr = String.valueOf(ca);\\n    \\t\\tmap.putIfAbsent(keyStr, new ArrayList<>());\\t\\t// If no mapping for a key, then map a new key with an empty list.\\n\\t\\t\\tmap.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n\\n**Solution 2: Group by Character Counts**\\n\\n> Two strings are `anagrams` if and only if their character counts are the same.\\n- We can transform each string `s` into an encoded string based on the its character counts.\\n- For example, string `abbccc` will be `a1b2c3d0e0...z0` where there are `26` entries for each character from `a` to `z`.\\n\\nTime complexity: `O(n * k)` - Encoding each string is linear in the size of the string which is `O(k)`, and we encode every string. So `O(n) * O(k) = O(n * k)`.\\nSpace complexity: `O(n * k)` - the total information content stored in a `Map`.\\n\\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n        Map<String, List<String>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(String s : strs)\\n\\t\\t{\\n            String keyStr = encodeString(s);\\n            map.putIfAbsent(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n\\n\\tprivate String encodeString(String s)\\n\\t{\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint[] count = new int[26];\\n\\t\\tArrays.fill(count, 0);\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t{\\n\\t\\t\\tcount[c - \\'a\\'] += 1;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0; i < 26; i++)\\n\\t\\t{\\n\\t\\t\\tsb.append(i + \\'a\\').append(count[i]);\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\t}\\n}\\n```\\n\\n**Solution 3: Group by hashCode**\\n\\n- Here we compute the `hashCode` of an array of character counts of the string.\\n\\nTime complexity: `O(n * k)` - Computing a hashCode for each string is linear in the size of the string which is `O(k)`, and we do this for every string. So `O(n) * O(k) = O(n * k)`.\\nSpace complexity: `O(n * k)` - the total information content stored in a `Map`.\\n\\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n        Map<Integer, List<String>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(String s : strs)\\n\\t\\t{\\n            int hashCode = computeHashCode(s);\\n            map.putIfAbsent(hashCode, new ArrayList<>());\\n            map.get(hashCode).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n\\n\\tprivate int computeHashCode(String s)\\n\\t{\\n\\t\\tint[] count = new int[26];\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t{\\n\\t\\t\\tcount[c - \\'a\\'] += 1;\\n\\t\\t}\\n\\t\\treturn Arrays.hashCode(count);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n\\t\\tMap<String, List<String>> map = new HashMap<>();\\n\\t\\t\\n        for(String s : strs)\\n\\t\\t{\\n            char[] ca = s.toCharArray();\\n            Arrays.sort(ca);\\n            String keyStr = String.valueOf(ca);\\n    \\t\\tmap.putIfAbsent(keyStr, new ArrayList<>());\\t\\t// If no mapping for a key, then map a new key with an empty list.\\n\\t\\t\\tmap.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n        Map<String, List<String>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(String s : strs)\\n\\t\\t{\\n            String keyStr = encodeString(s);\\n            map.putIfAbsent(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n\\n\\tprivate String encodeString(String s)\\n\\t{\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint[] count = new int[26];\\n\\t\\tArrays.fill(count, 0);\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t{\\n\\t\\t\\tcount[c - \\'a\\'] += 1;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0; i < 26; i++)\\n\\t\\t{\\n\\t\\t\\tsb.append(i + \\'a\\').append(count[i]);\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\t}\\n}\\n```\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n        Map<Integer, List<String>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(String s : strs)\\n\\t\\t{\\n            int hashCode = computeHashCode(s);\\n            map.putIfAbsent(hashCode, new ArrayList<>());\\n            map.get(hashCode).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n\\n\\tprivate int computeHashCode(String s)\\n\\t{\\n\\t\\tint[] count = new int[26];\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t{\\n\\t\\t\\tcount[c - \\'a\\'] += 1;\\n\\t\\t}\\n\\t\\treturn Arrays.hashCode(count);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19463,
                "title": "accept-java-solution",
                "content": "    public class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            Map <String,Integer>mp = new HashMap<String,Integer>();\\n            Arrays.sort(strs);\\n            for(String str : strs){\\n                char[] ch = str.toCharArray();\\n                Arrays.sort(ch);\\n                String s = new String(ch);\\n                if(mp.containsKey(s)){\\n                    List li = res.get(mp.get(s));\\n                    li.add(str);\\n                }else{\\n                    List li = new ArrayList();\\n                    li.add(str);\\n                    res.add(li);\\n                    mp.put(s,res.size()-1);\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n\\nstep 1. sort the original array. Make sure the output order is correct.\\nstep 2. sort every string, check if it's in hash map. if is, add to the result, if not, add to the hashMap.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            Map <String,Integer>mp = new HashMap<String,Integer>();\\n            Arrays.sort(strs);\\n            for(String str : strs){\\n                char[] ch = str.toCharArray();\\n                Arrays.sort(ch);\\n                String s = new String(ch);\\n                if(mp.containsKey(s)){\\n                    List li = res.get(mp.get(s));\\n                    li.add(str);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3267924,
                "title": "c-solution-using-groupby-and-sorting",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        return strs\\n            .GroupBy(s => new string(s.OrderBy(c => c).ToArray()))\\n            .Select(g => g.ToList() as IList<string>)\\n            .ToList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        return strs\\n            .GroupBy(s => new string(s.OrderBy(c => c).ToArray()))\\n            .Select(g => g.ToList() as IList<string>)\\n            .ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750508,
                "title": "js-javascript-solution-with-map",
                "content": "# Any feedback would be appreciated \\uD83D\\uDE0A\\n\\n```\\nconst groupAnagrams = function(strs) {\\n  const map = new Map();\\n  \\n  for (let str of strs) {\\n    let curr = [...str].sort().join(\\'\\');\\n    if (!map.has(curr)) map.set(curr, []);\\n    map.get(curr).push(str);\\n  }\\n  return Array.from(map.values());\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst groupAnagrams = function(strs) {\\n  const map = new Map();\\n  \\n  for (let str of strs) {\\n    let curr = [...str].sort().join(\\'\\');\\n    if (!map.has(curr)) map.set(curr, []);\\n    map.get(curr).push(str);\\n  }\\n  return Array.from(map.values());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2252670,
                "title": "solved-with-c",
                "content": "Simple and fast solution using c#\\n\\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n\\n           if (strs == null || strs.Length == 0) return new List<IList<string>>();\\n            var countDict = new Dictionary<string, IList<string>>();\\n            foreach (string str in strs)\\n            {\\n                var charList = new char[26];\\n                foreach (char c in str)\\n                {\\n                    charList[c - \\'a\\']++;\\n                }\\n\\n                var key = new string(charList);\\n\\n                if (!countDict.ContainsKey(key))\\n                {\\n                    countDict.Add(key, new List<string> { str });\\n                }\\n                else\\n                {\\n                    countDict[key].Add(str);\\n                }\\n            }\\n\\n            return countDict.Values.ToList();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n\\n           if (strs == null || strs.Length == 0) return new List<IList<string>>();\\n            var countDict = new Dictionary<string, IList<string>>();\\n            foreach (string str in strs)\\n            {\\n                var charList = new char[26];\\n                foreach (char c in str)\\n                {\\n                    charList[c - \\'a\\']++;\\n                }\\n\\n                var key = new string(charList);\\n\\n                if (!countDict.ContainsKey(key))\\n                {\\n                    countDict.Add(key, new List<string> { str });\\n                }\\n                else\\n                {\\n                    countDict[key].Add(str);\\n                }\\n            }\\n\\n            return countDict.Values.ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085008,
                "title": "error-incompatible-types-boolean-cannot-be-converted-to-list-string",
                "content": "Not sure why I am getting this error. Can someone please help me in understanding this.\\n![image](https://assets.leetcode.com/users/images/8851fbfc-88d5-46f8-b001-06a281427eb6_1653769454.915814.png)\\n\\ncode:\\n```\\nHashMap<String, List<String>> hm = new HashMap<>();\\nhm.put(temp, hm.get(temp).add(s));\\n```\\nHere temp and s are of type String\\n\\nBut below code snippet is working fine\\n\\n``` \\nList<String> list = hm.get(temp);  \\nlist.add(s);            \\nhm.put(temp,list); \\n```\\n\\n\\nFull code:\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        if(strs.length == 0)\\n            return new ArrayList();\\n        \\n        HashMap<String, List<String>> hm = new HashMap<>();\\n        \\n        for(String s : strs){   \\n            char[] ch = s.toCharArray();\\n            Arrays.sort(ch);   \\n\\n            String temp = new String(ch);\\n            \\n            if(hm.containsKey(temp)){   \\n                List<String> list = hm.get(temp);  \\n                list.add(s);           \\n                hm.put(temp,list);      \\n                //hm.put(temp, hm.get(temp).add(s));    // why it\\'s not working? --getting error here\\n            }\\n            else{\\n                List<String> list = new ArrayList<>(1);\\n                list.add(s);\\n                hm.put(temp,list);\\n            }\\n        }\\n \\n        List<List<String>> ans = new ArrayList<>();\\n        \\n        for(Map.Entry entry : hm.entrySet()){   \\n            List list = (List)entry.getValue();\\n            ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nHashMap<String, List<String>> hm = new HashMap<>();\\nhm.put(temp, hm.get(temp).add(s));\\n```\n``` \\nList<String> list = hm.get(temp);  \\nlist.add(s);            \\nhm.put(temp,list); \\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        if(strs.length == 0)\\n            return new ArrayList();\\n        \\n        HashMap<String, List<String>> hm = new HashMap<>();\\n        \\n        for(String s : strs){   \\n            char[] ch = s.toCharArray();\\n            Arrays.sort(ch);   \\n\\n            String temp = new String(ch);\\n            \\n            if(hm.containsKey(temp)){   \\n                List<String> list = hm.get(temp);  \\n                list.add(s);           \\n                hm.put(temp,list);      \\n                //hm.put(temp, hm.get(temp).add(s));    // why it\\'s not working? --getting error here\\n            }\\n            else{\\n                List<String> list = new ArrayList<>(1);\\n                list.add(s);\\n                hm.put(temp,list);\\n            }\\n        }\\n \\n        List<List<String>> ans = new ArrayList<>();\\n        \\n        for(Map.Entry entry : hm.entrySet()){   \\n            List list = (List)entry.getValue();\\n            ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442564,
                "title": "c-using-hashmap",
                "content": "**Please Upvote if you like the code!**\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs)\\n    {\\n        vector<vector<string>> res;\\n        unordered_map<string,vector<string>> m;\\n        string temp;\\n        \\n        for(int i=0;i<strs.size();i++)\\n        {\\n            temp=strs[i];\\n            sort(strs[i].begin(),strs[i].end());\\n            m[strs[i]].push_back(temp);\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            res.push_back(it->second);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "**Please Upvote if you like the code!**\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs)\\n    {\\n        vector<vector<string>> res;\\n        unordered_map<string,vector<string>> m;\\n        string temp;\\n        \\n        for(int i=0;i<strs.size();i++)\\n        {\\n            temp=strs[i];\\n            sort(strs[i].begin(),strs[i].end());\\n            m[strs[i]].push_back(temp);\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            res.push_back(it->second);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 833858,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        if strs.isEmpty { return [] }\\n        \\n        var map = [String: [String]]()\\n        for str in strs {\\n            let sortedStr = String(str.sorted())\\n            map[sortedStr, default: []] += [str]\\n        }\\n                \\n        return Array(map.values)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        if strs.isEmpty { return [] }\\n        \\n        var map = [String: [String]]()\\n        for str in strs {\\n            let sortedStr = String(str.sorted())\\n            map[sortedStr, default: []] += [str]\\n        }\\n                \\n        return Array(map.values)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225669,
                "title": "scala-one-liner",
                "content": "```\\n  def groupAnagrams(strs: Array[String]): List[List[String]] = {\\n    strs.groupBy(_.sorted).values.map(_.toList).toList\\n  }\\n ```\\n",
                "solutionTags": [],
                "code": "```\\n  def groupAnagrams(strs: Array[String]): List[List[String]] = {\\n    strs.groupBy(_.sorted).values.map(_.toList).toList\\n  }\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 200240,
                "title": "neat-java-solution",
                "content": "```java\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Hashtable;\\nimport java.util.List;\\n\\npublic class Solution {\\n\\n  public List<List<String>> groupAnagrams(String[] strs) {\\n    Hashtable<String, List<String>> ht = new Hashtable<>();\\n    for (String s : strs) {\\n      char[] temp = s.toCharArray();\\n      Arrays.sort(temp);\\n      String _s = String.valueOf(temp);\\n      ht.putIfAbsent(_s, new ArrayList<>());\\n      ht.get(_s).add(s);\\n    }\\n    return new ArrayList<>(ht.values());\\n  }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n  public List<List<String>> groupAnagrams(String[] strs) {\\n    Hashtable<String, List<String>> ht = new Hashtable<>();\\n    for (String s : strs) {\\n      char[] temp = s.toCharArray();\\n      Arrays.sort(temp);\\n      String _s = String.valueOf(temp);\\n      ht.putIfAbsent(_s, new ArrayList<>());\\n      ht.get(_s).add(s);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 164186,
                "title": "python-solution",
                "content": "Hash map O(NK) time, O(N) space:\\n```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        def convert(s):\\n            res = [0]*26\\n            for char in s:\\n                res[ord(char)-ord(\\'a\\')] += 1\\n            return tuple(res)\\n        rec = {}\\n        res = []\\n        for s in strs:\\n            t = convert(s)\\n            if t in rec:\\n                res[rec[t]].append(s)\\n            else:\\n                res.append([s])\\n                rec[t] = len(res)-1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        def convert(s):\\n            res = [0]*26\\n            for char in s:\\n                res[ord(char)-ord(\\'a\\')] += 1\\n            return tuple(res)\\n        rec = {}\\n        res = []\\n        for s in strs:\\n            t = convert(s)\\n            if t in rec:\\n                res[rec[t]].append(s)\\n            else:\\n                res.append([s])\\n                rec[t] = len(res)-1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19236,
                "title": "swift-solution-hash-table",
                "content": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        if strs.count == 0 {\\n            return [[String]]()\\n        }\\n        \\n        var map = [String: [String]]()\\n        \\n        for str in strs {\\n            let key = String(Array(str.characters).sorted())\\n            if !map.keys.contains(key) {\\n                map[key] = [String]()\\n            }\\n            map[key]?.append(str)\\n        }\\n        \\n        return Array(map.values)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        if strs.count == 0 {\\n            return [[String]]()\\n        }\\n        \\n        var map = [String: [String]]()\\n        \\n        for str in strs {\\n            let key = String(Array(str.characters).sorted())\\n            if !map.keys.contains(key) {\\n                map[key] = [String]()\\n            }\\n            map[key]?.append(str)\\n        }\\n        \\n        return Array(map.values)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19330,
                "title": "share-my-simple-java-solution-pretty-easy-to-understand",
                "content": "I don't see this code needs any more explanation. Straightforward.\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n      Arrays.sort(strs);\\n      HashMap<String, List<String>> hm = new HashMap<>();\\n      for(int i = 0; i < strs.length; i++){\\n        String currString = strs[i];\\n        char[] charArr = strs[i].toCharArray();\\n        Arrays.sort(charArr);\\n        String sortString = new String(charArr);\\n        List<String > tempList = hm.getOrDefault(sortString, new ArrayList<String>());\\n        tempList.add(currString);\\n        hm.put(sortString, tempList);\\n      }\\n      return new ArrayList<>(hm.values());\\n    }",
                "solutionTags": [],
                "code": "I don't see this code needs any more explanation. Straightforward.\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n      Arrays.sort(strs);\\n      HashMap<String, List<String>> hm = new HashMap<>();\\n      for(int i = 0; i < strs.length; i++){\\n        String currString = strs[i];\\n        char[] charArr = strs[i].toCharArray();\\n        Arrays.sort(charArr);\\n        String sortString = new String(charArr);\\n        List<String > tempList = hm.getOrDefault(sortString, new ArrayList<String>());\\n        tempList.add(currString);\\n        hm.put(sortString, tempList);\\n      }\\n      return new ArrayList<>(hm.values());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4025789,
                "title": "easy-python-solution-briefly-explained",
                "content": "# Code Explanation\\nThe provided Python code defines a class `Solution` with a method `groupAnagrams`. This method takes a list of strings `strs` as input and is supposed to group the anagrams from the input list into lists of lists, where each inner list contains words that are anagrams of each other. Anagrams are words or phrases formed by rearranging the letters of another, such as \"listen\" and \"silent.\"\\n\\nLet\\'s break down the code step by step:\\n\\n1. **Initialize a Dictionary**: The code starts by initializing an empty dictionary called `ans`. This dictionary will be used to store groups of anagrams, with the keys being the character counts of the letters in the anagrams and the values being lists of strings that belong to each group.\\n\\n    ```python\\n    ans = collections.defaultdict(list)\\n    ```\\n\\n    Here, `collections.defaultdict(list)` creates a dictionary where the default value for each key is an empty list.\\n\\n2. **Iterate Through the Input List**: The code then enters a loop to iterate through each string `s` in the input list `strs`.\\n\\n    ```python\\n    for s in strs:\\n    ```\\n\\n3. **Initialize a Character Count List**: Inside the loop, a list called `count` is initialized with 26 zeros. This list will be used to count the occurrences of each letter in the current string `s`. Each index in the `count` list corresponds to a letter in the lowercase English alphabet.\\n\\n    ```python\\n    count = [0] * 26\\n    ```\\n\\n4. **Count the Occurrence of Letters in the String**: The code then enters another loop to iterate through each character `c` in the current string `s`.\\n\\n    ```python\\n    for c in s:\\n    ```\\n\\n5. **Increment the Count for Each Letter**: Inside the inner loop, the code calculates the position of the character `c` in the alphabet (by subtracting the ASCII value of \\'a\\' from the ASCII value of `c`) and increments the corresponding element in the `count` list. This effectively counts the occurrence of each letter in the current string `s`.\\n\\n    ```python\\n    count[ord(c) - ord(\"a\")] += 1\\n    ```\\n\\n6. **Group Anagrams Using Character Counts as Keys**: After counting the occurrences of letters in the current string `s`, the code converts the `count` list into a tuple. This tuple is used as a key in the `ans` dictionary. The value associated with this key is a list, and the current string `s` is appended to this list. This step groups strings with the same character count together.\\n\\n    ```python\\n    ans[tuple(count)].append(s)\\n    ```\\n\\n7. **Return Grouped Anagrams**: After processing all strings in the input list `strs`, the code returns the values of the `ans` dictionary. These values are lists of grouped anagrams.\\n\\n    ```python\\n    return ans.values()\\n    ```\\n\\nSo, in summary, this code efficiently groups anagrams by counting the occurrences of each letter in each string and using these counts as keys in a dictionary. It ensures that anagrams with the same character counts are grouped together, and it returns these groups as a list of lists.\\n\\n# Python Code\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        ans = collections.defaultdict(list)\\n\\n        for s in strs:\\n            count = [0] * 26\\n            for c in s:\\n                count[ord(c) - ord(\"a\")] += 1                \\n            ans[tuple(count)].append(s)\\n\\n        return ans.values()\\n\\n```\\n\\n**Please upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```python\\n    ans = collections.defaultdict(list)\\n    ```\n```python\\n    for s in strs:\\n    ```\n```python\\n    count = [0] * 26\\n    ```\n```python\\n    for c in s:\\n    ```\n```python\\n    count[ord(c) - ord(\"a\")] += 1\\n    ```\n```python\\n    ans[tuple(count)].append(s)\\n    ```\n```python\\n    return ans.values()\\n    ```\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        ans = collections.defaultdict(list)\\n\\n        for s in strs:\\n            count = [0] * 26\\n            for c in s:\\n                count[ord(c) - ord(\"a\")] += 1                \\n            ans[tuple(count)].append(s)\\n\\n        return ans.values()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752865,
                "title": "c-one-pass-hashmap-sorting-time-o-n",
                "content": "# Intuition\\nIn a HashMap, keep a track of where the string will go in the resultant array i.e., where that string\\'s anagrams were inserted before. Key will be the sorted string and value will be the index.\\n\\nFor every string $$s$$\\n- If its sorted key $$t$$ is present in the HashMap, that means $$s$$\\'s anagrams were found before too, and were inserted at some index $$map[t]$$. Insert $s$ at that index too.\\n- If its sorted key $$t$$ is not present in the HashMap, that means it is a new type of anagram never seen before. Create a new index for it in resultant array and store the new index in HashMap.\\n\\n# Code\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, int> index;\\n        vector<vector<string>> result;\\n        for (string& s: strs) {\\n            string t = s;\\n            sort(t.begin(), t.end());\\n            if (index.find(t) == index.end()) { // new anagram\\n                index[t] = result.size();\\n                result.push_back({});\\n            }\\n            result[index[t]].push_back(s);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time Complexity: $$O(n)$$\\n- Space Complexity: $$O(n)$$\\n\\nConsidering length of each string negligible as compared to number of strings.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, int> index;\\n        vector<vector<string>> result;\\n        for (string& s: strs) {\\n            string t = s;\\n            sort(t.begin(), t.end());\\n            if (index.find(t) == index.end()) { // new anagram\\n                index[t] = result.size();\\n                result.push_back({});\\n            }\\n            result[index[t]].push_back(s);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752816,
                "title": "simple-easy-to-understand-go-sol",
                "content": "Please Upvote if you found this helpful \\n\\n```\\nfunc groupAnagrams(strs []string) [][]string {\\n    mapS := make(map[string][]string, 0)\\n    \\n    for _, val := range strs {\\n        byteString := []byte(val)\\n        sort.Slice(byteString, func(i,j int) bool { return byteString[i] < byteString[j]})\\n        sortedString := string(byteString)\\n        \\n        mapS[sortedString] = append(mapS[sortedString], val)\\n    }\\n    \\n    ans := make([][]string,0)\\n\\n    for _,val := range mapS {\\n        ans = append(ans, val)\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    mapS := make(map[string][]string, 0)\\n    \\n    for _, val := range strs {\\n        byteString := []byte(val)\\n        sort.Slice(byteString, func(i,j int) bool { return byteString[i] < byteString[j]})\\n        sortedString := string(byteString)\\n        \\n        mapS[sortedString] = append(mapS[sortedString], val)\\n    }\\n    \\n    ans := make([][]string,0)\\n\\n    for _,val := range mapS {\\n        ans = append(ans, val)\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607029,
                "title": "python-95-faster-96-less-memory-use-easiest-solution-to-undertand",
                "content": "### ------ please upvote if it\\'s helpful ----#####\\n# we will be using dictionary to store which string has which characters and their frequencies \\n# dic => key = letters of words as sorted and in string form because we can\\'t use lists as key in dictionary // value = the string that question asks from us\\n\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic = {}\\n        for string in strs:\\n            current = sorted(string)\\n            current = \"\".join(current)\\n            if current in dic:\\n                dic[current].append(string)\\n                \\n            else:\\n                dic[current] = [string]\\n                \\n        ans = []\\n        for string in dic:\\n            ans.append(dic[string])\\n            \\n        return ans",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "### ------ please upvote if it\\'s helpful ----#####\\n# we will be using dictionary to store which string has which characters and their frequencies \\n# dic => key = letters of words as sorted and in string form because we can\\'t use lists as key in dictionary // value = the string that question asks from us\\n\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic = {}\\n        for string in strs:\\n            current = sorted(string)\\n            current = \"\".join(current)\\n            if current in dic:\\n                dic[current].append(string)\\n                \\n            else:\\n                dic[current] = [string]\\n                \\n        ans = []\\n        for string in dic:\\n            ans.append(dic[string])\\n            \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2184993,
                "title": "java-10ms-explained-with-comments-explained-for-kid-level",
                "content": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n//       Initialization of Hashmap Key is type of String and Value is type of List<String\\n        HashMap<String, List<String> > map = new HashMap<>(); \\n        \\n        \\n        for(String s : strs){ // Taking one by one String from strs array\\n            char[] chars = s.toCharArray(); //Converting String to Char Array\\n            Arrays.sort(chars); // Sorting The Char Array by using inbuilt Sorting Method\\n            String key = String.valueOf(chars); //Converting Sorted Char array to String. It will act as a Key for our hashmap\\n            if(map.containsKey(key))\\n                map.get(key).add(s); //If key exist then add the String or append the string to the end of the list\\n            else{\\n                map.put(key, new ArrayList<>()); // If key not present then initialize the ArrayList \\n                map.get(key).add(s); // and add the Perticular String to that key.\\n            } \\n        }\\n        \\n        List<List<String>> answer = new ArrayList<>(); // Initialize the Answer arraylist of arraylist\\n        for(String key : map.keySet()) // keySet will give you all the keys available for that Hashmap use it to get the keys and get the list out of it\\n            answer.add(map.get(key));  // Append the list of given key to the answer list\\n        \\n        \\n        return answer; // return the answer array\\n    }\\n}\\nTime Complexity  O(n mlogm) \\nO(n) for iterating to the whole string array\\no(mlogm) for converting to the char array and sorting the array\\n\\nSpace Complexity : O(n*m) \\nspace",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n//       Initialization of Hashmap Key is type of String and Value is type of List<String\\n        HashMap<String, List<String> > map = new HashMap<>(); \\n        \\n        \\n        for(String s : strs){ // Taking one by one String from strs array\\n            char[] chars = s.toCharArray(); //Converting String to Char Array\\n            Arrays.sort(chars); // Sorting The Char Array by using inbuilt Sorting Method\\n            String key = String.valueOf(chars); //Converting Sorted Char array to String. It will act as a Key for our hashmap\\n            if(map.containsKey(key))\\n                map.get(key).add(s); //If key exist then add the String or append the string to the end of the list\\n            else{\\n                map.put(key, new ArrayList<>()); // If key not present then initialize the ArrayList \\n                map.get(key).add(s); // and add the Perticular String to that key.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1250146,
                "title": "python3-sorted-str-solution-o-n-klogk-time-o-nk-space",
                "content": "Please comment if you have any suggestions or need a clear explanation, I promise I will respond!\\n\\nAlso, please upvote if this was at all helpful :)\\n\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        strs_dict = {}\\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            strs_dict[sorted_word] = strs_dict.get(sorted_word, []) + [word]\\n        return strs_dict.values()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        strs_dict = {}\\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            strs_dict[sorted_word] = strs_dict.get(sorted_word, []) + [word]\\n        return strs_dict.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070582,
                "title": "js-6-lines-of-code-99-9-faster-the-ultimate-solution",
                "content": "```\\nconst groupAnagrams = function (strs) {\\n    const map = new Map();\\n\\n    strs.forEach(v => {\\n        const key = v.split(\\'\\').sort().join(\\'\\');\\n        map.has(key) ? map.set(key, [...map.get(key), v]) : map.set(key, [v]);\\n    })\\n\\n    return [...map.values()];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst groupAnagrams = function (strs) {\\n    const map = new Map();\\n\\n    strs.forEach(v => {\\n        const key = v.split(\\'\\').sort().join(\\'\\');\\n        map.has(key) ? map.set(key, [...map.get(key), v]) : map.set(key, [v]);\\n    })\\n\\n    return [...map.values()];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054435,
                "title": "kotlin",
                "content": "```\\n   fun groupAnagrams(strs: Array<String>): List<List<String>> {\\n        val map = mutableMapOf<String, MutableList<String>>()\\n        strs.forEach {\\n            val key = it.toCharArray().sorted().joinToString(\"\")\\n            if (!map.containsKey(key)) map[key] = mutableListOf()\\n            map[key]?.add(it)\\n        }\\n\\n        return map.values.toList()\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n   fun groupAnagrams(strs: Array<String>): List<List<String>> {\\n        val map = mutableMapOf<String, MutableList<String>>()\\n        strs.forEach {\\n            val key = it.toCharArray().sorted().joinToString(\"\")\\n            if (!map.containsKey(key)) map[key] = mutableListOf()\\n            map[key]?.add(it)\\n        }\\n\\n        return map.values.toList()\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442430,
                "title": "c-linq-solution",
                "content": "```\\n  public class Solution\\n    {\\n        public IList<IList<string>> GroupAnagrams(string[] strs)\\n        {\\n            return new List<IList<string>>(strs.GroupBy(x => x.Customehashcode()).Select(grp => grp.ToList()));\\n        }\\n    }\\n\\n    static class ExtensionMethods\\n    {\\n        public static string Customehashcode(this string s)\\n        {\\n            int[] hashset = new int[26];\\n            for (int i = 0; i < s.Length; i++) {\\n                hashset[s[i] - \\'a\\'] = hashset[s[i] - \\'a\\'] + 1;\\n            }\\n\\n            return string.Join(\"\", hashset);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public class Solution\\n    {\\n        public IList<IList<string>> GroupAnagrams(string[] strs)\\n        {\\n            return new List<IList<string>>(strs.GroupBy(x => x.Customehashcode()).Select(grp => grp.ToList()));\\n        }\\n    }\\n\\n    static class ExtensionMethods\\n    {\\n        public static string Customehashcode(this string s)\\n        {\\n            int[] hashset = new int[26];\\n            for (int i = 0; i < s.Length; i++) {\\n                hashset[s[i] - \\'a\\'] = hashset[s[i] - \\'a\\'] + 1;\\n            }\\n\\n            return string.Join(\"\", hashset);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376880,
                "title": "fast-and-clean-solution-python",
                "content": "The main ideas are:\\n- Use a dictionary type to create the resulting list of lists. Use as many keys as anagram groups there are.\\n- Intuitively, we will use the sorted words as the keys of our dictionary. Thus, all members of an anagram group will share the same key. \\n- As **keys must be of a hashable type** and the output of `sorted` is a list, we need to convert it to an immutable type. Joining the output before appending - **sorting splits the string into a list of individual characters** - will do just that by converting it to a string.\\n- By using `defaultdict`, whenever we try to append a value to an innexistent key it will return an empty list and concatenate it with the given value i.e. `[] + [w] = [w]`.\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]: \\n        d = collections.defaultdict(list)\\n        for w in strs:\\n            d[\\'\\'.join(sorted(w))].append(w)\\n        return d.values()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]: \\n        d = collections.defaultdict(list)\\n        for w in strs:\\n            d[\\'\\'.join(sorted(w))].append(w)\\n        return d.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152243,
                "title": "go-solution",
                "content": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    groups := make(map[string][]string)\\n    for _, str := range strs {\\n        b := []byte(str)\\n        sort.Slice(b, func(i, j int) bool {\\n            return b[i] < b[j]\\n        })\\n        key := string(b)\\n        groups[key] = append(groups[key], str)\\n    }\\n    \\n    ret := make([][]string, 0, len(groups))\\n    for _, v := range groups {\\n        ret = append(ret, v)        \\n    }\\n    return ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    groups := make(map[string][]string)\\n    for _, str := range strs {\\n        b := []byte(str)\\n        sort.Slice(b, func(i, j int) bool {\\n            return b[i] < b[j]\\n        })\\n        key := string(b)\\n        groups[key] = append(groups[key], str)\\n    }\\n    \\n    ret := make([][]string, 0, len(groups))\\n    for _, v := range groups {\\n        ret = append(ret, v)        \\n    }\\n    return ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19218,
                "title": "c-9-lines-28ms-92-35",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>>res;\\n        unordered_map<string, vector<string>>m;\\n        for(auto s: strs){\\n            string tmp = s;\\n            sort(tmp.begin(), tmp.end());\\n            m[tmp].push_back(s);\\n        }\\n        for(auto x: m) res.push_back(x.second);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>>res;\\n        unordered_map<string, vector<string>>m;\\n        for(auto s: strs){\\n            string tmp = s;\\n            sort(tmp.begin(), tmp.end());\\n            m[tmp].push_back(s);\\n        }\\n        for(auto x: m) res.push_back(x.second);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19375,
                "title": "u3010python-u3011beating-86-solution-with-a-defaultdict",
                "content": "We build a dictionary to store the strings, where the key should be \"characters where order does not matter\". \\n\\nThe easiest way to achieve that is to use`''.join(sorted(my_string))`, where `sorted()` kills the order of charcters and `join()` hashable the list.\\n\\n\\n    from collections improt defaultdict\\n    def groupAnagrams(self, strs):\\n\\n        dic = defaultdict(list)\\n        for string in strs:\\n                dic[''.join(sorted(string))] += [string]\\n\\n        return [value for key, value in dic.items()]",
                "solutionTags": [
                    "Python"
                ],
                "code": "We build a dictionary to store the strings, where the key should be \"characters where order does not matter\". \\n\\nThe easiest way to achieve that is to use`''.join(sorted(my_string))`, where `sorted()` kills the order of charcters and `join()` hashable the list.\\n\\n\\n    from collections improt defaultdict\\n    def groupAnagrams(self, strs):\\n\\n        dic = defaultdict(list)\\n        for string in strs:\\n                dic[''.join(sorted(string))] += [string]\\n\\n        return [value for key, value in dic.items()]",
                "codeTag": "Python3"
            },
            {
                "id": 19398,
                "title": "49-group-anagrams-cpp-solution",
                "content": "    // 49. Group Anagrams\\n    // https://leetcode.com/problems/anagrams/\\n    class Solution {\\n    public:\\n    \\tvector<vector<string>> groupAnagrams(const vector<string>& strs) {\\n    \\t\\tvector<vector<string>> result;\\n    \\t\\tunordered_map<string, vector<string>> hashmap;\\n    \\t\\tfor(const auto& i : strs){\\n    \\t\\t\\tstring s = i;\\n    \\t\\t\\tsort(s.begin(), s.end());\\n    \\t\\t\\thashmap[s].push_back(i);\\n    \\t\\t}\\n    \\t\\tfor(const auto& i : hashmap){\\n    \\t\\t\\tvector<string> s = i.second;\\n    \\t\\t\\tsort(s.begin(), s.end());\\n    \\t\\t\\tresult.push_back(s);\\n    \\t\\t}\\n    \\t\\treturn result;\\t\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<vector<string>> groupAnagrams(const vector<string>& strs) {\\n    \\t\\tvector<vector<string>> result;\\n    \\t\\tunordered_map<string, vector<string>> hashmap;\\n    \\t\\tfor(const auto& i : strs){\\n    \\t\\t\\tstring s = i;\\n    \\t\\t\\tsort(s.begin(), s.end());\\n    \\t\\t\\thashmap[s].push_back(i);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3862253,
                "title": "easy-java-solution-beats-95-with-explanation",
                "content": "# Approach\\n*This Java code is an implementation of a function groupAnagrams that takes an array of strings strs as input and groups the anagrams together. Anagrams are words that have the same characters but in a different order.*\\n\\n##### Let\\'s go through the code step by step:\\n\\n1. Create a HashMap called hm, where the key is a sorted string representation of each word (anagram), and the value is a list of strings representing the anagrams.\\n\\n2. Iterate through each string in the strs array.\\n\\n3. Convert the current string strs[i] to a character array arr.\\n\\n4. Sort the character array arr using Arrays.sort(arr). This will arrange the characters in ascending order, making anagrams have the same sorted representation.\\n\\n5. Convert the sorted character array arr back to a string ch using String.valueOf(arr).\\n\\n6. Check if the hm already contains the key ch. If yes, then it means we have already encountered an anagram of the current string. We get the corresponding list of anagrams using hm.get(ch) and add the current string strs[i] to that list. Then, we update the hm with the updated list.\\n\\n7. If the hm does not contain the key ch, it means we have not encountered this anagram before. In that case, we create a new list, add the current string strs[i] to it, and put it in the hm with the key ch.\\n\\n8. After processing all strings in the strs array, we have a hashmap hm with keys as sorted anagrams and values as lists of strings containing the anagrams.\\n\\n9. Create a new List called st to store the final result.\\n\\n10. Iterate through each entry in the hm using a for-each loop (for (Map.Entry<String,List<String>> mapElement : hm.entrySet())).\\n\\n11. Get the value (list of anagrams) corresponding to the current key (sorted anagram) using mapElement.getValue() and add it to the st list.\\n\\n12. After iterating through all entries in the hm, the st list will contain lists of anagrams grouped together.\\n\\n13. Return the st list, which contains the groups of anagrams.\\n\\nThe overall time complexity of this solution is O(N * K * log K), where N is the number of strings in the input array strs, and K is the maximum length of a string in strs. The reason for this complexity is that we are sorting each string, which takes O(K * log K) time, and we do this for each of the N strings in the array.\\n\\n# Complexity\\nLet\\'s analyze the time and space complexity of the given solution:\\n\\n**Time Complexity**:\\n\\n1. The first loop iterates through each string in the strs array. This loop has a time complexity of O(N), where N is the number of strings in the array.\\n2. Inside the loop, we convert each string to a character array and then sort it using Arrays.sort(arr). Sorting takes O(K * log K) time, where K is the maximum length of a string in the array.\\n3. For each iteration of the loop, we perform sorting, which contributes O(K * log K) time complexity.\\n4. The second loop iterates through the hm hashmap, which has at most N entries (N unique anagram keys).\\n5. Inside this loop, we add each list of anagrams to the final result list. This operation takes O(M) time, where M is the number of anagrams for each key (can vary but is overall bounded by N).\\nPutting it all together, the overall time complexity is:\\n\\nO(N) * (O(K * log K) + O(M)) = O(N * K * log K + N * M)\\n\\nIn the worst case, when all the strings in the array are anagrams of each other, M can be equal to N (each key in the hashmap has a list of N anagrams). In such cases, the time complexity simplifies to:\\n\\nO(N * K * log K + N * N) = O(N^2 + N * K * log K)\\n\\nHowever, it\\'s important to note that the average case time complexity can be much better since the distribution of anagrams and the lengths of strings can vary.\\n\\n**Space Complexity:**\\n\\nThe space complexity of the given code can be analyzed as follows:\\n\\n* **HashMap Storage**: The primary data structure used in the code is a HashMap (hm) to store the anagram groups. In the worst case, where there are no anagrams and each string is unique, the HashMap would store all the input strings. Therefore, the space complexity due to the HashMap is O(n), where n is the number of input strings.\\n\\n* **Lists in HashMap**: Each entry in the HashMap stores a list of strings. In the worst case, again when there are no anagrams and each string is unique, the total space used by all the lists would be O(n), as each string would be in its own list.\\n\\n* **Final List of Lists**: The st list of lists is created to store the grouped anagrams. In the worst case, where there are no anagrams and each string is unique, this list would also use O(n) space.\\n\\nCombining all these factors, the overall space complexity of the code is O(n), where n is the number of input strings. This is because the HashMap and the final list are the primary data structures that scale with the input size, and their combined space usage dominates the space complexity. \\n\\n\\n\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>>hm = new HashMap<>();\\n        for(int i = 0;i<strs.length;i++){\\n            char[] arr = strs[i].toCharArray();\\n            Arrays.sort(arr);\\n            String ch = String.valueOf(arr);\\n            if(hm.containsKey(ch)){\\n                List<String>s = hm.get(ch);\\n                s.add(strs[i]);\\n                hm.put(ch,s);\\n            }\\n            else{\\n                List<String>s = new ArrayList<String>();\\n                s.add(strs[i]);\\n                hm.put(ch,s);\\n            }\\n\\n        }\\n        List<List<String>> st = new ArrayList<>();\\n        \\n        for (Map.Entry<String,List<String>> mapElement : hm.entrySet()) {\\n            \\n \\n            st.add(mapElement.getValue());\\n            \\n        }\\n        return st;\\n        \\n    }\\n}\\n```\\n\\n# please upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>>hm = new HashMap<>();\\n        for(int i = 0;i<strs.length;i++){\\n            char[] arr = strs[i].toCharArray();\\n            Arrays.sort(arr);\\n            String ch = String.valueOf(arr);\\n            if(hm.containsKey(ch)){\\n                List<String>s = hm.get(ch);\\n                s.add(strs[i]);\\n                hm.put(ch,s);\\n            }\\n            else{\\n                List<String>s = new ArrayList<String>();\\n                s.add(strs[i]);\\n                hm.put(ch,s);\\n            }\\n\\n        }\\n        List<List<String>> st = new ArrayList<>();\\n        \\n        for (Map.Entry<String,List<String>> mapElement : hm.entrySet()) {\\n            \\n \\n            st.add(mapElement.getValue());\\n            \\n        }\\n        return st;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697942,
                "title": "python-beats-99-38",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        answer = defaultdict(list)\\n        for word in strs:\\n            answer[\"\".join(sorted(word))].append(word)\\n        return list(answer.values())\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        answer = defaultdict(list)\\n        for word in strs:\\n            answer[\"\".join(sorted(word))].append(word)\\n        return list(answer.values())\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520194,
                "title": "python-o-n-solution",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSorted anagrams string will always be equal.\\nHence, create a hash_map where key will the sorted string.\\nAdd current string if its key is present, other wise create a new entry.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nAs, first we are traversing over the given list.\\nFor each list sorting and join operation will take constant time as its given string size will be max of 100 characters.\\n\\n- Space complexity:\\n$$O(n)$$\\nAs, in worst case all unique string in given list. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        # Hash Map\\n        hash_map = {}\\n        # Iterate over each string in given list\\n        for s in strs:\\n            # Hash function to get key\\n            key = \\'\\'.join(sorted(s))\\n            # CASE: If key is in hash map\\n            if key in hash_map:\\n                hash_map[key].append(s)\\n            # CASE: If key is not in hash map\\n            else:\\n                hash_map[key] = [s]\\n        return list(hash_map.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        # Hash Map\\n        hash_map = {}\\n        # Iterate over each string in given list\\n        for s in strs:\\n            # Hash function to get key\\n            key = \\'\\'.join(sorted(s))\\n            # CASE: If key is in hash map\\n            if key in hash_map:\\n                hash_map[key].append(s)\\n            # CASE: If key is not in hash map\\n            else:\\n                hash_map[key] = [s]\\n        return list(hash_map.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161171,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>>mp;\\n        vector<vector<string>>ans;\\n        for(int i=0;i<strs.size();i++){\\n                string t=strs[i];\\n                sort(t.begin(),t.end());\\n                mp[t].push_back(strs[i]);\\n            \\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            ans.push_back(it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nf = open(\\'user.out\\', \\'w\\'); [print(json.dumps(list(reduce(lambda res, s: res[str(sorted(s))].append(s) or res, json.loads(line.rstrip()), defaultdict(list)).values())), file=f) for line in stdin];exit(); \\n\\nf = open(\"user.out\", \"w\");[print(json.dumps(list(reduce(lambda res, s: res[str(sorted(s))].append(s) or res, json.loads(line.rstrip()), defaultdict(list)).values())), file=f) for line in stdin];exit()\\n```\\n\\n```Java []\\nimport java.util.AbstractList;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        return new AbstractList<List<String>>(){\\n            \\n            List<List<String>> result;\\n            public List<String> get(int index) {\\n                if (result == null) init();\\n                return result.get(index);\\n            }\\n\\n            public int size() {\\n                if (result == null) init();\\n                return result.size();\\n            }\\n\\n            private void init() {\\n                for (String s: strs) {\\n                    char[] keys = new char[26];\\n                    for (int i = 0; i < s.length(); i++)\\n                        keys[s.charAt(i) - \\'a\\']++;\\n\\n                    String key = new String(keys);\\n                    System.out.println(key);\\n                    List<String> list = map.get(key);\\n                    if (list == null) map.put(key, new ArrayList<>());\\n                    map.get(key).add(s);\\n                }\\n                result = new ArrayList<>(map.values());\\n            }\\n        };\\n    \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>>mp;\\n        vector<vector<string>>ans;\\n        for(int i=0;i<strs.size();i++){\\n                string t=strs[i];\\n                sort(t.begin(),t.end());\\n                mp[t].push_back(strs[i]);\\n            \\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            ans.push_back(it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nf = open(\\'user.out\\', \\'w\\'); [print(json.dumps(list(reduce(lambda res, s: res[str(sorted(s))].append(s) or res, json.loads(line.rstrip()), defaultdict(list)).values())), file=f) for line in stdin];exit(); \\n\\nf = open(\"user.out\", \"w\");[print(json.dumps(list(reduce(lambda res, s: res[str(sorted(s))].append(s) or res, json.loads(line.rstrip()), defaultdict(list)).values())), file=f) for line in stdin];exit()\\n```\n```Java []\\nimport java.util.AbstractList;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        return new AbstractList<List<String>>(){\\n            \\n            List<List<String>> result;\\n            public List<String> get(int index) {\\n                if (result == null) init();\\n                return result.get(index);\\n            }\\n\\n            public int size() {\\n                if (result == null) init();\\n                return result.size();\\n            }\\n\\n            private void init() {\\n                for (String s: strs) {\\n                    char[] keys = new char[26];\\n                    for (int i = 0; i < s.length(); i++)\\n                        keys[s.charAt(i) - \\'a\\']++;\\n\\n                    String key = new String(keys);\\n                    System.out.println(key);\\n                    List<String> list = map.get(key);\\n                    if (list == null) map.put(key, new ArrayList<>());\\n                    map.get(key).add(s);\\n                }\\n                result = new ArrayList<>(map.values());\\n            }\\n        };\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056211,
                "title": "typescript-solution-beats-98-on-execution-time-based-on-the-platform-results",
                "content": "# Code\\n```\\nfunction groupAnagrams(strs: string[]): string[][] {\\n\\tconst map = new Map<string, string[]>();\\n\\tconst getKey = (s: string) => s.split(\"\").sort().join(\"\");\\n\\n\\tstrs.forEach((s) => {\\n\\t\\tconst k = getKey(s);\\n\\t\\tmap.set(k, [...(map.get(k) || []), s]);\\n\\t});\\n\\n\\treturn [...map.values()];\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction groupAnagrams(strs: string[]): string[][] {\\n\\tconst map = new Map<string, string[]>();\\n\\tconst getKey = (s: string) => s.split(\"\").sort().join(\"\");\\n\\n\\tstrs.forEach((s) => {\\n\\t\\tconst k = getKey(s);\\n\\t\\tmap.set(k, [...(map.get(k) || []), s]);\\n\\t});\\n\\n\\treturn [...map.values()];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2994029,
                "title": "c-solution",
                "content": "# Intuition\\nHashing\\n\\n# Approach\\nUsing hashing and sorting of each string\\n\\n# Complexity\\n- Time complexity:\\nn*m*log(m) where m is size of each string and n is size of vector of string\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n=strs.size();\\n        unordered_map<string,vector<string> > mp;\\n        for(int i=0;i<n;i++){\\n            string str=strs[i];\\n            sort(str.begin(),str.end());\\n            mp[str].push_back(strs[i]);\\n\\n        }\\n        vector<vector<string>> ans;\\n        for(auto it: mp){\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n=strs.size();\\n        unordered_map<string,vector<string> > mp;\\n        for(int i=0;i<n;i++){\\n            string str=strs[i];\\n            sort(str.begin(),str.end());\\n            mp[str].push_back(strs[i]);\\n\\n        }\\n        vector<vector<string>> ans;\\n        for(auto it: mp){\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845888,
                "title": "fully-explained-every-line-of-code-re-arrange-and-group-o-n-java",
                "content": "# Approach : Re-Arramging characters and grouping the anagrams\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)*O(k logk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# *If you find this solution easy to understand and helpful, then please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D*\\n\\n# Code (Explained in Comments)\\n```\\nclass Solution \\n{\\n    public List<List<String>> groupAnagrams(String[] strs) \\n    {\\n        HashMap<String,List<String>> map=new HashMap<>();//declaring a HashMap\\n        for(String s:strs)//iterate over string\\n        {\\n            char[] c=s.toCharArray();//storing characters in array\\n            Arrays.sort(c);//sorting the characters\\n            String key=new String(c);//creating key\\n            map.computeIfAbsent(key,k ->new ArrayList()).add(s);\\n            //if key is not present then create new ArrayList and add string\\n        }\\n        return new ArrayList(map.values());//returning ArrayList of map values\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<List<String>> groupAnagrams(String[] strs) \\n    {\\n        HashMap<String,List<String>> map=new HashMap<>();//declaring a HashMap\\n        for(String s:strs)//iterate over string\\n        {\\n            char[] c=s.toCharArray();//storing characters in array\\n            Arrays.sort(c);//sorting the characters\\n            String key=new String(c);//creating key\\n            map.computeIfAbsent(key,k ->new ArrayList()).add(s);\\n            //if key is not present then create new ArrayList and add string\\n        }\\n        return new ArrayList(map.values());//returning ArrayList of map values\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289230,
                "title": "c-easy-solution-for-indians-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& s) {\\n       vector<vector<string>>ans; // edge cases\\n      if(s.size()==1)  return {{s[0]}};\\n      unordered_map<string,vector<string>>m; // key value is sorted string and vector store the anagrams\\n      for(auto i:s) {\\n        string str=i;\\n        sort(i.begin(),i.end());\\n        m[i].push_back(str);\\n      }\\n      for(auto i:m)\\n        ans.push_back(i.second); \\n    return ans;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& s) {\\n       vector<vector<string>>ans; // edge cases\\n      if(s.size()==1)  return {{s[0]}};\\n      unordered_map<string,vector<string>>m; // key value is sorted string and vector store the anagrams\\n      for(auto i:s) {\\n        string str=i;\\n        sort(i.begin(),i.end());\\n        m[i].push_back(str);\\n      }\\n      for(auto i:m)\\n        ans.push_back(i.second); \\n    return ans;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990013,
                "title": "java-c-python-javascript-kotlin-swift-2line-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>> map=new HashMap<>();\\n        \\n        for(int i=0;i<strs.length;i++){\\n            String s1=strs[i];\\n            char[] arr=s1.toCharArray();\\n            Arrays.sort(arr);\\n            String str=new String(arr);\\n            \\n            if(map.containsKey(str)){\\n                map.get(str).add(s1); \\n            }else{\\n                map.put(str,new ArrayList<>());\\n                map.get(str).add(s1);\\n            }\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for(auto i: strs){\\n            string temp = i;\\n            sort(temp.begin(), temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for(auto i: mp){\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\ndef anagrams(self, strs):\\n        count = collections.Counter([tuple(sorted(s)) for s in strs])\\n        return filter(lambda x: count[tuple(sorted(x))]>1, strs)\\n```\\n\\n***JavaScript***\\n```\\n  var groupAnagrams = function (strs) {\\n      const map = {};\\n      const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\\n      strs.forEach(str => {\\n        let prod = str.split(\"\").reduce((r, c) => r * primes[c.charCodeAt() - 97], 1);\\n        map[prod] ? map[prod].push(str) : map[prod] = [str];\\n      });\\n      return Object.values(map);\\n    };\\n```\\n\\n***Kotlin***\\n```\\nfun groupAnagrams(strs: Array<String>): List<List<String>> {\\n    return strs.groupBy { it.toCharArray().sorted() }.map { it.value }\\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var map: [String: [String]] = [:]\\n        var res: [[String]] = []\\n\\n        \\n        func sort(_ str: String) -> String {\\n            var chars = Array(str)\\n            let sorted = chars.sorted()\\n            var string = \"\"\\n            for c in sorted { string += String(c) }\\n            return string\\n        }\\n\\n        for str in strs {\\n            let sorted_str = sort(str)\\n            if let _ = map[sorted_str] {\\n                map[sorted_str]?.append(str)\\n            } else {\\n                map[sorted_str] = [str]\\n            }\\n        }\\n        for (_, value) in map { res.append(value) }        \\n        return res\\n    }\\n\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***\\n***\"Open your eyes.\"***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>> map=new HashMap<>();\\n        \\n        for(int i=0;i<strs.length;i++){\\n            String s1=strs[i];\\n            char[] arr=s1.toCharArray();\\n            Arrays.sort(arr);\\n            String str=new String(arr);\\n            \\n            if(map.containsKey(str)){\\n                map.get(str).add(s1); \\n            }else{\\n                map.put(str,new ArrayList<>());\\n                map.get(str).add(s1);\\n            }\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for(auto i: strs){\\n            string temp = i;\\n            sort(temp.begin(), temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for(auto i: mp){\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\ndef anagrams(self, strs):\\n        count = collections.Counter([tuple(sorted(s)) for s in strs])\\n        return filter(lambda x: count[tuple(sorted(x))]>1, strs)\\n```\n```\\n  var groupAnagrams = function (strs) {\\n      const map = {};\\n      const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\\n      strs.forEach(str => {\\n        let prod = str.split(\"\").reduce((r, c) => r * primes[c.charCodeAt() - 97], 1);\\n        map[prod] ? map[prod].push(str) : map[prod] = [str];\\n      });\\n      return Object.values(map);\\n    };\\n```\n```\\nfun groupAnagrams(strs: Array<String>): List<List<String>> {\\n    return strs.groupBy { it.toCharArray().sorted() }.map { it.value }\\n}\\n```\n```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var map: [String: [String]] = [:]\\n        var res: [[String]] = []\\n\\n        \\n        func sort(_ str: String) -> String {\\n            var chars = Array(str)\\n            let sorted = chars.sorted()\\n            var string = \"\"\\n            for c in sorted { string += String(c) }\\n            return string\\n        }\\n\\n        for str in strs {\\n            let sorted_str = sort(str)\\n            if let _ = map[sorted_str] {\\n                map[sorted_str]?.append(str)\\n            } else {\\n                map[sorted_str] = [str]\\n            }\\n        }\\n        for (_, value) in map { res.append(value) }        \\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967413,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>> mp;\\n        for(int i=0;i<strs.size();i++){\\n            string temp=strs[i];\\n            sort(temp.begin(),temp.end());\\n            mp[temp].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x:mp){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>> mp;\\n        for(int i=0;i<strs.size();i++){\\n            string temp=strs[i];\\n            sort(temp.begin(),temp.end());\\n            mp[temp].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x:mp){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904401,
                "title": "kotlin-one-liner",
                "content": "```kotlin\\nfun groupAnagrams(strs: Array<String>): List<List<String>> {\\n    return strs.groupBy { it.toCharArray().sorted() }.values.toList()\\n}\\n```\\nExplanation:\\nit here is a String, `it.toCharArray().sorted()` gives us like a signature. `eat`, `tea`, `ate` will all have the same signature: `[a, e, t]`.\\nOnce we figure out the signatures then we can group words that have same signatures, using Kotlin\\'s `groupBy`.",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nfun groupAnagrams(strs: Array<String>): List<List<String>> {\\n    return strs.groupBy { it.toCharArray().sorted() }.values.toList()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1799276,
                "title": "hash-map-sorting-c-easy-solution-with-well-explained-comments",
                "content": "***If you find it helpful, please do upvote <3***\\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string> &strs)\\n    {\\n        unordered_map<string, vector<string>> hash; // hash[string] = {anagramic set of that string}\\n        vector<vector<string>> ans;\\n        for (auto str : strs)\\n        {\\n            string tmp = str;\\n            sort(begin(tmp), end(tmp));\\n            if (hash.find(tmp) != end(hash)) // If anagram of current string has been found previously\\n                hash[tmp].push_back(str); // Push current string into that anagramic set\\n            else\\n                hash.insert({tmp, {str}}); // Otherwise create a new entry into the hash map\\n        }\\n        for (auto [k, v] : hash)\\n            ans.push_back(v); // Push each anagramic set into the answer vector\\n        return ans;\\n    }\\n};\\n```\\n***Any suggestions are welcome into the comment section\\nThank you !!***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string> &strs)\\n    {\\n        unordered_map<string, vector<string>> hash; // hash[string] = {anagramic set of that string}\\n        vector<vector<string>> ans;\\n        for (auto str : strs)\\n        {\\n            string tmp = str;\\n            sort(begin(tmp), end(tmp));\\n            if (hash.find(tmp) != end(hash)) // If anagram of current string has been found previously\\n                hash[tmp].push_back(str); // Push current string into that anagramic set\\n            else\\n                hash.insert({tmp, {str}}); // Otherwise create a new entry into the hash map\\n        }\\n        for (auto [k, v] : hash)\\n            ans.push_back(v); // Push each anagramic set into the answer vector\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734998,
                "title": "c-solution-easy-to-understand-single-loop",
                "content": "```\\n    vector<vector<string>> groupAnagrams(vector<string>& str) \\n    {\\n        unordered_map<string,vector<string>> mp;\\n        for(auto i:str)\\n        {\\n            string temp=i;\\n            sort(temp.begin(),temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        vector<vector<string>> res;\\n        for(auto j:mp)\\n            res.push_back(j.second);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<vector<string>> groupAnagrams(vector<string>& str) \\n    {\\n        unordered_map<string,vector<string>> mp;\\n        for(auto i:str)\\n        {\\n            string temp=i;\\n            sort(temp.begin(),temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        vector<vector<string>> res;\\n        for(auto j:mp)\\n            res.push_back(j.second);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1398976,
                "title": "explanation-w-images-using-map-c-python-java",
                "content": "**Pre-requisite:**\\n*What is an Anagram?*\\nTwo strings are said to be anagrams of each other if they are made up of the same characters with same frequency. For example: the word `LISTEN` and `SILENT` are anagrams. They are composed of the letters `E, I, L, N, S, T`.\\n`Insight-` The input is only `lowercase aplhabets`\\n\\n\\n**Algorithm:**\\n`Technique` - Group By Sorting\\n*SAMPLE CASE-*\\n![image](https://assets.leetcode.com/users/images/9e9dee48-ad03-4047-8a66-b11e8dbcac7f_1628753485.5853918.png)\\n*SORTED SAMPLE CASE-*\\n![image](https://assets.leetcode.com/users/images/12e377a3-1779-4e7c-ba97-f19fb5d390db_1628753533.013706.png)\\n* Once we have made this observation, we create a map for the same where the `key` will be the sorted string, and the `value` would be the list of all the strings that are anagrams.\\n* After iteration over all the strings, we get the desired group of anagrams\\n* The time complexity of this approach depends on the sorting technique you use to sort the strings.\\n\\n**Solution:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans ;\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<string> temp = strs ;\\n        map<string, vector<string>> mp;\\n        for(int i=0; i < temp.size() ; i++)\\n\\t\\t{\\n            string t = temp[i];\\n            sort(temp[i].begin(), temp[i].end());\\n            mp[temp[i]].push_back(t);\\n        }\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        map_dict = {}\\n        for i,string in enumerate(strs):\\n            tmp = (\"\").join(sorted(string))\\n            try:\\n                map_dict[tmp].append(strs[i])\\n            except:\\n                map_dict[tmp] = [strs[i]]\\n\\n        return list(map_dict.values())\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String ,List<String>> map = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char[] c = strs[i].toCharArray();\\n            Arrays.sort(c) ;\\n            String temp = String.valueOf(c);\\n            if(map.containsKey(temp))\\n            {\\n                List<String> list = map.get(temp);\\n                list.add(strs[i]);\\n                map.put(temp,list);\\n            }\\n            else\\n            { \\n                List<String> list = new ArrayList<>();\\n                list.add(strs[i]);\\n                map.put(temp, list);\\n            }            \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        ans.addAll(map.values());\\n        return ans;\\n    }\\n}\\n```\\n**TIME COMPLEXITY - O(N*KlogK)**, where k is the length of the largest string. \\n* This is because we are sorting string in every iteration.\\n* It would be **different for different sorting techniques** for e.g. `O(N*K) for Counting Sort`\\n\\n**SPACE COMPLEXITY - O(N*K)**\\n\\n\\n**SCRAP APPROACH:**\\n`Brute Force-` Will give TLE on Large Testcases\\n* Iterate over each string in the input array.\\n* For each string, check with each element of the array if they are anagrams.\\n* If it is an anagram, add it to a group.\\n* Else, move the string to a different group\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans ;\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<string> temp = strs ;\\n        map<string, vector<string>> mp;\\n        for(int i=0; i < temp.size() ; i++)\\n\\t\\t{\\n            string t = temp[i];\\n            sort(temp[i].begin(), temp[i].end());\\n            mp[temp[i]].push_back(t);\\n        }\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        map_dict = {}\\n        for i,string in enumerate(strs):\\n            tmp = (\"\").join(sorted(string))\\n            try:\\n                map_dict[tmp].append(strs[i])\\n            except:\\n                map_dict[tmp] = [strs[i]]\\n\\n        return list(map_dict.values())\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String ,List<String>> map = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char[] c = strs[i].toCharArray();\\n            Arrays.sort(c) ;\\n            String temp = String.valueOf(c);\\n            if(map.containsKey(temp))\\n            {\\n                List<String> list = map.get(temp);\\n                list.add(strs[i]);\\n                map.put(temp,list);\\n            }\\n            else\\n            { \\n                List<String> list = new ArrayList<>();\\n                list.add(strs[i]);\\n                map.put(temp, list);\\n            }            \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        ans.addAll(map.values());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312470,
                "title": "quick-and-easy-solution-c-using-unordered-map",
                "content": "Intuition : Every anagram when sorted read the same word\\nSo, for every word we encounter, let\\'s sort it and see which bucket it belongs to \\nExamples ; {\"eat, \"tea\"}\\nIf we take, \"eat\" and sort it, we get \"aet\" and now we attach the word \"eat\" to \"aet\" as it is an anagram of it\\nWe keep repeating this process and once we are done iterating throught the array, we now iterate through the hashmap and push_back the vector that contains all the anagrams for all keys possible. \\nWe then return the answer. \\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> answer;\\n        unordered_map<string, vector<string>> mpp;\\n        for(string str:strs)\\n        {\\n            string s = str;\\n            sort(s.begin(), s.end());\\n            mpp[s].push_back(str);\\n        }\\n        for(auto const& it : mpp)\\n        {\\n            answer.push_back(it.second);\\n        }\\n        return answer;\\n    }\\n};\\n```\\n\\nPro tip : the `auto const&` in the iteration step of the hashmap tends to increase the speed compared to a `auto it`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> answer;\\n        unordered_map<string, vector<string>> mpp;\\n        for(string str:strs)\\n        {\\n            string s = str;\\n            sort(s.begin(), s.end());\\n            mpp[s].push_back(str);\\n        }\\n        for(auto const& it : mpp)\\n        {\\n            answer.push_back(it.second);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294258,
                "title": "java-solution-99-02-faster-easy-code-explained-in-comments",
                "content": "# Please Upvote if you find it helpful :)\\nsubmit twice if you get slower run time\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result =new ArrayList<>();\\n        HashMap<String,List<String>> map=new HashMap<>();\\n\\t\\t\\n        for(int i=0;i<strs.length;i++){\\n            String s=sortStr(strs[i]);// sort the string |  every anagram will return same string\\n            if(!map.containsKey(s)){\\n                map.put(s,new ArrayList<String>()); // psuh that sorted string as key \\n            }\\n            map.get(s).add(strs[i]);// add in the list  \\n        }\\n        for(List<String> list : map.values()){\\n            result.add(list);\\n        }\\n        return result;\\n    }\\n    public String sortStr(String s){\\n        char c[]=s.toCharArray();\\n        Arrays.sort(c);\\n        String s1=new String(c);\\n        return s1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result =new ArrayList<>();\\n        HashMap<String,List<String>> map=new HashMap<>();\\n\\t\\t\\n        for(int i=0;i<strs.length;i++){\\n            String s=sortStr(strs[i]);// sort the string |  every anagram will return same string\\n            if(!map.containsKey(s)){\\n                map.put(s,new ArrayList<String>()); // psuh that sorted string as key \\n            }\\n            map.get(s).add(strs[i]);// add in the list  \\n        }\\n        for(List<String> list : map.values()){\\n            result.add(list);\\n        }\\n        return result;\\n    }\\n    public String sortStr(String s){\\n        char c[]=s.toCharArray();\\n        Arrays.sort(c);\\n        String s1=new String(c);\\n        return s1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036740,
                "title": "swift-without-sort",
                "content": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var s = [[Character:Int]: [String]]()\\n        strs.forEach {\\n            var k = [Character: Int]()\\n            $0.forEach { c in\\n                k[c, default: 0] += 1\\n            }\\n            s[k, default: []].append($0)\\n        }\\n        return Array(s.values)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var s = [[Character:Int]: [String]]()\\n        strs.forEach {\\n            var k = [Character: Int]()\\n            $0.forEach { c in\\n                k[c, default: 0] += 1\\n            }\\n            s[k, default: []].append($0)\\n        }\\n        return Array(s.values)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027473,
                "title": "java-solution-with-customized-java-objects-o-m-n-beat-98-93",
                "content": "Two strings are anagrams when their character counts are the same, e.g., \"eat\" is `{e:1, a:1, t:1}` and \"tea\" is `{e:1, a:1, t:1}`, so they are in the same group\\n\\nHowever the leetcode standard final solution is not ideal, as  you may notice, it stores a count inside a string, so that to present hashkey checking, however in most real world application, we usually create some customized java objects to perform these checking instead of call `toString()`, because `string.equals()` checking is just too slow for real application.\\n\\nSo this is an example we create a 26 characters customized java object and use it as the key to do hashmap lookup. And it\\'s really fast!\\n\\n```\\nclass Solution {\\n    class BitKey {\\n        // should use a set and get\\n        public final int[] bits;\\n        \\n        public BitKey(int[] bits) {\\n            this.bits = bits;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            // If the object is compared with itself then return true  \\n            if (o == this) {\\n                return true;\\n            }\\n\\n            /* Check if o is an instance of Complex or not\\n              \"null instanceof [type]\" also returns false */\\n            if (!(o instanceof BitKey)) {\\n                return false;\\n            }\\n\\n            // typecast o to Complex so that we can compare data members \\n            BitKey c = (BitKey) o;\\n            \\n            if (this.bits.length != c.bits.length) {\\n                return false;\\n            } else {\\n                for (int i = 0; i < this.bits.length; i++) {\\n                    if (this.bits[i] != c.bits[i]){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }\\n        }\\n        \\n        private Integer hash = null;\\n        @Override\\n        public int hashCode() {\\n            if (hash == null) {\\n                hash = 1;\\n                for (int i = 0; i < this.bits.length; i++) {\\n                    hash += (29 << i) * this.bits[i];\\n                }\\n            }\\n            return hash;\\n        }\\n    }\\n    \\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<BitKey, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            BitKey count = getCounts(s);\\n            \\n            List<String> data = map.get(count);\\n            if (data == null) {\\n                data = new LinkedList<>();\\n                map.put(count, data);\\n            }\\n            data.add(s);\\n        }\\n        \\n        // convert to result\\n        return new ArrayList<List<String>>(map.values());\\n        \\n    }\\n    \\n    public BitKey getCounts(String s) {\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            int offset = s.charAt(i) - \\'a\\';\\n            counts[offset]++;\\n        }\\n        BitKey bitKey = new BitKey(counts);\\n        return bitKey;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class BitKey {\\n        // should use a set and get\\n        public final int[] bits;\\n        \\n        public BitKey(int[] bits) {\\n            this.bits = bits;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            // If the object is compared with itself then return true  \\n            if (o == this) {\\n                return true;\\n            }\\n\\n            /* Check if o is an instance of Complex or not\\n              \"null instanceof [type]\" also returns false */\\n            if (!(o instanceof BitKey)) {\\n                return false;\\n            }\\n\\n            // typecast o to Complex so that we can compare data members \\n            BitKey c = (BitKey) o;\\n            \\n            if (this.bits.length != c.bits.length) {\\n                return false;\\n            } else {\\n                for (int i = 0; i < this.bits.length; i++) {\\n                    if (this.bits[i] != c.bits[i]){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }\\n        }\\n        \\n        private Integer hash = null;\\n        @Override\\n        public int hashCode() {\\n            if (hash == null) {\\n                hash = 1;\\n                for (int i = 0; i < this.bits.length; i++) {\\n                    hash += (29 << i) * this.bits[i];\\n                }\\n            }\\n            return hash;\\n        }\\n    }\\n    \\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<BitKey, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            BitKey count = getCounts(s);\\n            \\n            List<String> data = map.get(count);\\n            if (data == null) {\\n                data = new LinkedList<>();\\n                map.put(count, data);\\n            }\\n            data.add(s);\\n        }\\n        \\n        // convert to result\\n        return new ArrayList<List<String>>(map.values());\\n        \\n    }\\n    \\n    public BitKey getCounts(String s) {\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            int offset = s.charAt(i) - \\'a\\';\\n            counts[offset]++;\\n        }\\n        BitKey bitKey = new BitKey(counts);\\n        return bitKey;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620612,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        map <string, vector<string>> m;\\n        for (auto word : strs) {\\n            string temp = word;\\n            sort(temp.begin(), temp.end());\\n            m[temp].push_back(word);\\n        }\\n        vector<vector<string>> ans;\\n        ans.resize(m.size(), {});\\n        int i = 0;\\n        for (auto ele : m) {\\n            for (auto words : ele.second) {\\n                ans[i].push_back(words);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        map <string, vector<string>> m;\\n        for (auto word : strs) {\\n            string temp = word;\\n            sort(temp.begin(), temp.end());\\n            m[temp].push_back(word);\\n        }\\n        vector<vector<string>> ans;\\n        ans.resize(m.size(), {});\\n        int i = 0;\\n        for (auto ele : m) {\\n            for (auto words : ele.second) {\\n                ans[i].push_back(words);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351121,
                "title": "python-no-sort-solution",
                "content": "Use count every character\\'s position and number to identify the anagrams.\\n\\n```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}\\n        for word in strs:\\n            count = [0] * 26\\n            for ch in word:\\n                count[ord(ch) - ord(\\'a\\')] += 1\\n            d[tuple(count)] = d.get(tuple(count), []) + [word]\\n        return list(d.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}\\n        for word in strs:\\n            count = [0] * 26\\n            for ch in word:\\n                count[ord(ch) - ord(\\'a\\')] += 1\\n            d[tuple(count)] = d.get(tuple(count), []) + [word]\\n        return list(d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334633,
                "title": "c-sort-the-string-and-use-it-as-the-key-of-anagrams-practice",
                "content": "I like to share my C# practice using sorting and then save all anagrams with the same key - sorted string. \\nIt is easy to prove that all anagrams will be the same string if all chars in the string are sorted by alphabetically order. \\n\\n\\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n         if(strs == null || strs.Length == 0){\\n\\t\\t        return new List<IList<String>>();\\n\\t        }\\n\\n\\t        var map = new Dictionary<String, List<String>>();\\n\\t        \\n\\t        foreach (String s in strs) {\\n\\t\\t        char[] ca = s.ToCharArray();\\n\\t\\t        Array.Sort(ca);\\n\\n\\t\\t        String keyStr = new string(ca);\\n\\t\\t        if(!map.ContainsKey(keyStr))\\n                {\\n\\t\\t\\t        map.Add(keyStr, new List<String>());\\n                }\\n\\n\\t\\t        map[keyStr].Add(s);\\n\\t        }\\t       \\n\\n\\t        return new List<IList<String>>(map.Values);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n         if(strs == null || strs.Length == 0){\\n\\t\\t        return new List<IList<String>>();\\n\\t        }\\n\\n\\t        var map = new Dictionary<String, List<String>>();\\n\\t        \\n\\t        foreach (String s in strs) {\\n\\t\\t        char[] ca = s.ToCharArray();\\n\\t\\t        Array.Sort(ca);\\n\\n\\t\\t        String keyStr = new string(ca);\\n\\t\\t        if(!map.ContainsKey(keyStr))\\n                {\\n\\t\\t\\t        map.Add(keyStr, new List<String>());\\n                }\\n\\n\\t\\t        map[keyStr].Add(s);\\n\\t        }\\t       \\n\\n\\t        return new List<IList<String>>(map.Values);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316008,
                "title": "single-line-kotlin-solution-because-we-can",
                "content": "```\\nclass Solution {\\n    fun groupAnagrams(strs: Array<String>): List<List<String>> {\\n        return strs.groupBy{ it.groupingBy{ it }.eachCount() }.values.toList()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun groupAnagrams(strs: Array<String>): List<List<String>> {\\n        return strs.groupBy{ it.groupingBy{ it }.eachCount() }.values.toList()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190917,
                "title": "javascript-es6-beats-100",
                "content": "```\\nvar groupAnagrams = function(strs) {\\n    if(strs.length == 0) return [];\\n    const result = new Map();\\n    const primes = [2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107];\\n    const getKey = str => {\\n        let key = 1;\\n        for(let i = 0; i < str.length; i++){\\n            key =  primes[str.charCodeAt(i) - 97] * key;\\n        }\\n        return key;\\n    }\\n    strs.forEach(w => {\\n        let key = getKey(w);\\n        if(result.has(key)) {\\n            result.get(key).push(w);\\n        } else {\\n            result.set(key,  [w]);\\n        }\\n       \\n    });\\n    return [...result.values()];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar groupAnagrams = function(strs) {\\n    if(strs.length == 0) return [];\\n    const result = new Map();\\n    const primes = [2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107];\\n    const getKey = str => {\\n        let key = 1;\\n        for(let i = 0; i < str.length; i++){\\n            key =  primes[str.charCodeAt(i) - 97] * key;\\n        }\\n        return key;\\n    }\\n    strs.forEach(w => {\\n        let key = getKey(w);\\n        if(result.has(key)) {\\n            result.get(key).push(w);\\n        } else {\\n            result.set(key,  [w]);\\n        }\\n       \\n    });\\n    return [...result.values()];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 148319,
                "title": "simple-python",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}\\n        for st in strs:\\n            s = \\'\\'.join(sorted(st))\\n            d[s] = d.get(s, []) + [st]\\n        return list(d.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}\\n        for st in strs:\\n            s = \\'\\'.join(sorted(st))\\n            d[s] = d.get(s, []) + [st]\\n        return list(d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19213,
                "title": "my-ruby-solution",
                "content": "```\\ndef group_anagrams(strs)\\n    anagrams = Hash.new {|h, k| h[k] = []}\\n    \\n    strs.each do |str|\\n        sorted = str.chars.sort\\n        anagrams[sorted] << str\\n    end\\n    \\n    anagrams.values\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef group_anagrams(strs)\\n    anagrams = Hash.new {|h, k| h[k] = []}\\n    \\n    strs.each do |str|\\n        sorted = str.chars.sort\\n        anagrams[sorted] << str\\n    end\\n    \\n    anagrams.values\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 19350,
                "title": "7-lines-java-solution",
                "content": "I have to say java stream is really inefficient and slow, you can replace **computeIfAbsent** with conventional java code, but I use it because it makes my code short and clean, but it is really really slow:\\n```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String str : strs) {\\n            char[] chars = str.toCharArray();\\n            Arrays.sort(chars);\\n            String key = String.valueOf(chars);\\n            map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);\\n        }\\n        return new ArrayList<>(map.values());\\n    }",
                "solutionTags": [],
                "code": "I have to say java stream is really inefficient and slow, you can replace **computeIfAbsent** with conventional java code, but I use it because it makes my code short and clean, but it is really really slow:\\n```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String str : strs) {\\n            char[] chars = str.toCharArray();\\n            Arrays.sort(chars);\\n            String key = String.valueOf(chars);\\n            map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);\\n        }\\n        return new ArrayList<>(map.values());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19400,
                "title": "easy-to-understand-java-solution-using-hashmaps-edited",
                "content": "    public class Solution {\\n       public List<List<String>> groupAnagrams(String[] strs) {\\n           List<List<String>>result= new ArrayList<>();\\n           Map<String,List<String>> map = new HashMap<String,List<String>>();\\n     \\n           for(String s:strs)\\n         {\\n               char[]c= s.toCharArray(); \\n               Arrays.sort(c);                  \\n         \\n         //all Anagrams will be the same string if sorted  (tea,eat -->aet) , which serves as our key\\n             \\n             String keyStr= String.valueOf(c);\\n             if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<String>());\\n             map.get(keyStr).add(s);\\n          }\\n     \\n      //All the key value entries are stored in an entrySet which helps us return those values that have a key corresponding to it\\n     \\n         for (Map.Entry<String, List<String>> entry : map.entrySet()) {\\n          \\n               List<String> values = entry.getValue();\\n\\n               //since we want lexicographic order of the result, we sort the list\\n               Collections.sort(values);               \\n\\n               result.add(values);\\n          }\\n\\n         return result;   \\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n       public List<List<String>> groupAnagrams(String[] strs) {\\n           List<List<String>>result= new ArrayList<>();\\n           Map<String,List<String>> map = new HashMap<String,List<String>>();\\n     \\n           for(String s:strs)\\n         {\\n               char[]c= s.toCharArray(); \\n               Arrays.sort(c);                  \\n         \\n         //all Anagrams will be the same string if sorted  (tea,eat -->aet) , which serves as our key\\n             \\n             String keyStr= String.valueOf(c);\\n             if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<String>());\\n             map.get(keyStr).add(s);\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 19422,
                "title": "sharing-my-simple-76ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n            vector<vector<string>> result;\\n            unordered_map<string, vector<string>> myMap;\\n            string temp;\\n            for(int i=0; i<strs.size(); i++)\\n            {\\n                temp = strs[i];\\n                sort(temp.begin(), temp.end());\\n                myMap[temp].push_back(strs[i]);\\n            }\\n            \\n            for(auto x=myMap.begin(); x!=myMap.end(); x++)\\n            {\\n                vector<string> tmp = x->second;\\n                sort(tmp.begin(), tmp.end());\\n                result.push_back(tmp);\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n            vector<vector<string>> result;\\n            unordered_map<string, vector<string>> myMap;\\n            string temp;\\n            for(int i=0; i<strs.size(); i++)\\n            {\\n                temp = strs[i];\\n                sort(temp.begin(), temp.end());\\n                myMap[temp].push_back(strs[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 19424,
                "title": "24ms-short-java-solution",
                "content": "    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ar = s.toCharArray();\\n            Arrays.sort(ar);\\n            String sorted = String.valueOf(ar);\\n            List<String> list = map.get(sorted);\\n            if (list == null) list = new ArrayList<String>();\\n            list.add(s);\\n            map.put(sorted, list);\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        for (List<String> l : map.values()) {\\n            Collections.sort(l);\\n            res.add(l);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ar = s.toCharArray();\\n            Arrays.sort(ar);\\n            String sorted = String.valueOf(ar);\\n            List<String> list = map.get(sorted);\\n            if (list == null) list = new ArrayList<String>();\\n            list.add(s);\\n            map.put(sorted, list);\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        for (List<String> l : map.values()) {\\n            Collections.sort(l);\\n            res.add(l);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19415,
                "title": "java-22-ms-and-20-lines-36-ms-and-11-lines-172-ms-and-9-lines-d",
                "content": "~22 ms\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] keyArr = new char[26];\\n            for (int i = 0; i < s.length(); i++)\\n                keyArr[s.charAt(i) - 'a']++;\\n            String key = new String(keyArr);\\n            if (map.containsKey(key)) map.get(key).add(s);\\n            else {\\n                List<String> val = new ArrayList<>();\\n                val.add(s);\\n                map.put(key, val);\\n            }\\n        }\\n        for (Map.Entry<String, List<String>> entry : map.entrySet()) {\\n            List<String> val = entry.getValue();\\n            Collections.sort(val);\\n            res.add(val);\\n        }\\n        return res;\\n    }\\n\\n~36 ms\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] keyArr = s.toCharArray();\\n            Arrays.sort(keyArr);\\n            String key = new String(keyArr);\\n            if (map.containsKey(key)) map.get(key).add(s);\\n            else map.put(key, new ArrayList<>(Arrays.asList(s)));\\n        }\\n        for (List<String> val : map.values())\\n            Collections.sort(val);\\n        return new ArrayList<List<String>>(map.values());\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "~22 ms\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] keyArr = new char[26];\\n            for (int i = 0; i < s.length(); i++)\\n                keyArr[s.charAt(i) - 'a']++;\\n            String key = new String(keyArr);\\n            if (map.containsKey(key)) map.get(key).add(s);\\n            else {\\n                List<String> val = new ArrayList<>();\\n                val.add(s);\\n                map.put(key, val);\\n            }\\n        }\\n        for (Map.Entry<String, List<String>> entry : map.entrySet()) {\\n            List<String> val = entry.getValue();\\n            Collections.sort(val);\\n            res.add(val);\\n        }\\n        return res;\\n    }\\n\\n~36 ms\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] keyArr = s.toCharArray();\\n            Arrays.sort(keyArr);\\n            String key = new String(keyArr);\\n            if (map.containsKey(key)) map.get(key).add(s);\\n            else map.put(key, new ArrayList<>(Arrays.asList(s)));\\n        }\\n        for (List<String> val : map.values())\\n            Collections.sort(val);\\n        return new ArrayList<List<String>>(map.values());\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564708,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565002,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1570544,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565940,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565941,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1841445,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1803102,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1576350,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1571122,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1568872,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1564708,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565002,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1570544,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565940,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565941,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1841445,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1803102,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1576350,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1571122,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1568872,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1571118,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1803676,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1567824,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1571121,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1568873,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1567825,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1567178,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 2047581,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1576794,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1575181,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1574673,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1573598,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1571119,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1571120,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2046371,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2043822,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2043809,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2038922,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2038700,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2030271,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2015389,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 2014174,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 2004090,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 2000575,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1999665,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1991383,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1984928,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1975723,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1963413,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1931709,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1922079,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1921191,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1919790,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1916978,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1912405,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1911672,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1909227,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1907310,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1905029,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1901183,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1898994,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1890843,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1849312,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1845504,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1811154,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1803454,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1802309,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1797307,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1783235,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1776933,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1770139,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1768446,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1752633,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1750256,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1749641,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1747849,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1723158,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1717608,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1708797,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1707703,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Max Points on a Line",
        "question_content": "<p>Given an array of <code>points</code> where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents a point on the <strong>X-Y</strong> plane, return <em>the maximum number of points that lie on the same straight line</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg\" style=\"width: 300px; height: 294px;\" />\n<pre>\n<strong>Input:</strong> points = [[1,1],[2,2],[3,3]]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg\" style=\"width: 300px; height: 294px;\" />\n<pre>\n<strong>Input:</strong> points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 300</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>All the <code>points</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 47113,
                "title": "a-java-solution-with-notes",
                "content": "  \\n\\n      /*\\n         *  A line is determined by two factors,say y=ax+b\\n         *  \\n         *  If two points(x1,y1) (x2,y2) are on the same line(Of course). \\n\\n         *  Consider the gap between two points.\\n\\n         *  We have (y2-y1)=a(x2-x1),a=(y2-y1)/(x2-x1) a is a rational, b is canceled since b is a constant\\n\\n         *  If a third point (x3,y3) are on the same line. So we must have y3=ax3+b\\n\\n         *  Thus,(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a\\n\\n         *  Since a is a rational, there exists y0 and x0, y0/x0=(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a\\n\\n         *  So we can use y0&x0 to track a line;\\n         */\\n        \\n        public class Solution{\\n            public int maxPoints(Point[] points) {\\n            \\tif (points==null) return 0;\\n            \\tif (points.length<=2) return points.length;\\n            \\t\\n            \\tMap<Integer,Map<Integer,Integer>> map = new HashMap<Integer,Map<Integer,Integer>>();\\n            \\tint result=0;\\n            \\tfor (int i=0;i<points.length;i++){ \\n            \\t\\tmap.clear();\\n            \\t\\tint overlap=0,max=0;\\n            \\t\\tfor (int j=i+1;j<points.length;j++){\\n            \\t\\t\\tint x=points[j].x-points[i].x;\\n            \\t\\t\\tint y=points[j].y-points[i].y;\\n            \\t\\t\\tif (x==0&&y==0){\\n            \\t\\t\\t\\toverlap++;\\n            \\t\\t\\t\\tcontinue;\\n            \\t\\t\\t}\\n            \\t\\t\\tint gcd=generateGCD(x,y);\\n            \\t\\t\\tif (gcd!=0){\\n            \\t\\t\\t\\tx/=gcd;\\n            \\t\\t\\t\\ty/=gcd;\\n            \\t\\t\\t}\\n            \\t\\t\\t\\n            \\t\\t\\tif (map.containsKey(x)){\\n            \\t\\t\\t\\tif (map.get(x).containsKey(y)){\\n            \\t\\t\\t\\t\\tmap.get(x).put(y, map.get(x).get(y)+1);\\n            \\t\\t\\t\\t}else{\\n            \\t\\t\\t\\t\\tmap.get(x).put(y, 1);\\n            \\t\\t\\t\\t}   \\t\\t\\t\\t\\t\\n            \\t\\t\\t}else{\\n            \\t\\t\\t\\tMap<Integer,Integer> m = new HashMap<Integer,Integer>();\\n            \\t\\t\\t\\tm.put(y, 1);\\n            \\t\\t\\t\\tmap.put(x, m);\\n            \\t\\t\\t}\\n            \\t\\t\\tmax=Math.max(max, map.get(x).get(y));\\n            \\t\\t}\\n            \\t\\tresult=Math.max(result, max+overlap+1);\\n            \\t}\\n            \\treturn result;\\n            \\t\\n            \\t\\n            }\\n            private int generateGCD(int a,int b){\\n        \\n            \\tif (b==0) return a;\\n            \\telse return generateGCD(b,a%b);\\n            \\t\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution{\\n            public int maxPoints(Point[] points) {\\n            \\tif (points==null) return 0;\\n            \\tif (points.length<=2) return points.length;\\n            \\t\\n            \\tMap<Integer,Map<Integer,Integer>> map = new HashMap<Integer,Map<Integer,Integer>>();\\n            \\tint result=0;\\n            \\tfor (int i=0;i<points.length;i++){ \\n            \\t\\tmap.clear();\\n            \\t\\tint overlap=0,max=0;\\n            \\t\\tfor (int j=i+1;j<points.length;j++){\\n            \\t\\t\\tint x=points[j].x-points[i].x;\\n            \\t\\t\\tint y=points[j].y-points[i].y;\\n            \\t\\t\\tif (x==0&&y==0){\\n            \\t\\t\\t\\toverlap++;\\n            \\t\\t\\t\\tcontinue;\\n            \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 47117,
                "title": "sharing-my-simple-solution-with-explanation",
                "content": "    int maxPoints(vector<Point> &points) {\\n        int result = 0;\\n        for(int i = 0; i < points.size(); i++){\\n            int samePoint = 1;\\n            unordered_map<double, int> map;\\n            for(int j = i + 1; j < points.size(); j++){\\n                if(points[i].x == points[j].x && points[i].y == points[j].y){\\n                    samePoint++;\\n                }\\n                else if(points[i].x == points[j].x){\\n                    map[INT_MAX]++;\\n                }\\n                else{\\n                    double slope = double(points[i].y - points[j].y) / double(points[i].x - points[j].x);\\n                    map[slope]++;\\n                }\\n            }\\n            int localMax = 0;\\n            for(auto it = map.begin(); it != map.end(); it++){\\n                localMax = max(localMax, it->second);\\n            }\\n            localMax += samePoint;\\n            result = max(result, localMax);\\n        }\\n        return result;\\n    }\\n\\nFirst, let's talk about mathematics.\\n\\nHow to determine if three points are on the same line?\\n\\nThe answer is to see if slopes of arbitrary two pairs are the same.\\n\\nSecond, let's see what the minimum time complexity can be.\\n\\nDefinitely, O(n^2). It's because you have to calculate all slopes between any two points. \\n\\nThen let's go back to the solution of this problem.\\n\\nIn order to make this discussion simpler, let's pick a random point A as an example.\\n\\nGiven point A, we need to calculate all slopes between A and other points. There will be three cases:\\n\\n1. Some other point is the same as point A.\\n\\n2. Some other point has the same x coordinate as point A, which will result to a positive infinite slope.\\n\\n3. General case. We can calculate slope.\\n\\nWe can store all slopes in a hash table. And we find which slope shows up mostly. Then add the number of same points to it. Then we know the maximum number of points on the same line for point A.\\n\\nWe can do the same thing to point B, point C...\\n\\nFinally, just return the maximum result among point A, point B, point C...",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "    int maxPoints(vector<Point> &points) {\\n        int result = 0;\\n        for(int i = 0; i < points.size(); i++){\\n            int samePoint = 1;\\n            unordered_map<double, int> map;\\n            for(int j = i + 1; j < points.size(); j++){\\n                if(points[i].x == points[j].x && points[i].y == points[j].y){\\n                    samePoint++;\\n                }\\n                else if(points[i].x == points[j].x){\\n                    map[INT_MAX]++;\\n                }\\n                else{\\n                    double slope = double(points[i].y - points[j].y) / double(points[i].x - points[j].x);\\n                    map[slope]++;\\n                }\\n            }\\n            int localMax = 0;\\n            for(auto it = map.begin(); it != map.end(); it++){\\n                localMax = max(localMax, it->second);\\n            }\\n            localMax += samePoint;\\n            result = max(result, localMax);\\n        }\\n        return result;\\n    }\\n\\nFirst, let's talk about mathematics.\\n\\nHow to determine if three points are on the same line?\\n\\nThe answer is to see if slopes of arbitrary two pairs are the same.\\n\\nSecond, let's see what the minimum time complexity can be.\\n\\nDefinitely, O(n^2). It's because you have to calculate all slopes between any two points. \\n\\nThen let's go back to the solution of this problem.\\n\\nIn order to make this discussion simpler, let's pick a random point A as an example.\\n\\nGiven point A, we need to calculate all slopes between A and other points. There will be three cases:\\n\\n1. Some other point is the same as point A.\\n\\n2. Some other point has the same x coordinate as point A, which will result to a positive infinite slope.\\n\\n3. General case. We can calculate slope.\\n\\nWe can store all slopes in a hash table. And we find which slope shows up mostly. Then add the number of same points to it. Then we know the maximum number of points on the same line for point A.\\n\\nWe can do the same thing to point B, point C...\\n\\nFinally, just return the maximum result among point A, point B, point C...",
                "codeTag": "Unknown"
            },
            {
                "id": 47124,
                "title": "c-slope-counter",
                "content": "A simple idea is to traverse all possible pairs of points and see how many other points fall in the line determined by them, which gives an `O(n^3)` solution.\\n\\nTo improve the time complexity, we traverse all possible lines. We can determine a line by the slope and a point on it.\\n\\nGiven a point `p`, we compute the slopes of all lines connecting `p` and other points. Points corresponding to the same slope will fall on the same line. In this way, we can figure out the maximum number of points on lines containing `p`. We exhaust all possible `p`s and the largest maximum number is just the answer.\\n\\nTo represent a slope (`dy / dx`), we may simply use a `double`. A safer way is to store the pair `{dy, dx}`. However, since `pair` is not hashable, we need to use `map` instead of `unordered_map`, which increases the time complexity. Another way is to encode `dx` and `dy` into a string like `\"dx_dy\"`. Moreover, since `dy = 4, dx = 2` and `dy = 8, dx = 4` represents the same slope, we need to divide them by their gcd before the encoding.\\n\\nWe still need to handle the case of duplicate points simply by adding the number of duplicates to the result.\\n\\nThis is an `O(n^2)` solution given the nested `for` loops. All operations of `unordered_map` take `O(1)` time on average.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxPoints(vector<Point>& points) {\\n        int n = points.size(), ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            unordered_map<string, int> counter;\\n            int dup = 1;\\n            for (int j = i + 1; j < n; j++) {\\n                if (points[j].x == points[i].x && points[j].y == points[i].y) {\\n                    dup++;\\n                } else {\\n                    int dx = points[j].x - points[i].x, dy = points[j].y - points[i].y, g = gcd(dx, dy);\\n                    counter[to_string(dx / g) + \\'_\\' + to_string(dy / g)]++;\\n                }\\n            }\\n            ans = max(ans, dup);\\n            for (auto p : counter) {\\n                ans = max(ans, p.second + dup);\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int gcd(int a, int b) {\\n        while (b) {\\n            a = a % b;\\n            swap(a, b);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxPoints(vector<Point>& points) {\\n        int n = points.size(), ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            unordered_map<string, int> counter;\\n            int dup = 1;\\n            for (int j = i + 1; j < n; j++) {\\n                if (points[j].x == points[i].x && points[j].y == points[i].y) {\\n                    dup++;\\n                } else {\\n                    int dx = points[j].x - points[i].x, dy = points[j].y - points[i].y, g = gcd(dx, dy);\\n                    counter[to_string(dx / g) + \\'_\\' + to_string(dy / g)]++;\\n                }\\n            }\\n            ans = max(ans, dup);\\n            for (auto p : counter) {\\n                ans = max(ans, p.second + dup);\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int gcd(int a, int b) {\\n        while (b) {\\n            a = a % b;\\n            swap(a, b);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016390,
                "title": "c-easy-beats-approx-100-explanation",
                "content": "\\uD83C\\uDFA5\\uD83D\\uDD25 Exciting News! Join my Coding Journey! Subscribe Now! \\uD83D\\uDD25\\uD83C\\uDFA5\\n\\n\\uD83D\\uDD17 Link in the leetcode profile \\n\\nNew coding channel alert! \\uD83D\\uDE80\\uD83D\\uDCBB Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! \\uD83C\\uDF1F\\uD83D\\uDCAA\\n\\nThanks for your support! \\uD83D\\uDE4F\\n# Intuition\\n- Here we will calculate the slope\\n\\n# Approach\\nIdea is very simple\\n1. We will select point and for every selected point we will calculate the slope wr.t to another point and store into the map\\n2. In map we will store <slope,that selected point>\\n- for example we have point :-[[1,1],[2,2],[3,3]......\\n   we pick point [1,1]and for that [1,1] we will calculate the slope\\n   w.r.t [2,2] ,[3,3]....... and store like this-\\n    for understanding purpose i\\'m writing\\n    mp[slope1,[1,1]]\\n    mp[slope2,[1,1]]\\n    mp[slope1,[1,1]].........\\n   This type we will store the slope for [2,2] , [3,3],....\\n3. Ater storing the slope into map we will calculate the max point for that slope\\n  For example after storing the slope map can look like this\\n[2/3,3]\\n[INF,1]//for perpendicular case\\n[1/3,2]...\\n4. find the max number of points having the same slope w.r.t. that selected point :-means which slope have maximum point\\n:- here 2/3 have 3 point so our answer will be 3+1(we are adding that point as well) \\n![maxpointupdate.png](https://assets.leetcode.com/users/images/ea135bbf-9a36-47e3-8e84-4db223742bbf_1673169518.2250805.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& pt) {\\n        int ans=1; \\n        int n=pt.size();\\n       // slope of every point with selected point\\n        for(int i=0;i<n-1;i++){\\n            map<double,int> mp;\\n            for(int j=i+1;j<n;j++){\\n                //calculating the slope\\n                double x = (double)(pt[j][1]-pt[i][1])/(double)(pt[j][0]-pt[i][0]);\\n                if(pt[j][1]-pt[i][1]<0 &&(pt[j][0]-pt[i][0])==0 ) //infinite slop for Perpendicular line\\n                mp[abs(x)]++; \\n                else\\n               //storing the slop into map\\n                    mp[x]++;\\n            }\\n            // same slope w.r.t.that selected point\\n            int temp = 0;\\n            for(auto it:mp)\\n                temp = max(temp, it.second+1);    // +1 for the current point(point itself)\\n            ans = max(temp, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you really found my solution helpful **please upvote it**, as it motivates me to post such kind of codes.\\n*Let me know in comment if i can do better.*\\nLets connect on [Linkdin](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/)",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& pt) {\\n        int ans=1; \\n        int n=pt.size();\\n       // slope of every point with selected point\\n        for(int i=0;i<n-1;i++){\\n            map<double,int> mp;\\n            for(int j=i+1;j<n;j++){\\n                //calculating the slope\\n                double x = (double)(pt[j][1]-pt[i][1])/(double)(pt[j][0]-pt[i][0]);\\n                if(pt[j][1]-pt[i][1]<0 &&(pt[j][0]-pt[i][0])==0 ) //infinite slop for Perpendicular line\\n                mp[abs(x)]++; \\n                else\\n               //storing the slop into map\\n                    mp[x]++;\\n            }\\n            // same slope w.r.t.that selected point\\n            int temp = 0;\\n            for(auto it:mp)\\n                temp = max(temp, it.second+1);    // +1 for the current point(point itself)\\n            ans = max(temp, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47106,
                "title": "c-o-n-2-solution-for-your-reference",
                "content": "Hint by @stellari\\n\\n\"For each point pi, calculate the slope of each line it forms with all other points with greater indices, i.e. pi+1, pi+2, ..., and use a map to record how many lines have the same slope (If two lines have the same slope and share a common point, then the two lines must be the same one). By doing so, you can easily find how many points are on the same line that ends at pi in O(n). Thus the amortized running time of the whole algorithm is O(n^2).\"\\n\\nIn order to avoid using double type(the slope k) as map key, I used pair (int a, int b) as the key where a=pj.x-pi.x, b=pj.y-pi.y, and k=b/a. Using greatest common divider of a and b to divide both a, b ensures that lines with same slope have the same key. \\n\\nI also handled two special cases: (1) when two points are on a vertical line (2) when two points are the same.\\n\\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            \\n            if(points.size()<2) return points.size();\\n            \\n            int result=0;\\n            \\n            for(int i=0; i<points.size(); i++) {\\n                \\n                map<pair<int, int>, int> lines;\\n                int localmax=0, overlap=0, vertical=0;\\n                \\n                for(int j=i+1; j<points.size(); j++) {\\n                    \\n                    if(points[j].x==points[i].x && points[j].y==points[i].y) {\\n                        \\n                        overlap++;\\n                        continue;\\n                    }\\n                    else if(points[j].x==points[i].x) vertical++;\\n                    else {\\n                        \\n                        int a=points[j].x-points[i].x, b=points[j].y-points[i].y;\\n                        int gcd=GCD(a, b);\\n                        \\n                        a/=gcd;\\n                        b/=gcd;\\n                        \\n                        lines[make_pair(a, b)]++;\\n                        localmax=max(lines[make_pair(a, b)], localmax);\\n                    }\\n    \\n                    localmax=max(vertical, localmax);\\n                }\\n                \\n                result=max(result, localmax+overlap+1);\\n            }\\n            \\n            return result;\\n        }\\n    \\n    private:\\n        int GCD(int a, int b) {\\n            \\n            if(b==0) return a;\\n            else return GCD(b, a%b);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            \\n            if(points.size()<2) return points.size();\\n            \\n            int result=0;\\n            \\n            for(int i=0; i<points.size(); i++) {\\n                \\n                map<pair<int, int>, int> lines;\\n                int localmax=0, overlap=0, vertical=0;\\n                \\n                for(int j=i+1; j<points.size(); j++) {\\n                    \\n                    if(points[j].x==points[i].x && points[j].y==points[i].y) {\\n                        \\n                        overlap++;\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3016360,
                "title": "easiest-c-solution-with-detailed-explanation",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Intuition:** We have to see straight line so we use geometry concept\\n\\n**Approach:**\\n* From the time constrains we can observe that solution having O(N^3) are also permitted.\\n* So we will simply apply the SLOPE concept from geometry.\\n* ![image](https://assets.leetcode.com/users/images/9d971e66-1da7-42ab-a2cb-b0614f6b9774_1673140806.3116992.png)\\n* If the points have same slope means they are in a straight line.\\n* We just counting them and take max of different slope count.\\n* Return the max count;\\n\\n**Brute Force Approach:**\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n<=2)\\n            return n;\\n        \\n        int maxi = 2;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            {\\n                int count=2;\\n                for(int k=0; k<n; k++)\\n                {\\n                    if(k!=i && k!=j)\\n                    {\\n                        if((points[j][1]-points[i][1])*(points[i][0]-points[k][0])==(points[i][1]-points[k][1])*(points[j][0]-points[i][0]))\\n                            count++;\\n                    }\\n                }\\n                maxi = max(maxi,count);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n**Time Complexity** => `O(N^3)`\\n**Space Complexity** => `O(1)`\\n\\n**Optimised Approach:**\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=2) return n;\\n        int ans = 0;\\n\\n        for(auto it1 : points){\\n            unordered_map<double,int> mp;\\n            double x1 = it1[0], y1 = it1[1];\\n            for(auto it2 : points){   \\n                if(it2 == it1) continue;\\n                double x2 = it2[0], y2 = it2[1];\\n                double slope;\\n                if(x2-x1 == 0){\\n                    slope = INT_MAX; // slope is infinity for vertical line\\n                }else{\\n                    slope = (y2-y1)/(x2-x1);   \\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n        return ans+1; //including point i\\n    }\\n};\\n```\\n**Time Complexity** => `O(N^2)`\\n**Space Complexity** => `O(N)`\\n\\n![image](https://assets.leetcode.com/users/images/b4a29db6-fe84-4707-b565-c9200aaca31d_1673140967.8644767.png)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n<=2)\\n            return n;\\n        \\n        int maxi = 2;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            {\\n                int count=2;\\n                for(int k=0; k<n; k++)\\n                {\\n                    if(k!=i && k!=j)\\n                    {\\n                        if((points[j][1]-points[i][1])*(points[i][0]-points[k][0])==(points[i][1]-points[k][1])*(points[j][0]-points[i][0]))\\n                            count++;\\n                    }\\n                }\\n                maxi = max(maxi,count);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=2) return n;\\n        int ans = 0;\\n\\n        for(auto it1 : points){\\n            unordered_map<double,int> mp;\\n            double x1 = it1[0], y1 = it1[1];\\n            for(auto it2 : points){   \\n                if(it2 == it1) continue;\\n                double x2 = it2[0], y2 = it2[1];\\n                double slope;\\n                if(x2-x1 == 0){\\n                    slope = INT_MAX; // slope is infinity for vertical line\\n                }else{\\n                    slope = (y2-y1)/(x2-x1);   \\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n        return ans+1; //including point i\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47098,
                "title": "accepted-java-solution-easy-to-understand",
                "content": "        /**\\n     * Definition for a point.\\n     * class Point {\\n     *     int x;\\n     *     int y;\\n     *     Point() { x = 0; y = 0; }\\n     *     Point(int a, int b) { x = a; y = b; }\\n     * }\\n     */\\n    public class Solution {\\n        public int maxPoints(Point[] points) {\\n            if(points.length <= 0) return 0;\\n            if(points.length <= 2) return points.length;\\n            int result = 0;\\n            for(int i = 0; i < points.length; i++){\\n                HashMap<Double, Integer> hm = new HashMap<Double, Integer>();\\n                int samex = 1;\\n                int samep = 0;\\n                for(int j = 0; j < points.length; j++){\\n                    if(j != i){\\n                        if((points[j].x == points[i].x) && (points[j].y == points[i].y)){\\n                            samep++;\\n                        }\\n                        if(points[j].x == points[i].x){\\n                            samex++;\\n                            continue;\\n                        }\\n                        double k = (double)(points[j].y - points[i].y) / (double)(points[j].x - points[i].x);\\n                        if(hm.containsKey(k)){\\n                            hm.put(k,hm.get(k) + 1);\\n                        }else{\\n                            hm.put(k, 2);\\n                        }\\n                        result = Math.max(result, hm.get(k) + samep);\\n                    }\\n                }\\n                result = Math.max(result, samex);\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int maxPoints(Point[] points) {\\n            if(points.length <= 0) return 0;\\n            if(points.length <= 2) return points.length;\\n            int result = 0;\\n            for(int i = 0; i < points.length; i++){\\n                HashMap<Double, Integer> hm = new HashMap<Double, Integer>();\\n                int samex = 1;\\n                int samep = 0;\\n                for(int j = 0; j < points.length; j++){\\n                    if(j != i){\\n                        if((points[j].x == points[i].x) && (points[j].y == points[i].y)){\\n                            samep++;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1983010,
                "title": "python-3-using-slopes-and-hash-tables-clean-python-solution",
                "content": "**Concept**: A set of points are on a line each of their pair-wise slopes has the same value.\\n\\nFor each point, we iterate through all the other points and find the slope with each of the other points and store the number of pairs which have the same slope and find the max of the number of points.\\n\\n**Time Complexity:** O(N^2)\\n**Space Complexity:** O(N) as we track only N-1 lines in total.\\n\\n**Do UPVOTE if you found it helpful**\\n\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points) <= 2:\\n            return len(points)\\n        \\n        def find_slope(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            if x1-x2 == 0:\\n                return inf\\n            return (y1-y2)/(x1-x2)\\n        \\n        ans = 1\\n        for i, p1 in enumerate(points):\\n            slopes = defaultdict(int)\\n            for j, p2 in enumerate(points[i+1:]):\\n                slope = find_slope(p1, p2)\\n                slopes[slope] += 1\\n                ans = max(slopes[slope], ans)\\n        return ans+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points) <= 2:\\n            return len(points)\\n        \\n        def find_slope(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            if x1-x2 == 0:\\n                return inf\\n            return (y1-y2)/(x1-x2)\\n        \\n        ans = 1\\n        for i, p1 in enumerate(points):\\n            slopes = defaultdict(int)\\n            for j, p2 in enumerate(points[i+1:]):\\n                slope = find_slope(p1, p2)\\n                slopes[slope] += 1\\n                ans = max(slopes[slope], ans)\\n        return ans+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016432,
                "title": "python3-o-n-2-hash-map-with-line-equation-explained",
                "content": "- One thing that need to be solved is using something to represent a line formed by two points. For example, point A and point B form a line, and point C is on this line, then the representation of line AB and line AC should be the same. One way of doing this is using Equation of Straight Line: y = slope * x + b, so we use (slope, b).\\n - The second part is count the number of points in each unique line equation. This can be done by using each point as the start point, compute the line equation using other point as the end point, and increase the count of a line euqation if we see a new end point on it. We can use hashmap to count the points on each line euqation.\\n\\n```python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \\n        if len(points)<=2: return len(points)\\n        \\n        # Line equation: y = slope * x + b\\n        # Given two points, solve for slope and b\\n        # The slope of a vertical line is undefined, and the form is x = a, \\n        # Where a is the x-intercept, so return (x)\\n        def line(p1,p2):\\n            # Vertical line\\n            if p2[0]-p1[0] == 0:\\n                return (p1[0])\\n            slope = (p2[1]-p1[1]) / (p2[0]-p1[0])                \\n            b = p1[1] - slope * p1[0]\\n            return (slope,\"%.5f\" % b) #Floating Point has issues and limitations, using floating point as hash key isn\\'t a good iead, so round it up a little bit. Check the comment below for the issue.\\n\\n        res = 0\\n        # Let each point be the start point.\\n        # Check the lines formed using other points as the end point.\\n        # Only the distinct line equation matters here (Using hash map to count). \\n        # We want to count how many points are in each line euqation.\\n        # Update the result with the maximum number of points in a line euqation.\\n        for i in range(len(points)):\\n            count = defaultdict(int)\\n            for j in range(i+1,len(points)):\\n                count[line(points[i],points[j])] += 1\\n            if count:\\n                res = max(res,max(count.values()))\\n        \\n        # We didn\\'t count the start point, so +1 here.\\n        return res + 1\\n```\\n\\n**Actually, we don\\'t even need the line equation, and just using the slope will do the trick. Using the same example as before, point A and point B form a line, and point C is on this line, then the slope of line AB and line AC is the same.**\\n\\n```python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \\n        if len(points)<=2: return len(points)\\n\\n        def slope(p1,p2):\\n            # Vertical line\\n            if p2[0]-p1[0] == 0:\\n                return inf\\n            return (p2[1]-p1[1]) / (p2[0]-p1[0])                \\n\\n        res = 0\\n        for i in range(len(points)):\\n            count = defaultdict(int)\\n            for j in range(i+1,len(points)):\\n                count[slope(points[i],points[j])] += 1\\n            if count:\\n                res = max(res,max(count.values()))\\n        \\n        return res + 1\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \\n        if len(points)<=2: return len(points)\\n        \\n        # Line equation: y = slope * x + b\\n        # Given two points, solve for slope and b\\n        # The slope of a vertical line is undefined, and the form is x = a, \\n        # Where a is the x-intercept, so return (x)\\n        def line(p1,p2):\\n            # Vertical line\\n            if p2[0]-p1[0] == 0:\\n                return (p1[0])\\n            slope = (p2[1]-p1[1]) / (p2[0]-p1[0])                \\n            b = p1[1] - slope * p1[0]\\n            return (slope,\"%.5f\" % b) #Floating Point has issues and limitations, using floating point as hash key isn\\'t a good iead, so round it up a little bit. Check the comment below for the issue.\\n\\n        res = 0\\n        # Let each point be the start point.\\n        # Check the lines formed using other points as the end point.\\n        # Only the distinct line equation matters here (Using hash map to count). \\n        # We want to count how many points are in each line euqation.\\n        # Update the result with the maximum number of points in a line euqation.\\n        for i in range(len(points)):\\n            count = defaultdict(int)\\n            for j in range(i+1,len(points)):\\n                count[line(points[i],points[j])] += 1\\n            if count:\\n                res = max(res,max(count.values()))\\n        \\n        # We didn\\'t count the start point, so +1 here.\\n        return res + 1\\n```\n```python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \\n        if len(points)<=2: return len(points)\\n\\n        def slope(p1,p2):\\n            # Vertical line\\n            if p2[0]-p1[0] == 0:\\n                return inf\\n            return (p2[1]-p1[1]) / (p2[0]-p1[0])                \\n\\n        res = 0\\n        for i in range(len(points)):\\n            count = defaultdict(int)\\n            for j in range(i+1,len(points)):\\n                count[slope(points[i],points[j])] += 1\\n            if count:\\n                res = max(res,max(count.values()))\\n        \\n        return res + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47108,
                "title": "python-68-ms-code",
                "content": "        def maxPoints(self, points):\\n            l = len(points)\\n            m = 0\\n            for i in range(l):\\n                dic = {'i': 1}\\n                same = 0\\n                for j in range(i+1, l):\\n                    tx, ty = points[j].x, points[j].y\\n                    if tx == points[i].x and ty == points[i].y: \\n                        same += 1\\n                        continue\\n                    if points[i].x == tx: slope = 'i'\\n                    else:slope = (points[i].y-ty) * 1.0 /(points[i].x-tx)\\n                    if slope not in dic: dic[slope] = 1\\n                    dic[slope] += 1\\n                m = max(m, max(dic.values()) + same)\\n        return m",
                "solutionTags": [
                    "Python"
                ],
                "code": "        def maxPoints(self, points):\\n            l = len(points)\\n            m = 0\\n            for i in range(l):\\n                dic = {'i': 1}\\n                same = 0\\n                for j in range(i+1, l):\\n                    tx, ty = points[j].x, points[j].y\\n                    if tx == points[i].x and ty == points[i].y: \\n                        same += 1\\n                        continue\\n                    if points[i].x == tx: slope = 'i'\\n                    else:slope = (points[i].y-ty) * 1.0 /(points[i].x-tx)\\n                    if slope not in dic: dic[slope] = 1\\n                    dic[slope] += 1\\n                m = max(m, max(dic.values()) + same)\\n        return m",
                "codeTag": "Python3"
            },
            {
                "id": 3017341,
                "title": "java-solution-with-explantation",
                "content": "\\n# Approach and Explantation\\n<!-- Describe your approach to solving the problem. -->\\n1. It does this by iterating through every combination of two points (i and j) in the input array of points and then checks every other point (k) to see if it is collinear with i and j.\\n\\n2. To determine if three points are collinear, the code calculates the slope between point i and point j, and then compares it to the slope between point i and point k. If the slopes are equal, then the three points are collinear.\\n\\n3. The slope between two points (x1, y1) and (x2, y2) is calculated as (y2 - y1) / (x2 - x1).Let suppose we have three points  (x1, y1),(x2, y2) and (x3, y3) and compare the two slopes then expression is written in this formet` (y2 - y1) * (x3 - x1) = (y3 - y1) * (x2 - x1) ` similarly In this code, this calculation is broken down into two separate parts: `(points[j][1] - points[i][1]) * (points[k][0] - points[i][0]) and (points[k][1] - points[i][1]) * (points[j][0] - points[i][0]).` The reason for this is to avoid a division by zero error in cases where the two points have the same x-coordinate.\\n\\n4. If the code determines that three points i, j, and k are collinear, it increments a temporary count variable temp. After checking every point k, the code compares temp to the current maximum number of collinear points found so far, ans, and updates ans if temp is larger.\\n\\n5. Finally, the code returns the maximum number of collinear points, ans.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    // This method returns the maximum number of points that lie on the same line\\n    // given a set of points represented by the 2D array points\\n    public int maxPoints(int[][] points) {\\n        // n is the number of points in the array\\n        int n = points.length;\\n        \\n        // If there are 0 or 1 points, there is at most one line that can be formed\\n        // (i.e., the line formed by the single point, or no line if there are no points)\\n        if(n <= 2) return n;\\n        \\n        // Initialize the maximum number of points on a line to 2, since there must be at least 2 points to form a line\\n        int ans = 2;\\n        \\n        // Iterate through all pairs of points\\n        for(int i = 0 ;i < n; i++){\\n            for(int j = i+1; j < n ; j++){\\n                // temp is the number of points on the line formed by point i and point j\\n                int temp = 2;\\n                // Check if any other points are on the same line as point i and point j\\n                for(int k = j+1 ; k<n ; k++ ){                   \\n                    // Check if point k is on the same line as point i and point j\\n                    // This is done by checking if the slope between point i and point k is equal to the slope between point i and point j\\n                    int x = (points[j][1] - points[i][1]) * (points[k][0] - points[i][0]);\\n                    int y = (points[k][1] - points[i][1]) * (points[j][0] - points[i][0]);\\n                    if(x == y){\\n                        // If the slopes are equal, point k is on the same line as point i and point j\\n                        temp++;\\n                    }\\n                }\\n                // Update the maximum number of points on a line if necessary\\n                if(temp > ans){\\n                    ans = temp;\\n                }\\n            }\\n        }   \\n        // Return the maximum number of points on a line\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // This method returns the maximum number of points that lie on the same line\\n    // given a set of points represented by the 2D array points\\n    public int maxPoints(int[][] points) {\\n        // n is the number of points in the array\\n        int n = points.length;\\n        \\n        // If there are 0 or 1 points, there is at most one line that can be formed\\n        // (i.e., the line formed by the single point, or no line if there are no points)\\n        if(n <= 2) return n;\\n        \\n        // Initialize the maximum number of points on a line to 2, since there must be at least 2 points to form a line\\n        int ans = 2;\\n        \\n        // Iterate through all pairs of points\\n        for(int i = 0 ;i < n; i++){\\n            for(int j = i+1; j < n ; j++){\\n                // temp is the number of points on the line formed by point i and point j\\n                int temp = 2;\\n                // Check if any other points are on the same line as point i and point j\\n                for(int k = j+1 ; k<n ; k++ ){                   \\n                    // Check if point k is on the same line as point i and point j\\n                    // This is done by checking if the slope between point i and point k is equal to the slope between point i and point j\\n                    int x = (points[j][1] - points[i][1]) * (points[k][0] - points[i][0]);\\n                    int y = (points[k][1] - points[i][1]) * (points[j][0] - points[i][0]);\\n                    if(x == y){\\n                        // If the slopes are equal, point k is on the same line as point i and point j\\n                        temp++;\\n                    }\\n                }\\n                // Update the maximum number of points on a line if necessary\\n                if(temp > ans){\\n                    ans = temp;\\n                }\\n            }\\n        }   \\n        // Return the maximum number of points on a line\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224773,
                "title": "python-easy-and-concise-with-detailed-explanation-algebra",
                "content": "```py\\n# Definition for a point.\\n# class Point(object):\\n#     def __init__(self, a=0, b=0):\\n#         self.x = a\\n#         self.y = b\\n\\nclass Solution(object):\\n\\tdef maxPoints(self, points):\\n\\t\\t\"\"\"\\n\\t\\t:type points: List[Point]\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tdef gcd(a, b):\\n\\t\\t\\treturn gcd(b % a, a) if a != 0 else b\\n\\t\\tpointsInLine = {}\\n\\t\\t# idea:\\n\\t\\t# calculate the representation of the line between all pairs of points\\n\\t\\t# add points on the same line into a set\\n\\t\\t# pointsInLine[a, b, c] = set of all indices of points lying on the line ax + by + c = 0\\n\\t\\t# using indices to handle duplicates\\n\\t\\t# return the size of the largest set\\n\\t\\tfor i in xrange(len(points)):\\n\\t\\t\\tfor j in xrange(i + 1, len(points)):\\n\\t\\t\\t\\tx1, y1, x2, y2 = points[i].x, points[i].y, points[j].x, points[j].y\\n\\t\\t\\t\\t# line: ax + by + c = 0\\n\\t\\t\\t\\tif x1 == x2:\\n\\t\\t\\t\\t\\t# equation: x = x1\\n\\t\\t\\t\\t\\ta, b, c = 1, 0, -x1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# not using usual linear equation y = kx + b\\n\\t\\t\\t\\t\\t# because of the precision problem of float\\n\\t\\t\\t\\t\\t# we need to make sure all numbers are integer\\n\\t\\t\\t\\t\\t# so use ax + by + c = 0 instead\\n\\t\\t\\t\\t\\t# value of a, b, c can be deduced from the following\\n\\t\\t\\t\\t\\t# simultaneous equations:\\n\\t\\t\\t\\t\\t# 1) ax1 + by1 + c = 0\\n\\t\\t\\t\\t\\t#    ax2 + by2 + c = 0\\n\\t\\t\\t\\t\\t# using basic algebra, we get:\\n\\t\\t\\t\\t\\t# 2) a/b = -(y2-y1)/(x2-x1), set a to y2-y1, b to x1-x2\\n\\t\\t\\t\\t\\t# substitute a and b into the previous simultaneous equations\\n\\t\\t\\t\\t\\t# we get: 3) c = x2y1-x1y2\\n\\t\\t\\t\\t\\t# To make sure the same (a, b, c) are calculated for all\\n\\t\\t\\t\\t\\t# same lines. We need to set some rules. Because values of\\n\\t\\t\\t\\t\\t# a and b are only bounded by a ratio (eq 2), and a and b\\n\\t\\t\\t\\t\\t# are picked arbitrarily.\\n\\t\\t\\t\\t\\t# first: make sure a is positive\\n\\t\\t\\t\\t\\t# \\t\\treason: -ax - by - c = 0 represents the same line\\n\\t\\t\\t\\t\\t# \\t\\t\\t\\tas ax + by + c = 0\\n\\t\\t\\t\\t\\t# second: reduce fraction of a, b and c\\n\\t\\t\\t\\t\\t# \\t\\treason: 2ax + 2by + 2c = 0 represents the same line\\n\\t\\t\\t\\t\\t# \\t\\t\\t\\tas ax + by + c = 0\\n\\t\\t\\t\\t\\ta, b, c = y2 - y1, x1 - x2, x2 * y1 - x1 * y2\\n\\t\\t\\t\\t\\t# make sure a is positive\\n\\t\\t\\t\\t\\tif a < 0:\\n\\t\\t\\t\\t\\t\\ta, b, c = -a, -b, -c\\n\\t\\t\\t\\t\\t# get gcd of a, b and c\\n\\t\\t\\t\\t\\tg = reduce(gcd, (a, b, c))\\n\\t\\t\\t\\t\\t# reduce fraction\\n\\t\\t\\t\\t\\ta, b, c = a / g, b / g, c / g\\n\\t\\t\\t\\tline = (a, b, c)\\n\\t\\t\\t\\tpointsInLine.setdefault(line, set())\\n\\t\\t\\t\\tpointsInLine[line].add(i)\\n\\t\\t\\t\\tpointsInLine[line].add(j)\\n\\t\\t# edge case: return 0 for 0 point, 1 for 1 point\\n\\t\\treturn max(map(len, pointsInLine.itervalues())) if pointsInLine else len(points)\\n```",
                "solutionTags": [],
                "code": "```py\\n# Definition for a point.\\n# class Point(object):\\n#     def __init__(self, a=0, b=0):\\n#         self.x = a\\n#         self.y = b\\n\\nclass Solution(object):\\n\\tdef maxPoints(self, points):\\n\\t\\t\"\"\"\\n\\t\\t:type points: List[Point]\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tdef gcd(a, b):\\n\\t\\t\\treturn gcd(b % a, a) if a != 0 else b\\n\\t\\tpointsInLine = {}\\n\\t\\t# idea:\\n\\t\\t# calculate the representation of the line between all pairs of points\\n\\t\\t# add points on the same line into a set\\n\\t\\t# pointsInLine[a, b, c] = set of all indices of points lying on the line ax + by + c = 0\\n\\t\\t# using indices to handle duplicates\\n\\t\\t# return the size of the largest set\\n\\t\\tfor i in xrange(len(points)):\\n\\t\\t\\tfor j in xrange(i + 1, len(points)):\\n\\t\\t\\t\\tx1, y1, x2, y2 = points[i].x, points[i].y, points[j].x, points[j].y\\n\\t\\t\\t\\t# line: ax + by + c = 0\\n\\t\\t\\t\\tif x1 == x2:\\n\\t\\t\\t\\t\\t# equation: x = x1\\n\\t\\t\\t\\t\\ta, b, c = 1, 0, -x1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# not using usual linear equation y = kx + b\\n\\t\\t\\t\\t\\t# because of the precision problem of float\\n\\t\\t\\t\\t\\t# we need to make sure all numbers are integer\\n\\t\\t\\t\\t\\t# so use ax + by + c = 0 instead\\n\\t\\t\\t\\t\\t# value of a, b, c can be deduced from the following\\n\\t\\t\\t\\t\\t# simultaneous equations:\\n\\t\\t\\t\\t\\t# 1) ax1 + by1 + c = 0\\n\\t\\t\\t\\t\\t#    ax2 + by2 + c = 0\\n\\t\\t\\t\\t\\t# using basic algebra, we get:\\n\\t\\t\\t\\t\\t# 2) a/b = -(y2-y1)/(x2-x1), set a to y2-y1, b to x1-x2\\n\\t\\t\\t\\t\\t# substitute a and b into the previous simultaneous equations\\n\\t\\t\\t\\t\\t# we get: 3) c = x2y1-x1y2\\n\\t\\t\\t\\t\\t# To make sure the same (a, b, c) are calculated for all\\n\\t\\t\\t\\t\\t# same lines. We need to set some rules. Because values of\\n\\t\\t\\t\\t\\t# a and b are only bounded by a ratio (eq 2), and a and b\\n\\t\\t\\t\\t\\t# are picked arbitrarily.\\n\\t\\t\\t\\t\\t# first: make sure a is positive\\n\\t\\t\\t\\t\\t# \\t\\treason: -ax - by - c = 0 represents the same line\\n\\t\\t\\t\\t\\t# \\t\\t\\t\\tas ax + by + c = 0\\n\\t\\t\\t\\t\\t# second: reduce fraction of a, b and c\\n\\t\\t\\t\\t\\t# \\t\\treason: 2ax + 2by + 2c = 0 represents the same line\\n\\t\\t\\t\\t\\t# \\t\\t\\t\\tas ax + by + c = 0\\n\\t\\t\\t\\t\\ta, b, c = y2 - y1, x1 - x2, x2 * y1 - x1 * y2\\n\\t\\t\\t\\t\\t# make sure a is positive\\n\\t\\t\\t\\t\\tif a < 0:\\n\\t\\t\\t\\t\\t\\ta, b, c = -a, -b, -c\\n\\t\\t\\t\\t\\t# get gcd of a, b and c\\n\\t\\t\\t\\t\\tg = reduce(gcd, (a, b, c))\\n\\t\\t\\t\\t\\t# reduce fraction\\n\\t\\t\\t\\t\\ta, b, c = a / g, b / g, c / g\\n\\t\\t\\t\\tline = (a, b, c)\\n\\t\\t\\t\\tpointsInLine.setdefault(line, set())\\n\\t\\t\\t\\tpointsInLine[line].add(i)\\n\\t\\t\\t\\tpointsInLine[line].add(j)\\n\\t\\t# edge case: return 0 for 0 point, 1 for 1 point\\n\\t\\treturn max(map(len, pointsInLine.itervalues())) if pointsInLine else len(points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739295,
                "title": "simple-c-solution-2-approaches-brute-force-as-well-using-using-hashmap-16ms",
                "content": "**1.Brute force Approach:**\\nTime complexity : O(n^3)\\n**Runtime : 8ms**\\n![image](https://assets.leetcode.com/users/images/c46f254a-0f64-4e91-9245-22db6b75dd2a_1643805387.9644039.png)\\n\\n```\\nclass Solution{\\npublic :\\n    \\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2) return points.size();\\n        int res=0;\\n        int n=points.size();\\n        for(int i=0;i<n;i++){\\n\\n            for(int j=i+1;j<n;j++){\\n\\n                int x1 = points[i][0];\\n                int x2 = points[j][0];\\n                int y1 = points[i][1];\\n                int y2 = points[j][1];    \\n\\n                // double slope = double(y2 - y1)/double(x2 - x1);\\n                int total=2;\\n                for(int k=0;k<n && k!=i && k!=j;k++){\\n                    \\n                    int x = points[k][0];\\n                    int y = points[k][1];\\n                    // third point\\n                    // double(y - y1)/double(x1 - x1)\\n                    if((y2 - y1)*(x - x1) == (x2 - x1)*(y - y1))\\n                        total++;\\n                }\\n                res = max(res, total);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**2. using hashmap**\\nTime Complexity : O(n^2)\\n**Runtime : 20ms**\\n![image](https://assets.leetcode.com/users/images/1caabcb8-c0cc-4f16-8ce9-d4c778e1749d_1643805452.3230746.png)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // According to constraint we are allowed with maximum time complexity of O(n^3)\\n    // 1 <= points.length <= 300\\n    ///////   All the points are unique.\\n    int maxPoints(vector<vector<int>>& points) {\\n        \\n        if(points.size()<=2) return points.size(); // only two points are always on the same line, beacuse using 2 points\\n                                                    // line is made\\n        int res = 0;\\n        for(int i = 0; i < points.size(); i++)\\n        {\\n            unordered_map<double, int> mp;\\n            int duplicate = 0;\\n            double slope = 0.0;\\n            for(int j = 0; j < points.size(); j++)\\n            {\\n                int x1 = points[i][0];\\n                int x2 = points[j][0];\\n                int y1 = points[i][1];\\n                int y2 = points[j][1];    \\n                \\n                // slope = dy/dx.\\n                int dy = y2 - y1;\\n                int dx = x2 - x1;\\n                if(dy == 0 && dx == 0){  // same overlapping point --> consider 2 same point as single point\\n                    duplicate++; \\n                    continue;\\n                }\\n                \\n                if(dx != 0)\\n                    slope = dy*1.0/dx; // store in double\\n                else // dx==0 means slope is infinity\\n                    slope = INT_MAX;\\n                \\n                mp[slope]++;\\n            }\\n\\n            if(mp.size() == 0)\\n                res = duplicate;\\n            else\\n            {\\n                for(auto slope : mp){\\n                    \\n                    res = max(res, slope.second + duplicate);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**if you like my approach please don\\'t forget to hit upvote button ! : )**\\n\\uD83D\\uDE07\\uD83D\\uDE07\\uD83D\\uDE07",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution{\\npublic :\\n    \\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2) return points.size();\\n        int res=0;\\n        int n=points.size();\\n        for(int i=0;i<n;i++){\\n\\n            for(int j=i+1;j<n;j++){\\n\\n                int x1 = points[i][0];\\n                int x2 = points[j][0];\\n                int y1 = points[i][1];\\n                int y2 = points[j][1];    \\n\\n                // double slope = double(y2 - y1)/double(x2 - x1);\\n                int total=2;\\n                for(int k=0;k<n && k!=i && k!=j;k++){\\n                    \\n                    int x = points[k][0];\\n                    int y = points[k][1];\\n                    // third point\\n                    // double(y - y1)/double(x1 - x1)\\n                    if((y2 - y1)*(x - x1) == (x2 - x1)*(y - y1))\\n                        total++;\\n                }\\n                res = max(res, total);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // According to constraint we are allowed with maximum time complexity of O(n^3)\\n    // 1 <= points.length <= 300\\n    ///////   All the points are unique.\\n    int maxPoints(vector<vector<int>>& points) {\\n        \\n        if(points.size()<=2) return points.size(); // only two points are always on the same line, beacuse using 2 points\\n                                                    // line is made\\n        int res = 0;\\n        for(int i = 0; i < points.size(); i++)\\n        {\\n            unordered_map<double, int> mp;\\n            int duplicate = 0;\\n            double slope = 0.0;\\n            for(int j = 0; j < points.size(); j++)\\n            {\\n                int x1 = points[i][0];\\n                int x2 = points[j][0];\\n                int y1 = points[i][1];\\n                int y2 = points[j][1];    \\n                \\n                // slope = dy/dx.\\n                int dy = y2 - y1;\\n                int dx = x2 - x1;\\n                if(dy == 0 && dx == 0){  // same overlapping point --> consider 2 same point as single point\\n                    duplicate++; \\n                    continue;\\n                }\\n                \\n                if(dx != 0)\\n                    slope = dy*1.0/dx; // store in double\\n                else // dx==0 means slope is infinity\\n                    slope = INT_MAX;\\n                \\n                mp[slope]++;\\n            }\\n\\n            if(mp.size() == 0)\\n                res = duplicate;\\n            else\\n            {\\n                for(auto slope : mp){\\n                    \\n                    res = max(res, slope.second + duplicate);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47102,
                "title": "20-line-c-o-n-2-hashing-solution",
                "content": "The idea is straight forward. Calculate each slope between two points and handle two special cases: 1. vertical, 2. duplicate. \\n\\n\\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point>& points) \\n        {\\n            if(points.size()<=2) return points.size();\\n            int res=0;\\n            for(int i=0;i<points.size()-1;i++) {\\n                int numVertical=1,local=1,duplicate=0;\\n                unordered_map<double,int> map;\\n                for(int j=i+1;j<points.size();j++) \\n                    if(points[i].x==points[j].x) // special cases\\n                        if(points[i].y==points[j].y) // duplicate \\n                            duplicate++;\\n                        else // vertical\\n                            numVertical++;\\n                    else {\\n                        double slope=(points[i].y-points[j].y)*1.0/(points[i].x-points[j].x);\\n                        map[slope]==0?map[slope]=2:map[slope]++;\\n                        local=max(local,map[slope]);\\n                    }\\n                local=max(local+duplicate,numVertical+duplicate);\\n                res=max(res,local);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point>& points) \\n        {\\n            if(points.size()<=2) return points.size();\\n            int res=0;\\n            for(int i=0;i<points.size()-1;i++) {\\n                int numVertical=1,local=1,duplicate=0;\\n                unordered_map<double,int> map;\\n                for(int j=i+1;j<points.size();j++) \\n                    if(points[i].x==points[j].x) // special cases\\n                        if(points[i].y==points[j].y) // duplicate \\n                            duplicate++;\\n                        else // vertical\\n                            numVertical++;\\n                    else {\\n                        double slope=(points[i].y-points[j].y)*1.0/(points[i].x-points[j].x);\\n                        map[slope]==0?map[slope]=2:map[slope]++;\\n                        local=max(local,map[slope]);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 494635,
                "title": "come-on-in-correct-and-natural-solution-in-java",
                "content": "**Logic**\\nFor this problem, we can iterate each one of the points, scan the rest points after it, and find the number of points in the same line with that point. We update the global maximum one through the process.\\n\\nFor each point, there can be **unlimited lines** starting from it. So we need to a `Map` structure to keep track of each line and the number of points on it. **How to describe each line then?** It is the **slope**. **How to represent slope?** It is **`dy / dx`**, delta of `y` coordinate devided by delta of `x` coordinate. **How to store slope?** Possible optioanls are:\\n- `double slope` \\u274C\\n- `BigDecimal slope` \\u274C\\n- `int[] slope = new int[2];` \\u274C\\n- `List<Integer> slope = new List<>();` \\u2705\\n- `String slope` \\u2705\\uD83D\\uDC4D\\n\\n\\n`double` can be an option, but this is not gonna work actually \\u274C. Using decimal points causes 2 issues:\\n1. `/ by zero`. When `dx = 0`, the slope is `dy / 0` which will cause `java.lang.ArithmeticException: / by zero` in Java\\n2. Precision issue. We cannot compare the 2 slopes whose value are extreme close because `decimal` number in programming language can only have limited digits to represent fraction part. Java for example:\\n\\t> The `double` data type is a double-precision 64-bit IEEE 754 floating point.(From https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html),  A double variable can provide precision up to **15 to 16 decimal points** as compared to float precision of **6 to 7 decimal digits**. \\n\\t\\n\\tIf we look the following extreme example, the first 15 decimal points are exactly the same but the slope are not the same even really close.\\n\\n\\t```\\n\\t[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\t94911151 / 94911150 = 1.000000010536169  8809886931092922\\n\\t94911152 / 94911151 = 1.000000010536169  7699778185178684\\n\\t\\t\\t\\t\\t\\t    first 15 digits \\n\\t```\\n\\n`BigDecimal` will still have the same issue. \\u274C\\n\\n`int[] slope = new int[2]`: i.e. `Map<int[], Integer> map = new HashMap<>()`. But `int[]` actually **cannot** be the key of hashMap, bbecause hashCode() and equals() methods are not overriden. Its members only have `length` field and `clone()` method(referred from https://docs.oracle.com/javase/specs/jls/se7/html/jls-10.html#jls-10.7) \\u274C\\n\\n`List<Integer>`: i.e. `Map<List<Integer>, Integer> = new HashMap<>()`, it works compared with `int[]` as the key, since hashCode is element-wise for list. Check official document [here](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/List.html#hashCode%28%29). However, set an mutable data type as the key is really **a bad idea**, because if it is modified after insertion, it will result in undefined behavior in the `Map`. (However, even it is not recommended, it can still work) \\u2705\\n\\n`String`: `Map<String, Integer> = new HashMap<>()`, it is immutable compared to `List<Integer>`, so `String` should the best option. \\u2705\\uD83D\\uDC4D\\n\\n---\\nFor the `List<Integer>` and `String` options, we need to think about **Fraction Number**\\nAbove 2 options can be seen that we are using the fraction number form to represent the slope, **`numerator / denominator`**. To group the points together with same slope together, we need to store the fraction number `dy / dx` to its **the simplest form**(think about `2/4` and `3/6`). This can be done by deviding the numerator and denominator by their **greatest common devisor(gcd)**. GCD can be donw using **Euclidean algorithm**, it is nothing but a simple recursion method(remember to reverse the parameters!)\\n```java\\npublic int gcd(int num1, int num2){\\n    if(num1 == 0) return num1;\\n    return gcd(num2, num1 % num2);\\n}\\n```\\n\\n---\\n**Code**: `List<Integer>` as slope\\n```java\\nclass Solution {\\n    public int maxPoints(Point[] points) {\\n        // corner case\\n        if(points == null || points.length == 0) return 0;\\n        \\n        // key: slope<dy, dx>, value: freq\\n        Map<List<Integer>, Integer> map = new HashMap<>();\\n        int res = 0;\\n        \\n        int m = points.length;\\n        for(int i = 0; i < m; i++){\\n            int sameCount = 0;\\n            int max = 0;\\n            for(int j = i + 1; j < m; j++){\\n                int dy = points[j].y - points[i].y;\\n                int dx = points[j].x - points[i].x;\\n                if(dx == 0 && dy == 0){\\n                    sameCount++;\\n                }else{\\n                    List<Integer> slope = getSlope(dy, dx);\\n                    map.put(slope, map.getOrDefault(slope, 0) + 1);\\n                    max = Math.max(max, map.get(slope));\\n                }\\n            }\\n            res = Math.max(res, sameCount + max + 1);\\n            map.clear();\\n        }\\n        \\n        return res;\\n    }\\n    \\n\\t// return the irreducible slope by reducing dy and dx\\n    public List<Integer> getSlope(int dy, int dx){\\n        if(dx == 0) return Arrays.asList(1, 0);\\n        if(dy == 0) return Arrays.asList(0, 1);\\n        \\n        int d = gcd(dy, dx);\\n        return Arrays.asList(dy/d, dx/d);\\n    }\\n    \\n\\t// return the most common divisor of m and n using Euclidean algorithm\\n    public int gcd(int m, int n){\\n        if(n == 0) return m;\\n        return gcd(n, m % n);\\n    }\\n}\\n```\\n\\n---\\n**Code** with `String` as slope\\n**Updated:** Added code with more comment\\n```java\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points == null || points.length == 0 || points[0].length == 0) return 0;\\n        \\n        int res = 1;\\n        int n = points.length;\\n        \\n        // For this problem, we can iterate each one of the points, we scan the rest points, and find \\n\\t\\t// the number of points in the same line with that point\\n        for(int i = 0; i < n - 1; i++) {\\n            // because there can be unlimited lines starting from a single point we need a map to keep \\n\\t\\t\\t// track of the number points in different lines\\n            Map<String, Integer> slopeCountMap = new HashMap<>(); // <slope, count>\\n            // we are not using double to represent slope, because of the precision issue, and if the 2 \\n\\t\\t\\t// points have same x coordinates, then we will be deviding a number by 0 because the \\n\\t\\t\\t// denominator will be 0. \\n            \\n            // Fractions consist of two numbers: a numerator (which is above the line) and a denominator (which is below the line).\\n            \\n            // so instead we will use fraction to represent slope, and to help identify the same slope, \\n            // we will store fraction in simplest form in the map.\\n            \\n            // To find the slope in fraction in simplest form, we need to find the greatest common divisor, \\n            // short as gcd. And divide the numberator and denominator by gcd\\n            \\n            // we will iterate the points after this point\\n            for(int j = i + 1; j  < n; j++) {\\n                String slope = getSlope(points[i], points[j]);\\n                slopeCountMap.put(slope, slopeCountMap.getOrDefault(slope, 0) + 1);\\n                res = Math.max(res, slopeCountMap.get(slope) + 1);\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n        \\n    public String getSlope(int[] point1, int[] point2) {\\n        int dx = point1[0] - point2[0];\\n        int dy = point1[1] - point2[1];\\n\\n        // The greatest common divisor (GCD) of two nonzero integers a and b is the greatest positive \\n        // integer d such that d is a divisor of both a and b; \\n        if(dx == 0 && dy == 0) return \"0/0\";\\n        if(dx == 0 && dy != 0) return \"1/0\";\\n        if(dx != 0 && dy == 0) return \"0/1\";\\n\\n        int gcd = getGCD(dx, dy);\\n        // we do not need to care abour the sign, because the gcd is already the same sign as \\n        // denominator, so the denominator is already positive. So the slope will be the same\\n        dx /= gcd;\\n        dy /= gcd;\\n        \\n        return dx + \"/\" + dy;\\n    }\\n\\n    public int getGCD(int num1, int num2) {\\n        if(num2 == 0) return num1;\\n\\n        return getGCD(num2, num1 % num2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\t94911151 / 94911150 = 1.000000010536169  8809886931092922\\n\\t94911152 / 94911151 = 1.000000010536169  7699778185178684\\n\\t\\t\\t\\t\\t\\t    first 15 digits \\n\\t```\n```java\\npublic int gcd(int num1, int num2){\\n    if(num1 == 0) return num1;\\n    return gcd(num2, num1 % num2);\\n}\\n```\n```java\\nclass Solution {\\n    public int maxPoints(Point[] points) {\\n        // corner case\\n        if(points == null || points.length == 0) return 0;\\n        \\n        // key: slope<dy, dx>, value: freq\\n        Map<List<Integer>, Integer> map = new HashMap<>();\\n        int res = 0;\\n        \\n        int m = points.length;\\n        for(int i = 0; i < m; i++){\\n            int sameCount = 0;\\n            int max = 0;\\n            for(int j = i + 1; j < m; j++){\\n                int dy = points[j].y - points[i].y;\\n                int dx = points[j].x - points[i].x;\\n                if(dx == 0 && dy == 0){\\n                    sameCount++;\\n                }else{\\n                    List<Integer> slope = getSlope(dy, dx);\\n                    map.put(slope, map.getOrDefault(slope, 0) + 1);\\n                    max = Math.max(max, map.get(slope));\\n                }\\n            }\\n            res = Math.max(res, sameCount + max + 1);\\n            map.clear();\\n        }\\n        \\n        return res;\\n    }\\n    \\n\\t// return the irreducible slope by reducing dy and dx\\n    public List<Integer> getSlope(int dy, int dx){\\n        if(dx == 0) return Arrays.asList(1, 0);\\n        if(dy == 0) return Arrays.asList(0, 1);\\n        \\n        int d = gcd(dy, dx);\\n        return Arrays.asList(dy/d, dx/d);\\n    }\\n    \\n\\t// return the most common divisor of m and n using Euclidean algorithm\\n    public int gcd(int m, int n){\\n        if(n == 0) return m;\\n        return gcd(n, m % n);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points == null || points.length == 0 || points[0].length == 0) return 0;\\n        \\n        int res = 1;\\n        int n = points.length;\\n        \\n        // For this problem, we can iterate each one of the points, we scan the rest points, and find \\n\\t\\t// the number of points in the same line with that point\\n        for(int i = 0; i < n - 1; i++) {\\n            // because there can be unlimited lines starting from a single point we need a map to keep \\n\\t\\t\\t// track of the number points in different lines\\n            Map<String, Integer> slopeCountMap = new HashMap<>(); // <slope, count>\\n            // we are not using double to represent slope, because of the precision issue, and if the 2 \\n\\t\\t\\t// points have same x coordinates, then we will be deviding a number by 0 because the \\n\\t\\t\\t// denominator will be 0. \\n            \\n            // Fractions consist of two numbers: a numerator (which is above the line) and a denominator (which is below the line).\\n            \\n            // so instead we will use fraction to represent slope, and to help identify the same slope, \\n            // we will store fraction in simplest form in the map.\\n            \\n            // To find the slope in fraction in simplest form, we need to find the greatest common divisor, \\n            // short as gcd. And divide the numberator and denominator by gcd\\n            \\n            // we will iterate the points after this point\\n            for(int j = i + 1; j  < n; j++) {\\n                String slope = getSlope(points[i], points[j]);\\n                slopeCountMap.put(slope, slopeCountMap.getOrDefault(slope, 0) + 1);\\n                res = Math.max(res, slopeCountMap.get(slope) + 1);\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n        \\n    public String getSlope(int[] point1, int[] point2) {\\n        int dx = point1[0] - point2[0];\\n        int dy = point1[1] - point2[1];\\n\\n        // The greatest common divisor (GCD) of two nonzero integers a and b is the greatest positive \\n        // integer d such that d is a divisor of both a and b; \\n        if(dx == 0 && dy == 0) return \"0/0\";\\n        if(dx == 0 && dy != 0) return \"1/0\";\\n        if(dx != 0 && dy == 0) return \"0/1\";\\n\\n        int gcd = getGCD(dx, dy);\\n        // we do not need to care abour the sign, because the gcd is already the same sign as \\n        // denominator, so the denominator is already positive. So the slope will be the same\\n        dx /= gcd;\\n        dy /= gcd;\\n        \\n        return dx + \"/\" + dy;\\n    }\\n\\n    public int getGCD(int num1, int num2) {\\n        if(num2 == 0) return num1;\\n\\n        return getGCD(num2, num1 % num2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47268,
                "title": "two-concise-python-solutions",
                "content": "The first solution uses slope directly as the key for the dictionary. Python can handle it. The second solution uses a tuple of integer (dx, dy) as the key.\\n\\nSolution 1:\\n\\n    def maxPoints(self, points):\\n        if len(points) <= 2: return len(points)\\n        d = collections.defaultdict(int) # slope : count\\n        result = 0\\n        for i in range(len(points)):\\n            d.clear()\\n            overlap, curmax = 0, 0\\n            for j in range(i+1, len(points)):\\n                dx, dy = points[j].x - points[i].x, points[j].y - points[i].y\\n                if dx == 0 and dy == 0:\\n                    overlap += 1\\n                    continue\\n                slope = dy * 1.0 / dx if dx != 0 else 'infinity'\\n                d[slope] += 1\\n                curmax = max(curmax, d[slope])\\n            result = max(result, curmax+overlap+1)\\n        return result\\n\\n\\nSolution 2:\\n\\n    def maxPoints(self, points):\\n        if len(points) <= 2: return len(points)\\n        d = collections.defaultdict(int) # (x,y) : count\\n        result = 0\\n        for i in range(len(points)):\\n            d.clear()\\n            overlap = 0\\n            curmax = 0\\n            for j in range(i+1, len(points)):\\n                dx = points[j].x - points[i].x\\n                dy = points[j].y - points[i].y\\n                if dx == 0 and dy == 0:\\n                    overlap += 1\\n                    continue\\n                gcd = self.getGcd(dx, dy)\\n                dx //= gcd\\n                dy //= gcd\\n                d[(dx,dy)] += 1\\n                curmax = max(curmax, d[(dx,dy)])\\n            result = max(result, curmax+overlap+1)\\n        return result\\n    \\n    def getGcd(self, a, b):\\n        if b == 0: return a\\n        return self.getGcd(b, a%b)",
                "solutionTags": [],
                "code": "The first solution uses slope directly as the key for the dictionary. Python can handle it. The second solution uses a tuple of integer (dx, dy) as the key.\\n\\nSolution 1:\\n\\n    def maxPoints(self, points):\\n        if len(points) <= 2: return len(points)\\n        d = collections.defaultdict(int) # slope : count\\n        result = 0\\n        for i in range(len(points)):\\n            d.clear()\\n            overlap, curmax = 0, 0\\n            for j in range(i+1, len(points)):\\n                dx, dy = points[j].x - points[i].x, points[j].y - points[i].y\\n                if dx == 0 and dy == 0:\\n                    overlap += 1\\n                    continue\\n                slope = dy * 1.0 / dx if dx != 0 else 'infinity'\\n                d[slope] += 1\\n                curmax = max(curmax, d[slope])\\n            result = max(result, curmax+overlap+1)\\n        return result\\n\\n\\nSolution 2:\\n\\n    def maxPoints(self, points):\\n        if len(points) <= 2: return len(points)\\n        d = collections.defaultdict(int) # (x,y) : count\\n        result = 0\\n        for i in range(len(points)):\\n            d.clear()\\n            overlap = 0\\n            curmax = 0\\n            for j in range(i+1, len(points)):\\n                dx = points[j].x - points[i].x\\n                dy = points[j].y - points[i].y\\n                if dx == 0 and dy == 0:\\n                    overlap += 1\\n                    continue\\n                gcd = self.getGcd(dx, dy)\\n                dx //= gcd\\n                dy //= gcd\\n                d[(dx,dy)] += 1\\n                curmax = max(curmax, d[(dx,dy)])\\n            result = max(result, curmax+overlap+1)\\n        return result\\n    \\n    def getGcd(self, a, b):\\n        if b == 0: return a\\n        return self.getGcd(b, a%b)",
                "codeTag": "Python3"
            },
            {
                "id": 3016632,
                "title": "python-3-11-lines-w-explanation-and-example-t-m-95-97",
                "content": "Here\\'s the plan:\\n- We compute `dx` and `dy`, the changes of`x`and`y`,respectively, for each pair in`points`.\\n- We keep track of the slopes of each line segment formed by such a pair. Instead of computing the ratio`dy/dx`, we divide each quantity by their common gcd (much like reducing a fraction) and express the slope as a tuple`(dx,dy)`.\\n- We count the line segments with the dict `slope`, using their tuples as the key. The endpoints of any two or more line segments with the same key are on the same line, and the number of points on the line is one greater than the number of line segments.\\n```\\nclass Solution:\\n    def maxPoints(self, points: list[list[int]]) -> int:\\n                                                #   points = [[1,0],[2,1],[3,4], [5,4]]\\n\\n        points.sort()                           #   point1 point2 (dx,dy)    m     slope                M\\n        slope, M = defaultdict(int), 0          #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                #   [1,0]  [2,1]   (1,1)   (1,1)   {(1,1):1}            1\\n        for i, (x1, y1) in enumerate(points):   #          [3,4]   (2,4)   (1,2)   {(1,1):1,(1,2):1}    1\\n                                                #          [5,4]   (4,4)   (1,1)   {(1,1):2,(1,2):1}    2\\n            slope.clear()                       #   [2,1]  [3,4]   (1,3)   (1,3)   {(1,3):1}            2\\n                                                #          [5,4]   (3,3)   (1,1)   {(1,3):1,(1,1):1}    2\\n            for x2, y2 in points[i + 1:]:       #   [3,4]  [5,4]   (3,0)   (1,0)   {(1,0):1}            2\\n                dx, dy = x2 - x1, y2 - y1\\n                                                #  M + 1 = 2 + 1 = 3 <-- return\\n                G = gcd(dx, dy)                 \\n                m = (dx//G,dy//G)\\n                \\n                slope[m] += 1\\n                if slope[m] > M: M = slope[m]\\n    \\n        return M + 1\\n\\n```\\n[https://leetcode.com/problems/max-points-on-a-line/submissions/873726776/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: list[list[int]]) -> int:\\n                                                #   points = [[1,0],[2,1],[3,4], [5,4]]\\n\\n        points.sort()                           #   point1 point2 (dx,dy)    m     slope                M\\n        slope, M = defaultdict(int), 0          #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                #   [1,0]  [2,1]   (1,1)   (1,1)   {(1,1):1}            1\\n        for i, (x1, y1) in enumerate(points):   #          [3,4]   (2,4)   (1,2)   {(1,1):1,(1,2):1}    1\\n                                                #          [5,4]   (4,4)   (1,1)   {(1,1):2,(1,2):1}    2\\n            slope.clear()                       #   [2,1]  [3,4]   (1,3)   (1,3)   {(1,3):1}            2\\n                                                #          [5,4]   (3,3)   (1,1)   {(1,3):1,(1,1):1}    2\\n            for x2, y2 in points[i + 1:]:       #   [3,4]  [5,4]   (3,0)   (1,0)   {(1,0):1}            2\\n                dx, dy = x2 - x1, y2 - y1\\n                                                #  M + 1 = 2 + 1 = 3 <-- return\\n                G = gcd(dx, dy)                 \\n                m = (dx//G,dy//G)\\n                \\n                slope[m] += 1\\n                if slope[m] > M: M = slope[m]\\n    \\n        return M + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018587,
                "title": "explanation-with-simulation-images-from-high-school-to-leetcode-easy-geometry",
                "content": "# Simulation and Understanding:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSuppose, we have input = [[1, 1], [2, 2], [3, 3]]. We need to find the maximum number of points that are on a line. If you have some idea of the slope of tangent, you will catch that this must be done using the slope of tangent method. All points on a line have the same slope. Therefore, the tangent will be equal.\\n\\n![image.png](https://assets.leetcode.com/users/images/b28fedc7-7854-42ab-be4b-519f26fb78ab_1673167992.4192362.png)\\n\\n\\n- Behind the Scene Geometry: \\n\\n![image.png](https://assets.leetcode.com/users/images/ce44647b-5a6e-4cee-8c28-03b1fc65bd6e_1673168043.211971.png)\\n\\nTo calcualte the tangent of single point, we need another reference point. \\nIn the above case, $$[0, 0]$$ is our reference point. Using the above formula we can calculate the tangent of point $$[1, 1]$$.\\n\\n## Let\\'s get into the understanding with simulation:\\n\\n### Approach: \\n\\n- For each point, we will calculate the tangent with other points. \\n- We will store them into a tangent map.\\n- After it is done, we will calculate the max points that have the same tangent from the `tangentMap`.\\n- Finally, return the `max`.\\n\\nSo, for point $$[1, 1]$$ our simulation will look like this:\\n\\n![image.png](https://assets.leetcode.com/users/images/d606a478-2916-4d7f-8596-090f2e7d8f3e_1673168181.3943129.png)\\n\\n\\nWe can see that points $$[2,2]$$ and $$[3,3]$$ have the same tangent with point $$[1,1]$$. So, all these 3 points (including point $$[1,1]$$ itself) are on the same line.\\n\\nSimilarly, we will iterate the loop using point $$[2, 2]$$ and so on.\\n\\n\\n\\n# Complexity:\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we have used nested **for** loops. It will require $$n^2$$ time.\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we have used a hashMap and it\\'s size depends on the length of the points array, in worst case, we will need a hashmap of size $$n$$. So, the space complexity is $$O(n)$$.\\n\\n# Code:\\nSimilar in other languages. Just change of some syntax.\\n``` java []\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n = points.length;\\n        // if there is only one point, the max points will be 1\\n        if( n == 1) return 1;\\n        // if there are more points, the max will be at least 2\\n        int max = 2;\\n        for(int i=0; i<n-1; i++){\\n            Map<Double, Integer> tangentMap = new HashMap<>();\\n            for(int j=0; j<n; j++){\\n                if(i == j)\\n                    continue;\\n                \\n                int[] p1 = points[i];\\n                int[] p2 = points[j];\\n                int x1 = p1[0];\\n                int y1 = p1[1];\\n                int x2 = p2[0];\\n                int y2 = p2[1];\\n                \\n                // calculate the tangent..\\n                double tangent = Math.atan2((y2-y1),(x2-x1));\\n                int c = tangentMap.getOrDefault(tangent, 0);\\n                // increase the count..\\n                tangentMap.put(tangent, c+1);\\n            }\\n\\n            // calculate the max points from the tangentMap.\\n            // To include the point points[i] itself \\n            // we added +1 to the values\\n            max = Math.max(max, Collections.max(tangentMap.values())+1);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        // if there is only one point, the max points will be 1\\n        if( n == 1) return 1;\\n        // if there are more points, the max will be at least 2\\n        int maxAns = 2;\\n        for(int i=0; i<n-1; i++){\\n            map<double, int> tangentMap;\\n            for(int j=0; j<n; j++){\\n                if(i == j)\\n                    continue;\\n                \\n                int x1 = points[i][0];\\n                int y1 = points[i][1];\\n                int x2 = points[j][0];\\n                int y2 = points[j][1];\\n                \\n                // calculate the tangent..\\n                double tangent = atan2((y2-y1),(x2-x1));\\n                // increase the count..\\n                tangentMap[tangent]++;\\n                // calculate the max points from the tangentMap.\\n                // To include the point points[i] itself \\n                // we added +1 to the values\\n                maxAns = max(maxAns, tangentMap[tangent]+1);\\n            }\\n        }\\n        \\n        return maxAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n = points.length;\\n        // if there is only one point, the max points will be 1\\n        if( n == 1) return 1;\\n        // if there are more points, the max will be at least 2\\n        int max = 2;\\n        for(int i=0; i<n-1; i++){\\n            Map<Double, Integer> tangentMap = new HashMap<>();\\n            for(int j=0; j<n; j++){\\n                if(i == j)\\n                    continue;\\n                \\n                int[] p1 = points[i];\\n                int[] p2 = points[j];\\n                int x1 = p1[0];\\n                int y1 = p1[1];\\n                int x2 = p2[0];\\n                int y2 = p2[1];\\n                \\n                // calculate the tangent..\\n                double tangent = Math.atan2((y2-y1),(x2-x1));\\n                int c = tangentMap.getOrDefault(tangent, 0);\\n                // increase the count..\\n                tangentMap.put(tangent, c+1);\\n            }\\n\\n            // calculate the max points from the tangentMap.\\n            // To include the point points[i] itself \\n            // we added +1 to the values\\n            max = Math.max(max, Collections.max(tangentMap.values())+1);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        // if there is only one point, the max points will be 1\\n        if( n == 1) return 1;\\n        // if there are more points, the max will be at least 2\\n        int maxAns = 2;\\n        for(int i=0; i<n-1; i++){\\n            map<double, int> tangentMap;\\n            for(int j=0; j<n; j++){\\n                if(i == j)\\n                    continue;\\n                \\n                int x1 = points[i][0];\\n                int y1 = points[i][1];\\n                int x2 = points[j][0];\\n                int y2 = points[j][1];\\n                \\n                // calculate the tangent..\\n                double tangent = atan2((y2-y1),(x2-x1));\\n                // increase the count..\\n                tangentMap[tangent]++;\\n                // calculate the max points from the tangentMap.\\n                // To include the point points[i] itself \\n                // we added +1 to the values\\n                maxAns = max(maxAns, tangentMap[tangent]+1);\\n            }\\n        }\\n        \\n        return maxAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019363,
                "title": "my-accepted-solution-98-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n      public int maxPoints(int[][] arr) {\\n        int max = 1;\\n        for (int i = 0; i < arr.length; i++) {\\n            HashMap<Double, Integer> map = new HashMap<>();\\n            for (int j = 0; j < arr.length; j++) {\\n                if (i == j) continue;\\n                double slope = (arr[j][0] - arr[i][0]) != 0 ? (arr[j][1] - arr[i][1]) * 1.0 / (arr[j][0] - arr[i][0]) : Integer.MAX_VALUE;\\n                map.put(slope, map.getOrDefault(slope, 1) + 1);\\n                max = Math.max(max, map.get(slope));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      public int maxPoints(int[][] arr) {\\n        int max = 1;\\n        for (int i = 0; i < arr.length; i++) {\\n            HashMap<Double, Integer> map = new HashMap<>();\\n            for (int j = 0; j < arr.length; j++) {\\n                if (i == j) continue;\\n                double slope = (arr[j][0] - arr[i][0]) != 0 ? (arr[j][1] - arr[i][1]) * 1.0 / (arr[j][0] - arr[i][0]) : Integer.MAX_VALUE;\\n                map.put(slope, map.getOrDefault(slope, 1) + 1);\\n                max = Math.max(max, map.get(slope));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47330,
                "title": "does-anyone-use-the-idea-of-hough-transform-o-n",
                "content": "When I first read the question, the idea of \"hough transform\" pops out. I wrote my solution using this idea, but I get a TLE. As you may see, the complexity of Hough transform is only O(180N), which is much lower than those O(N^2) solutions in this discussion board.\\n\\nI expected to see a \"wrong answer\" error, because \"hough transform\" has the parameter theta ( in polar coordinates ): you may have to sample the entire theta space and thus get an approximate result instead of an accurate one. Anyway, I guess some of you might be interested in knowing this classic pattern recognition algorithm. \\n\\n\\n    #define computeRho( pt, T ) ( ( pt.x * cos( T ) ) + ( pt.y * sin( T ) ) ) \\n\\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            if ( points.size() <= 2 ) {\\n                return points.size();\\n            }\\n            int max_points = 0;\\n            for ( int i = 0; i < 180; i++ ) {\\n                double theta = double( i ) / 180.0 * 3.141592657;\\n                map<int,int> accumulator;\\n                for ( int j = 0; j < points.size(); j++ ) {\\n                    int rho = round( computeRho( points[j], theta ) );\\n                    accumulator[ rho ]++;\\n                    if ( accumulator[ rho ] > max_points ) {\\n                        max_points = accumulator[ rho ];\\n                    }\\n                }\\n            }\\n            return max_points;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            if ( points.size() <= 2 ) {\\n                return points.size();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3016367,
                "title": "c-hashmap-slope-faster-easy-to-understand",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // take every point and find the slope with other points\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // declare a map which will store the frequency of each slope\\n            \\n            unordered_map<double, int> mp;\\n            \\n            int temp_max = 0;\\n            \\n            int x1 = arr[i][0];\\n            \\n            int y1 = arr[i][1];\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(j == i)\\n                {\\n                    continue;\\n                }\\n                \\n                int x2 = arr[j][0];\\n                \\n                int y2 = arr[j][1];\\n                \\n                double nume = y2 - y1;\\n                \\n                double deno = x2 - x1;\\n                \\n                // if denominator will be zero then slope will be INT_MAX\\n                \\n                if(deno == 0)\\n                {\\n                    mp[INT_MAX]++;\\n                    \\n                    // update temp_max\\n                    \\n                    temp_max = max(temp_max, mp[INT_MAX]);\\n                    \\n                    continue;\\n                }\\n                \\n                // find the slope and update frequency\\n                \\n                double slope = nume / deno;\\n                \\n                mp[slope]++;\\n                \\n                temp_max = max(temp_max, mp[slope]);\\n            }\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, temp_max + 1);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // take every point and find the slope with other points\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // declare a map which will store the frequency of each slope\\n            \\n            unordered_map<double, int> mp;\\n            \\n            int temp_max = 0;\\n            \\n            int x1 = arr[i][0];\\n            \\n            int y1 = arr[i][1];\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(j == i)\\n                {\\n                    continue;\\n                }\\n                \\n                int x2 = arr[j][0];\\n                \\n                int y2 = arr[j][1];\\n                \\n                double nume = y2 - y1;\\n                \\n                double deno = x2 - x1;\\n                \\n                // if denominator will be zero then slope will be INT_MAX\\n                \\n                if(deno == 0)\\n                {\\n                    mp[INT_MAX]++;\\n                    \\n                    // update temp_max\\n                    \\n                    temp_max = max(temp_max, mp[INT_MAX]);\\n                    \\n                    continue;\\n                }\\n                \\n                // find the slope and update frequency\\n                \\n                double slope = nume / deno;\\n                \\n                mp[slope]++;\\n                \\n                temp_max = max(temp_max, mp[slope]);\\n            }\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, temp_max + 1);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1005591,
                "title": "c-simple-beats-99-99-no-need-complicated-magic-for-slope",
                "content": "The trick is to use long double instad of double to adjust the precision.\\nEnjoy!\\n\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int result = 0;\\n        for(int i=0; i<points.size();++i){\\n            unordered_map<long double,int> h;\\n            int same = 1;\\n            int localmax = 0;\\n            for(int j=i+1;j<points.size();++j){\\n                if(points[i][0] == points[j][0] && points[i][1]==points[j][1]){\\n                    same++;\\n                }\\n                else if(points[i][0]==points[j][0]){\\n                    h[INT_MAX]++;\\n                }\\n                else{\\n                    long double slope = (long double)(points[i][1] - points[j][1])/(long double)(points[i][0] - points[j][0]);\\n                    h[slope]++;\\n                }\\n            }\\n            for(auto i : h){\\n                localmax = max(localmax,i.second);\\n            }\\n            localmax +=same;\\n            result = max(result,localmax);\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int result = 0;\\n        for(int i=0; i<points.size();++i){\\n            unordered_map<long double,int> h;\\n            int same = 1;\\n            int localmax = 0;\\n            for(int j=i+1;j<points.size();++j){\\n                if(points[i][0] == points[j][0] && points[i][1]==points[j][1]){\\n                    same++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 47101,
                "title": "7-line-c-concise-solution-no-double-hash-key-or-gcd-for-slope",
                "content": "The key to this problem is how to characterize \"slope\" determined by two points. I see many posts here using either a ```double```to represent slope or ```pair<int,int>```with GCD process to make it unique. But this either has issues with numerical accuracy or having to do the recursive calculation.\\n\\nThe idea here is to simply define an order of slope in the representation of ```pair<int,int>```: \\n\\n**Define slope `a:=(a.x, a.y)`is *less than* slope `b:=(b.x, b.y)` if**\\n* **`(a.y*b.y > 0)? a.x*b.y < a.y*b.x : a.x*b.y > a.y*b.x`**. \\n\\nNote that this formulation is actually an extension to the traditional slope calculation `x/y` which not only needs to deal with `y == 0`as corner case but also unavoidably involves floating point numerical comparison. \\n\\nOnce the order is defined, it can be used as a key in ```std::map``` for counting purpose to gather points along the same line with a reference point, i.e., \\n* define `map<Point, int> count` with `count[Point(x,y)]` being the number of points with slope `(x,y)` to the reference point. \\n\\nNote that we count singular slope `(0,0)` (i.e., duplicated points) separately since this \"special\" slope is essentially undefined.\\n\\nSince an ordered container ```std::map```is used, the time complexity is ```O(N^2*logN)```. The space complexity is ```O(N)```to store `map<Point, int> count`.\\n```cpp\\n    int maxPoints(vector<Point>& pts) {\\n        int maxPts = 0;\\n        for (auto& i:pts) {\\n          map<Point, int, Comp> count; int dup = 0;\\n          for (auto& j:pts) {\\n              int curMax = (i.x==j.x && i.y==j.y)? ++dup : ++count[Point(i.x-j.x,i.y-j.y)]+dup;\\n              maxPts = max(maxPts, curMax);\\n          }\\n        }\\n        return maxPts;\\n    }\\n        \\n    struct Comp { // comparator for key (slope) in map\\n        bool operator()(const Point& a, const Point& b) \\n        { \\n          int64_t diff = (int64_t)a.x*b.y - (int64_t)a.y*b.x; // convert to 64bit int for int overflow\\n          return (int64_t)a.y*b.y>0? diff > 0 : diff < 0;\\n        } \\n    };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```double```\n```pair<int,int>```\n```pair<int,int>```\n```std::map```\n```std::map```\n```O(N^2*logN)```\n```O(N)```\n```cpp\\n    int maxPoints(vector<Point>& pts) {\\n        int maxPts = 0;\\n        for (auto& i:pts) {\\n          map<Point, int, Comp> count; int dup = 0;\\n          for (auto& j:pts) {\\n              int curMax = (i.x==j.x && i.y==j.y)? ++dup : ++count[Point(i.x-j.x,i.y-j.y)]+dup;\\n              maxPts = max(maxPts, curMax);\\n          }\\n        }\\n        return maxPts;\\n    }\\n        \\n    struct Comp { // comparator for key (slope) in map\\n        bool operator()(const Point& a, const Point& b) \\n        { \\n          int64_t diff = (int64_t)a.x*b.y - (int64_t)a.y*b.x; // convert to 64bit int for int overflow\\n          return (int64_t)a.y*b.y>0? diff > 0 : diff < 0;\\n        } \\n    };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941855,
                "title": "100-fastest-swift-solution-hashmap-o-n-2",
                "content": "```\\nclass Solution {\\n\\t// - Complexity:\\n    //   - HashMap O(n ^ 2)\\n\\n\\tfunc maxPoints(_ points: [[Int]]) -> Int {\\n\\t\\tguard points.count > 2 else { return points.count }\\n\\t\\t\\n        var map: [String: Set<Int>] = [:]\\n\\t\\tvar max = 0\\n\\t\\t\\n        for i in 0..<points.count {\\n\\t\\t\\tif i + 1 >= points.count { break }\\n\\t\\t\\t\\n            for j in i+1..<points.count {\\n\\t\\t\\t\\tlet line = lineOfTwoPoint(i, j, points)\\n\\t\\t\\t\\tlet key = \"\\\\(line.0)-\\\\(line.1)\"\\n                var indexs = map[key] != nil ? map[key]! : Set<Int>()\\n                \\n                indexs.insert(i)\\n                indexs.insert(j)\\n                map[key] = indexs\\n\\t\\t\\t\\tmax = max > map[key]!.count ? max : map[key]!.count\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\treturn max\\n\\t}\\n\\n\\t// y = kx + a, idx0, idx1\\n\\tfunc lineOfTwoPoint(_ idx0: Int, _ idx1: Int, _ points: [[Int]]) -> (Double, Double) {\\n\\t\\tlet p0 = points[idx0]\\n\\t\\tlet p1 = points[idx1]\\n\\t\\tvar k, a: Double\\n\\t\\t\\n        if p0[1] == p1[1] {\\n\\t\\t\\tk = 0\\n\\t\\t\\ta = Double(p0[1])\\n\\t\\t\\n        } else if p0[0] == p1[0] {\\n\\t\\t\\tk = Double(Int.max)\\n\\t\\t\\ta = Double(p0[0])\\n\\t\\t\\n        } else {\\n\\t\\t\\n            k = Double(p0[1] - p1[1]) / Double(p0[0] - p1[0])\\n\\t\\t\\ta = Double(p0[1]) - k * Double(p0[0])\\n\\t\\t}\\n        \\n\\t\\treturn (k, a)\\n\\t}\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\t// - Complexity:\\n    //   - HashMap O(n ^ 2)\\n\\n\\tfunc maxPoints(_ points: [[Int]]) -> Int {\\n\\t\\tguard points.count > 2 else { return points.count }\\n\\t\\t\\n        var map: [String: Set<Int>] = [:]\\n\\t\\tvar max = 0\\n\\t\\t\\n        for i in 0..<points.count {\\n\\t\\t\\tif i + 1 >= points.count { break }\\n\\t\\t\\t\\n            for j in i+1..<points.count {\\n\\t\\t\\t\\tlet line = lineOfTwoPoint(i, j, points)\\n\\t\\t\\t\\tlet key = \"\\\\(line.0)-\\\\(line.1)\"\\n                var indexs = map[key] != nil ? map[key]! : Set<Int>()\\n                \\n                indexs.insert(i)\\n                indexs.insert(j)\\n                map[key] = indexs\\n\\t\\t\\t\\tmax = max > map[key]!.count ? max : map[key]!.count\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\treturn max\\n\\t}\\n\\n\\t// y = kx + a, idx0, idx1\\n\\tfunc lineOfTwoPoint(_ idx0: Int, _ idx1: Int, _ points: [[Int]]) -> (Double, Double) {\\n\\t\\tlet p0 = points[idx0]\\n\\t\\tlet p1 = points[idx1]\\n\\t\\tvar k, a: Double\\n\\t\\t\\n        if p0[1] == p1[1] {\\n\\t\\t\\tk = 0\\n\\t\\t\\ta = Double(p0[1])\\n\\t\\t\\n        } else if p0[0] == p1[0] {\\n\\t\\t\\tk = Double(Int.max)\\n\\t\\t\\ta = Double(p0[0])\\n\\t\\t\\n        } else {\\n\\t\\t\\n            k = Double(p0[1] - p1[1]) / Double(p0[0] - p1[0])\\n\\t\\t\\ta = Double(p0[1]) - k * Double(p0[0])\\n\\t\\t}\\n        \\n\\t\\treturn (k, a)\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47169,
                "title": "my-java-accepted-solution-for-your-reference-only-using-array",
                "content": "        public class Solution \\n        {\\n            public int maxPoints(Point[] points) \\n            {\\n                int n=points.length;\\n                if (n<2) return n;\\n                int currentL=0,maxL=2,x=0,y=0,dx=0,dy=0,overlap=0,upperB=n;\\n                for(int i=0; i<upperB; i++)\\n                {\\n                    for(int j=i+1; j<n; j++)\\n                    {\\n                        currentL=1; \\n    /*\\n     * Given two points: (a,b) and (c,d), the corresponding normal vector is (b-d,c-a)\\n     * If another point (s,t) is in the same line uniquely defined by (a,b) and (c,d),\\n     * then (s-a,t-b) dot (b-d,c-a) = 0\\n     */\\n                        x=points[i].y-points[j].y;\\n                        y=points[j].x-points[i].x;\\n    \\n    /* If two points are the same, there is no need to check further, \\n     * since a line has to be defined by exactly two distinct points.\\n     */\\n                        if(x==0 && y==0) \\n                            overlap++;\\n    \\n    /* Well, it might be the case that duplicates are not consecutive, \\n     * but as long as we can have a non-trivial normal vector, it won't matter.\\n     */ \\n                        else \\n                        {\\n                            currentL++;\\n    \\n    /*  Explaining (currentL+n-k>maxL):\\n     *  no further checking is necessary when there isn't enough left to make it surpass maxL. \\n     */ \\n                            for(int k=j+1; k<n && currentL+n-k>maxL; k++)\\n                            {\\n                                dx=points[k].x-points[i].x;\\n                                dy=points[k].y-points[i].y;\\n                                if(x*dx+y*dy==0)\\n                                    currentL++;\\n                            }\\n                        }\\n                        maxL=Math.max(currentL+overlap,maxL);\\n                    }\\n    \\n    /* Explaining (upperB=n-maxL): \\n     * it would be crystal clear as soon as you draw a table for combinations of case n>3.\\n     */\\n                    upperB=n-maxL;\\n                    overlap=0;\\n                }\\n                return maxL;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution \\n        {\\n            public int maxPoints(Point[] points) \\n            {\\n                int n=points.length;\\n                if (n<2) return n;\\n                int currentL=0,maxL=2,x=0,y=0,dx=0,dy=0,overlap=0,upperB=n;\\n                for(int i=0; i<upperB; i++)\\n                {\\n                    for(int j=i+1; j<n; j++)\\n                    {\\n                        currentL=1; \\n    /*\\n     * Given two points: (a,b) and (c,d), the corresponding normal vector is (b-d,c-a)\\n     * If another point (s,t) is in the same line uniquely defined by (a,b) and (c,d),\\n     * then (s-a,t-b) dot (b-d,c-a) = 0\\n     */\\n                        x=points[i].y-points[j].y;\\n                        y=points[j].x-points[i].x;\\n    \\n    /* If two points are the same, there is no need to check further, \\n     * since a line has to be defined by exactly two distinct points.\\n     */\\n                        if(x==0 && y==0) \\n                            overlap++;\\n    \\n    /* Well, it might be the case that duplicates are not consecutive, \\n     * but as long as we can have a non-trivial normal vector, it won't matter.\\n     */ \\n                        else \\n                        {\\n                            currentL++;\\n    \\n    /*  Explaining (currentL+n-k>maxL):\\n     *  no further checking is necessary when there isn't enough left to make it surpass maxL. \\n     */ \\n                            for(int k=j+1; k<n && currentL+n-k>maxL; k++)\\n                            {\\n                                dx=points[k].x-points[i].x;\\n                                dy=points[k].y-points[i].y;\\n                                if(x*dx+y*dy==0)\\n                                    currentL++;\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 3016303,
                "title": "java-c-javascript-beats-90-map-o-n-2-time",
                "content": "```java []\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int max=0;\\n        // x -> x[0],x[1]  (x1,y1)\\n        for(int[] x:points)\\n        {\\n            Map<Double,Integer> map= new HashMap<>();\\n            // y -> y[0],y[1]  (x2,y2)\\n            for(int[] y:points){\\n                if(x==y)\\n                  continue;\\n                \\n                double slope=0;\\n                // if (x2 - x1 == 0) \\n                if(y[0]-x[0]==0)\\n                   slope=Double.POSITIVE_INFINITY; \\n                else\\n                   // slope = (y2 - y1) / (x2 - x1)\\n                   slope = (y[1]-x[1])/(double)(y[0]-x[0]);\\n                \\n                map.put(slope,map.getOrDefault(slope,0)+1);\\n                max=Math.max(max,map.get(slope));\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int maxi = 0;\\n        // x -> x[0],x[1]  (x1,y1)\\n        for (auto& x : points) {\\n            map<double, int> slopes;\\n            // y -> y[0],y[1]  (x2,y2)\\n            for (auto& y : points) {\\n                if (x == y) continue;\\n                double slope = numeric_limits<double>::infinity();\\n                // if (x2 - x1 != 0)\\n                if (y[0] - x[0] != 0) {\\n                    // slope = (y2 - y1) / (x2 - x1)\\n                    slope = (double)(y[1] - x[1]) / (y[0] - x[0]);\\n                }\\n                ++slopes[slope];\\n                maxi = max(maxi, slopes[slope]);\\n            }\\n        }\\n        return maxi + 1;\\n    }\\n};\\n```\\n```javascript []\\nvar maxPoints = function(points) {\\n  let max = 0;\\n    // x -> x[0],x[1]  (x1,y1)\\n    for (const x of points) {\\n      const slopes = new Map();\\n    // y -> y[0],y[1]  (x2,y2)\\n    for (const y of points) {\\n      if (x === y) continue;\\n      let slope = Infinity;\\n      // if (x2 - x1 != 0)\\n      if (y[0] - x[0] !== 0) {\\n        // slope = (y2 - y1) / (x2 - x1)\\n        slope = (y[1] - x[1]) / (y[0] - x[0]);\\n      }\\n      if (slopes.has(slope)) {\\n        slopes.set(slope, slopes.get(slope) + 1);\\n      } else {\\n        slopes.set(slope, 1);\\n      }\\n      max = Math.max(max, slopes.get(slope));\\n    }\\n  }\\n  return max + 1;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Math",
                    "Geometry"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int max=0;\\n        // x -> x[0],x[1]  (x1,y1)\\n        for(int[] x:points)\\n        {\\n            Map<Double,Integer> map= new HashMap<>();\\n            // y -> y[0],y[1]  (x2,y2)\\n            for(int[] y:points){\\n                if(x==y)\\n                  continue;\\n                \\n                double slope=0;\\n                // if (x2 - x1 == 0) \\n                if(y[0]-x[0]==0)\\n                   slope=Double.POSITIVE_INFINITY; \\n                else\\n                   // slope = (y2 - y1) / (x2 - x1)\\n                   slope = (y[1]-x[1])/(double)(y[0]-x[0]);\\n                \\n                map.put(slope,map.getOrDefault(slope,0)+1);\\n                max=Math.max(max,map.get(slope));\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int maxi = 0;\\n        // x -> x[0],x[1]  (x1,y1)\\n        for (auto& x : points) {\\n            map<double, int> slopes;\\n            // y -> y[0],y[1]  (x2,y2)\\n            for (auto& y : points) {\\n                if (x == y) continue;\\n                double slope = numeric_limits<double>::infinity();\\n                // if (x2 - x1 != 0)\\n                if (y[0] - x[0] != 0) {\\n                    // slope = (y2 - y1) / (x2 - x1)\\n                    slope = (double)(y[1] - x[1]) / (y[0] - x[0]);\\n                }\\n                ++slopes[slope];\\n                maxi = max(maxi, slopes[slope]);\\n            }\\n        }\\n        return maxi + 1;\\n    }\\n};\\n```\n```javascript []\\nvar maxPoints = function(points) {\\n  let max = 0;\\n    // x -> x[0],x[1]  (x1,y1)\\n    for (const x of points) {\\n      const slopes = new Map();\\n    // y -> y[0],y[1]  (x2,y2)\\n    for (const y of points) {\\n      if (x === y) continue;\\n      let slope = Infinity;\\n      // if (x2 - x1 != 0)\\n      if (y[0] - x[0] !== 0) {\\n        // slope = (y2 - y1) / (x2 - x1)\\n        slope = (y[1] - x[1]) / (y[0] - x[0]);\\n      }\\n      if (slopes.has(slope)) {\\n        slopes.set(slope, slopes.get(slope) + 1);\\n      } else {\\n        slopes.set(slope, 1);\\n      }\\n      max = Math.max(max, slopes.get(slope));\\n    }\\n  }\\n  return max + 1;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016349,
                "title": "explained-java-solution",
                "content": "We compare the slopes for different 2nd points keeping the first point same. Points are on the same line if they have the same m (slope) and c (intercept). So when we keep the first point same , we dont need to compare the intercept hence only slope variable is used. \\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) \\n    {\\n        int max = 0;\\n        for(int[] point_1 : points)\\n        {\\n            Map<Double,Integer> map= new HashMap<>();\\n            for(int[] point_2 : points)\\n            {\\n                if(point_1 == point_2) continue;\\n                \\n                double slope=0;\\n                // if x2 - x1 are equal then line is vertical\\n                if(point_2[0] == point_1[0])\\n                   slope=Double.POSITIVE_INFINITY; \\n                else\\n                {\\n                    // slope (m) = (y2 - y1) / (x2 - x1) \\n                    slope = (point_2[1] - point_1[1]) / (double)(point_2[0] - point_1[0]);\\n                }\\n                map.put( slope , map.getOrDefault(slope,0)+1 );\\n                if(map.get(slope)>max)\\n                    max=map.get(slope);\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) \\n    {\\n        int max = 0;\\n        for(int[] point_1 : points)\\n        {\\n            Map<Double,Integer> map= new HashMap<>();\\n            for(int[] point_2 : points)\\n            {\\n                if(point_1 == point_2) continue;\\n                \\n                double slope=0;\\n                // if x2 - x1 are equal then line is vertical\\n                if(point_2[0] == point_1[0])\\n                   slope=Double.POSITIVE_INFINITY; \\n                else\\n                {\\n                    // slope (m) = (y2 - y1) / (x2 - x1) \\n                    slope = (point_2[1] - point_1[1]) / (double)(point_2[0] - point_1[0]);\\n                }\\n                map.put( slope , map.getOrDefault(slope,0)+1 );\\n                if(map.get(slope)>max)\\n                    max=map.get(slope);\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015881,
                "title": "easiest-soln-goldman-sachs-well-explained",
                "content": "# If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n**ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ1. Max Points on a Line**\\n\\n## Approach\\nfloating point arithmetic, alt integer arithemetic which is comparatively faster. O(n^2)(cross-product)\\n\\n![1.max-points-on-a-line.jpg](https://assets.leetcode.com/users/images/d8221a32-5dc9-43a8-93b8-eb5efc6ebdd2_1673126558.9596267.jpeg)\\n\\n## Complexity\\nThe **time complexity** of this solution is O(n^3), as we need to iterate through each pair of points and check the slope between that pair and every other point.\\n\\nThe **space complexity** is O(1), as we only use a constant amount of space to store the variables ans and total\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    // Function to find the maximum number of points that lie on the same straight line\\n    int maxPoints(vector<vector<int>>& points) {\\n        // Get the number of points\\n        int n = points.size();\\n\\n        // Edge case: 0 or 1 points\\n        if (n <= 1) return n;\\n\\n        // Initialize the maximum number of points to 2 (the minimum possible)\\n        int ans = 2;\\n\\n        // Iterate through all pairs of points\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                // Initialize the total number of points on the same straight line as points[i] and points[j] to 2 (points[i] and points[j])\\n                int total = 2;\\n\\n                // Iterate through all other points\\n                for (int k = 0; k < n; k++) {\\n                    // Skip points i and j\\n                    if (k == i || k == j) continue;\\n\\n                    // Check if point k lies on the same straight line as points i and j\\n                    if ((points[j][1] - points[i][1]) * (points[i][0] - points[k][0]) == (points[i][1] - points[k][1]) * (points[j][0] - points[i][0])) {\\n                        // Point k lies on the same straight line as points i and j, increment the total\\n                        total++;\\n                    }\\n                }\\n                // Update the maximum number of points\\n                ans = max(ans, total);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to find the maximum number of points that lie on the same straight line\\n    int maxPoints(vector<vector<int>>& points) {\\n        // Get the number of points\\n        int n = points.size();\\n\\n        // Edge case: 0 or 1 points\\n        if (n <= 1) return n;\\n\\n        // Initialize the maximum number of points to 2 (the minimum possible)\\n        int ans = 2;\\n\\n        // Iterate through all pairs of points\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                // Initialize the total number of points on the same straight line as points[i] and points[j] to 2 (points[i] and points[j])\\n                int total = 2;\\n\\n                // Iterate through all other points\\n                for (int k = 0; k < n; k++) {\\n                    // Skip points i and j\\n                    if (k == i || k == j) continue;\\n\\n                    // Check if point k lies on the same straight line as points i and j\\n                    if ((points[j][1] - points[i][1]) * (points[i][0] - points[k][0]) == (points[i][1] - points[k][1]) * (points[j][0] - points[i][0])) {\\n                        // Point k lies on the same straight line as points i and j, increment the total\\n                        total++;\\n                    }\\n                }\\n                // Update the maximum number of points\\n                ans = max(ans, total);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47243,
                "title": "have-an-o-n-2-accepted-solution-but-feel-terrible-about-it-what-do-others-think",
                "content": "My submission:\\n\\n    import java.util.Map;\\n    import java.util.HashMap;\\n    \\n    /**\\n     * Definition for a point.\\n     * class Point {\\n     *     int x;\\n     *     int y;\\n     *     Point() { x = 0; y = 0; }\\n     *     Point(int a, int b) { x = a; y = b; }\\n     * }\\n     */\\n    public class Solution {\\n        public int maxPoints(Point[] points) {\\n            int maxLine = 0;\\n            \\n            for (int i=0; i<(points.length-maxLine); i++) {\\n                int coincident = 0;\\n                Map<Double, Integer> pointCounts = new HashMap<Double, Integer>();\\n                for (int j=i+1; j<points.length; j++) {\\n                    Double slope;\\n                    if (points[i].x==points[j].x && points[i].y==points[j].y) {\\n                        coincident++;\\n                        continue;\\n                    } else if (points[i].x == points[j].x) {\\n                        slope = Math.PI;\\n                    } else if (points[i].y == points[j].y) {\\n                        slope = 0.0; // logically we don't need this, but in practice i find that we do\\n                    } else {\\n                        slope = new Double((double)(points[i].y-points[j].y) / (double)(points[i].x-points[j].x));\\n                    }\\n                    \\n                    if (pointCounts.containsKey(slope))\\n                        pointCounts.put(slope, pointCounts.get(slope)+1);\\n                    else\\n                        pointCounts.put(slope, new Integer(1));\\n                }\\n                maxLine = Math.max(maxLine, 1+coincident+maxValue(pointCounts));\\n            }\\n            \\n            return maxLine;\\n        }\\n        \\n        private int maxValue(Map<Double, Integer> doubleIntMap) {\\n            int max = 0;\\n            Set<Double> keys = doubleIntMap.keySet();\\n            Iterator iter = keys.iterator();\\n            while (iter.hasNext())\\n                max = Math.max(max, doubleIntMap.get(iter.next()));\\n            return max;\\n        }\\n    }\\nMy Algorithm was the following:\\n\\n    for every point i from 0 to points.length - maxColinearPointsFoundSoFar {\\n        for every j from i+1 to points.length-1 {\\n            ithPointHashTable[slope] += 1;\\n        } \\n        find max value in ithPointHashTable and update maxColinearPointsFoundSoFar;\\n    }\\n\\nHere are the reasons that combine to make me feel terrible:\\n\\nWhenever I use a hash table to achieve O(some runtime) having to assume hash table insertion is O(1), I don't feel great. hash tables also use extra memory which we are also watching our algorithms for.\\n\\nThis might've been the first time ever for me attempting to use a Double as a map key. Through this exercise I've discovered that its not a good idea. For instance (double) (0/1) and (double) (0/-1) evaluates to two different things. That's one thing the test cases uncovered. There might be more cases where mathematically expressions should evaluate to the same thing but in above code they don't.\\n\\nMore along those lines, for two points that have infinite slope, I inesrt them into the hashMap with a key of Math.PI. Mathematically no two points with integer coordinates should have an irrational slope, however in practice because of computer precision. But could there be a case where two points with integer coordinates have a slope between them that creates an equivalent map key as Math.PI? Although its not very likely, the probability might not be 0.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxPoints(Point[] points) {\\n            int maxLine = 0;\\n            \\n            for (int i=0; i<(points.length-maxLine); i++) {\\n                int coincident = 0;\\n                Map<Double, Integer> pointCounts = new HashMap<Double, Integer>();\\n                for (int j=i+1; j<points.length; j++) {\\n                    Double slope;\\n                    if (points[i].x==points[j].x && points[i].y==points[j].y) {\\n                        coincident++;\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 431375,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. Basically brutal force, given a point, find all the points that lie on the same line\\n2. Beware that duplicate points are counted as well\\n3. Beware that JS\\'s problem when calculating big decimal numbers, use hack `1000000.0 *`\\n``` javascript\\nvar maxPoints = function(points) {\\n    if (points.length <2|| points == null) return points.length;\\n    let max = 2;\\n    for (let i=0;i<points.length;i++) {\\n        let [p1x, p1y] = points[i];\\n        let samePoint = 1, map = {\\'base\\':0}; // to avoid when map = {}, the max value is -Infinity\\n        for (let j=i+1;j<points.length;j++) {\\n            if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {\\n                samePoint++;\\n            } else {\\n                let [p2x, p2y] = points[j];\\n                let slope = 1000000.0 * (p2y - p1y)/(p2x - p1x);\\n                if (!Number.isFinite(slope)) slope = \"v\";\\n                else if (Number.isNaN(slope)) slope = \"h\";\\n                map[slope] = map[slope]+1||1;\\n            }   \\n        }\\n        max = Math.max(Math.max(...Object.values(map))+samePoint, max);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar maxPoints = function(points) {\\n    if (points.length <2|| points == null) return points.length;\\n    let max = 2;\\n    for (let i=0;i<points.length;i++) {\\n        let [p1x, p1y] = points[i];\\n        let samePoint = 1, map = {\\'base\\':0}; // to avoid when map = {}, the max value is -Infinity\\n        for (let j=i+1;j<points.length;j++) {\\n            if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {\\n                samePoint++;\\n            } else {\\n                let [p2x, p2y] = points[j];\\n                let slope = 1000000.0 * (p2y - p1y)/(p2x - p1x);\\n                if (!Number.isFinite(slope)) slope = \"v\";\\n                else if (Number.isNaN(slope)) slope = \"h\";\\n                map[slope] = map[slope]+1||1;\\n            }   \\n        }\\n        max = Math.max(Math.max(...Object.values(map))+samePoint, max);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 47256,
                "title": "java-solution-with-no-double-if-you-are-concerned-with-using-doubles-floats-fear-not-there-is-a-way-around",
                "content": "This solution is somewhat slower than the standard solution which uses doubles to store slopes. It, however, guarantees that there will not be any precision error, as long as we are dealing with integers as point coordinates.\\n\\nYou can read here about the pairing functions that uniquely represent any pair of integers. [https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function][1]\\n\\n    /**\\n     * We can use a pairing function to represent two integers uniquely.\\n     * In our case we use a pairing function to represent a fraction, \\n     * with first integer being the numerator and second integer being the denominator.\\n     * Hence, we avoid precision concerns that may come up if we use floats / doubles.\\n     */\\n    public int maxPoints(Point[] points) {\\n        if (points.length < 2) return points.length;\\n        int max = 2;\\n        for (Point p1 : points) {\\n            Map<Integer, Integer> slopes = new HashMap<>(points.length);\\n            int localMax = 0;\\n            for (Point p2 : points) {\\n                int num = p2.y - p1.y;\\n                int den = p2.x - p1.x;\\n                \\n                // pairing functions only work with non-negative integers\\n                // we store the sign in a separate variable\\n                int sign = 1;\\n                if ((num > 0 && den < 0) || (num < 0 && den > 0)) sign = -1;\\n                num = Math.abs(num);\\n                den = Math.abs(den);\\n                \\n                // pairing functions represent a pair of any two integers uniquely;\\n                // they can be used as hash functions for any sequence of integers;\\n                // therefore, a pairing function from 1/2 doesn't equal to that from 3/6\\n                // even though the slope 1/2 and 3/6 is the same.\\n                // => we need to convert each fraction to its simplest form, i.e. 3/6 => 1/2\\n                int gcd = GCD(num, den);\\n                num = gcd == 0 ? num : num / gcd;\\n                den = gcd == 0 ? den : den / gcd;\\n                \\n                // We can use Cantor pairing function pi(k1, k2) = 1/2(k1 + k2)(k1 + k2 + 1) + k2\\n                // and include the sign\\n                int m = sign * (num + den) * (num + den + 1) / 2 + den;\\n                if (slopes.containsKey(m)) slopes.put(m, slopes.get(m)+1);\\n                else slopes.put(m, 1);\\n                if (m == 0) continue;\\n                \\n                localMax = Math.max(slopes.get(m),localMax);\\n            }\\n            max = Math.max(max, localMax + slopes.get(0));\\n        }\\n        return max;\\n    }\\n    \\n    public int GCD(int a, int b) {\\n       if (b == 0) return a;\\n       return GCD(b,a % b);\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function",
                "solutionTags": [
                    "Java"
                ],
                "code": "This solution is somewhat slower than the standard solution which uses doubles to store slopes. It, however, guarantees that there will not be any precision error, as long as we are dealing with integers as point coordinates.\\n\\nYou can read here about the pairing functions that uniquely represent any pair of integers. [https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function][1]\\n\\n    /**\\n     * We can use a pairing function to represent two integers uniquely.\\n     * In our case we use a pairing function to represent a fraction, \\n     * with first integer being the numerator and second integer being the denominator.\\n     * Hence, we avoid precision concerns that may come up if we use floats / doubles.\\n     */\\n    public int maxPoints(Point[] points) {\\n        if (points.length < 2) return points.length;\\n        int max = 2;\\n        for (Point p1 : points) {\\n            Map<Integer, Integer> slopes = new HashMap<>(points.length);\\n            int localMax = 0;\\n            for (Point p2 : points) {\\n                int num = p2.y - p1.y;\\n                int den = p2.x - p1.x;\\n                \\n                // pairing functions only work with non-negative integers\\n                // we store the sign in a separate variable\\n                int sign = 1;\\n                if ((num > 0 && den < 0) || (num < 0 && den > 0)) sign = -1;\\n                num = Math.abs(num);\\n                den = Math.abs(den);\\n                \\n                // pairing functions represent a pair of any two integers uniquely;\\n                // they can be used as hash functions for any sequence of integers;\\n                // therefore, a pairing function from 1/2 doesn't equal to that from 3/6\\n                // even though the slope 1/2 and 3/6 is the same.\\n                // => we need to convert each fraction to its simplest form, i.e. 3/6 => 1/2\\n                int gcd = GCD(num, den);\\n                num = gcd == 0 ? num : num / gcd;\\n                den = gcd == 0 ? den : den / gcd;\\n                \\n                // We can use Cantor pairing function pi(k1, k2) = 1/2(k1 + k2)(k1 + k2 + 1) + k2\\n                // and include the sign\\n                int m = sign * (num + den) * (num + den + 1) / 2 + den;\\n                if (slopes.containsKey(m)) slopes.put(m, slopes.get(m)+1);\\n                else slopes.put(m, 1);\\n                if (m == 0) continue;\\n                \\n                localMax = Math.max(slopes.get(m),localMax);\\n            }\\n            max = Math.max(max, localMax + slopes.get(0));\\n        }\\n        return max;\\n    }\\n    \\n    public int GCD(int a, int b) {\\n       if (b == 0) return a;\\n       return GCD(b,a % b);\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function",
                "codeTag": "Unknown"
            },
            {
                "id": 1133281,
                "title": "java-using-hashmap-explained",
                "content": "```\\n  public int maxPoints(int[][] points) {\\n        int n = points.length;\\n        int out = 0;\\n        if(n==1)\\n            return n;\\n        Map<Double, Integer> map = new HashMap<>(); // count pairs of points having same slops\\n       for(int i=0;i<n;i++){\\n           for(int j=i+1;j<n;j++){\\n               // if(i==j)\\n               //     continue;\\n               Double m = null; // null values as key is for vertical lines having slop = 90degree\\n                if(points[i][1]==points[j][1]){ // straight horizontal line\\n                    m = 0.0;\\n                } else \\n                if(points[i][0]!=points[j][0]){\\n                    m = ((points[i][1]-points[j][1])*1.0)/(points[i][0]-points[j][0]);\\n                }\\n\\n               \\n               int val = map.getOrDefault(m,1);\\n               map.put(m, val+1);\\n           }\\n           for(Integer val : map.values()){\\n               out = Math.max(out, val);\\n           }\\n           map = new HashMap<>();\\n       }\\n        return out;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public int maxPoints(int[][] points) {\\n        int n = points.length;\\n        int out = 0;\\n        if(n==1)\\n            return n;\\n        Map<Double, Integer> map = new HashMap<>(); // count pairs of points having same slops\\n       for(int i=0;i<n;i++){\\n           for(int j=i+1;j<n;j++){\\n               // if(i==j)\\n               //     continue;\\n               Double m = null; // null values as key is for vertical lines having slop = 90degree\\n                if(points[i][1]==points[j][1]){ // straight horizontal line\\n                    m = 0.0;\\n                } else \\n                if(points[i][0]!=points[j][0]){\\n                    m = ((points[i][1]-points[j][1])*1.0)/(points[i][0]-points[j][0]);\\n                }\\n\\n               \\n               int val = map.getOrDefault(m,1);\\n               map.put(m, val+1);\\n           }\\n           for(Integer val : map.values()){\\n               out = Math.max(out, val);\\n           }\\n           map = new HashMap<>();\\n       }\\n        return out;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018023,
                "title": "java-c-100-solution-with-hashing-max-points-on-a-line",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int ans = 0;\\n        for (int i = 0; i<points.length; ++i){\\n            Map<Double, Integer> check = new HashMap<>();\\n            for (int  j = i+1; j<points.length; ++j){\\n                double slope;\\n                if (points[i][0] == points[j][0])\\n                    slope = Double.MAX_VALUE;\\n                else{\\n                    slope = (points[i][1] - points[j][1]) / ((double) (points[i][0] - points[j][0]));\\n                    if (slope == -0.0)\\n                        slope = 0.0;\\n                }\\n                check.put(slope, check.getOrDefault(slope, 0) + 1);\\n                ans = Math.max(ans, check.get(slope));\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n       int ans = 0;\\n        for (int i = 0; i<points.size(); ++i){\\n            map<double,int> check;\\n            for (int  j = i+1; j<points.size(); ++j){\\n                double slope;\\n                if (points[i][0] == points[j][0])\\n                    slope = DBL_MAX;\\n                else{\\n                    slope = (points[i][1] - points[j][1]) / ((double) (points[i][0] - points[j][0]));\\n                }\\n                check[slope]++;\\n                ans = max(ans, check[slope]);\\n            }\\n        }\\n        return ans+1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int ans = 0;\\n        for (int i = 0; i<points.length; ++i){\\n            Map<Double, Integer> check = new HashMap<>();\\n            for (int  j = i+1; j<points.length; ++j){\\n                double slope;\\n                if (points[i][0] == points[j][0])\\n                    slope = Double.MAX_VALUE;\\n                else{\\n                    slope = (points[i][1] - points[j][1]) / ((double) (points[i][0] - points[j][0]));\\n                    if (slope == -0.0)\\n                        slope = 0.0;\\n                }\\n                check.put(slope, check.getOrDefault(slope, 0) + 1);\\n                ans = Math.max(ans, check.get(slope));\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n       int ans = 0;\\n        for (int i = 0; i<points.size(); ++i){\\n            map<double,int> check;\\n            for (int  j = i+1; j<points.size(); ++j){\\n                double slope;\\n                if (points[i][0] == points[j][0])\\n                    slope = DBL_MAX;\\n                else{\\n                    slope = (points[i][1] - points[j][1]) / ((double) (points[i][0] - points[j][0]));\\n                }\\n                check[slope]++;\\n                ans = max(ans, check[slope]);\\n            }\\n        }\\n        return ans+1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017375,
                "title": "python-simple-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> It was a simple intuition that to check if the line equation formed from combinations of any two points in the given array satisfies with the number points in the given points array. i.e return the maximum points that satisfies the line equation. :)\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nC2 * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ll = len(points) \\n        if ll == 1: return 1\\n        elif ll == 2: return 2\\n        else:\\n            ans = 0\\n            for i in list(combinations(points,2)):\\n                cnt = 0\\n                for j in points:\\n                    if (j[1] - i[0][1]) * (i[1][0] - i[0][0]) == (j[0] - i[0][0]) * (i[1][1] - i[0][1]):\\n                        cnt += 1\\n                ans = max(ans, cnt)\\n            return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ll = len(points) \\n        if ll == 1: return 1\\n        elif ll == 2: return 2\\n        else:\\n            ans = 0\\n            for i in list(combinations(points,2)):\\n                cnt = 0\\n                for j in points:\\n                    if (j[1] - i[0][1]) * (i[1][0] - i[0][0]) == (j[0] - i[0][0]) * (i[1][1] - i[0][1]):\\n                        cnt += 1\\n                ans = max(ans, cnt)\\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328705,
                "title": "c-85-beat-o-n-2-solution-exploit-gcd-cool-bros-solution",
                "content": "The idea is pretty straight forward. For any point, all points with the same slope with respect to the point are on the same line. We use CGD to avoid floating point errors.\\n\\nFor example, take the point (2, 2)\\n\\nTake (3, 3) - the xdiff = -1, ydiff = -1, the gcd is -1: and the slope is 1 for \"intercept\" of 1.\\nTake (4, 4) - the xdiff is -2, ydiff is -2, the gcd is -2: and the slope is 1 for \"intercept\" of 1.\\nTake (-2, -2) - the xdiff = 4, ydiff = 4, the gcd is 4: and the slope is 1 for \"intercept\" of 1.\\n(Note, this is not actually in y-intercept form. The \"slope\" and \"intercept\" here are just the x_diff and y_diff divided by the gcd. So what that really means is that you must advance x by 1 when y is at 1. This is a way to define a line... lul... \\n\\nSo, ((2,2), (3,3)) and ((2,2), (4,4)) and ((2,2), (-2,-2)) are on the same line...\\n\\nThe only corner cases are vertical or horizontal lines, which we can easily count separately for each point. (We are visiting the points in a triangular loop)\\n\\nFinally, any points equal to our candidate point (2,2) we simply add to the max of the possible solutions, horizontal, vertical, or \"slope buddies\"\\n\\nThe other funny thing for C++, I noticed that you can use pairs in a map, but not in an unordered_set or unordered_map. Alternatively you could use a set of sets. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int gcd(int pSmall, int pLarge) {\\n        int aRemainder = 0;\\n        while (pSmall != 0) {\\n            aRemainder = pLarge % pSmall;\\n            pLarge = pSmall;\\n            pSmall = aRemainder;\\n        }\\n        return pLarge;\\n    }\\n    \\n    int maxPoints(vector<vector<int>>& points) {\\n        \\n        int aResult = 0;\\n        int aPointCount = points.size();\\n        \\n        int aX1, aY1, aX2, aY2;\\n        int aDiffX, aDiffY, aGCD;\\n        int aHorCount, aVerCount, aEqualCount, aSlopeCount, aIterationCount;\\n        \\n        pair<int, int> aPair;\\n        \\n        for (int i=0;i<aPointCount;i++) {\\n            \\n            map<pair<int, int>, int> aLUT;\\n            \\n            aX1 = points[i][0];\\n            aY1 = points[i][1];\\n            \\n            aHorCount = 0;\\n            aVerCount = 0;\\n            aEqualCount = 0;\\n            aSlopeCount = 0;\\n            \\n            for (int j=i-1;j>=0;j--) {\\n                aX2 = points[j][0];\\n                aY2 = points[j][1];\\n                \\n                aDiffX = aX1 - aX2;\\n                aDiffY = aY1 - aY2;\\n                \\n                if (aDiffX == 0 && aDiffY == 0) {\\n                    aEqualCount++;\\n                } else if (aDiffX == 0) {\\n                    ++aHorCount;\\n                } else if (aDiffY == 0) {\\n                    ++aVerCount;\\n                } else {\\n                    aGCD = gcd(aDiffX, aDiffY);\\n                    \\n                    aPair.first = aDiffX /= aGCD;\\n                    aPair.second = aDiffY /= aGCD;\\n                    \\n                    aLUT[aPair]++;\\n                    \\n                    aSlopeCount = max(aSlopeCount, aLUT[aPair]);\\n                }\\n            }\\n            \\n            aIterationCount = max(max(aSlopeCount, aHorCount), aVerCount) + aEqualCount + 1;\\n            aResult = max(aResult, aIterationCount);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int gcd(int pSmall, int pLarge) {\\n        int aRemainder = 0;\\n        while (pSmall != 0) {\\n            aRemainder = pLarge % pSmall;\\n            pLarge = pSmall;\\n            pSmall = aRemainder;\\n        }\\n        return pLarge;\\n    }\\n    \\n    int maxPoints(vector<vector<int>>& points) {\\n        \\n        int aResult = 0;\\n        int aPointCount = points.size();\\n        \\n        int aX1, aY1, aX2, aY2;\\n        int aDiffX, aDiffY, aGCD;\\n        int aHorCount, aVerCount, aEqualCount, aSlopeCount, aIterationCount;\\n        \\n        pair<int, int> aPair;\\n        \\n        for (int i=0;i<aPointCount;i++) {\\n            \\n            map<pair<int, int>, int> aLUT;\\n            \\n            aX1 = points[i][0];\\n            aY1 = points[i][1];\\n            \\n            aHorCount = 0;\\n            aVerCount = 0;\\n            aEqualCount = 0;\\n            aSlopeCount = 0;\\n            \\n            for (int j=i-1;j>=0;j--) {\\n                aX2 = points[j][0];\\n                aY2 = points[j][1];\\n                \\n                aDiffX = aX1 - aX2;\\n                aDiffY = aY1 - aY2;\\n                \\n                if (aDiffX == 0 && aDiffY == 0) {\\n                    aEqualCount++;\\n                } else if (aDiffX == 0) {\\n                    ++aHorCount;\\n                } else if (aDiffY == 0) {\\n                    ++aVerCount;\\n                } else {\\n                    aGCD = gcd(aDiffX, aDiffY);\\n                    \\n                    aPair.first = aDiffX /= aGCD;\\n                    aPair.second = aDiffY /= aGCD;\\n                    \\n                    aLUT[aPair]++;\\n                    \\n                    aSlopeCount = max(aSlopeCount, aLUT[aPair]);\\n                }\\n            }\\n            \\n            aIterationCount = max(max(aSlopeCount, aHorCount), aVerCount) + aEqualCount + 1;\\n            aResult = max(aResult, aIterationCount);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328269,
                "title": "a-java-solution-with-my-understanding",
                "content": "The major algorithm is from:\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/discuss/47113/A-java-solution-with-notes\\n\\nThe basic approach:\\n\\n1. Use a HashMap to save the **slope** and relevant point count. e.g. if there is an entry of the map as (1.5, 3), it means 5 points having slope 1.5.\\n1. Go though the points array, compare each pair of the points, and calculate the slope/count.\\n1. Return the max value of the points with the same slope.\\n\\n**How to calculate the slope?**\\n\\nAssume `dx = (x2 - x1), dy = (y2 = y1)`. A straightforward way is to use a double: `slope = (float)(dy) / dx`. However, we cannot simply use a double to indicate the slope, which might lose precision for very big numbers. e.g. for (2 ^ 32) / (2 ^ 32) and (2 ^ 32 - 1) / (2 ^ 32), the results are the same, but in fact they are not. A better way is to use **fraction**: use a long type slope, with the first 32 bits indicating dy and the last 32 bits indicating dx.\\n\\nNotes that we need to save the slope in **irreducible fraction**, so divide dx/dy with the great common divisor (GCD) before saving them.\\n\\nIn addition, remember to cast (dy / gcd) to **long** before move the result by 32 bits, otherwise we will get 0 finally since it\\'s an **int** with 32 bits:\\n\\n`slope = ((long)(dy / gcd) << 32) + (dx / gcd);`\\n\\nA complete rule for calculating the slope:\\n\\n1. If both dx and dy are 0, it means the two points are duplicated. Increase `dup` to remember duplicated points.\\n2. Otherwise, save the slope in fraction.\\n\\n**How to get the GCD?**\\n\\nIt\\'s implemented in function getGCD(): if b == 0, return a directly; otherwise, call getGCD() recursively by b and (a % b). \\n\\n**How to handle the duplicated points?**\\n\\nUse `dup` to remember how many duplicated points we have gotten. Initialize `dup = 1` because we need to account the original point as well, e.g if the count 1, we have two duplicated points. Then go through the entire hashmap to find the max value of count. \\n\\nNote that the count should be `entry.getValue() + dup` because we need to account the original point plus all duplicated points. e.g. for slope = 1.5, count = 3, and dup = 2, it means 1 original point, 1 duplicated point (with the same position to original point), from where there are 3 points with the same slope (1.5). So the number of points that lie on the same straight line is `(2 + 3) = 5`.\\n\\nComplete code:\\n\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points.length < 3)return points.length;\\n        int max = 0;\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        for(int i = 0;i < points.length;i++) {\\n            int dup = 1;\\n            map.clear();\\n            for(int j = i + 1;j < points.length;j++) {\\n                int dx = points[j][0] - points[i][0], dy = points[j][1] - points[i][1];\\n                if(dx == 0 && dy == 0)dup++;\\n                else {\\n                    int gcd = getGcd(dx, dy);\\n                    long slope = ((long)(dy / gcd) << 32) + (dx / gcd);\\n                    map.put(slope, map.getOrDefault(slope, 0) + 1);\\n                }               \\n            }\\n            max = Math.max(max, dup);\\n            for(Map.Entry<Long, Integer> entry : map.entrySet())\\n                max = Math.max(max, entry.getValue() + dup);\\n        }\\n        return max;\\n    }\\n    \\n    int getGcd(int a, int b) {\\n        return b == 0 ? a : getGcd(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points.length < 3)return points.length;\\n        int max = 0;\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        for(int i = 0;i < points.length;i++) {\\n            int dup = 1;\\n            map.clear();\\n            for(int j = i + 1;j < points.length;j++) {\\n                int dx = points[j][0] - points[i][0], dy = points[j][1] - points[i][1];\\n                if(dx == 0 && dy == 0)dup++;\\n                else {\\n                    int gcd = getGcd(dx, dy);\\n                    long slope = ((long)(dy / gcd) << 32) + (dx / gcd);\\n                    map.put(slope, map.getOrDefault(slope, 0) + 1);\\n                }               \\n            }\\n            max = Math.max(max, dup);\\n            for(Map.Entry<Long, Integer> entry : map.entrySet())\\n                max = Math.max(max, entry.getValue() + dup);\\n        }\\n        return max;\\n    }\\n    \\n    int getGcd(int a, int b) {\\n        return b == 0 ? a : getGcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47111,
                "title": "16ms-c-easy-understanding-solution",
                "content": "    class Solution {\\n    public:\\n        int maxPoints(vector<Point>& points) {\\n            int n = (int)points.size();\\n            unordered_map<float, int> map;\\n            int res = 0;\\n            for(int i = 0; i < n; i++){\\n                int same = 1;\\n                int vertical = 0;\\n                int tmp = 0;\\n                map.clear();\\n                for(int j = i + 1; j < n; j++){\\n                    Point a = points[i];\\n                    Point b = points[j];\\n                    if(a.x == b.x){\\n                        if(a.y != b.y){\\n                            vertical++;\\n                        }\\n                        else{\\n                            same++;\\n                        }\\n                    }\\n                    else{\\n                         tmp = max(++map[(float)(b.y - a.y) / (b.x - a.x)], tmp);\\n                    }\\n                }\\n                res = max(res, same + max(vertical, tmp));\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point>& points) {\\n            int n = (int)points.size();\\n            unordered_map<float, int> map;\\n            int res = 0;\\n            for(int i = 0; i < n; i++){\\n                int same = 1;\\n                int vertical = 0;\\n                int tmp = 0;\\n                map.clear();\\n                for(int j = i + 1; j < n; j++){\\n                    Point a = points[i];\\n                    Point b = points[j];\\n                    if(a.x == b.x){\\n                        if(a.y != b.y){\\n                            vertical++;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 47204,
                "title": "easy-java-solution",
                "content": "Using double as the `HashMap` key is a bad practice. \\n\\nBut for this problem, as long as we handle the case of gradient `0.0`, it's fine to use `Double`. This is because Double `+0.0` and `-0.0` is treated as  different key.\\n\\n> Note that in most cases, for two instances of class Double, d1 and d2,\\n> the value of d1.equals(d2) is true if and only if `d1.doubleValue() == d2.doubleValue()` also has the value true. However,\\n> there are two exceptions:\\n> \\n> If d1 and d2 both represent Double.NaN, then the equals method returns\\n> true, even though `Double.NaN==Double.NaN` has the value false. If d1\\n> represents +0.0 while d2 represents -0.0, or vice versa, the equal\\n> test has the value false, even though `+0.0==-0.0` has the value true.\\n> This definition allows hash tables to operate properly.\\n\\nBy adding the following line, it's ok to use `Double` as the key.\\n\\n    double k =  (p2.y == p1.y) ? 0.0 :((double) (p2.y - p1.y) / (p2.x - p1.x));\\n\\nThis is an my Java AC solution:\\n\\n    public int maxPoints(Point[] points) {\\n        int result = 0;\\n        for (int i = 0; i < points.length; i++) {\\n            Map<Double, Integer> map = new HashMap<>();\\n            int dups = 0, verticals = 0;\\n            \\n            for (int j = i + 1; j < points.length; j++) {\\n                Point p1 = points[i], p2 = points[j];\\n                \\n                if (p1.x == p2.x && p1.y == p2.y) {\\n                    dups++;\\n                } else if (p1.x == p2.x) {\\n                    verticals++;\\n                } else if (p1.y == p2.y) {\\n                    map.put(0.0, map.getOrDefault(0.0, 0) + 1);\\n                } else {\\n                    double k = (double) (p2.y - p1.y) / (p2.x - p1.x);    \\n                    map.put(k, map.getOrDefault(k, 0) + 1);\\n                }\\n            }\\n            \\n            int max = 0;\\n            for (Map.Entry<Double, Integer> entry: map.entrySet()) {\\n                max = Math.max(max, entry.getValue() + dups + 1);\\n            }\\n            \\n            max = Math.max(max, verticals + dups + 1);\\n            result = Math.max(max, result);\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Using double as the `HashMap` key is a bad practice. \\n\\nBut for this problem, as long as we handle the case of gradient `0.0`, it's fine to use `Double`. This is because Double `+0.0` and `-0.0` is treated as  different key.\\n\\n> Note that in most cases, for two instances of class Double, d1 and d2,\\n> the value of d1.equals(d2) is true if and only if `d1.doubleValue() == d2.doubleValue()` also has the value true. However,\\n> there are two exceptions:\\n> \\n> If d1 and d2 both represent Double.NaN, then the equals method returns\\n> true, even though `Double.NaN==Double.NaN` has the value false. If d1\\n> represents +0.0 while d2 represents -0.0, or vice versa, the equal\\n> test has the value false, even though `+0.0==-0.0` has the value true.\\n> This definition allows hash tables to operate properly.\\n\\nBy adding the following line, it's ok to use `Double` as the key.\\n\\n    double k =  (p2.y == p1.y) ? 0.0 :((double) (p2.y - p1.y) / (p2.x - p1.x));\\n\\nThis is an my Java AC solution:\\n\\n    public int maxPoints(Point[] points) {\\n        int result = 0;\\n        for (int i = 0; i < points.length; i++) {\\n            Map<Double, Integer> map = new HashMap<>();\\n            int dups = 0, verticals = 0;\\n            \\n            for (int j = i + 1; j < points.length; j++) {\\n                Point p1 = points[i], p2 = points[j];\\n                \\n                if (p1.x == p2.x && p1.y == p2.y) {\\n                    dups++;\\n                } else if (p1.x == p2.x) {\\n                    verticals++;\\n                } else if (p1.y == p2.y) {\\n                    map.put(0.0, map.getOrDefault(0.0, 0) + 1);\\n                } else {\\n                    double k = (double) (p2.y - p1.y) / (p2.x - p1.x);    \\n                    map.put(k, map.getOrDefault(k, 0) + 1);\\n                }\\n            }\\n            \\n            int max = 0;\\n            for (Map.Entry<Double, Integer> entry: map.entrySet()) {\\n                max = Math.max(max, entry.getValue() + dups + 1);\\n            }\\n            \\n            max = Math.max(max, verticals + dups + 1);\\n            result = Math.max(max, result);\\n        }\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 47147,
                "title": "11-lines-python",
                "content": "    def maxPoints(self, points):\\n        answer = 0\\n        for p in points:\\n            pctr = 0\\n            ctr = collections.Counter()\\n            for q in points:\\n                x, y = q.x - p.x, q.y - p.y\\n                pctr += x == y == 0\\n                ctr[float(y)/x if x else 'inf'] += 1\\n            ctr['inf'] -= pctr\\n            answer = max(answer, pctr + max(ctr.values()))\\n        return answer\\n\\nFor each point p...\\n\\n 1. Count how often p itself appears.\\n 2. Count how often each slope through p appears (use 'inf' for vertical lines).\\n 3. The p-counter plus the largest slope-counter tell the largest number of points on a line through p.\\n\\nMaximize the latter over all points p.\\n\\n---\\n\\nImplementation detail: I count every p towards `ctr['inf']` and subtract them afterwards because that's slightly simpler/shorter and because this way, `ctr` can't be empty (which would give me trouble when asking `max(ctr.values())`).",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def maxPoints(self, points):\\n        answer = 0\\n        for p in points:\\n            pctr = 0\\n            ctr = collections.Counter()\\n            for q in points:\\n                x, y = q.x - p.x, q.y - p.y\\n                pctr += x == y == 0\\n                ctr[float(y)/x if x else 'inf'] += 1\\n            ctr['inf'] -= pctr\\n            answer = max(answer, pctr + max(ctr.values()))\\n        return answer\\n\\nFor each point p...\\n\\n 1. Count how often p itself appears.\\n 2. Count how often each slope through p appears (use 'inf' for vertical lines).\\n 3. The p-counter plus the largest slope-counter tell the largest number of points on a line through p.\\n\\nMaximize the latter over all points p.\\n\\n---\\n\\nImplementation detail: I count every p towards `ctr['inf']` and subtract them afterwards because that's slightly simpler/shorter and because this way, `ctr` can't be empty (which would give me trouble when asking `max(ctr.values())`).",
                "codeTag": "Python3"
            },
            {
                "id": 3018635,
                "title": "python-solution-explained-o-n-2-97",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first iterate through the points and find the `slop` from the curent point to all preceding point.\\n\\n$$slop = (y2-y1)/(x2-x1)$$\\n\\nThen we add that `slop`as `key` to our hash and the point-count as its `value`.\\n\\nThen we update our `maxlen` if our current `slop` count is greater.\\n\\nFinaly we return `maxlen`\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        # check for edge case\\n        if len(points)<3:\\n            return len(points)\\n        \\n        maxlen = 0\\n        for i in range(len(points)):\\n            line = {}\\n            for j in range(i+1,len(points)):\\n                y = points[i][1] - points[j][1]\\n                x = points[i][0] - points[j][0]\\n                \\n                # for finding the y-intercept (b)\\n                # b = points[i][0] if x == 0  else points[i][1] - ((y/x) * points[i][0])\\n                \\n                # use the slop as the hash map key\\n                slop = y/x if x!=0 else inf\\n                \\n                if slop in line:\\n                    line[slop]+= 1\\n                else:\\n                    line[slop] = 2 \\n                maxlen = max(line[slop] , maxlen)\\n        return maxlen\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        # check for edge case\\n        if len(points)<3:\\n            return len(points)\\n        \\n        maxlen = 0\\n        for i in range(len(points)):\\n            line = {}\\n            for j in range(i+1,len(points)):\\n                y = points[i][1] - points[j][1]\\n                x = points[i][0] - points[j][0]\\n                \\n                # for finding the y-intercept (b)\\n                # b = points[i][0] if x == 0  else points[i][1] - ((y/x) * points[i][0])\\n                \\n                # use the slop as the hash map key\\n                slop = y/x if x!=0 else inf\\n                \\n                if slop in line:\\n                    line[slop]+= 1\\n                else:\\n                    line[slop] = 2 \\n                maxlen = max(line[slop] , maxlen)\\n        return maxlen\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017515,
                "title": "c-begineer-friendly-easy-understanding-heap-video-solution",
                "content": "# Intuition && Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=TGRl2dJzL64/\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017376,
                "title": "easy-to-understand-c-solution-with-explaination",
                "content": "# Approach\\nWe use property of coordinate geometry. We calculate slope and store its frequency in map. Now for every pair possible there are 3 cases to consider:\\n\\n1) If the second point is same as the first then we will have overlapping points. So to tackle this we will maintain the count of same points and then add then to our answer.\\n2) If the difference between x coordinates become ```zero``` then slope becomes infinity. So to tackle this we will store their frequencies at ```INT_MAX```.\\n3) Then all that left is general case where we calculate slope and count its frequency. \\n\\nFor each point we maintain a ```currMax``` which will store result for current point. And at the end of each iteration we will take maximum with previous result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int res=0;\\n        int n=points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int samePnt=1;\\n            unordered_map<double,int>mp;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(points[i][0]==points[j][0] and points[i][1]==points[j][1])\\n                {\\n                    samePnt++;\\n                }\\n                else if(points[i][0]==points[j][0])\\n                {\\n                    mp[INT_MAX]++;\\n                }\\n                else\\n                {\\n                    double slope=(double)(points[i][1]-points[j][1])/(double)(points[i][0]-points[j][0]);\\n                    mp[slope]++;\\n                }\\n            }\\n            int currMax=0;\\n            for(auto &i:mp)\\n            {\\n                currMax=max(currMax,i.second);\\n            }\\n            currMax+=samePnt;\\n            res=max(res,currMax);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n### Upvote or I will steal your badges \\uD83D\\uDE0B",
                "solutionTags": [
                    "C++",
                    "Geometry"
                ],
                "code": "```zero```\n```INT_MAX```\n```currMax```\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int res=0;\\n        int n=points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int samePnt=1;\\n            unordered_map<double,int>mp;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(points[i][0]==points[j][0] and points[i][1]==points[j][1])\\n                {\\n                    samePnt++;\\n                }\\n                else if(points[i][0]==points[j][0])\\n                {\\n                    mp[INT_MAX]++;\\n                }\\n                else\\n                {\\n                    double slope=(double)(points[i][1]-points[j][1])/(double)(points[i][0]-points[j][0]);\\n                    mp[slope]++;\\n                }\\n            }\\n            int currMax=0;\\n            for(auto &i:mp)\\n            {\\n                currMax=max(currMax,i.second);\\n            }\\n            currMax+=samePnt;\\n            res=max(res,currMax);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779318,
                "title": "python-9-lines-using-equivalence-classes-for-hashing-slopes-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs hashing of slopes using their equivalence classes with respect to signed GCD. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment.** The idea of this solution is to compute counts for slopes of lines coming from each point and then take the maximum of them (plus one for the point itself). However, hashing slopes is error-prone because they\\'re real numbers in general. Thus, to hash safely, we compute for each point its equivalence class, namely a pair of coordinates `(x,y)` with `GCD(x,y) = 1` and `x >= 0`. This trick allows to use \"integer slopes\", i.e., pairs of coordinates on a lattice which serve as some sort of unit vectors that uniquely describe lines on a lattice.\\n\\n**Python.**\\n```\\nfrom math import gcd\\nfrom numpy import sign\\n\\nclass Solution:\\n    def maxPoints(self, p: List[List[int]], m=1, i=0) -> int:\\n        \\n        for rx, ry in p:\\n            i, slopes = i+1, defaultdict(lambda : 1)\\n            for px, py in p[i:]:\\n                vx, vy = px-rx, py-ry\\n                g = gcd(vx, vy) * sign(vx)\\n                s = (vx//g, vy//g)\\n                slopes[s] += 1\\n                m = max(m, slopes[s])\\n        \\n        return m             \\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import gcd\\nfrom numpy import sign\\n\\nclass Solution:\\n    def maxPoints(self, p: List[List[int]], m=1, i=0) -> int:\\n        \\n        for rx, ry in p:\\n            i, slopes = i+1, defaultdict(lambda : 1)\\n            for px, py in p[i:]:\\n                vx, vy = px-rx, py-ry\\n                g = gcd(vx, vy) * sign(vx)\\n                s = (vx//g, vy//g)\\n                slopes[s] += 1\\n                m = max(m, slopes[s])\\n        \\n        return m             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 641492,
                "title": "javascript-solution-beats-91-with-readable-code",
                "content": "```js\\n/*\\n * @lc app=leetcode id=149 lang=javascript\\n *\\n * [149] Max Points on a Line\\n */\\n\\n// @lc code=start\\n\\nvar getGCD = function(a, b) {\\n    return b === 0 ? a : getGCD(b, a % b);\\n}\\n\\nvar getSlope = function (p1, p2) {\\n    var xDiff = p1[0] - p2[0];\\n    var yDiff = p1[1] - p2[1];\\n    if (xDiff === 0) return \\'y\\';\\n    if (yDiff === 0) return \\'x\\';\\n    var gcd = getGCD(xDiff, yDiff);\\n    xDiff /= gcd;\\n    yDiff /= gcd;\\n    return `${xDiff}/${yDiff}`;\\n}\\n\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar maxPoints = function(points) {\\n    var len = points.length;\\n    if (len < 3) return len;\\n    var max = 0;\\n    for (var i = 0; i < len; i++) {\\n        var map = new Map();\\n        var sameCount = 0;\\n        var curMax = 0;\\n        for (var j = i + 1; j < len; j++) {\\n            if (points[j][0] === points[i][0] && points[j][1] === points[i][1]) {\\n                sameCount++;\\n                continue;\\n            }\\n            var slope = getSlope(points[i], points[j]);\\n            if (!map.has(slope)) map.set(slope, 1);\\n            else map.set(slope, map.get(slope) + 1);\\n            curMax = Math.max(curMax, map.get(slope));\\n        }\\n        max = Math.max(max, curMax + sameCount + 1);\\n    }\\n    return max;\\n};\\n\\n\\n// console.log(maxPoints([[0,0],[1,1],[0,0]]))\\n// console.log(maxPoints([[1,1],[1,1],[1,1]]))\\n// console.log(maxPoints([[4,0],[4,-1],[4,5]]))\\n// console.log(maxPoints([[1,1],[2,2],[3,3]]))\\n// console.log(maxPoints([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]))\\n// console.log(maxPoints([[0,0],[94911151,94911150],[94911152,94911151]]))\\n\\n\\n// @lc code=end\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/*\\n * @lc app=leetcode id=149 lang=javascript\\n *\\n * [149] Max Points on a Line\\n */\\n\\n// @lc code=start\\n\\nvar getGCD = function(a, b) {\\n    return b === 0 ? a : getGCD(b, a % b);\\n}\\n\\nvar getSlope = function (p1, p2) {\\n    var xDiff = p1[0] - p2[0];\\n    var yDiff = p1[1] - p2[1];\\n    if (xDiff === 0) return \\'y\\';\\n    if (yDiff === 0) return \\'x\\';\\n    var gcd = getGCD(xDiff, yDiff);\\n    xDiff /= gcd;\\n    yDiff /= gcd;\\n    return `${xDiff}/${yDiff}`;\\n}\\n\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar maxPoints = function(points) {\\n    var len = points.length;\\n    if (len < 3) return len;\\n    var max = 0;\\n    for (var i = 0; i < len; i++) {\\n        var map = new Map();\\n        var sameCount = 0;\\n        var curMax = 0;\\n        for (var j = i + 1; j < len; j++) {\\n            if (points[j][0] === points[i][0] && points[j][1] === points[i][1]) {\\n                sameCount++;\\n                continue;\\n            }\\n            var slope = getSlope(points[i], points[j]);\\n            if (!map.has(slope)) map.set(slope, 1);\\n            else map.set(slope, map.get(slope) + 1);\\n            curMax = Math.max(curMax, map.get(slope));\\n        }\\n        max = Math.max(max, curMax + sameCount + 1);\\n    }\\n    return max;\\n};\\n\\n\\n// console.log(maxPoints([[0,0],[1,1],[0,0]]))\\n// console.log(maxPoints([[1,1],[1,1],[1,1]]))\\n// console.log(maxPoints([[4,0],[4,-1],[4,5]]))\\n// console.log(maxPoints([[1,1],[2,2],[3,3]]))\\n// console.log(maxPoints([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]))\\n// console.log(maxPoints([[0,0],[94911151,94911150],[94911152,94911151]]))\\n\\n\\n// @lc code=end\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 450896,
                "title": "python-slope-counter-with-gcd",
                "content": "The intuition of this problem is quite straightforward: just iterate over each pair `(x1, y1), (x2, y2)`, store the slope into a slope counter. The tricky point is just how to represent the slope.\\n\\nDue to the precison of float point number, one cannot directly use `(y2 - y1) / (x2 - x1)` to store the slope; thus, we must store the slope as a fraction of `(dy, dx)`, and we need to make sure the fraction with common factor can be simplified, which is done by `gcd`.\\n\\n``` python \\nclass Solution:\\n    def maxPoints(self, points):\\n        \"\"\"\\n        :type points: List[Point]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t\\n\\t\\t# We first remove duplicate points to make life easier\\n        point_counter = collections.Counter(map(tuple, points))\\n        points = list(point_counter.keys())\\n        \\n        maxpoint = 0\\n        for i, (x1, y1) in enumerate(points):\\n            slope_counter = collections.Counter({(0, 0): 0})\\n            for j in range(i + 1, len(points)):\\n                x2, y2 = points[j]\\n\\t\\t\\t\\t# for each pair of (x1, y1) and (x2, y2), compute slope as (dx // gcd, dy // gcd)\\n                slope_counter[_slope(x2 - x1, y2 - y1)] += point_counter[(x2, y2)]\\n            \\n            maxpoint = max(maxpoint, max(slope_counter.values()) + point_counter[(x1, y1)])\\n        \\n        return maxpoint\\n\\ndef _gcd(a, b):\\n    while b:\\n        a, b = b, a % b\\n    return a\\n    \\ndef _slope(dx, dy):\\n    gcd = _gcd(dx, dy)\\n    return (dx // gcd, dy // gcd)\\n```",
                "solutionTags": [],
                "code": "``` python \\nclass Solution:\\n    def maxPoints(self, points):\\n        \"\"\"\\n        :type points: List[Point]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t\\n\\t\\t# We first remove duplicate points to make life easier\\n        point_counter = collections.Counter(map(tuple, points))\\n        points = list(point_counter.keys())\\n        \\n        maxpoint = 0\\n        for i, (x1, y1) in enumerate(points):\\n            slope_counter = collections.Counter({(0, 0): 0})\\n            for j in range(i + 1, len(points)):\\n                x2, y2 = points[j]\\n\\t\\t\\t\\t# for each pair of (x1, y1) and (x2, y2), compute slope as (dx // gcd, dy // gcd)\\n                slope_counter[_slope(x2 - x1, y2 - y1)] += point_counter[(x2, y2)]\\n            \\n            maxpoint = max(maxpoint, max(slope_counter.values()) + point_counter[(x1, y1)])\\n        \\n        return maxpoint\\n\\ndef _gcd(a, b):\\n    while b:\\n        a, b = b, a % b\\n    return a\\n    \\ndef _slope(dx, dy):\\n    gcd = _gcd(dx, dy)\\n    return (dx // gcd, dy // gcd)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47137,
                "title": "clean-python-code",
                "content": "This problem has two points to note:\\n\\n - point in `points` may be duplicate.\\n - use `a*y + b*x + c = 0` to represent a line, not `y = k*x + b`, because `k` and `b` may be float number, and float numbers can't be compared with `=`.  Two equal `key` in hash table representing `line` may differ.\\n\\n.\\n\\n    class Solution(object):\\n        def gcd(self, a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n    \\n        def maxPoints(self, points):\\n            if not points:\\n                return 0\\n    \\n            points = map(lambda p: (p.x, p.y), points)\\n    \\n            counter, points, lines = (\\n                collections.Counter(points), list(set(points)),\\n                collections.defaultdict(set))\\n    \\n            for i in xrange(len(points)):\\n                for j in xrange(i + 1, len(points)):\\n                    (x1, y1), (x2, y2) = points[i], points[j]\\n    \\n                    a, b, c = x1 - x2, y2 - y1, x2 * y1 - x1 * y2\\n                    if a < 0 or a == 0 and b < 0:\\n                        a, b, c = -a, -b, -c\\n    \\n                    gcd = self.gcd(self.gcd(abs(a), abs(b)), abs(c))\\n                    lines[(a / gcd, b / gcd, c / gcd)] |= {points[i], points[j]}\\n    \\n            return max([\\n                sum([counter[p] for p in ps])\\n                for ps in lines.values()\\n            ] + counter.values())",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n        def gcd(self, a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n    \\n        def maxPoints(self, points):\\n            if not points:\\n                return 0\\n    \\n            points = map(lambda p: (p.x, p.y), points)\\n    \\n            counter, points, lines = (\\n                collections.Counter(points), list(set(points)),\\n                collections.defaultdict(set))\\n    \\n            for i in xrange(len(points)):\\n                for j in xrange(i + 1, len(points)):\\n                    (x1, y1), (x2, y2) = points[i], points[j]\\n    \\n                    a, b, c = x1 - x2, y2 - y1, x2 * y1 - x1 * y2\\n                    if a < 0 or a == 0 and b < 0:\\n                        a, b, c = -a, -b, -c\\n    \\n                    gcd = self.gcd(self.gcd(abs(a), abs(b)), abs(c))\\n                    lines[(a / gcd, b / gcd, c / gcd)] |= {points[i], points[j]}",
                "codeTag": "Java"
            },
            {
                "id": 47253,
                "title": "52ms-python-solution-o-n-2-with-point-dedup",
                "content": "Basically the same N square solution. Used a map to merge identical points to speed up the double loop.\\n\\nRunning time 52 ms above 100% rest submissions in Python category (I know the float key in hash sucks :-)).\\n\\n    # Definition for a point.\\n    # class Point(object):\\n    #     def __init__(self, a=0, b=0):\\n    #         self.x = a\\n    #         self.y = b\\n    \\n    class Solution(object):\\n        def maxPoints(self, points):\\n            \"\"\"\\n            :type points: List[Point]\\n            :rtype: int\\n            \"\"\"\\n            if len(points) == 0:\\n                return 0\\n            mm = {}\\n            for p in points:\\n                mm[(p.x,p.y)] = mm.get((p.x,p.y), 0) + 1\\n            P = mm.keys()    \\n            if len(P) == 1:\\n                return mm[P[0]]\\n            maxP = 0\\n            for i in xrange(len(P)-1):\\n                slopes,repCnt = {},1\\n                for j in xrange(i+1,len(P)):\\n                    dx,dy = P[i][0]-P[j][0],P[i][1]-P[j][1]\\n                    if dx == 0:\\n                        slope = \"#\"\\n                    elif dy == 0:\\n                        slope = 0\\n                    else:\\n                        slope = float(dy) / dx\\n                    slopes[slope] = slopes.get(slope,0) + mm[P[j]]\\n                maxP = max(maxP, mm[P[i]] + max(slopes.values()))\\n            return maxP",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def maxPoints(self, points):\\n            \"\"\"\\n            :type points: List[Point]\\n            :rtype: int\\n            \"\"\"\\n            if len(points) == 0:\\n                return 0\\n            mm = {}",
                "codeTag": "Java"
            },
            {
                "id": 3016317,
                "title": "implementation-using-c",
                "content": "\\n\\n```\\npublic class Solution {\\n    public int MaxPoints(int[][] points) {\\n        int n = points.Length;\\n        if (n == 1) {\\n            return 1;\\n        }\\n        int result = 2;\\n        for (int i = 0; i < n; ++i) {\\n            var cnt = new Dictionary<double, int>();\\n            for (int j = 0; j < n; ++j) {\\n                if (j != i) {\\n                    var angle = Math.Atan2(points[j][1] - points[i][1], points[j][0] - points[i][0]);\\n                    cnt[angle] = cnt.GetValueOrDefault(angle, 0) + 1;\\n                }\\n            }\\n            result = Math.Max(result, cnt.Values.Max() + 1);\\n        }\\n        return result;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxPoints(int[][] points) {\\n        int n = points.Length;\\n        if (n == 1) {\\n            return 1;\\n        }\\n        int result = 2;\\n        for (int i = 0; i < n; ++i) {\\n            var cnt = new Dictionary<double, int>();\\n            for (int j = 0; j < n; ++j) {\\n                if (j != i) {\\n                    var angle = Math.Atan2(points[j][1] - points[i][1], points[j][0] - points[i][0]);\\n                    cnt[angle] = cnt.GetValueOrDefault(angle, 0) + 1;\\n                }\\n            }\\n            result = Math.Max(result, cnt.Values.Max() + 1);\\n        }\\n        return result;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016275,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//Prerequisites: Basic Coordinate Geometry\\nclass point{\\n    public:\\n    double x,y;\\n    point(double x,double y){\\n        this->x=x;\\n        this->y=y;\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool isCollinear(point a,point b,point c){//checks if three given points lie on a same line\\n        double m1=(b.y-a.y)/(b.x-a.x);\\n        double m2=(c.y-b.y)/(c.x-b.x);\\n        return m1==m2;\\n    }\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=2){//2 or less than two points are always collinear\\n            return n;\\n        }\\n        vector<point> coordinates;\\n        for(auto& i:points){\\n            point k=point((double)i[0],(double)i[1]);\\n            coordinates.push_back(k);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int cnt=0;\\n                for(int k=0;k<n;k++){\\n                    if(i!=j&&j!=k&&i!=k){\\n                        if(isCollinear(coordinates[i],coordinates[j],coordinates[k])){\\n                            cnt++;\\n                        }\\n                    }\\n                }\\n                ans=max(cnt+2,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\n//Prerequisites: Basic Coordinate Geometry\\nclass point{\\n    public:\\n    double x,y;\\n    point(double x,double y){\\n        this->x=x;\\n        this->y=y;\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool isCollinear(point a,point b,point c){//checks if three given points lie on a same line\\n        double m1=(b.y-a.y)/(b.x-a.x);\\n        double m2=(c.y-b.y)/(c.x-b.x);\\n        return m1==m2;\\n    }\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=2){//2 or less than two points are always collinear\\n            return n;\\n        }\\n        vector<point> coordinates;\\n        for(auto& i:points){\\n            point k=point((double)i[0],(double)i[1]);\\n            coordinates.push_back(k);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int cnt=0;\\n                for(int k=0;k<n;k++){\\n                    if(i!=j&&j!=k&&i!=k){\\n                        if(isCollinear(coordinates[i],coordinates[j],coordinates[k])){\\n                            cnt++;\\n                        }\\n                    }\\n                }\\n                ans=max(cnt+2,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585883,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // take every point and find the slope with other points\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // declare a map which will store the frequency of each slope\\n            \\n            unordered_map<double, int> mp;\\n            \\n            int temp_max = 0;\\n            \\n            int x1 = arr[i][0];\\n            \\n            int y1 = arr[i][1];\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(j == i)\\n                {\\n                    continue;\\n                }\\n                \\n                int x2 = arr[j][0];\\n                \\n                int y2 = arr[j][1];\\n                \\n                double nume = y2 - y1;\\n                \\n                double deno = x2 - x1;\\n                \\n                // if denominator will be zero then slope will be INT_MAX\\n                \\n                if(deno == 0)\\n                {\\n                    mp[INT_MAX]++;\\n                    \\n                    // update temp_max\\n                    \\n                    temp_max = max(temp_max, mp[INT_MAX]);\\n                    \\n                    continue;\\n                }\\n                \\n                // find the slope and update frequency\\n                \\n                double slope = nume / deno;\\n                \\n                mp[slope]++;\\n                \\n                temp_max = max(temp_max, mp[slope]);\\n            }\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, temp_max + 1);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // take every point and find the slope with other points\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // declare a map which will store the frequency of each slope\\n            \\n            unordered_map<double, int> mp;\\n            \\n            int temp_max = 0;\\n            \\n            int x1 = arr[i][0];\\n            \\n            int y1 = arr[i][1];\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(j == i)\\n                {\\n                    continue;\\n                }\\n                \\n                int x2 = arr[j][0];\\n                \\n                int y2 = arr[j][1];\\n                \\n                double nume = y2 - y1;\\n                \\n                double deno = x2 - x1;\\n                \\n                // if denominator will be zero then slope will be INT_MAX\\n                \\n                if(deno == 0)\\n                {\\n                    mp[INT_MAX]++;\\n                    \\n                    // update temp_max\\n                    \\n                    temp_max = max(temp_max, mp[INT_MAX]);\\n                    \\n                    continue;\\n                }\\n                \\n                // find the slope and update frequency\\n                \\n                double slope = nume / deno;\\n                \\n                mp[slope]++;\\n                \\n                temp_max = max(temp_max, mp[slope]);\\n            }\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, temp_max + 1);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418570,
                "title": "c-solution-beats-96-slope-in-the-form-of-p-q",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<pair<int, int>, int> mp;\\n        sort(points.begin(), points.end());\\n        int n = points.size();\\n        if (n == 0) return 0;\\n        int ans = 1;\\n        for (int i = 0; i < n; ++i) {\\n            int p = 0, m = 0;\\n            for (int j = i + 1; j < n; ++j) {\\n                if (points[j] == points[i])\\n                    p++;\\n                int x = points[j][0] - points[i][0];\\n                int y = points[j][1] - points[i][1];\\n                if ( x == 0 and y == 0)\\n                    continue;\\n                int g = __gcd(x, y);\\n                pair<int, int> a = {x / g, y / g};\\n                mp[a]++;\\n                m = max(m, mp[a]);\\n                \\n                    \\n            }\\n            ans = max(ans, m + p + 1);\\n            mp.clear();\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<pair<int, int>, int> mp;\\n        sort(points.begin(), points.end());\\n        int n = points.size();\\n        if (n == 0) return 0;\\n        int ans = 1;\\n        for (int i = 0; i < n; ++i) {\\n            int p = 0, m = 0;\\n            for (int j = i + 1; j < n; ++j) {\\n                if (points[j] == points[i])\\n                    p++;\\n                int x = points[j][0] - points[i][0];\\n                int y = points[j][1] - points[i][1];\\n                if ( x == 0 and y == 0)\\n                    continue;\\n                int g = __gcd(x, y);\\n                pair<int, int> a = {x / g, y / g};\\n                mp[a]++;\\n                m = max(m, mp[a]);\\n                \\n                    \\n            }\\n            ans = max(ans, m + p + 1);\\n            mp.clear();\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47205,
                "title": "11ms-java-solution-without-any-map-structure",
                "content": "         public int maxPoints(Point[] points){\\n      if(points == null || points.length == 0){\\n          return 0;\\n      }\\n      \\n      if(points.length <= 2){\\n          return points.length;\\n      }\\n      \\n      int ret = 0;\\n      \\n      int n = points.length;\\n      int count = 0; \\n      int duplicates = 0;\\n      \\n      for(int i = 0; i < n; i++){\\n          Point p = points[i];\\n          count = 0;\\n          duplicates = 0;\\n          \\n          for(int j = i + 1; j < n; j++){\\n              Point q = points[j];\\n              if(q.x == p.x && q.y == p.y){\\n                  duplicates++;\\n                  ret = Math.max(ret, duplicates + 1);\\n                  continue;\\n              }\\n              \\n              //count point q\\n              count = 1;\\n              \\n              for(int k = j + 1; k < n; k++){\\n                  Point r = points[k];\\n                  count += isCoLinear(p, q, r)? 1: 0;\\n              }\\n              \\n              //count point p\\n              ret = Math.max(ret, count + duplicates + 1);\\n          }\\n          \\n      }\\n      \\n      return ret;\\n  }\\n\\n     private boolean isCoLinear(Point p, Point q, Point r){\\n      int val = (q.y - p.y) *(r.x - q.x) - (r.y - q.y)*(q.x - p.x);\\n\\t  return val == 0;\\n  }",
                "solutionTags": [],
                "code": "         public int maxPoints(Point[] points){\\n      if(points == null || points.length == 0){\\n          return 0;\\n      }\\n      \\n      if(points.length <= 2){\\n          return points.length;\\n      }\\n      \\n      int ret = 0;\\n      \\n      int n = points.length;\\n      int count = 0; \\n      int duplicates = 0;\\n      \\n      for(int i = 0; i < n; i++){\\n          Point p = points[i];\\n          count = 0;\\n          duplicates = 0;\\n          \\n          for(int j = i + 1; j < n; j++){\\n              Point q = points[j];\\n              if(q.x == p.x && q.y == p.y){\\n                  duplicates++;\\n                  ret = Math.max(ret, duplicates + 1);\\n                  continue;\\n              }\\n              \\n              //count point q\\n              count = 1;\\n              \\n              for(int k = j + 1; k < n; k++){\\n                  Point r = points[k];\\n                  count += isCoLinear(p, q, r)? 1: 0;\\n              }\\n              \\n              //count point p\\n              ret = Math.max(ret, count + duplicates + 1);\\n          }\\n          \\n      }\\n      \\n      return ret;\\n  }\\n\\n     private boolean isCoLinear(Point p, Point q, Point r){\\n      int val = (q.y - p.y) *(r.x - q.x) - (r.y - q.y)*(q.x - p.x);\\n\\t  return val == 0;\\n  }",
                "codeTag": "Unknown"
            },
            {
                "id": 3021777,
                "title": "python-3-o-n-2-logically-explained",
                "content": "**Intuition**\\n\\nThere are nC2 ways in which we can select two points to form a line, we\\'re just hashing that line and finding how many pairs of points form the same unique line. Which can be done easiliy in O(nc2) ~ O(n^2)\\n\\n**Simple step by step solution -**\\n\\ni. Iterate through all points in the array, and for each point, store its slope with respect to every other point in a dictionary. The slope between two points (x1, y1) and (x2, y2) is given by (y2 - y1) / (x2 - x1).\\n\\nii. For each point, find the maximum number of points that have the same slope with respect to that point. This can be done by finding the maximum value in the dictionary of slopes for that point.\\n\\niii. Return the maximum number of points found in step 2. This will be the maximum number of points that lie on the same straight line.\\n\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        max_points = 0\\n        for i in range(len(points)):\\n            slopes = defaultdict(int)\\n            slopes[\\'a\\'] = 0\\n            same_points = 1\\n            for j in range(i + 1, len(points)):\\n                if points[i] == points[j]:\\n                    same_points += 1\\n                    continue\\n                slope = float(\\'inf\\') if points[i][0] == points[j][0] else (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\\n                slopes[slope] += 1\\n            a = max(slopes.values())\\n            max_points = max(max_points, a + same_points)\\n        return max_points\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        max_points = 0\\n        for i in range(len(points)):\\n            slopes = defaultdict(int)\\n            slopes[\\'a\\'] = 0\\n            same_points = 1\\n            for j in range(i + 1, len(points)):\\n                if points[i] == points[j]:\\n                    same_points += 1\\n                    continue\\n                slope = float(\\'inf\\') if points[i][0] == points[j][0] else (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\\n                slopes[slope] += 1\\n            a = max(slopes.values())\\n            max_points = max(max_points, a + same_points)\\n        return max_points\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019658,
                "title": "c-using-hash-pair-unordered-map-pair-int-int-int-must-watch",
                "content": "* **M1** \\n```c++\\nstruct hash_pair {\\n    template <class T1, class T2>\\n    size_t operator()(const pair<T1, T2>& p) const{\\n        auto hash1 = hash<T1>{}(p.first);\\n        auto hash2 = hash<T2>{}(p.second);\\n        return hash1 ^ hash2 ;\\n    }\\n};\\n\\nclass Solution {\\n    typedef pair<int,int> pii;\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size(), mx,my,x2,y2 ,ans = 0;\\n        for(int i = 0;i<n;i++){\\n            unordered_map<pii,int, hash_pair> mp;\\n            for(int j = 0;j<n;j++){\\n                if(i==j) continue;\\n                my = p[j][1]-p[i][1], mx = p[j][0]-p[i][0];\\n                int x = __gcd(my,mx);\\n                ans = max(ans,++mp[{my/x,mx/x}]);\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```\\n* **M2** \\n* EASY VERSION OF M1\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size(), mx,my,x2,y2 ,ans = 0;\\n        for(int i = 0;i<n;i++){\\n            unordered_map<double,int> mp;\\n            for(int j = 0;j<n;j++){\\n                if(i==j) continue;\\n                ans = max(ans,++mp[(p[j][1]-p[i][1])*1.0/(p[j][0]-p[i][0])]);\\n            }\\n        }\\n        // cout<<((4*1.00)/0);  outputs inf. \\n        return ans+1;\\n    }\\n};\\n```\\n* **M3** \\n* **TLE**\\n* **LINE Method**\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size(),my,mx,x1,y1,ans = 1;\\n        for(int i = 0;i<n;i++){\\n            x1 = p[i][0], y1 = p[i][1];\\n            for(int k = i+1;k<n;k++){\\n                my = p[k][1]-p[i][1], mx = p[k][0]-p[i][0];\\n                int temp = 0;\\n                for(auto it:p) mx*(it[1]-y1) == my*(it[0]-x1)? temp++ :0;\\n                ans = max(ans,temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nstruct hash_pair {\\n    template <class T1, class T2>\\n    size_t operator()(const pair<T1, T2>& p) const{\\n        auto hash1 = hash<T1>{}(p.first);\\n        auto hash2 = hash<T2>{}(p.second);\\n        return hash1 ^ hash2 ;\\n    }\\n};\\n\\nclass Solution {\\n    typedef pair<int,int> pii;\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size(), mx,my,x2,y2 ,ans = 0;\\n        for(int i = 0;i<n;i++){\\n            unordered_map<pii,int, hash_pair> mp;\\n            for(int j = 0;j<n;j++){\\n                if(i==j) continue;\\n                my = p[j][1]-p[i][1], mx = p[j][0]-p[i][0];\\n                int x = __gcd(my,mx);\\n                ans = max(ans,++mp[{my/x,mx/x}]);\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size(), mx,my,x2,y2 ,ans = 0;\\n        for(int i = 0;i<n;i++){\\n            unordered_map<double,int> mp;\\n            for(int j = 0;j<n;j++){\\n                if(i==j) continue;\\n                ans = max(ans,++mp[(p[j][1]-p[i][1])*1.0/(p[j][0]-p[i][0])]);\\n            }\\n        }\\n        // cout<<((4*1.00)/0);  outputs inf. \\n        return ans+1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size(),my,mx,x1,y1,ans = 1;\\n        for(int i = 0;i<n;i++){\\n            x1 = p[i][0], y1 = p[i][1];\\n            for(int k = i+1;k<n;k++){\\n                my = p[k][1]-p[i][1], mx = p[k][0]-p[i][0];\\n                int temp = 0;\\n                for(auto it:p) mx*(it[1]-y1) == my*(it[0]-x1)? temp++ :0;\\n                ans = max(ans,temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3019411,
                "title": "simple-c-beats-100-slope-approach-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust Simple maths find the slope of lines and then store the slopes the one having max occurences will be our answer if many lines are correspondig to a  slope then answer is just its ocurrneces +1 beacuse we have to return points .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple check all the combinations using two loops and count the slopes in a map store all the occurences of a slope and at last that slope which has maximum occurences will be answer just do +1 is answer because slope is between two points so  first point is not counted as we compare *(x1,y1) with (x2,y2) with (x3,y3).*.. and so on but on first comparison count is 1 but those are two points so we have to return *ans+1* .\\n***Formula for slope : (y2-y1)/(x2-x1)***\\n**Note:** Only in Case there is infinity slope take absloute of infinity because -inf and +inf is same thing here because no mater what y1 and y2 is if x1==x2 denominator is zero so it will be just infinity but compiler will take it as +inf and -inf as per y1 and y2 so take abs(inf)\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& pt) {\\n         int ans=1; \\n        int n=pt.size();\\n        for(int i=0;i<n-1;i++){\\n            map<double,int> mp;\\n            for(int j=i+1;j<n;j++){\\n                double x2=pt[j][0],x1=pt[i][0];\\n                double y2=pt[j][1],y1=pt[i][1];\\n                double slope =(y2-y1)/(x2-x1);\\n                if(pt[j][1]-pt[i][1]<0 &&(pt[j][0]-pt[i][0])==0 ) \\n                mp[abs(slope)]++; \\n                else\\n                    mp[slope]++;\\n            }\\n            int temp = 0;\\n            for(auto it:mp)\\n                temp = max(temp, it.second); \\n            ans = max(temp+1, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& pt) {\\n         int ans=1; \\n        int n=pt.size();\\n        for(int i=0;i<n-1;i++){\\n            map<double,int> mp;\\n            for(int j=i+1;j<n;j++){\\n                double x2=pt[j][0],x1=pt[i][0];\\n                double y2=pt[j][1],y1=pt[i][1];\\n                double slope =(y2-y1)/(x2-x1);\\n                if(pt[j][1]-pt[i][1]<0 &&(pt[j][0]-pt[i][0])==0 ) \\n                mp[abs(slope)]++; \\n                else\\n                    mp[slope]++;\\n            }\\n            int temp = 0;\\n            for(auto it:mp)\\n                temp = max(temp, it.second); \\n            ans = max(temp+1, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018879,
                "title": "c-beats-approx-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Solve using calculating Slopes\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We will select point and for every selected point we will calculate the slope with respect to another point and store into the map.\\n- Then, find the max number of points having the same slope with respect to that selected point :-means which slope have maximum point\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int ans=1; \\n        int n=points.size();\\n        sort(points.begin(),points.end());\\n       // slope of every point with selected point\\n       for(int i=0;i<n-1;i++)\\n       {\\n           map<double,int> slope;\\n           for(int j=i+1;j<n;j++)\\n           {\\n               if(points[i][1]==points[j][1])\\n                    slope[INT_MAX]++;// for perpendicular line\\n               else\\n               {\\n                   double x=(double)(points[j][0]-points[i][0])/(double)(points[j][1]-points[i][1]);\\n                   slope[x]++;\\n               }\\n           }\\n           // same slope w.r.t.that selected point\\n            int temp = 0;\\n            for(auto it:slope)\\n                temp = max(temp, it.second+1);    // +1 for the current point(point itself)\\n            ans = max(temp, ans);\\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int ans=1; \\n        int n=points.size();\\n        sort(points.begin(),points.end());\\n       // slope of every point with selected point\\n       for(int i=0;i<n-1;i++)\\n       {\\n           map<double,int> slope;\\n           for(int j=i+1;j<n;j++)\\n           {\\n               if(points[i][1]==points[j][1])\\n                    slope[INT_MAX]++;// for perpendicular line\\n               else\\n               {\\n                   double x=(double)(points[j][0]-points[i][0])/(double)(points[j][1]-points[i][1]);\\n                   slope[x]++;\\n               }\\n           }\\n           // same slope w.r.t.that selected point\\n            int temp = 0;\\n            for(auto it:slope)\\n                temp = max(temp, it.second+1);    // +1 for the current point(point itself)\\n            ans = max(temp, ans);\\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016188,
                "title": "daily-leetcoding-challenge-january-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/max-points-on-a-line/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/max-points-on-a-line/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2994261,
                "title": "easiest-solution-using-map-and-slope-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Two points lie on a line when their slope is equal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- To find the maximum number of points that lie on a single line, check lines of all points.\\n- Starting from point 1 count how many points can lie on the line between point 1 and all others.\\n- Similarly repeat this process for all points.\\n- To know if they lie on same line or not, calculate slope and store it in map.\\n- So for every point maintain map and count of points having differnt slopes.\\n- Finally return max points that lie on a line. \\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=2) return n;\\n        int ans = 0;\\n\\n        for(auto it1 : points){\\n            unordered_map<double,int> mp;\\n            double x1 = it1[0], y1 = it1[1];\\n            for(auto it2 : points){   \\n                if(it2 == it1) continue;\\n                double x2 = it2[0], y2 = it2[1];\\n                double slope;\\n                if(x2-x1 == 0){\\n                    slope = INT_MAX; // slope is infinity for vertical line\\n                }else{\\n                    slope = (y2-y1)/(x2-x1);   \\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n        return ans+1; //including point i\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=2) return n;\\n        int ans = 0;\\n\\n        for(auto it1 : points){\\n            unordered_map<double,int> mp;\\n            double x1 = it1[0], y1 = it1[1];\\n            for(auto it2 : points){   \\n                if(it2 == it1) continue;\\n                double x2 = it2[0], y2 = it2[1];\\n                double slope;\\n                if(x2-x1 == 0){\\n                    slope = INT_MAX; // slope is infinity for vertical line\\n                }else{\\n                    slope = (y2-y1)/(x2-x1);   \\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n        return ans+1; //including point i\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419909,
                "title": "simple-and-efficient-solution",
                "content": "Just calculate the slope of every point with selected point and store it in the map then  find the max number of points having the same slope w.r.t. that selected point.\\n\\nPlease upvote...\\n\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int mx = 1, n=points.size();\\n        \\n        for(int i=0;i<n-1;i++){\\n            map<double, int> mp;\\n            for(int j=i+1;j<n;j++){\\n                if(points[j][1]==points[i][1])      mp[-3000]++;    // just random slope to avoid slope of 90 degree\\n                else{ \\n                    double x = (double)(points[j][0]-points[i][0])/(double)(points[j][1]-points[i][1]);\\n                    mp[x]++;\\n                }\\n            }\\n            int temp = 0;\\n            for(auto it:mp)\\n                temp = max(temp, it.second+1);    // +1 for the point[i]\\n            mx = max(temp, mx);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int mx = 1, n=points.size();\\n        \\n        for(int i=0;i<n-1;i++){\\n            map<double, int> mp;\\n            for(int j=i+1;j<n;j++){\\n                if(points[j][1]==points[i][1])      mp[-3000]++;    // just random slope to avoid slope of 90 degree\\n                else{ \\n                    double x = (double)(points[j][0]-points[i][0])/(double)(points[j][1]-points[i][1]);\\n                    mp[x]++;\\n                }\\n            }\\n            int temp = 0;\\n            for(auto it:mp)\\n                temp = max(temp, it.second+1);    // +1 for the point[i]\\n            mx = max(temp, mx);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152319,
                "title": "easy-c-solution-hashmap-slope-formula-90-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==2)\\n            return 2;\\n        int max_points = 0;\\n        \\n        for(int i=0; i<points.size(); i++){\\n            unordered_map <float, int> map;\\n            for(int j=i+1; j<points.size(); j++){\\n                if((points[i][0] - points[j][0]) != 0){\\n                    float m = (float(points[i][1] - points[j][1]) / float(points[i][0] - points[j][0]));\\n                    map[m]++; \\n                    if(map[m]>max_points)\\n                        max_points = map[m];\\n                }\\n                else{\\n                    map[INT_MAX]++;\\n                    if(map[INT_MAX]>max_points)\\n                        max_points = map[INT_MAX];\\n                }\\n            }\\n        }\\n        \\n        return max_points+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==2)\\n            return 2;\\n        int max_points = 0;\\n        \\n        for(int i=0; i<points.size(); i++){\\n            unordered_map <float, int> map;\\n            for(int j=i+1; j<points.size(); j++){\\n                if((points[i][0] - points[j][0]) != 0){\\n                    float m = (float(points[i][1] - points[j][1]) / float(points[i][0] - points[j][0]));\\n                    map[m]++; \\n                    if(map[m]>max_points)\\n                        max_points = map[m];\\n                }\\n                else{\\n                    map[INT_MAX]++;\\n                    if(map[INT_MAX]>max_points)\\n                        max_points = map[INT_MAX];\\n                }\\n            }\\n        }\\n        \\n        return max_points+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886185,
                "title": "c-slope-y2-y1-x2-x1-keep-note-of-vertical-line-also",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size() == 1) return 1;\\n        int ans = 0;\\n        for(auto &it : points){\\n            unordered_map<double,int> mp;\\n            double x1 = it[0], y1 = it[1];\\n            for(auto &i : points){\\n                if(i == it) continue;\\n                double x2 = i[0], y2 = i[1];\\n                double curr_slope;\\n                if(x2-x1 == 0){\\n                    curr_slope = 1e9; // if line is vertical \\n                }else{\\n                    curr_slope = (y2-y1)/(x2-x1);   \\n                }\\n                mp[curr_slope]++;\\n                ans = max(ans,mp[curr_slope]);\\n            }\\n        }\\n        return ans+1; // ans + 1 is becuase the first point of line was not counted before\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size() == 1) return 1;\\n        int ans = 0;\\n        for(auto &it : points){\\n            unordered_map<double,int> mp;\\n            double x1 = it[0], y1 = it[1];\\n            for(auto &i : points){\\n                if(i == it) continue;\\n                double x2 = i[0], y2 = i[1];\\n                double curr_slope;\\n                if(x2-x1 == 0){\\n                    curr_slope = 1e9; // if line is vertical \\n                }else{\\n                    curr_slope = (y2-y1)/(x2-x1);   \\n                }\\n                mp[curr_slope]++;\\n                ans = max(ans,mp[curr_slope]);\\n            }\\n        }\\n        return ans+1; // ans + 1 is becuase the first point of line was not counted before\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672166,
                "title": "simple-c-solution-with-comments",
                "content": "Approach:\\ni) If the no of points is less than or equal to 2, then that particular no is the answer.\\nii) For each point, we find out \\n\\t\\ta) how many duplicates it have\\n\\t\\tb) how many points lie on the same x-axis as that point\\n\\t\\tc) which slope of that point has the maximum no of points in it\\n\\tFor these reasons, every point has its own map and other variables.\\niii) After checking all other points from i+1 to n-1 for i-th point, the answer is compared\\n\\twith previous maximum ans and if the new localAns is maximum, it is stored in the ans.\\n```\\nint maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n <= 2)\\n            return n;\\n        int ans = 0;\\n        for(int i=0; i< n; i++){\\n            int local = 1;          //To hold the local result\\n            int vertical = 1;      // To check if both points are on the same line on x axis\\n            int duplicate = 0;     //To keep count of duplicates\\n            unordered_map<long double,int> um;\\n            for(int j=i+1;j<n; j++){\\n                int x1 = points[i][0];\\n                int y1 = points[i][1];\\n                int x2 = points[j][0];\\n                int y2 = points[j][1];\\n                if(x2 == x1 && y2 == y1)\\n                    duplicate++;\\n                else if(x2 - x1 == 0)\\n                    vertical++;\\n                else{\\n                    long double numerator = (y2-y1);\\n                    long double denominator = (x2-x1);\\n                    long double slope = numerator/denominator; //Formula to find out slope\\n                    if(um[slope] == 0)\\n                        um[slope] = 2;\\n                    else\\n                        um[slope]++;\\n                    \\n                    local = max(local,um[slope]);     // Check if the current slope has max no of points\\n                                                     //or the previous slope had the most no of points\\n                }\\n            }\\n            local = max(local+duplicate,vertical+duplicate);  //Adding the duplicates while checking as those will fetch similar results\\n            ans = max(ans,local);\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n <= 2)\\n            return n;\\n        int ans = 0;\\n        for(int i=0; i< n; i++){\\n            int local = 1;          //To hold the local result\\n            int vertical = 1;      // To check if both points are on the same line on x axis\\n            int duplicate = 0;     //To keep count of duplicates\\n            unordered_map<long double,int> um;\\n            for(int j=i+1;j<n; j++){\\n                int x1 = points[i][0];\\n                int y1 = points[i][1];\\n                int x2 = points[j][0];\\n                int y2 = points[j][1];\\n                if(x2 == x1 && y2 == y1)\\n                    duplicate++;\\n                else if(x2 - x1 == 0)\\n                    vertical++;\\n                else{\\n                    long double numerator = (y2-y1);\\n                    long double denominator = (x2-x1);\\n                    long double slope = numerator/denominator; //Formula to find out slope\\n                    if(um[slope] == 0)\\n                        um[slope] = 2;\\n                    else\\n                        um[slope]++;\\n                    \\n                    local = max(local,um[slope]);     // Check if the current slope has max no of points\\n                                                     //or the previous slope had the most no of points\\n                }\\n            }\\n            local = max(local+duplicate,vertical+duplicate);  //Adding the duplicates while checking as those will fetch similar results\\n            ans = max(ans,local);\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375601,
                "title": "one-point-doesn-t-make-a-line",
                "content": "The test case of \\n```Input\\n[[0,0]]\\nOutput\\n0\\nExpected\\n1\\n```\\nis incorrect. As one point doesn\\'t make a line! \\n",
                "solutionTags": [],
                "code": "```Input\\n[[0,0]]\\nOutput\\n0\\nExpected\\n1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328729,
                "title": "swift-o-n-2-85-beat-clever-stuff-doesn-t-work-with-slope-haxor",
                "content": "```\\nclass Solution {\\n    \\n    struct LineType: Hashable, Equatable {\\n        \\n        var x: Int = 0\\n        var y: Int = 0\\n        \\n        var hashValue : Int {\\n          get {\\n              return x.hashValue ^ y.hashValue\\n          }\\n        }\\n        \\n        //Note: this doesn\\'t appear to be necessary.\\n        static func == (lhs: LineType, rhs: LineType) -> Bool {\\n            return lhs.x == rhs.x && lhs.y == rhs.y\\n        }\\n    }\\n    \\n    func maxPoints(_ points: [[Int]]) -> Int {\\n        \\n        var result = 0\\n        \\n        for i in 0..<points.count {\\n            \\n            var j = i - 1\\n            \\n            var horCount = 0\\n            var verCount = 0\\n            var sameCount = 0\\n            var slopeCount = 0\\n            \\n            var slopeMap = [LineType: Int]()\\n            \\n            while j >= 0 {\\n                \\n                var dx = points[i][0] - points[j][0]\\n                var dy = points[i][1] - points[j][1]\\n                \\n                if dx == 0 && dy == 0 {\\n                    sameCount += 1\\n                } else if dx == 0 {\\n                    verCount += 1\\n                } else if dy == 0 {\\n                    horCount += 1\\n                } else {\\n                    \\n                    var gcd = 0\\n                    var num1 = dx\\n                    var num2 = dy\\n                    var remainder = 0\\n                    while num1 != 0 {\\n                        remainder = num2 % num1\\n                        num2 = num1\\n                        num1 = remainder\\n                    }\\n                    gcd = num2\\n                    \\n                    var slopeClassification = LineType(x: dx / gcd, y: dy / gcd)\\n                    \\n                    if var count = slopeMap[slopeClassification] {\\n                        count += 1\\n                        slopeMap[slopeClassification] = count\\n                    } else {\\n                        slopeMap[slopeClassification] = 1\\n                    }\\n                    \\n                    if var count = slopeMap[slopeClassification] {\\n                        slopeCount = max(slopeCount, count)\\n                    }\\n                }\\n                j -= 1\\n            }\\n            \\n            var checkResult = max(max(horCount, verCount), slopeCount)\\n            result = max(result, checkResult + sameCount + 1)\\n        }\\n        return result\\n    }\\n}\\n```\\n\\nPlease see C++ result for more detailed explanation. This was a valuable learning experience. I\\'ve learned that tuples are not hashable and not able to be used in dictionaries.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    struct LineType: Hashable, Equatable {\\n        \\n        var x: Int = 0\\n        var y: Int = 0\\n        \\n        var hashValue : Int {\\n          get {\\n              return x.hashValue ^ y.hashValue\\n          }\\n        }\\n        \\n        //Note: this doesn\\'t appear to be necessary.\\n        static func == (lhs: LineType, rhs: LineType) -> Bool {\\n            return lhs.x == rhs.x && lhs.y == rhs.y\\n        }\\n    }\\n    \\n    func maxPoints(_ points: [[Int]]) -> Int {\\n        \\n        var result = 0\\n        \\n        for i in 0..<points.count {\\n            \\n            var j = i - 1\\n            \\n            var horCount = 0\\n            var verCount = 0\\n            var sameCount = 0\\n            var slopeCount = 0\\n            \\n            var slopeMap = [LineType: Int]()\\n            \\n            while j >= 0 {\\n                \\n                var dx = points[i][0] - points[j][0]\\n                var dy = points[i][1] - points[j][1]\\n                \\n                if dx == 0 && dy == 0 {\\n                    sameCount += 1\\n                } else if dx == 0 {\\n                    verCount += 1\\n                } else if dy == 0 {\\n                    horCount += 1\\n                } else {\\n                    \\n                    var gcd = 0\\n                    var num1 = dx\\n                    var num2 = dy\\n                    var remainder = 0\\n                    while num1 != 0 {\\n                        remainder = num2 % num1\\n                        num2 = num1\\n                        num1 = remainder\\n                    }\\n                    gcd = num2\\n                    \\n                    var slopeClassification = LineType(x: dx / gcd, y: dy / gcd)\\n                    \\n                    if var count = slopeMap[slopeClassification] {\\n                        count += 1\\n                        slopeMap[slopeClassification] = count\\n                    } else {\\n                        slopeMap[slopeClassification] = 1\\n                    }\\n                    \\n                    if var count = slopeMap[slopeClassification] {\\n                        slopeCount = max(slopeCount, count)\\n                    }\\n                }\\n                j -= 1\\n            }\\n            \\n            var checkResult = max(max(horCount, verCount), slopeCount)\\n            result = max(result, checkResult + sameCount + 1)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47274,
                "title": "another-accepted-java-solution",
                "content": "A line can be represented as y = k * x + d, it can also be represented as k = (y - d) / x, d = y - k * x. The idea is to find all the possible line representation and count the max one.\\n\\n\\n\\n    public int maxPoints(Point[] points) {\\n      if (points == null || points.length == 0)\\n        return 0;\\n          \\n      int n = points.length, max = 1;\\n      \\n      Map<String, Set<Point>> map = new HashMap<String, Set<Point>>();\\n      \\n      // sort the points by x to avoid -0.0 slope issue!\\n      Collections.sort(Arrays.asList(points), new Comparator<Point>() {\\n        public int compare(Point a, Point b) { return a.x - b.x; }\\n      });\\n      \\n      for (int i = 0; i < n; i++) {\\n        for (int j = i + 1; j < n; j++) {\\n          Point p1 = points[i];\\n          Point p2 = points[j];\\n          \\n          StringBuilder sb = new StringBuilder();\\n          \\n          if (p1.x == p2.x) {\\n            sb.append(\"inf\").append(p1.x);\\n          } else {\\n            // y = k * x + d\\n            double k = (double)(p1.y - p2.y) / (p1.x - p2.x);\\n            double d = p1.y - k * p1.x;\\n            sb.append(\"k\").append(k).append(\"d\").append(d);\\n          }\\n          \\n          String key = sb.toString();\\n          Set<Point> set = map.containsKey(key) ? map.get(key) : new HashSet<Point>();\\n          \\n          set.add(p1);\\n          set.add(p2);\\n          \\n          map.put(key, set);\\n          max = Math.max(max, set.size());\\n        }\\n      }\\n      \\n      return max;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "A line can be represented as y = k * x + d, it can also be represented as k = (y - d) / x, d = y - k * x. The idea is to find all the possible line representation and count the max one.\\n\\n\\n\\n    public int maxPoints(Point[] points) {\\n      if (points == null || points.length == 0)\\n        return 0;\\n          \\n      int n = points.length, max = 1;\\n      \\n      Map<String, Set<Point>> map = new HashMap<String, Set<Point>>();\\n      \\n      // sort the points by x to avoid -0.0 slope issue!\\n      Collections.sort(Arrays.asList(points), new Comparator<Point>() {\\n        public int compare(Point a, Point b) { return a.x - b.x; }\\n      });\\n      \\n      for (int i = 0; i < n; i++) {\\n        for (int j = i + 1; j < n; j++) {\\n          Point p1 = points[i];\\n          Point p2 = points[j];\\n          \\n          StringBuilder sb = new StringBuilder();\\n          \\n          if (p1.x == p2.x) {\\n            sb.append(\"inf\").append(p1.x);\\n          } else {\\n            // y = k * x + d\\n            double k = (double)(p1.y - p2.y) / (p1.x - p2.x);\\n            double d = p1.y - k * p1.x;\\n            sb.append(\"k\").append(k).append(\"d\").append(d);\\n          }\\n          \\n          String key = sb.toString();\\n          Set<Point> set = map.containsKey(key) ? map.get(key) : new HashSet<Point>();\\n          \\n          set.add(p1);\\n          set.add(p2);\\n          \\n          map.put(key, set);\\n          max = Math.max(max, set.size());\\n        }\\n      }\\n      \\n      return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 47273,
                "title": "solution-in-java-without-hashing-and-floats",
                "content": "The idea is to get two points and than find other points on the line. See comments.\\n\\n    public int maxPoints(Point[] points) {\\n\\t\\tif (points.length < 3) {\\n\\t\\t\\treturn points.length;\\n\\t\\t}\\n\\t\\tint max = 0;\\n\\t\\tfor (int a = 0; a<points.length-2; a++) {\\n\\t\\t\\tboolean[] checked = new boolean[points.length];\\n\\t\\t\\tfor (int b = a+1; b<points.length; b++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Do not check the same line\\n\\t\\t\\t\\tif (checked[b]) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// The point-b should differ from point-a\\n\\t\\t\\t\\twhile (b < points.length && points[b].x == points[a].x && points[b].y == points[a].y) {\\n\\t\\t\\t\\t\\tb++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Count all point between point-a and point-b \\n\\t\\t\\t\\t// witch have the same coordinates as point-a\\n\\t\\t\\t\\tint count = b == points.length ? 1 : 2;\\n\\t\\t\\t\\tfor (int i=a+1; i<b; i++) {\\n\\t\\t\\t\\t\\tif (points[i].x == points[a].x && points[i].y == points[a].y) {\\n\\t\\t\\t\\t\\t\\tcount++ ;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Count point-c if it lies on the point-a-point-b-line.\\n\\t\\t\\t\\tfor (int c = b+1; c<points.length; c++) {\\n\\t\\t\\t\\t\\tif (isOnLine(points[a], points[b], points[c])) {\\n\\t\\t\\t\\t\\t\\tcount++ ;\\n\\t\\t\\t\\t\\t\\tchecked[c] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (count > max) {\\n\\t\\t\\t\\t\\tmax = count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return max;\\n    }\\n\\t\\n\\tprivate boolean isOnLine(Point a, Point b, Point c) {\\n\\t\\treturn (b.y - a.y)*(c.x - a.x) == (c.y - a.y)*(b.x - a.x);\\n\\t}",
                "solutionTags": [],
                "code": "The idea is to get two points and than find other points on the line. See comments.\\n\\n    public int maxPoints(Point[] points) {\\n\\t\\tif (points.length < 3) {\\n\\t\\t\\treturn points.length;\\n\\t\\t}\\n\\t\\tint max = 0;\\n\\t\\tfor (int a = 0; a<points.length-2; a++) {\\n\\t\\t\\tboolean[] checked = new boolean[points.length];\\n\\t\\t\\tfor (int b = a+1; b<points.length; b++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Do not check the same line\\n\\t\\t\\t\\tif (checked[b]) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// The point-b should differ from point-a\\n\\t\\t\\t\\twhile (b < points.length && points[b].x == points[a].x && points[b].y == points[a].y) {\\n\\t\\t\\t\\t\\tb++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Count all point between point-a and point-b \\n\\t\\t\\t\\t// witch have the same coordinates as point-a\\n\\t\\t\\t\\tint count = b == points.length ? 1 : 2;\\n\\t\\t\\t\\tfor (int i=a+1; i<b; i++) {\\n\\t\\t\\t\\t\\tif (points[i].x == points[a].x && points[i].y == points[a].y) {\\n\\t\\t\\t\\t\\t\\tcount++ ;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Count point-c if it lies on the point-a-point-b-line.\\n\\t\\t\\t\\tfor (int c = b+1; c<points.length; c++) {\\n\\t\\t\\t\\t\\tif (isOnLine(points[a], points[b], points[c])) {\\n\\t\\t\\t\\t\\t\\tcount++ ;\\n\\t\\t\\t\\t\\t\\tchecked[c] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (count > max) {\\n\\t\\t\\t\\t\\tmax = count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return max;\\n    }\\n\\t\\n\\tprivate boolean isOnLine(Point a, Point b, Point c) {\\n\\t\\treturn (b.y - a.y)*(c.x - a.x) == (c.y - a.y)*(b.x - a.x);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 47313,
                "title": "o-n-3-solution-can-still-pass-test",
                "content": "Admin,\\n\\nFollowing code, O(n ^ 3), can still pass test. Please add more test cases. Thanks!\\n\\n----------\\n\\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n    \\t\\tint ans = 0;\\n    \\t\\tint n = points.size();\\n    \\t\\t\\n    \\t\\tfor (int i = 0; i < n; ++i) {\\n    \\t\\t\\tint dup = 0;\\n    \\t\\t\\tfor (int j = i + 1; j < n; ++j) {\\n    \\t\\t\\t\\tif (points[i].x == points[j].x && points[i].y == points[j].y) {\\n    \\t\\t\\t\\t\\t++dup;\\n    \\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tint cnt = 2;\\n    \\t\\t\\t\\tfor (int k = j + 1; k < n; ++k) {\\n    \\t\\t\\t\\t\\tif ((points[k].y - points[i].y) * (points[j].x - points[i].x) ==\\n    \\t\\t\\t\\t\\t\\t(points[j].y - points[i].y) * (points[k].x - points[i].x)) {\\n    \\t\\t\\t\\t\\t\\t++cnt;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tans = max(ans, cnt + dup);\\n    \\t\\t\\t}\\n    \\t\\t\\tans = max(ans, dup + 1);\\n    \\t\\t}\\n    \\n    \\t\\treturn ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n    \\t\\tint ans = 0;\\n    \\t\\tint n = points.size();\\n    \\t\\t\\n    \\t\\tfor (int i = 0; i < n; ++i) {\\n    \\t\\t\\tint dup = 0;\\n    \\t\\t\\tfor (int j = i + 1; j < n; ++j) {\\n    \\t\\t\\t\\tif (points[i].x == points[j].x && points[i].y == points[j].y) {\\n    \\t\\t\\t\\t\\t++dup;\\n    \\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 47312,
                "title": "a-neat-solution-in-c-for-ur-information",
                "content": "use slope and translation for each line as the key in map;\\n\\noverload < and == for map. set for counting.\\n\\nmap and set may be little bit slower but the code is clear\\n\\n    #include <map>\\n    #include <set>\\n    #include <algorithm>\\n    using namespace std;\\n    \\n    struct Line {\\n        double r;  // ratio ; slope\\n        double t;  // translation\\n        \\n        Line(Point p, Point q) { // math\\n            if (q.x == p.x) r = 1e20, t = p.x;\\n            else \\n            {\\n                r = (double) (q.y-p.y) / (double) (q.x-p.x);\\n                t = p.y - p.x * r;\\n            }\\n        }\\n    };\\n    \\n    bool operator < (const Line& a, const Line& b) {\\n        return a.r == b.r ? a.t < b.t : a.r < b.r;\\n    }\\n    \\n    bool operator == (const Line& a, const Line& b) {\\n        return a.r == b.r && a.t == b.t;\\n    }\\n    \\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            if (points.empty()) return 0;\\n            \\n            map<Line, set<Point*> > line_map;\\n            for (auto & a : points)\\n            for (auto & b : points)\\n            {\\n                Line line(a,b);\\n                line_map[line].insert(&a);\\n                line_map[line].insert(&b);\\n            }\\n            \\n            int ret = 1;\\n            for (auto & pr : line_map) ret = max(ret,(int)pr.second.size());\\n            \\n            return ret;\\n        }\\n    };\\n\\n\\n----------\\n\\nNov. 20\\n\\nWell, actually shiyan2 raised a very interesting question. I tried to make it faster by add\\n\\n     for (auto & a : points)\\n           for (auto & b : points)\\n           {\\n               if ( (&a) >= (&b) ) continue;\\n               Line line(a,b);\\n               line_map[line].insert(&a);\\n               line_map[line].insert(&b);\\n           }\\n\\nsuppose it will be two times faster than the prev 1.  but it failed on case \\n \\n\\n     [(3,10),(0,2),(0,2),(3,10)]\\n\\nit said the output it 3 rather than 4. And I test on my machine it's 4.\\n\\nAnyone have any clue about this ?\\n\\n\\n----------\\n\\nNov. 25\\n\\nFinally I got answer for the problems on Nov 20. It is due to the type \"double\" accuracy.\\n\\nnow I changed the == and <  to \\n\\n    inline bool double_equal(double a, double b) { return abs(a-b) < 1e-10; }\\n    inline bool double_less (double a, double b) { return a-b < -1e-10; }\\n\\nand it just works well.\\n\\nbut the time is still high, due to the func calling.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            if (points.empty()) return 0;\\n            \\n            map<Line, set<Point*> > line_map;\\n            for (auto & a : points)\\n            for (auto & b : points)\\n            {\\n                Line line(a,b);\\n                line_map[line].insert(&a);\\n                line_map[line].insert(&b);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 47125,
                "title": "share-my-accepted-java-code-with-explanation",
                "content": "        /**\\n     * Definition for a point.\\n     * class Point {\\n     *     int x;\\n     *     int y;\\n     *     Point() { x = 0; y = 0; }\\n     *     Point(int a, int b) { x = a; y = b; }\\n     * }\\n     */\\n    import java.util.HashMap;\\n    public class Solution {\\n        public int maxPoints(Point[] points) {\\n            if (points.length <= 2){\\n                return points.length;\\n            }\\n            int result=1;\\n         \\n          //A line is defined y=a/bx+c, so (a, b, c) will represent a unique line\\n         // run through each point and calculate (a, b, c) that defines the lines of itself \\n         //with all the the remaining points \\n            for (int i=0; i<points.length; i++){\\n                int max=0, countSame=0;\\n                HashMap<String, Integer> hm = new HashMap<String, Integer>();\\n                for (int j=i+1; j<points.length; j++){\\n                    if (points[i].x == points[j].x && points[i].y == points[j].y){\\n                        countSame++;       //same points will just add to the result\\n                    }\\n                    else{\\n                        String key = normalize(points[i],points[j]);\\n                        if(hm.get(key) == null){\\n                            hm.put(key, 1);\\n                            if(max ==0){\\n                                max++;\\n                            }\\n                        }\\n                        else {\\n                           int count = hm.get(key)+1;\\n                           hm.put(key, count);\\n                         \\n                            if (count > max)\\n                                max = count;\\n                        }\\n                    }\\n                    \\n                }\\n                result = Math.max(result, max+countSame+1);\\n            }\\n    \\n            \\n            return result;\\n        }\\n        \\n        //ax+by+c=0 or y=a/b x + c\\n        private String normalize(Point p1, Point p2){\\n            int a, b;\\n            float c;\\n            \\n            if (p1.x == p2.x){  //a line parallel to y axis\\n                a = 1;\\n                b = 0;\\n                c = -1 * p1.x;\\n            }\\n            else if (p1.y == p2.y){ //a line parallel to x axis\\n                a = 0;\\n                b = 1;\\n                c = p1.y;\\n            }\\n            else{\\n                int gcd = gcd(Math.abs(p1.x-p2.x), Math.abs(p1.y-p2.y));\\n                b = (p2.x-p1.x)/gcd;\\n                a = (p2.y-p1.y)/gcd;\\n                if (a*b<0){                   //if the slope<0, always put (-) in front of a \\n                    a = -1 * Math.abs(a);\\n                    b = Math.abs(b); \\n                }\\n                else {\\n                    a = Math.abs(a);\\n                    b = Math.abs(b); \\n                }\\n                c = (float)(b*p1.y - a*p1.x)/(float)b;\\n            }\\n            return \"\"+a+\"||\"+b+\"||\"+c;     //use this presentation as a key\\n            \\n        }\\n        \\n        private int gcd(int x, int y) {\\n            if (y == 0) {\\n              return x;\\n            }\\n            return gcd(y, x % y);\\n      }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxPoints(Point[] points) {\\n            if (points.length <= 2){\\n                return points.length;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3725736,
                "title": "c-python-math-explanation-using-unordered-set-with-custom-hash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnly use integer computations. I reguard this question as a Diophantine problem.\\n\\nSince all points are with integer coefficients, it is very crucial how to parametize such linear equations\\n$$\\nax+by=c\\n$$\\nwhere $a, b, c \\\\in Z$ with $\\\\gcd( a, b, c)=1\\\\ &  \\\\ c>0$. \\nIf the constraint is changed, a linear equation has the following form:\\n$$\\ny=mx+c\\n$$\\nwhere $m\\\\in R\\\\cup\\\\{\\\\infty\\\\}, c\\\\in R$. note that when $m=\\\\infty$, it means $x=d$ for some $d\\\\in R$. Use this approach, there is no need for computation for gcds but using float computation.\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n![binary_line0.png](https://assets.leetcode.com/users/images/afecb0bb-e83d-41af-91e6-c8cf4cbefc64_1688826474.8209305.png)\\nSome modififications should be made! 2 different tuples $(a, b, c)$ and $(a\\', b\\', c\\')$ represent the same line and are similar $\\\\iff$\\n$$ \\\\exists d\\\\in Z \\\\ & \\\\ d\\\\not= 0 : (a, b, c)=(da\\', db\\', dc\\')\\n$$\\nOne way to find the representative for all similar tuples is to choose $(a, b, c)$ such tat $\\\\gcd(a, b,c)=1$ with the following conditions: (It should be noticed that it may happen that c=0 what is not to ignore! )\\n```\\nint d = gcd(a, b); //c is an integer linear combination of a & b therefore d|c\\na /= d, b /= d, c /= d;\\nif (c < 0) {\\n      a = -a, b = -b, c = -c;\\n}\\nelse if (c==0){ // This can occur!\\n    if (b<0 || (a<0 && b==0)) a=-a, b=-b;\\n}\\n```\\n\\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n   struct Myhash {\\n        size_t operator()(const vector<int>& vec) const {\\n            size_t digest = 0;\\n            auto f=hash<int>();\\n            for (const auto& v : vec) {\\n                digest = f(digest^v);\\n            }\\n            return digest;\\n        }\\n    };\\n    unordered_map<vector<int>, unordered_set<int>, Myhash> L;\\n\\n    void line(vector<vector<int>>& points, int i, int j) {\\n        int x0 = points[i][0], y0 = points[i][1];\\n        int x1 = points[j][0], y1 = points[j][1];\\n        int a = y1 - y0;\\n        int b = x0 - x1;\\n        int c = x0 * a + y0 * b;\\n        int d = gcd(a, b); //c is an integer linear combination of a & b therefore d|c\\n        a /= d, b /= d, c /= d;\\n        if (c < 0) {\\n            a = -a, b = -b, c = -c;\\n        }\\n        else if (c==0){ // This can occur!\\n            if (b<0 || (a<0 && b==0)) a=-a, b=-b;\\n        }\\n    //    cout<<\"(\"<<x0<<\",\"<<y0<<\"),(\"<<x1<<\",\"<<y1<<\")\\\\n\";\\n        vector<int> lineKey={a, b, c};\\n    //    cout<<lineKey<<endl;\\n        L[lineKey].insert(i);\\n        L[lineKey].insert(j);\\n    //    cout<<L[lineKey].size()<<\"\\\\n----\\\\n\";\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if (n==1) return 1;// edge case;\\n        for (int i = 0; i < n-1; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                line(points, i, j);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (auto& [_, set] : L) {\\n            int v = set.size();\\n            ans = max(ans, v);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n```python []\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        L = defaultdict(set)\\n        def line(points, i, j):\\n            x0, y0 = points[i]\\n            x1, y1 = points[j]\\n            a , b = y1 - y0, x0 - x1\\n            c = x0 * a + y0 * b\\n            d = gcd(gcd(a, b), c)\\n            a, b, c = a // d, b // d, c // d\\n            if c < 0:\\n                a, b, c=-a, -b, -c\\n            elif c==0:# This can occur!\\n                if b<0 or (a<0 and b==0): \\n                    a=-a \\n                    b=-b\\n            line_key = (a, b, c)\\n            L[line_key].add(i)\\n            L[line_key].add(j)\\n\\n        n = len(points)\\n        if n == 1:\\n            return 1  # edge case\\n\\n        for i in range(n - 1):\\n            for j in range(i + 1, n):\\n                line(points, i, j)\\n\\n        max_points_on_line = 0\\n\\n        for _, point_set in L.items():\\n            max_points_on_line = max(max_points_on_line, len(point_set))\\n\\n        return max_points_on_line\\n```\\n# Code for 2nd Approach\\n```\\n//Use y=mx+c\\nclass Solution {\\npublic:\\n    struct Myhash {\\n        size_t operator()(const vector<double>& vec) const {\\n            size_t digest = 0;\\n            auto f = hash<double>();\\n            for (const auto& v : vec) {\\n                size_t v_hash = f(v);\\n                digest ^= v_hash + 0x9e3779b9 + (digest << 6) + (digest >> 2);\\n            }\\n            return digest;\\n        }\\n    };\\n    unordered_map<vector<double>, unordered_set<int>, Myhash> L;\\n\\n    void line(vector<vector<int>>& points, int i, int j) {\\n        double x0 = points[i][0], y0 = points[i][1];\\n        double x1 = points[j][0], y1 = points[j][1];\\n        double dy = y1 - y0;\\n        double dx = x1 - x0;\\n        const double inf=1.0/0;//new version C++ spports\\n        double m, c;\\n        if (dx==0){//x=d\\n            m=inf;\\n            c=x0;\\n        }\\n        else{//dx!=0\\n            m = dy/dx;\\n            c = (x0 * dy - y0 * dx)/dx;\\n        }       \\n        \\n    //    cout<<\"(\"<<x0<<\",\"<<y0<<\"),(\"<<x1<<\",\"<<y1<<\")\\\\n\";\\n        vector<double> lineKey={m, c};\\n    //    cout<<lineKey<<endl;\\n        L[lineKey].insert(i);\\n        L[lineKey].insert(j);\\n    //    cout<<L[lineKey].size()<<\"\\\\n----\\\\n\";\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if (n<=2) return n;// edge case;\\n        for (int i = 0; i < n-1; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                line(points, i, j);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (auto& [_, set] : L) {\\n            int v = set.size();\\n            ans = max(ans, v);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nint d = gcd(a, b); //c is an integer linear combination of a & b therefore d|c\\na /= d, b /= d, c /= d;\\nif (c < 0) {\\n      a = -a, b = -b, c = -c;\\n}\\nelse if (c==0){ // This can occur!\\n    if (b<0 || (a<0 && b==0)) a=-a, b=-b;\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n   struct Myhash {\\n        size_t operator()(const vector<int>& vec) const {\\n            size_t digest = 0;\\n            auto f=hash<int>();\\n            for (const auto& v : vec) {\\n                digest = f(digest^v);\\n            }\\n            return digest;\\n        }\\n    };\\n    unordered_map<vector<int>, unordered_set<int>, Myhash> L;\\n\\n    void line(vector<vector<int>>& points, int i, int j) {\\n        int x0 = points[i][0], y0 = points[i][1];\\n        int x1 = points[j][0], y1 = points[j][1];\\n        int a = y1 - y0;\\n        int b = x0 - x1;\\n        int c = x0 * a + y0 * b;\\n        int d = gcd(a, b); //c is an integer linear combination of a & b therefore d|c\\n        a /= d, b /= d, c /= d;\\n        if (c < 0) {\\n            a = -a, b = -b, c = -c;\\n        }\\n        else if (c==0){ // This can occur!\\n            if (b<0 || (a<0 && b==0)) a=-a, b=-b;\\n        }\\n    //    cout<<\"(\"<<x0<<\",\"<<y0<<\"),(\"<<x1<<\",\"<<y1<<\")\\\\n\";\\n        vector<int> lineKey={a, b, c};\\n    //    cout<<lineKey<<endl;\\n        L[lineKey].insert(i);\\n        L[lineKey].insert(j);\\n    //    cout<<L[lineKey].size()<<\"\\\\n----\\\\n\";\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if (n==1) return 1;// edge case;\\n        for (int i = 0; i < n-1; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                line(points, i, j);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (auto& [_, set] : L) {\\n            int v = set.size();\\n            ans = max(ans, v);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\n```python []\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        L = defaultdict(set)\\n        def line(points, i, j):\\n            x0, y0 = points[i]\\n            x1, y1 = points[j]\\n            a , b = y1 - y0, x0 - x1\\n            c = x0 * a + y0 * b\\n            d = gcd(gcd(a, b), c)\\n            a, b, c = a // d, b // d, c // d\\n            if c < 0:\\n                a, b, c=-a, -b, -c\\n            elif c==0:# This can occur!\\n                if b<0 or (a<0 and b==0): \\n                    a=-a \\n                    b=-b\\n            line_key = (a, b, c)\\n            L[line_key].add(i)\\n            L[line_key].add(j)\\n\\n        n = len(points)\\n        if n == 1:\\n            return 1  # edge case\\n\\n        for i in range(n - 1):\\n            for j in range(i + 1, n):\\n                line(points, i, j)\\n\\n        max_points_on_line = 0\\n\\n        for _, point_set in L.items():\\n            max_points_on_line = max(max_points_on_line, len(point_set))\\n\\n        return max_points_on_line\\n```\n```\\n//Use y=mx+c\\nclass Solution {\\npublic:\\n    struct Myhash {\\n        size_t operator()(const vector<double>& vec) const {\\n            size_t digest = 0;\\n            auto f = hash<double>();\\n            for (const auto& v : vec) {\\n                size_t v_hash = f(v);\\n                digest ^= v_hash + 0x9e3779b9 + (digest << 6) + (digest >> 2);\\n            }\\n            return digest;\\n        }\\n    };\\n    unordered_map<vector<double>, unordered_set<int>, Myhash> L;\\n\\n    void line(vector<vector<int>>& points, int i, int j) {\\n        double x0 = points[i][0], y0 = points[i][1];\\n        double x1 = points[j][0], y1 = points[j][1];\\n        double dy = y1 - y0;\\n        double dx = x1 - x0;\\n        const double inf=1.0/0;//new version C++ spports\\n        double m, c;\\n        if (dx==0){//x=d\\n            m=inf;\\n            c=x0;\\n        }\\n        else{//dx!=0\\n            m = dy/dx;\\n            c = (x0 * dy - y0 * dx)/dx;\\n        }       \\n        \\n    //    cout<<\"(\"<<x0<<\",\"<<y0<<\"),(\"<<x1<<\",\"<<y1<<\")\\\\n\";\\n        vector<double> lineKey={m, c};\\n    //    cout<<lineKey<<endl;\\n        L[lineKey].insert(i);\\n        L[lineKey].insert(j);\\n    //    cout<<L[lineKey].size()<<\"\\\\n----\\\\n\";\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if (n<=2) return n;// edge case;\\n        for (int i = 0; i < n-1; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                line(points, i, j);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (auto& [_, set] : L) {\\n            int v = set.size();\\n            ans = max(ans, v);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3337644,
                "title": "javascript-149-max-points-on-a-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCheck 3 points on same line\\nMake smallest of all 3, as key to count others on same line\\n\\nTests\\n```\\n[[0,0]]\\n[[4,5],[4,-1],[4,0]]\\n[[0,0],[1,-1],[1,1]]\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n[[0,1],[0,0],[0,4],[0,-2],[0,-1],[0,3],[0,-4]]\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar maxPoints = function (ps) {\\n    if (ps.length <= 2) return ps.length; // 1 length\\n\\n    const key = (x1, y1) => x1 + \",\" + y1;\\n\\n    ps.sort(([x1, y1], [x2, y2]) => x1 - x2 || y1 - y2); // we could void? for [[0,0],[5,0]] like\\n\\n    let n = ps.length;\\n    let o = {};\\n    for (let i = 0; i < n; i++) {\\n        let [x1, y1] = ps[i];\\n\\n        for (let j = i + 1; j < n; j++) {\\n            let [x2, y2] = ps[j];\\n            let sl = (y2 - y1) / (x2 - x1); // slope1\\n\\n            for (let k = j + 1; k < n; k++) {\\n                let [x3, y3] = ps[k];\\n                let sl2 = (y3 - y1) / (x3 - x1); // slope2\\n\\n                if (sl === sl2) {\\n                    if (sl === 0) {\\n                        // some padding to make key1 in o[key1] distinct\\n                        sl += \"slopeIsZero\"; // on x & y axis\\n                        if (y1 === y2 && y1 === y3) sl += y1;\\n                        if (x1 === x2 && x1 === x3) sl += x1;\\n                    }\\n                    sl += x1 + \",\" + y1;\\n\\n                    o[sl] = o[sl] || new Set();\\n                    o[sl]\\n                        .add(key(x1, y1)) //\\n                        .add(key(x2, y2))\\n                        .add(key(x3, y3));\\n                }\\n            }\\n        }\\n    }\\n\\n    let max = -Infinity;\\n    for (let k in o) {\\n        max = Math.max(max, o[k].size);\\n    }\\n    return max === -Infinity ? 2 : max; // 2 length & more\\n};\\n```\\n\\n2\\n```\\nvar maxPoints = function (ps) {\\n    function areSameLine([x1, y1], [x2, y2], [x3, y3]) {\\n        if (\\n            (x1 == x2 && x2 == x3) || //\\n            (y1 == y2 && y2 == y3)\\n        )\\n            return true;\\n\\n        if (\\n            x1 == x2 || //\\n            x2 == x3 ||\\n            y1 == y2 ||\\n            y2 == y3\\n        )\\n            return false;\\n\\n        const s1 = (y1 - y2) / (x1 - x2);\\n        const s2 = (y2 - y3) / (x2 - x3);\\n        return s1 === s2;\\n    }\\n\\n    let max = 1;\\n    for (let i = 0; i < ps.length; i++)\\n        for (let j = i + 1; j < ps.length; j++) {\\n            let count = 2;\\n            for (let k = j + 1; k < ps.length; k++)\\n                if (areSameLine(ps[i], ps[j], ps[k])) {\\n                    count++;\\n                }\\n            max = Math.max(max, count);\\n        }\\n    return max;\\n};\\n```\\n\\n3\\n```\\nvar maxPoints = function (ps) {\\n    const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\\n\\n    const getSlopeKey = ([x1, y1], [x2, y2]) => {\\n        const [dx, dy] = [x1 - x2, y1 - y2];\\n        const g = gcd(dx, dy);\\n        return `${dy / g}, ${dx / g}`;\\n    };\\n\\n    let max = 1;\\n    for (let i = 0; i < ps.length; i++) {\\n        const o = {};\\n        for (let j = i + 1; j < ps.length; j++) {\\n            const key = getSlopeKey(ps[i], ps[j]);\\n            o[key] = (o[key] || 0) + 1;\\n        }\\n        const count = Math.max(...Object.values(o)) + 1;\\n        max = Math.max(count, max);\\n    }\\n    return max;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n[[0,0]]\\n[[4,5],[4,-1],[4,0]]\\n[[0,0],[1,-1],[1,1]]\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n[[0,1],[0,0],[0,4],[0,-2],[0,-1],[0,3],[0,-4]]\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\n```\\nvar maxPoints = function (ps) {\\n    if (ps.length <= 2) return ps.length; // 1 length\\n\\n    const key = (x1, y1) => x1 + \",\" + y1;\\n\\n    ps.sort(([x1, y1], [x2, y2]) => x1 - x2 || y1 - y2); // we could void? for [[0,0],[5,0]] like\\n\\n    let n = ps.length;\\n    let o = {};\\n    for (let i = 0; i < n; i++) {\\n        let [x1, y1] = ps[i];\\n\\n        for (let j = i + 1; j < n; j++) {\\n            let [x2, y2] = ps[j];\\n            let sl = (y2 - y1) / (x2 - x1); // slope1\\n\\n            for (let k = j + 1; k < n; k++) {\\n                let [x3, y3] = ps[k];\\n                let sl2 = (y3 - y1) / (x3 - x1); // slope2\\n\\n                if (sl === sl2) {\\n                    if (sl === 0) {\\n                        // some padding to make key1 in o[key1] distinct\\n                        sl += \"slopeIsZero\"; // on x & y axis\\n                        if (y1 === y2 && y1 === y3) sl += y1;\\n                        if (x1 === x2 && x1 === x3) sl += x1;\\n                    }\\n                    sl += x1 + \",\" + y1;\\n\\n                    o[sl] = o[sl] || new Set();\\n                    o[sl]\\n                        .add(key(x1, y1)) //\\n                        .add(key(x2, y2))\\n                        .add(key(x3, y3));\\n                }\\n            }\\n        }\\n    }\\n\\n    let max = -Infinity;\\n    for (let k in o) {\\n        max = Math.max(max, o[k].size);\\n    }\\n    return max === -Infinity ? 2 : max; // 2 length & more\\n};\\n```\n```\\nvar maxPoints = function (ps) {\\n    function areSameLine([x1, y1], [x2, y2], [x3, y3]) {\\n        if (\\n            (x1 == x2 && x2 == x3) || //\\n            (y1 == y2 && y2 == y3)\\n        )\\n            return true;\\n\\n        if (\\n            x1 == x2 || //\\n            x2 == x3 ||\\n            y1 == y2 ||\\n            y2 == y3\\n        )\\n            return false;\\n\\n        const s1 = (y1 - y2) / (x1 - x2);\\n        const s2 = (y2 - y3) / (x2 - x3);\\n        return s1 === s2;\\n    }\\n\\n    let max = 1;\\n    for (let i = 0; i < ps.length; i++)\\n        for (let j = i + 1; j < ps.length; j++) {\\n            let count = 2;\\n            for (let k = j + 1; k < ps.length; k++)\\n                if (areSameLine(ps[i], ps[j], ps[k])) {\\n                    count++;\\n                }\\n            max = Math.max(max, count);\\n        }\\n    return max;\\n};\\n```\n```\\nvar maxPoints = function (ps) {\\n    const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\\n\\n    const getSlopeKey = ([x1, y1], [x2, y2]) => {\\n        const [dx, dy] = [x1 - x2, y1 - y2];\\n        const g = gcd(dx, dy);\\n        return `${dy / g}, ${dx / g}`;\\n    };\\n\\n    let max = 1;\\n    for (let i = 0; i < ps.length; i++) {\\n        const o = {};\\n        for (let j = i + 1; j < ps.length; j++) {\\n            const key = getSlopeKey(ps[i], ps[j]);\\n            o[key] = (o[key] || 0) + 1;\\n        }\\n        const count = Math.max(...Object.values(o)) + 1;\\n        max = Math.max(count, max);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3206816,
                "title": "149-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution also uses a dictionary to store the number of points that share the same slope with respect to the current point. It starts by iterating over each point in the array, and for each point, it creates a new dictionary slopes to store the number of points that share the same slope with respect to the current point, as well as a variable same to count the number of points that are the same as the current point. Then, it iterates over the remaining points, calculates the slope with respect to the current point, and updates the slopes dictionary accordingly. Finally, it computes the maximum number of points that share the same slope, adds the same variable, and compares it to the current maximum number of points max_points.\\n\\nNote that this solution also includes a special case when the remaining points have the same x-coordinate as the current point, in which case the slope is set to infinity. This is necessary to avoid a division by zero error.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n90.13%\\n\\n- Space complexity:\\nBeats\\n89.81%\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        n = len(points)\\n        if n < 2:\\n            return n\\n        \\n        max_points = 0\\n        for i in range(n):\\n            slopes = {}\\n            same = 1\\n            for j in range(i+1, n):\\n                if points[i][0] == points[j][0] and points[i][1] == points[j][1]:\\n                    same += 1\\n                elif points[i][0] == points[j][0]:\\n                    slope = float(\\'inf\\')\\n                    if slope in slopes:\\n                        slopes[slope] += 1\\n                    else:\\n                        slopes[slope] = 1\\n                else:\\n                    slope = (points[j][1]-points[i][1])/(points[j][0]-points[i][0])\\n                    if slope in slopes:\\n                        slopes[slope] += 1\\n                    else:\\n                        slopes[slope] = 1\\n            if not slopes:\\n                max_points = max(max_points, same)\\n            else:\\n                max_points = max(max_points, max(slopes.values())+same)\\n                \\n        return max_points\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        n = len(points)\\n        if n < 2:\\n            return n\\n        \\n        max_points = 0\\n        for i in range(n):\\n            slopes = {}\\n            same = 1\\n            for j in range(i+1, n):\\n                if points[i][0] == points[j][0] and points[i][1] == points[j][1]:\\n                    same += 1\\n                elif points[i][0] == points[j][0]:\\n                    slope = float(\\'inf\\')\\n                    if slope in slopes:\\n                        slopes[slope] += 1\\n                    else:\\n                        slopes[slope] = 1\\n                else:\\n                    slope = (points[j][1]-points[i][1])/(points[j][0]-points[i][0])\\n                    if slope in slopes:\\n                        slopes[slope] += 1\\n                    else:\\n                        slopes[slope] = 1\\n            if not slopes:\\n                max_points = max(max_points, same)\\n            else:\\n                max_points = max(max_points, max(slopes.values())+same)\\n                \\n        return max_points\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047929,
                "title": "c-java-very-intuitive-sorting-map-for-slope",
                "content": "\\uD83D\\uDE80 We just need to find a [slope](https://en.wikipedia.org/wiki/Slope) which has max number of points on it. \\n\\n\\u2714 C++:\\n\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        // find a slope having max number of points\\n        int ans = 1;\\n        sort(begin(points), end(points), [&] (auto x, auto y) { \\n            if(x[0] == y[0]) return x[1] < y[1];\\n            return x[0] < y[0];\\n        });\\n        for(int i = 0; i < size(points); ++i) {\\n            unordered_map<double, int> m;\\n            for(int j = i + 1; j < size(points); ++j) {\\n                double x = ((double)(points[j][1] - points[i][1]) / (points[j][0] - points[i][0]));\\n                double theta = atan(x);\\n                m[theta]++;\\n                ans = max(ans, m[theta] + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\u2714 Java:\\n\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int ans = 1;\\n        Arrays.sort(points, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] x, int[] y) {\\n                if(x[0] == y[0]) return x[1] - y[1];\\n                return x[0] - y[0];\\n            }\\n        });\\n        for(int i = 0; i < points.length; ++i) {\\n            var m = new HashMap<Double, Integer>();\\n            for(int j = i + 1; j < points.length; ++j) {\\n                double x = ((double) (points[j][1] - points[i][1]) / (points[j][0] - points[i][0]));\\n                double theta = Math.atan(x);\\n                m.put(theta, m.getOrDefault(theta, 0) + 1);\\n                ans = Math.max(ans, m.get(theta) + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**TC: O(n^2), SC: O(n)**\\n\\nThanks a lot for reading! ^_^\\n\\uD83D\\uDCAF An upvote would be appreciated.\\n\\uD83D\\uDC47 Comment down your doubts (if any).",
                "solutionTags": [
                    "Java",
                    "C",
                    "Hash Table",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        // find a slope having max number of points\\n        int ans = 1;\\n        sort(begin(points), end(points), [&] (auto x, auto y) { \\n            if(x[0] == y[0]) return x[1] < y[1];\\n            return x[0] < y[0];\\n        });\\n        for(int i = 0; i < size(points); ++i) {\\n            unordered_map<double, int> m;\\n            for(int j = i + 1; j < size(points); ++j) {\\n                double x = ((double)(points[j][1] - points[i][1]) / (points[j][0] - points[i][0]));\\n                double theta = atan(x);\\n                m[theta]++;\\n                ans = max(ans, m[theta] + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int ans = 1;\\n        Arrays.sort(points, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] x, int[] y) {\\n                if(x[0] == y[0]) return x[1] - y[1];\\n                return x[0] - y[0];\\n            }\\n        });\\n        for(int i = 0; i < points.length; ++i) {\\n            var m = new HashMap<Double, Integer>();\\n            for(int j = i + 1; j < points.length; ++j) {\\n                double x = ((double) (points[j][1] - points[i][1]) / (points[j][0] - points[i][0]));\\n                double theta = Math.atan(x);\\n                m.put(theta, m.getOrDefault(theta, 0) + 1);\\n                ans = Math.max(ans, m.get(theta) + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020487,
                "title": "c-python-faster-than-97-53-commented-simple-approach",
                "content": "# Intuition\\nAs this question is based on geometry (i.e. concept of straight line). The first intuition came in my mind to find slope of each point relative to other points and count the number of point having same slope. The maximum times the given slope will appear will define the number of points lies on the same straight line.\\n\\n# Approach\\nSo, to convert the above intution into code first we need to find the slope of each point with respect to others and use **dictionary(hashmap)** to keep the count of each slope (i.e. number of points lies on same straight line). To find the slope we will be using **Two-Point form** :\\nLet there be two points [x1,y2] and [x2,y2] so to find the slope (i.e.: m) we will be using the formula:<br> \\n### **m = y2-y1 / x2-x1** \\n\\nAfter finding the slope and storing its counts in dictionary we will check which slope value occured most of the time and that will be our answer to the question.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\nint maxPoints(vector<vector<int>>& points) {\\n        int size=points.size(), count=1;\\n        for(int i=0;i<size;i++){\\n            unordered_map<double,int>um; // Cretaing HashMap\\n            double slope;\\n            for(int j=i+1;j<size;j++){\\n                if(points[j][0]-points[i][0]==0) //Checking if the slope is perpendicular or not as the x2-x1 == 0 defines slope is at 90 degree\\n                    slope=10001.00;\\n                else{\\n                    slope=double(points[j][1]-points[i][1])/double(points[j][0]-points[i][0]); // Using two-point form\\n                }\\n                um[slope]++; //  Using map to store the slope count with respect to a single point\\n            }\\n            for(auto k:um){ //Counting the maximum count of slope\\n                count=max(count,k.second+1); // Here we\\'re adding 1 to include the point points[i] itself.\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\\n\\n# Python Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        count = 1 # Store the count\\n        for i in range(0,len(points)):\\n            dict_slope = {}  # Creating a dictionary(hashmap) \\n            for j in range(i+1,len(points)):\\n                if points[j][0] - points[i][0] == 0: # Checking if the slope is perpendicular or not as the x2-x1 == 0 defines slope is at 90 degree\\n                    slope = \\'INF\\'\\n                else:\\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0]) # Using two-point form\\n                if slope in dict_slope: # using map to store the slope count with respect to a single point\\n                    dict_slope[slope] += 1\\n                else:\\n                    dict_slope[slope] = 1\\n            for i in dict_slope: # Counting the maximum count of slope\\n                count = max(count,dict_slope[i]+1) # Here we\\'re adding 1 to include the point points[i] itself.\\n        return count\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint maxPoints(vector<vector<int>>& points) {\\n        int size=points.size(), count=1;\\n        for(int i=0;i<size;i++){\\n            unordered_map<double,int>um; // Cretaing HashMap\\n            double slope;\\n            for(int j=i+1;j<size;j++){\\n                if(points[j][0]-points[i][0]==0) //Checking if the slope is perpendicular or not as the x2-x1 == 0 defines slope is at 90 degree\\n                    slope=10001.00;\\n                else{\\n                    slope=double(points[j][1]-points[i][1])/double(points[j][0]-points[i][0]); // Using two-point form\\n                }\\n                um[slope]++; //  Using map to store the slope count with respect to a single point\\n            }\\n            for(auto k:um){ //Counting the maximum count of slope\\n                count=max(count,k.second+1); // Here we\\'re adding 1 to include the point points[i] itself.\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        count = 1 # Store the count\\n        for i in range(0,len(points)):\\n            dict_slope = {}  # Creating a dictionary(hashmap) \\n            for j in range(i+1,len(points)):\\n                if points[j][0] - points[i][0] == 0: # Checking if the slope is perpendicular or not as the x2-x1 == 0 defines slope is at 90 degree\\n                    slope = \\'INF\\'\\n                else:\\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0]) # Using two-point form\\n                if slope in dict_slope: # using map to store the slope count with respect to a single point\\n                    dict_slope[slope] += 1\\n                else:\\n                    dict_slope[slope] = 1\\n            for i in dict_slope: # Counting the maximum count of slope\\n                count = max(count,dict_slope[i]+1) # Here we\\'re adding 1 to include the point points[i] itself.\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020072,
                "title": "easy-solution-with-atan-and-hashmap-java-o-n-2",
                "content": "**Approach:**\\n* We will use the tan iinverse function to find the theta angle between all the points.\\n* For that we will run two nested loop (n^2).\\n* if (i==j) then we will continue, because it\\'ll be the same point\\n* Else we will find the value of `dy=(arr[j][1]-arr[i][1])` and `dx=(arr[j][0]-arr[i][0])`.\\n* This will give us the theta angle by atan function.\\n* Now we will put this into a map of angle to count\\n* And for each point we will find the max count of the theta angle and store res as max angle.\\n\\n**TC:** O(n^2)\\n**SC:** O(n)\\n\\n\\n**PLEASE UPVOTE !!**\\n\\n```\\nclass Solution {\\n    public int maxPoints(int[][] arr) {\\n        int n=arr.length;\\n        if(n==1)\\n            return n; // if there is only one point\\n        int res=0;\\n        for(int i =0;i<n;i++)\\n        {\\n            HashMap<Double,Integer> uwu=new HashMap<>(); //to store angle to its count\\n            int max=0; // max angle of the point\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j) // if the point is same we will continue\\n                    continue;\\n                double dy=(double)(arr[j][1]-arr[i][1]);\\n                double dx=(double)(arr[j][0]-arr[i][0]);\\n                double theta=Math.atan(dy/dx); //theta angle by atan function\\n                uwu.put(theta,uwu.getOrDefault(theta,0)+1); //store the count\\n                max=Math.max(max,uwu.getOrDefault(theta,0)); //also keep checking the max angle\\n            }\\n            res=Math.max(res,max+1); //for res count max+1 (+1 because we were not counting the angle at ith index in the loop)\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] arr) {\\n        int n=arr.length;\\n        if(n==1)\\n            return n; // if there is only one point\\n        int res=0;\\n        for(int i =0;i<n;i++)\\n        {\\n            HashMap<Double,Integer> uwu=new HashMap<>(); //to store angle to its count\\n            int max=0; // max angle of the point\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j) // if the point is same we will continue\\n                    continue;\\n                double dy=(double)(arr[j][1]-arr[i][1]);\\n                double dx=(double)(arr[j][0]-arr[i][0]);\\n                double theta=Math.atan(dy/dx); //theta angle by atan function\\n                uwu.put(theta,uwu.getOrDefault(theta,0)+1); //store the count\\n                max=Math.max(max,uwu.getOrDefault(theta,0)); //also keep checking the max angle\\n            }\\n            res=Math.max(res,max+1); //for res count max+1 (+1 because we were not counting the angle at ith index in the loop)\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018430,
                "title": "a-fast-and-simple-approach-using-a-hashmap",
                "content": "# Intuition\\nThe main idea behind this solution is to use the slope between each pair of points as a way to determine whether the points are on the same line. To do this, the code first iterates through each point and considers it as a starting point for a line. Then, for each starting point, the code looks at all of the other points and calculates the slope between the starting point and each of the other points. If the slope is the same for any two points, it means that they are on the same line.\\n\\nThe code uses a HashMap to store the number of points that have the same slope with respect to the starting point. The key of the HashMap is the slope value, and the value is the number of points with that slope. By storing the slopes and their frequencies in this way, the code can easily keep track of the maximum number of points on the same line for each starting point.\\n\\nFinally, the code returns the maximum number of points on the same line among all of the starting points. This gives us the overall maximum number of points on the same line for the entire set of points.\\n\\n# Approach\\n1. Initialize a variable ans to 1. This variable will be used to store the maximum number of points on the same line.\\n2. Check if the number of points is less than or equal to 2. If it is, return the number of points. This is because it is not possible to have more than 2 points on the same line if there are 2 or fewer points in total.\\n3. Iterate through each point in the points array. For each point, do the following:\\n4.  Initialize a HashMap to store the slopes and their frequencies\\n5. Consider the current point as the starting point for a line\\n6. Iterate through the other points in the array and calculate the slope between the starting point and each other point.\\n7. If the slope is the same for any two points, it means that they are on the same line. So, store the slope in the HashMap and increment the frequency count for that slope.\\n8. If the x-coordinates of the two points are the same, then the slope is infinity. In this case, store the slope as -90 in the HashMap.\\n9. If the y-coordinates of the two points are the same, then the slope is 0. In this case, store the slope as 0 in the HashMap. **This special case is needed because Java treats 0.0 and -0.0 as unequal.(This had me frustrated.)**\\n10. After iterating through all of the other points, find the maximum frequency count in the HashMap. This gives the maximum number of points on the same line for the current starting point.\\n11. Update the ans variable with the maximum number of points on the same line for the current starting point.\\n12. Repeat steps 3-11 for each point in the points array.\\n13. Return the ans variable as the result.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n^2), because the code performs a nested loop over all pairs of points. The inner loop processes each point and calculates the slope with respect to the current starting point, which takes O(1) time. The outer loop iterates over all points, so the total time complexity is **O(n * O(1)) = O(n)**.\\n\\n- Space complexity:\\nThe space complexity of this solution is **O(n)**, because the size of the HashMap used to store the slopes and their frequencies is proportional to the number of points.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int ans = 1;\\n        int n = points.length;\\n        if(n <= 2){\\n            return n;\\n        }\\n        for(int i = 0; i < n - 1; i++){\\n            HashMap<Double, Integer> map = new HashMap<>();\\n            for(int j = i + 1; j < n; j++){\\n                if(points[j][0] == points[i][0]){\\n                    map.put(-90.0, map.getOrDefault(-90.0, 0) + 1);\\n                }else if(points[j][1] == points[i][1]){\\n                    map.put(0.0, map.getOrDefault(0.0, 0) + 1);\\n                }\\n                else{\\n                    double slope = ((double)(points[j][1] - points[i][1]))/((double)(points[j][0] - points[i][0]));\\n                    map.put(slope, map.getOrDefault(slope, 0) + 1);\\n                }\\n            }\\n            int temp_max = 0;\\n            for(Map.Entry<Double, Integer> slope : map.entrySet()){\\n                temp_max =  Math.max(temp_max, slope.getValue() + 1);\\n               \\n            }\\n            ans = Math.max(ans, temp_max);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int ans = 1;\\n        int n = points.length;\\n        if(n <= 2){\\n            return n;\\n        }\\n        for(int i = 0; i < n - 1; i++){\\n            HashMap<Double, Integer> map = new HashMap<>();\\n            for(int j = i + 1; j < n; j++){\\n                if(points[j][0] == points[i][0]){\\n                    map.put(-90.0, map.getOrDefault(-90.0, 0) + 1);\\n                }else if(points[j][1] == points[i][1]){\\n                    map.put(0.0, map.getOrDefault(0.0, 0) + 1);\\n                }\\n                else{\\n                    double slope = ((double)(points[j][1] - points[i][1]))/((double)(points[j][0] - points[i][0]));\\n                    map.put(slope, map.getOrDefault(slope, 0) + 1);\\n                }\\n            }\\n            int temp_max = 0;\\n            for(Map.Entry<Double, Integer> slope : map.entrySet()){\\n                temp_max =  Math.max(temp_max, slope.getValue() + 1);\\n               \\n            }\\n            ans = Math.max(ans, temp_max);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018339,
                "title": "a-different-solution-with-x-and-y-intercepts",
                "content": "![image](https://assets.leetcode.com/users/images/5c8bd0af-fe2e-493a-af5f-0038cab30b6c_1673165422.149452.png)\\n\\n**Intuition**: Two lines can have same slopes. To determin if given points can be projected on same line we need **2 points on the line** or **1 point and slope**. Given solution contains 2 points on the line approach. We\\'re using X and Y intercepts to represent the line.\\n\\n**Edge case:**  [[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]].\\n\\n```\\nclass Solution {\\n    public int infinity = Integer.MAX_VALUE;\\n    public double[] getXandYintercept(int P[],\\n                                  int Q[])\\n    {\\n        int a = P[1] - Q[1];\\n        int b = P[0] - Q[0];\\n        double[] intercepts = new double[2];\\n        // if line is parallel to y axis\\n        if (b == 0) {\\n            intercepts[0] = P[0];\\n            intercepts[1] = infinity;\\n            return intercepts;\\n        }\\n \\n        // if line is parallel to x axis\\n        if (a == 0) {\\n            intercepts[0] = infinity;\\n            intercepts[1] = P[1];\\n            return intercepts;\\n        }\\n        \\n        double m = a / (b * 1.0);\\n        int x = P[0];\\n        int y = P[1];\\n        double c = y - m * x;\\n        y = 0;\\n        double r = (y - c) / (m * 1.0);\\n        x = 0;\\n        y = (int)(m * x + c);\\n        intercepts[0] = r;\\n        intercepts[1] = c;\\n        return intercepts;\\n    }\\n    \\n    public int maxPoints(int[][] points) {\\n        int n = points.length;\\n        int m = 2;\\n        double[][][] intercepts = new double[n][n][2];\\n        if(n == 1) return 1;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                intercepts[i][j] = getXandYintercept(points[i], points[j]);\\n                intercepts[j][i] = intercepts[i][j];\\n            }    \\n            intercepts[i][i] = new double[]{infinity, infinity};\\n        }\\n        int ans = 0;\\n        boolean containsOrigin = false;\\n        String origin = \"\";\\n        for(int i = 0; i < n; i++){\\n            if(points[i][0] == 0 && points[i][1] == 0){\\n                origin = (double) 0 + \" \" + (double) 0;\\n                containsOrigin = true;\\n                continue;\\n            } \\n            HashMap<String, Integer> set =  new HashMap<>();\\n            int cnt = 1;\\n            for(int j = i + 1; j < n; j++){\\n                double xint = intercepts[j][i][0];\\n                double yint = intercepts[i][j][1];\\n                String pair = xint + \" \"  + yint;\\n                int pairCnt = set.getOrDefault(pair, 0) + 1;\\n                cnt = Math.max(cnt, pairCnt);\\n                set.put(pair, pairCnt);\\n            }\\n            if(containsOrigin){\\n                String pair = origin;\\n                int pairCnt = set.getOrDefault(pair, 0) + 1;\\n                cnt = Math.max(cnt, pairCnt);  \\n            }\\n            ans = Math.max(ans, cnt + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int infinity = Integer.MAX_VALUE;\\n    public double[] getXandYintercept(int P[],\\n                                  int Q[])\\n    {\\n        int a = P[1] - Q[1];\\n        int b = P[0] - Q[0];\\n        double[] intercepts = new double[2];\\n        // if line is parallel to y axis\\n        if (b == 0) {\\n            intercepts[0] = P[0];\\n            intercepts[1] = infinity;\\n            return intercepts;\\n        }\\n \\n        // if line is parallel to x axis\\n        if (a == 0) {\\n            intercepts[0] = infinity;\\n            intercepts[1] = P[1];\\n            return intercepts;\\n        }\\n        \\n        double m = a / (b * 1.0);\\n        int x = P[0];\\n        int y = P[1];\\n        double c = y - m * x;\\n        y = 0;\\n        double r = (y - c) / (m * 1.0);\\n        x = 0;\\n        y = (int)(m * x + c);\\n        intercepts[0] = r;\\n        intercepts[1] = c;\\n        return intercepts;\\n    }\\n    \\n    public int maxPoints(int[][] points) {\\n        int n = points.length;\\n        int m = 2;\\n        double[][][] intercepts = new double[n][n][2];\\n        if(n == 1) return 1;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                intercepts[i][j] = getXandYintercept(points[i], points[j]);\\n                intercepts[j][i] = intercepts[i][j];\\n            }    \\n            intercepts[i][i] = new double[]{infinity, infinity};\\n        }\\n        int ans = 0;\\n        boolean containsOrigin = false;\\n        String origin = \"\";\\n        for(int i = 0; i < n; i++){\\n            if(points[i][0] == 0 && points[i][1] == 0){\\n                origin = (double) 0 + \" \" + (double) 0;\\n                containsOrigin = true;\\n                continue;\\n            } \\n            HashMap<String, Integer> set =  new HashMap<>();\\n            int cnt = 1;\\n            for(int j = i + 1; j < n; j++){\\n                double xint = intercepts[j][i][0];\\n                double yint = intercepts[i][j][1];\\n                String pair = xint + \" \"  + yint;\\n                int pairCnt = set.getOrDefault(pair, 0) + 1;\\n                cnt = Math.max(cnt, pairCnt);\\n                set.put(pair, pairCnt);\\n            }\\n            if(containsOrigin){\\n                String pair = origin;\\n                int pairCnt = set.getOrDefault(pair, 0) + 1;\\n                cnt = Math.max(cnt, pairCnt);  \\n            }\\n            ans = Math.max(ans, cnt + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017952,
                "title": "c-98-32-faster-easy-detailed-solution",
                "content": "\\n# Explanation:\\n    \\n###### I have used double loop to check the maximum possible count of any slope with all combination of <B>i</B>th point.\\n- Return `size` if the vector\\'s size is `less than` 3, i.e. 1 point will contain itself with a line & 2 points will make a line with their own pair.\\n- I\\'ve initialized a map `mp` inside the first loop, and it has a count of every slope that might possibly have an `i`th point and also handles the `self` point and `infinite slope` separately.\\n- After ending inside loop I have updated my final answer with `mx+self` points\\n- returned `ans`\\n\\n\\n#### Go through code once you will understand completely\\uD83D\\uDC47\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n =points.size();\\n        if(n<3)\\n        return n;\\n\\n        int ans = 0;\\n\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> mp;\\n            int self = 1;\\n            for(int j=i+1;j<n;j++){\\n                if(points[i][0] == points[j][0] && points[j][1] == points[i][1])\\n                self++;\\n                else if(points[i][0] == points[j][0])\\n                mp[INT_MAX]++;\\n                else{\\n                    double slope = double(points[i][1]-points[j][1])/double(points[i][0]-points[j][0]);\\n                    mp[slope]++;\\n                }\\n            }\\n            int mx = 0;\\n            for(auto ele : mp){\\n                mx = max(mx,ele.second);\\n            }\\n            ans = max(ans,mx+self);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Please upvote if you find this solution helpful\\uD83D\\uDE4F\\n#### Thank you in advance :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n =points.size();\\n        if(n<3)\\n        return n;\\n\\n        int ans = 0;\\n\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> mp;\\n            int self = 1;\\n            for(int j=i+1;j<n;j++){\\n                if(points[i][0] == points[j][0] && points[j][1] == points[i][1])\\n                self++;\\n                else if(points[i][0] == points[j][0])\\n                mp[INT_MAX]++;\\n                else{\\n                    double slope = double(points[i][1]-points[j][1])/double(points[i][0]-points[j][0]);\\n                    mp[slope]++;\\n                }\\n            }\\n            int mx = 0;\\n            for(auto ele : mp){\\n                mx = max(mx,ele.second);\\n            }\\n            ans = max(ans,mx+self);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017843,
                "title": "simple-hashmap-geometry-95-beats-in-time",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        int ans = 0;\\n        unordered_map<float, int>mp;\\n        \\n        for(int i = 0 ; i < points.size(); i++)\\n        {\\n              for(int j = i+1 ; j < points.size(); j++)\\n              {\\n                  float y2 = points[j][1], y1 = points[i][1];\\n                  float x2 = points[j][0], x1 = points[i][0];\\n                  float slope = (y2-y1)/(x2-x1);\\n                    if( (y2-y1) < 0 && (x2-x1) == 0) //infinite slope\\n                         mp[abs(slope)]++;\\n                    else\\n                        mp[slope]++;\\n              }\\n            for(auto e : mp)\\n            {\\n               int temp = e.second;\\n               ans = max(ans, temp);\\n            }\\n        mp.clear();\\n        }\\n           \\n        return ans+1;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        int ans = 0;\\n        unordered_map<float, int>mp;\\n        \\n        for(int i = 0 ; i < points.size(); i++)\\n        {\\n              for(int j = i+1 ; j < points.size(); j++)\\n              {\\n                  float y2 = points[j][1], y1 = points[i][1];\\n                  float x2 = points[j][0], x1 = points[i][0];\\n                  float slope = (y2-y1)/(x2-x1);\\n                    if( (y2-y1) < 0 && (x2-x1) == 0) //infinite slope\\n                         mp[abs(slope)]++;\\n                    else\\n                        mp[slope]++;\\n              }\\n            for(auto e : mp)\\n            {\\n               int temp = e.second;\\n               ans = max(ans, temp);\\n            }\\n        mp.clear();\\n        }\\n           \\n        return ans+1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017194,
                "title": "python-using-slope-90-runtime",
                "content": "# Intuition\\nWe loop over every point and find its slope with other points and put those slope in a hashmap\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n\\n        if len(points) == 1:\\n            return 1\\n\\n        res = 2\\n\\n        for i in range(len(points)):\\n            dic = defaultdict(int)\\n\\n            for j in range(i+1,len(points)):\\n\\n                    if points[j][0] - points[i] [0] == 0:\\n                        dic[float(\\'inf\\')] += 1\\n                    else:\\n                        dic[((points[j][1]- points[i][1])/ (points[j][0]-points[i][0]))] += 1\\n            if dic.values():\\n             res = max(res, max(dic.values())+1)\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n\\n        if len(points) == 1:\\n            return 1\\n\\n        res = 2\\n\\n        for i in range(len(points)):\\n            dic = defaultdict(int)\\n\\n            for j in range(i+1,len(points)):\\n\\n                    if points[j][0] - points[i] [0] == 0:\\n                        dic[float(\\'inf\\')] += 1\\n                    else:\\n                        dic[((points[j][1]- points[i][1])/ (points[j][0]-points[i][0]))] += 1\\n            if dic.values():\\n             res = max(res, max(dic.values())+1)\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017084,
                "title": "very-easy-intuitive-js-solution-98-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nComing back to basic concept of points lying on a line. Two points lie on same line if and only if their slope is equal to the slope of line. So get the slopes of all pairs of points.\\n> ***Slope Formula :*** ( y2 - y1 ) / ( x2 - x1 )\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initially the maximum points lying on a line will be 1 ( the point itself ). \\n- Another point to notice is that if the denominator of the fraction becomes 0 ( i.e points having same x coordinates ), then the slope becomes infinity. So we handle this situation separately. Else just calculate the slope and insert into the map.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\n\\n// author : Sourav Kumar Dubey\\n// My 1st submission in JavaScript! Enjoyed it!!!!\\nvar maxPoints = function(points) {\\n    \\n    let maxi = 0;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        \\n        const mp = new Map();\\n        const [x1, y1] = points[i]; // ... JS spread operator\\n        let currMax = 1, slope = 0;\\n\\n        for (let j = i + 1; j < points.length; j++) { \\n            \\n            const [x2, y2] = points[j];\\n            \\n            if (x1 === x2) slope = Number.MAX_VALUE; // if the denominator is 0, then the slope will become infinity\\n            else slope = (y2 - y1) / (x2 - x1);\\n            \\n            if (!mp.has(slope)) mp.set(slope, 2); // 2 coz we have got the new slope using 2 points.\\n            else mp.set(slope, mp.get(slope) + 1); // if slope already exits then just increment the number of frequencies\\n            \\n            currMax = Math.max(currMax, mp.get(slope));\\n\\n        }\\n        \\n        maxi = Math.max(maxi, currMax);\\n        \\n    }\\n\\n    return maxi;\\n\\n};\\n    \\n    \\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\n\\n// author : Sourav Kumar Dubey\\n// My 1st submission in JavaScript! Enjoyed it!!!!\\nvar maxPoints = function(points) {\\n    \\n    let maxi = 0;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        \\n        const mp = new Map();\\n        const [x1, y1] = points[i]; // ... JS spread operator\\n        let currMax = 1, slope = 0;\\n\\n        for (let j = i + 1; j < points.length; j++) { \\n            \\n            const [x2, y2] = points[j];\\n            \\n            if (x1 === x2) slope = Number.MAX_VALUE; // if the denominator is 0, then the slope will become infinity\\n            else slope = (y2 - y1) / (x2 - x1);\\n            \\n            if (!mp.has(slope)) mp.set(slope, 2); // 2 coz we have got the new slope using 2 points.\\n            else mp.set(slope, mp.get(slope) + 1); // if slope already exits then just increment the number of frequencies\\n            \\n            currMax = Math.max(currMax, mp.get(slope));\\n\\n        }\\n        \\n        maxi = Math.max(maxi, currMax);\\n        \\n    }\\n\\n    return maxi;\\n\\n};\\n    \\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3016973,
                "title": "c-solution",
                "content": "C++ code:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int maxi = 0;\\n        for (const auto& x : points) {\\n            unordered_map<double, int> slopes;\\n            for (const auto& y : points) {\\n            if (x == y) continue;\\n            double slope = numeric_limits<double>::infinity();\\n            if (y[0] - x[0] != 0) {\\n                slope = (double) (y[1] - x[1]) / (y[0] - x[0]);\\n            }\\n\\n            if (slopes.count(slope)) {\\n                slopes[slope]++;\\n            } else {\\n                slopes[slope] = 1;\\n            }\\n            maxi = std::max(maxi, slopes[slope]);\\n            }\\n        }\\n        return maxi + 1;\\n    }\\n};\\n```\\n\\n\\n*Upvote if helped*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int maxi = 0;\\n        for (const auto& x : points) {\\n            unordered_map<double, int> slopes;\\n            for (const auto& y : points) {\\n            if (x == y) continue;\\n            double slope = numeric_limits<double>::infinity();\\n            if (y[0] - x[0] != 0) {\\n                slope = (double) (y[1] - x[1]) / (y[0] - x[0]);\\n            }\\n\\n            if (slopes.count(slope)) {\\n                slopes[slope]++;\\n            } else {\\n                slopes[slope] = 1;\\n            }\\n            maxi = std::max(maxi, slopes[slope]);\\n            }\\n        }\\n        return maxi + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016637,
                "title": "equation-of-line-in-2-point-form-o-n-2-simple-and-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOn first glance, while looking at the constraints, I concluded that nlogn comparisons for each point is possible. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#### Two Point Form: Formula\\n\\n    y\\u2212y1 =y2-y1/x2-x1(x\\u2212x1)\\nwhere,\\n(x, y) is an arbitrary point on the line.\\n(x1, y1) and (x2, y2) are coordinates of points lying on the line.\\nand y2-y1/x2-x1 is the slope of the line. \\n\\nUsing this I stored all the points having the same slope in a map. \\nHere it is important to consider the case where the denominator is 0. In that case the slope is undefined. I set the slope to 10 for that case. \\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(nlogn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1) return 1;\\n        int ans = 0;\\n        for(int i =1;i<points.size();++i){\\n            map<float,set<pair<int,int>>> m;\\n            for(int j =0;j<i;++j){\\n                float x1 = points[i][0];\\n                float y1 = points[i][1];\\n                float x2 = points[j][0];\\n                float y2 = points[j][1];\\n                float slope;\\n                if(x2-x1==0){\\n                    slope = 10;\\n                }else slope  = (y2-y1)/(x2-x1);\\n                m[slope].insert({x1,y1});\\n                m[slope].insert({x2,y2});\\n                // cout << \"slope : \" << slope << \" \" << x1 << \" \" << y1 << \" \"<< x2 << \" \" << y2 <<endl; \\n            }\\n            for(auto p : m){\\n            // cout << \"slope is : \" << p.first <<endl;\\n            //for(auto elem : p.second){\\n            //    cout << elem.first << \" \"<< elem.second << endl;\\n            //}\\n            //cout << endl;\\n           int val = p.second.size();\\n        //    if(p.first==10)continue;\\n           ans = max(ans,val);\\n        }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1) return 1;\\n        int ans = 0;\\n        for(int i =1;i<points.size();++i){\\n            map<float,set<pair<int,int>>> m;\\n            for(int j =0;j<i;++j){\\n                float x1 = points[i][0];\\n                float y1 = points[i][1];\\n                float x2 = points[j][0];\\n                float y2 = points[j][1];\\n                float slope;\\n                if(x2-x1==0){\\n                    slope = 10;\\n                }else slope  = (y2-y1)/(x2-x1);\\n                m[slope].insert({x1,y1});\\n                m[slope].insert({x2,y2});\\n                // cout << \"slope : \" << slope << \" \" << x1 << \" \" << y1 << \" \"<< x2 << \" \" << y2 <<endl; \\n            }\\n            for(auto p : m){\\n            // cout << \"slope is : \" << p.first <<endl;\\n            //for(auto elem : p.second){\\n            //    cout << elem.first << \" \"<< elem.second << endl;\\n            //}\\n            //cout << endl;\\n           int val = p.second.size();\\n        //    if(p.first==10)continue;\\n           ans = max(ans,val);\\n        }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2507803,
                "title": "c-math-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end());\\n        int n = points.size(), cnt = 0;\\n        for(int i=0; i<n; ++i){\\n            unordered_map<double, int> mp;\\n            int yAxis = 0;\\n            for(int j=i+1; j<n; ++j){\\n                int dy = points[j][1] - points[i][1];\\n                int dx = points[j][0] - points[i][0];\\n                if(dx==0){\\n                    yAxis++;\\n                }else{\\n                    double slope = (double)dy/dx;\\n                    mp[slope]++;\\n                }\\n            }\\n            for(auto &m : mp){\\n                cnt = max(cnt, m.second);\\n            }\\n            cnt = max(cnt, yAxis);\\n        }\\n        return cnt+1;\\n    }\\n\\t\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end());\\n        int n = points.size(), cnt = 0;\\n        for(int i=0; i<n; ++i){\\n            unordered_map<double, int> mp;\\n            int yAxis = 0;\\n            for(int j=i+1; j<n; ++j){\\n                int dy = points[j][1] - points[i][1];\\n                int dx = points[j][0] - points[i][0];\\n                if(dx==0){\\n                    yAxis++;\\n                }else{\\n                    double slope = (double)dy/dx;\\n                    mp[slope]++;\\n                }\\n            }\\n            for(auto &m : mp){\\n                cnt = max(cnt, m.second);\\n            }\\n            cnt = max(cnt, yAxis);\\n        }\\n        return cnt+1;\\n    }\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297988,
                "title": "line-equation-y-mx-c-n-n-1-2-pairs-maths",
                "content": "This is pretty standard lines and points problem.\\n1. If there are two points (x1, y1) and (x2, y2), equation is `y = mx + c`. M is slope and c is constant, telling you how much offset it is from base.\\n2. `m = dy / dx` where `dy = y2 - y1` and `dx = x2 - x1`. When dx is zero, it is vertical line. So, handle vertical lines seperately \\n3. Using 2 points, create an equation, as we have `m` calculated using above formula, we can derive `c` using any one point\\'s value.\\n4. Make sure to truncate `m` and `c` to upto 4 or 5 floating points to have same equation.\\n5. Make a dictionary of all equations \\n6. Final max frequency of any equation is `number of pairs` formed by `n` number of points.\\n7. For e.g., 2 points => 2 pairs, 3 points => 4 pairs, 4 points => 6 pairs. `n x (n - 1) / 2 => pairs` \\n8. To get `n`, either solve it or use brute force approach using loop from 1 to 300\\n\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\n\\nvar maxPoints = function(points) {\\n    if (points.length === 1) {\\n        return 1;\\n    }\\n    \\n    const slopes = {};\\n    let dx, dy;\\n    let xbase, ybase;\\n    let xref, yref, key;\\n    const INFINITE_SLOPE = \\'infinite\\';\\n    \\n    for(let i = 0; i < points.length; i++) {\\n        [xbase, ybase] = points[i];\\n        \\n        for(let j = i + 1; j < points.length; j++) {                       \\n            \\n            [xref, yref] = points[j];\\n            \\n            if (xref === xbase) {\\n                key = `x = ${xref}`;\\n                \\n            } else {\\n                dx = xref - xbase;\\n                dy = yref - ybase;\\n                \\n                let m = dy / dx;\\n                let c = yref - m * xref;\\n                \\n                m = m.toFixed(4);\\n                c = c.toFixed(4);\\n                \\n                key = `y = ${m}x + ${c}`;                \\n            }\\n            \\n            slopes[key] || (slopes[key] = 0);\\n            slopes[key]++;\\n        }\\n    }\\n    \\n    const maxPairs = Math.max(...Object.values(slopes));\\n    \\n    if (maxPairs === 2) {\\n        return 2;\\n    }\\n    \\n    for(let i = 1; i <= 300; i++) {\\n        if (i * (i - 1) / 2 === maxPairs) {\\n            return i;\\n        }\\n    }\\n    \\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\n\\nvar maxPoints = function(points) {\\n    if (points.length === 1) {\\n        return 1;\\n    }\\n    \\n    const slopes = {};\\n    let dx, dy;\\n    let xbase, ybase;\\n    let xref, yref, key;\\n    const INFINITE_SLOPE = \\'infinite\\';\\n    \\n    for(let i = 0; i < points.length; i++) {\\n        [xbase, ybase] = points[i];\\n        \\n        for(let j = i + 1; j < points.length; j++) {                       \\n            \\n            [xref, yref] = points[j];\\n            \\n            if (xref === xbase) {\\n                key = `x = ${xref}`;\\n                \\n            } else {\\n                dx = xref - xbase;\\n                dy = yref - ybase;\\n                \\n                let m = dy / dx;\\n                let c = yref - m * xref;\\n                \\n                m = m.toFixed(4);\\n                c = c.toFixed(4);\\n                \\n                key = `y = ${m}x + ${c}`;                \\n            }\\n            \\n            slopes[key] || (slopes[key] = 0);\\n            slopes[key]++;\\n        }\\n    }\\n    \\n    const maxPairs = Math.max(...Object.values(slopes));\\n    \\n    if (maxPairs === 2) {\\n        return 2;\\n    }\\n    \\n    for(let i = 1; i <= 300; i++) {\\n        if (i * (i - 1) / 2 === maxPairs) {\\n            return i;\\n        }\\n    }\\n    \\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1572659,
                "title": "easy-java-5ms-faster-than-94",
                "content": "\\n```\\n // Time: O(N^2) \\n // Use a map to store <slope, points for lines with same slope>\\n // HashMap<Double, Set<Integer>> countSlopes ; \\n // Set<Integer> should store indices of the points (multiple indices with same coorsinates)\\n \\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points.length == 1)\\n            return 1;\\n        \\n        HashMap<Double, HashSet<Integer>> countSlopes = new HashMap<Double, HashSet<Integer>>();\\n        int maxpoints = 0;\\n        for(int i = 0; i < points.length;i++)\\n        {\\n            countSlopes.clear();\\n            \\n            for(int j =  i+1; j < points.length; j++)\\n            {\\n                double slope = getSlope(points[i],points[j]);\\n                HashSet<Integer> pointSet = countSlopes.getOrDefault(slope, new HashSet<Integer>());\\n                pointSet.add(i);\\n                pointSet.add(j);\\n                countSlopes.put(slope,pointSet);\\n                maxpoints = Math.max(maxpoints, pointSet.size());\\n            }\\n        }\\n        \\n        return maxpoints;\\n    }\\n    \\n\\t// Y= m*X + C. return m.\\n    public double getSlope(int[] pointA, int[] pointB)\\n    {\\n        int Y = pointA[1]-pointB[1];\\n        int X = pointA[0]- pointB[0];\\n        \\n        return X == 0 ? Double.MIN_VALUE : (double)(Y)/(double)X + 0.0; // +0.0 to get rid of -0.0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n // Time: O(N^2) \\n // Use a map to store <slope, points for lines with same slope>\\n // HashMap<Double, Set<Integer>> countSlopes ; \\n // Set<Integer> should store indices of the points (multiple indices with same coorsinates)\\n \\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points.length == 1)\\n            return 1;\\n        \\n        HashMap<Double, HashSet<Integer>> countSlopes = new HashMap<Double, HashSet<Integer>>();\\n        int maxpoints = 0;\\n        for(int i = 0; i < points.length;i++)\\n        {\\n            countSlopes.clear();\\n            \\n            for(int j =  i+1; j < points.length; j++)\\n            {\\n                double slope = getSlope(points[i],points[j]);\\n                HashSet<Integer> pointSet = countSlopes.getOrDefault(slope, new HashSet<Integer>());\\n                pointSet.add(i);\\n                pointSet.add(j);\\n                countSlopes.put(slope,pointSet);\\n                maxpoints = Math.max(maxpoints, pointSet.size());\\n            }\\n        }\\n        \\n        return maxpoints;\\n    }\\n    \\n\\t// Y= m*X + C. return m.\\n    public double getSlope(int[] pointA, int[] pointB)\\n    {\\n        int Y = pointA[1]-pointB[1];\\n        int X = pointA[0]- pointB[0];\\n        \\n        return X == 0 ? Double.MIN_VALUE : (double)(Y)/(double)X + 0.0; // +0.0 to get rid of -0.0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532303,
                "title": "java-simple-and-clean-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n      \\n        int maxPoints = -1;\\n        \\n        for(int i = 0; i < points.length; i++)\\n        {\\n            Map<Double, Integer> map = new HashMap<>();\\n            int sameX = 1, samePoints = 0;\\n            \\n            for(int j = 0; j < points.length; j++)\\n            {\\n                if(i == j) continue;\\n\\n                int x1 = points[i][0], y1 = points[i][1];\\n                int x2 = points[j][0], y2 = points[j][1];\\n\\n                if(x1 == x2 && y1 == y2) samePoints++;\\n                \\n                if(x1 == x2) \\n                {\\n                    sameX++; \\n                    continue;\\n                }\\n                \\n                double slope = (double) (y2 - y1) / (double) (x2 - x1);\\n                \\n                if(map.containsKey(slope))\\n                {\\n                    map.put(slope,map.get(slope) + 1);\\n                }\\n                else\\n                {\\n                    map.put(slope, 2);\\n                }\\n                \\n                maxPoints = Math.max(maxPoints, map.get(slope) + samePoints);\\n            }\\n            \\n            maxPoints = Math.max(maxPoints, sameX);\\n        }\\n        \\n        \\n        return maxPoints;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n      \\n        int maxPoints = -1;\\n        \\n        for(int i = 0; i < points.length; i++)\\n        {\\n            Map<Double, Integer> map = new HashMap<>();\\n            int sameX = 1, samePoints = 0;\\n            \\n            for(int j = 0; j < points.length; j++)\\n            {\\n                if(i == j) continue;\\n\\n                int x1 = points[i][0], y1 = points[i][1];\\n                int x2 = points[j][0], y2 = points[j][1];\\n\\n                if(x1 == x2 && y1 == y2) samePoints++;\\n                \\n                if(x1 == x2) \\n                {\\n                    sameX++; \\n                    continue;\\n                }\\n                \\n                double slope = (double) (y2 - y1) / (double) (x2 - x1);\\n                \\n                if(map.containsKey(slope))\\n                {\\n                    map.put(slope,map.get(slope) + 1);\\n                }\\n                else\\n                {\\n                    map.put(slope, 2);\\n                }\\n                \\n                maxPoints = Math.max(maxPoints, map.get(slope) + samePoints);\\n            }\\n            \\n            maxPoints = Math.max(maxPoints, sameX);\\n        }\\n        \\n        \\n        return maxPoints;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612420,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if (points.size()<=2){\\n            return points.size();\\n        }\\n        int overlap = 0, result = 0, cur = 0;\\n        int x, y, gcd;\\n        map<int, map<int, int>> freq;\\n        for (int i=0; i<points.size()-1; i++){\\n            overlap = 0; cur = 0; freq.clear();\\n            for (int j=i+1; j<points.size(); j++){\\n                x = points[j][0] - points[i][0];\\n                y = points[j][1] - points[i][1];\\n                if (x==0 && y==0){\\n                    overlap++; continue;\\n                }\\n                gcd = generateGCD(x, y);\\n                if (gcd != 0){\\n                    x /= gcd; y /= gcd;\\n                }\\n                freq[x][y]++;\\n                cur = max(cur, freq[x][y]);\\n            }\\n            result = max(result, cur + overlap + 1);\\n        }\\n        return result;\\n    }\\n    \\n    int generateGCD(int a, int b) {\\n        if (b == 0) return a;\\n        \\n        return generateGCD(b, a % b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if (points.size()<=2){\\n            return points.size();\\n        }\\n        int overlap = 0, result = 0, cur = 0;\\n        int x, y, gcd;\\n        map<int, map<int, int>> freq;\\n        for (int i=0; i<points.size()-1; i++){\\n            overlap = 0; cur = 0; freq.clear();\\n            for (int j=i+1; j<points.size(); j++){\\n                x = points[j][0] - points[i][0];\\n                y = points[j][1] - points[i][1];\\n                if (x==0 && y==0){\\n                    overlap++; continue;\\n                }\\n                gcd = generateGCD(x, y);\\n                if (gcd != 0){\\n                    x /= gcd; y /= gcd;\\n                }\\n                freq[x][y]++;\\n                cur = max(cur, freq[x][y]);\\n            }\\n            result = max(result, cur + overlap + 1);\\n        }\\n        return result;\\n    }\\n    \\n    int generateGCD(int a, int b) {\\n        if (b == 0) return a;\\n        \\n        return generateGCD(b, a % b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412945,
                "title": "python3-with-explanation",
                "content": "```\\nimport collections\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        # Question stem: we need to find all lines and return the maximum count of points in a line\\n        # Idea: Use a dictionary to store \\'slope\\' and \\'count\\'. \\n\\t\\t# We need to traverse all points and each time we will calculate the slope between two points \\n\\t\\t# and store it in string type (That\\'s why we need to calculate GCD. We need to simplify the fraction)\\n        \\n        if len(points) <= 2:\\n            return len(points)\\n\\n        def getGCD(a, b):\\n            if a == 0:\\n                return b\\n            return getGCD(b % a, a)\\n        \\n        max_n = 0\\n        for i in range(len(points)):\\n            dic = collections.defaultdict(int)\\n            line_n, same_n = 0, 0\\n            for j in range(i+1, len(points)):\\n                dx = points[j][0] - points[i][0]\\n                dy = points[j][1] - points[i][1]\\n                if dx== 0 and dy == 0: # Case: [[0,0],[0,0]], the result should be 2. So we should count the number of same points.\\n                    same_n += 1\\n                    continue\\n                gcd = getGCD(dx, dy)\\n                slope = str(dx//gcd) + \\' \\' + str(dy//gcd) # If use /, there will be \\'-0.0\\'\\n                dic[slope] += 1\\n                line_n = max(line_n, dic[slope])\\n            max_n = max(max_n, line_n+same_n+1)\\n        return max_n\\n                \\n                \\n    \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        # Question stem: we need to find all lines and return the maximum count of points in a line\\n        # Idea: Use a dictionary to store \\'slope\\' and \\'count\\'. \\n\\t\\t# We need to traverse all points and each time we will calculate the slope between two points \\n\\t\\t# and store it in string type (That\\'s why we need to calculate GCD. We need to simplify the fraction)\\n        \\n        if len(points) <= 2:\\n            return len(points)\\n\\n        def getGCD(a, b):\\n            if a == 0:\\n                return b\\n            return getGCD(b % a, a)\\n        \\n        max_n = 0\\n        for i in range(len(points)):\\n            dic = collections.defaultdict(int)\\n            line_n, same_n = 0, 0\\n            for j in range(i+1, len(points)):\\n                dx = points[j][0] - points[i][0]\\n                dy = points[j][1] - points[i][1]\\n                if dx== 0 and dy == 0: # Case: [[0,0],[0,0]], the result should be 2. So we should count the number of same points.\\n                    same_n += 1\\n                    continue\\n                gcd = getGCD(dx, dy)\\n                slope = str(dx//gcd) + \\' \\' + str(dy//gcd) # If use /, there will be \\'-0.0\\'\\n                dic[slope] += 1\\n                line_n = max(line_n, dic[slope])\\n            max_n = max(max_n, line_n+same_n+1)\\n        return max_n\\n                \\n                \\n    \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 111269,
                "title": "easy-to-understand-accepted-python-code-with-detailed-explanation",
                "content": "To find maximum points that are collinear (lie on a line), we need to understand when are more than two points collinear.\\n\\nTwo points are trivially collinear since two points determine a line.\\n\\nThree points $x_i=(x_i,y_i,z_i)$ for $i=1, 2, 3$ are collinear iff the ratios of distances satisfy\\n$$ x_2-x_1:y_2-y_1:z_2-z_1=x_3-x_1:y_3-y_1:z_3-z_1. $$\\n\\n<h4>Basic Idea</h4>\\nWe can just maintain a HashMap / Dictionary of slope values and increment its count for every similar value of the slope found as we iterate over the pair of points. For each point we update the maximum number of point count we have seen so far.\\n\\nBefore we do this, we just need to keep three things in mind:\\n1. Points might be vertical in which case calculating the slope would throw DivisionByZero exception. So for such cases, we can just keep a count of verticalPoints separately.\\n2. There might be overlapping points. We need to count them separately as well.\\n3. Even for the points which are neither vertical, nor overlapping, we will have to deal with fractional quantities and precision might become an issue. Thus, it'd be better to store the fraction $p/q$ in its a HashMap as a tuple. There's another problem in doing so. It isn't necessary that the ratio will always be in its reduced form. So instead of using ratio we reduce pair by their gcd before inserting into the HashMap. Since python does not allow list as a key of dictionary, we will resort to str.\\n\\n```\\ndef gcd(a, b):\\n    while b:\\n        a, b = b, a%b\\n    return a\\n\\ndef maxPoints(points):\\n    slopeMap = dict()\\n    num_points = len(points)\\n    maxPoint = 0\\n    for i in xrange(num_points):\\n        verticalPoints = overlapPoints = currMax = 0\\n        for j in xrange(i + 1, num_points):\\n            print \"(\" + str(points[i].x) + \",\" + str(points[i].y) + \") and (\" + str(points[j].x) + \",\" + str(\\n                points[j].y) + \")\",\\n            if (points[i].x == points[j].x and points[i].y == points[j].y):\\n                overlapPoints += 1\\n                print \"| OVERLAP |\",\\n            elif points[i].x == points[j].x:\\n                verticalPoints += 1\\n                print \"| VERT |\",\\n            else:\\n                print \"| NORM |\",\\n                slope = [(points[i].y - points[j].y), (points[i].x - points[j].x)]\\n                temp = gcd(slope[0], slope[1])\\n                slope = [slope[0] / temp, slope[1] / temp]\\n                try:\\n                    slopeMap[str(slope)] += 1\\n                except:\\n                    slopeMap[str(slope)] = 1\\n                # update the current max - has the current slope value risen to the top?\\n                print \"currMax =\", currMax, \"but slopeMap[slope] = \", slopeMap[str(slope)],\\n                currMax = max(currMax, slopeMap[str(slope)])\\n\\n            # has number of vertical points risen even more?\\n            currMax = max(currMax, verticalPoints)\\n            print \"currMax =\", currMax\\n\\n        # maxpoint - the maximum number of collinear points with this point\\n        maxPoint = max(maxPoint, currMax + overlapPoints + 1)\\n        print \" - Max number of points collinear at this stage are\", maxPoint\\n        slopeMap.clear()\\n    return maxPoint\\n```\\n\\n<h4>Testing</h4>\\nTo test our code, lets write a small test case generator.\\n\\n```\\ndef generateNPoints(N):\\n    return [Point(random.randint(0,12), random.randint(0,12)) for _ in xrange(N)]\\n\\ndef printPoints(NPoints):\\n    for point in NPoints:\\n        print \"[\" + str(point.x) + \",\" + str(point.y) + \"],\",\\n    print \"\"\\n```\\n\\n<h4>Example</h4>\\n\\nTest Case:\\n<pre>\\n[7,4], [5,7], [7,4], [8,6], [0,3], [1,6]\\n</pre>\\n\\nOutput\\n<pre>\\n(7,4) and (5,7) | NORM | currMax = 0 but slopeMap[slope] =  1 currMax = 1\\n(7,4) and (7,4) | OVERLAP | currMax = 1\\n(7,4) and (8,6) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n(7,4) and (0,3) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n(7,4) and (1,6) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n - Max number of points collinear at this stage are 3 0 1\\n(5,7) and (7,4) | NORM | currMax = 0 but slopeMap[slope] =  1 currMax = 1\\n(5,7) and (8,6) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n(5,7) and (0,3) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n(5,7) and (1,6) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n - Max number of points collinear at this stage are 3 0 0\\n(7,4) and (8,6) | NORM | currMax = 0 but slopeMap[slope] =  1 currMax = 1\\n(7,4) and (0,3) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n(7,4) and (1,6) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n - Max number of points collinear at this stage are 3 0 0\\n(8,6) and (0,3) | NORM | currMax = 0 but slopeMap[slope] =  1 currMax = 1\\n(8,6) and (1,6) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n - Max number of points collinear at this stage are 3 0 0\\n(0,3) and (1,6) | NORM | currMax = 0 but slopeMap[slope] =  1 currMax = 1\\n - Max number of points collinear at this stage are 3 0 0\\n - Max number of points collinear at this stage are 3 0 0\\n3\\n</pre>",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef gcd(a, b):\\n    while b:\\n        a, b = b, a%b\\n    return a\\n\\ndef maxPoints(points):\\n    slopeMap = dict()\\n    num_points = len(points)\\n    maxPoint = 0\\n    for i in xrange(num_points):\\n        verticalPoints = overlapPoints = currMax = 0\\n        for j in xrange(i + 1, num_points):\\n            print \"(\" + str(points[i].x) + \",\" + str(points[i].y) + \") and (\" + str(points[j].x) + \",\" + str(\\n                points[j].y) + \")\",\\n            if (points[i].x == points[j].x and points[i].y == points[j].y):\\n                overlapPoints += 1\\n                print \"| OVERLAP |\",\\n            elif points[i].x == points[j].x:\\n                verticalPoints += 1\\n                print \"| VERT |\",\\n            else:\\n                print \"| NORM |\",\\n                slope = [(points[i].y - points[j].y), (points[i].x - points[j].x)]\\n                temp = gcd(slope[0], slope[1])\\n                slope = [slope[0] / temp, slope[1] / temp]\\n                try:\\n                    slopeMap[str(slope)] += 1\\n                except:\\n                    slopeMap[str(slope)] = 1\\n                # update the current max - has the current slope value risen to the top?\\n                print \"currMax =\", currMax, \"but slopeMap[slope] = \", slopeMap[str(slope)],\\n                currMax = max(currMax, slopeMap[str(slope)])\\n\\n            # has number of vertical points risen even more?\\n            currMax = max(currMax, verticalPoints)\\n            print \"currMax =\", currMax\\n\\n        # maxpoint - the maximum number of collinear points with this point\\n        maxPoint = max(maxPoint, currMax + overlapPoints + 1)\\n        print \" - Max number of points collinear at this stage are\", maxPoint\\n        slopeMap.clear()\\n    return maxPoint\\n```\n```\\ndef generateNPoints(N):\\n    return [Point(random.randint(0,12), random.randint(0,12)) for _ in xrange(N)]\\n\\ndef printPoints(NPoints):\\n    for point in NPoints:\\n        print \"[\" + str(point.x) + \",\" + str(point.y) + \"],\",\\n    print \"\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 47164,
                "title": "2-liner-in-python-complex-solution-without-gcd",
                "content": "Motivated by @o_sharp's [solution](https://discuss.leetcode.com/topic/53632/6-liner-in-python-simple-solution-without-gcd) (and I pretty much stole the title :-P).\\n```\\nfrom collections import Counter\\nfrom cmath import phase\\n\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        P = [complex(p.x, p.y) for p in points]\\n        return max([P.count(p) + max(Counter(phase(q - p) for q in P if q != p).values() or [0]) for p in P] or [0])\\n```\\nGranted, it's three lines if I count the `cmath` import (LeetCode does import `collections` for us, but not `cmath`).",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nfrom cmath import phase\\n\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        P = [complex(p.x, p.y) for p in points]\\n        return max([P.count(p) + max(Counter(phase(q - p) for q in P if q != p).values() or [0]) for p in P] or [0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47278,
                "title": "simple-c-solution",
                "content": "    int maxPoints(vector<Point>& points) {\\n        int n = (int)points.size();\\n        if(n<3) return n;\\n        int result = 0;\\n        for(int i=0;i<n;i++) {\\n            int duplicate = 1;\\n            int localMax = 0;\\n            unordered_map<float,int> m;\\n            for (int j=i+1; j<n; j++) {\\n                if(points[j].x==points[i].x && points[j].y==points[i].y) duplicate++;\\n                else if(points[j].x==points[i].x) m[INFINITY]++;\\n                else {\\n                    float k = (float)(points[j].y-points[i].y)/(points[j].x-points[i].x);\\n                    m[k]++;\\n                }\\n            }\\n            for(auto i=m.begin();i!=m.end();i++)\\n                localMax = max(localMax,i->second);\\n            result = max(result,localMax+duplicate);\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    int maxPoints(vector<Point>& points) {\\n        int n = (int)points.size();\\n        if(n<3) return n;\\n        int result = 0;\\n        for(int i=0;i<n;i++) {\\n            int duplicate = 1;\\n            int localMax = 0;\\n            unordered_map<float,int> m;\\n            for (int j=i+1; j<n; j++) {\\n                if(points[j].x==points[i].x && points[j].y==points[i].y) duplicate++;\\n                else if(points[j].x==points[i].x) m[INFINITY]++;\\n                else {\\n                    float k = (float)(points[j].y-points[i].y)/(points[j].x-points[i].x);\\n                    m[k]++;\\n                }\\n            }\\n            for(auto i=m.begin();i!=m.end();i++)\\n                localMax = max(localMax,i->second);\\n            result = max(result,localMax+duplicate);\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 47277,
                "title": "30-ms-c-solution-with-explaination",
                "content": "    // LOGIC : sort the points based on x value. Now, calculate the slopes with points after the current \\n    // point. Keep on adding to points with same slope. Once done with current points, we ll have a set of slopes m\\n    // with the number of points with those slopes. Any possible slope having current point is already in the set of slopes.\\n    // If we take another point say j after i, then we have already calculated points with slope that is between j and i. thus we just need\\n    // to look after i. \\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            auto comp = [] (Point& a, Point& b) { return a.x < b.x; };\\n            int n = points.size();\\n            int max_count = 0;\\n            std::sort(points.begin(), points.end(), comp);\\n            for (int i = 0; i < n; ++i) {\\n                unordered_map<double, int> slope_map;\\n                Point& p1 = points[i];\\n                int same_point = 1;\\n                int local_max = 1; // local max to get the number of points passing through max slope line starting at i\\n                \\n                // only look for points after the current one since ,\\n                // we have taken care of line segments before i with j when\\n                // running iteration for previous values of i\\n                for (int j = i+1; j < n; ++j) {\\n                    double m = 0.0;\\n                    Point& p2 = points[j];\\n                    if (p1.x == p2.x && p1.y == p2.y) {\\n                        same_point++;\\n                        local_max = max(local_max, same_point);\\n                        continue;\\n                    } else if (p1.x == p2.x) {\\n                        m = INT_MAX;\\n                    } else {\\n                        m = ((double)(p2.y-p1.y))/(p2.x-p1.x);\\n                    }\\n                    if (slope_map.find(m) == slope_map.end()) {\\n                        slope_map[m] = same_point;\\n                    }\\n                    slope_map[m]++;\\n                    local_max = max(local_max, slope_map[m]);\\n                }\\n                max_count = max(local_max, max_count);\\n            }\\n            return max_count;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            auto comp = [] (Point& a, Point& b) { return a.x < b.x; }",
                "codeTag": "Java"
            },
            {
                "id": 47341,
                "title": "why-my-output-on-my-own-computer-is-correct-but-the-output-on-the-web-is-wrong",
                "content": "    class Solution:\\n    # @param points, a list of Points\\n    # @return an integer\\n    def maxPoints(self, points):\\n        if len(points) <= 1:\\n            return len(points)\\n        infinity = 100.34 #some number that's not likely to appear\\n        result = 0\\n        \\n        for i in range(len(points)):\\n            diction = dict({infinity:0})\\n            samepoint = 1\\n            for j in range(i + 1, len(points)):\\n                #print ('i',i,'j', j)\\n                if (points[i].x == points[j].x and points[i].y == points[j].y):\\n                    samepoint += 1\\n                elif (points[i].x == points[j].x):\\n                    diction[infinity] += 1\\n                else:\\n                    k = (points[j].y - points[i].y) /(points[j].x - points[i].x)\\n                    if (k in diction):\\n                        diction[k]+= 1\\n                    else:\\n                        diction.update({k: 1})\\n            #print (diction)\\n            Max = 0\\n            for i in diction:\\n                Max = max(Max, diction[i])\\n            thisresult = Max + samepoint\\n            \\n            result = max(result, thisresult)\\n        return result\\n\\nThe input of my wrong answer is [(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)].\\n\\nI copy the input in the wrong answer, then run on my IDLE, it outputs 6, which is the correct answer. But when I run this code, they told me my output is 8. Are there something wrong?",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param points, a list of Points\\n    # @return an integer\\n    def maxPoints(self, points):\\n        if len(points) <= 1:\\n            return len(points)\\n        infinity = 100.34 #some number that's not likely to appear\\n        result = 0\\n        \\n        for i in range(len(points)):\\n            diction = dict({infinity:0}",
                "codeTag": "Java"
            },
            {
                "id": 3050679,
                "title": "c-explained-o-n-2-solution-using-map",
                "content": "# Intuition\\nTake a point and calculate slope between that point and other points. The slope may be infinite or finite.\\nCheck for all the points and update answer as per the number of points with the same slope.\\n\\n# Approach\\nConsider a map to store number of points with a given slope.\\nTake a varibale named infinite and increment it for the points whose slope is infinite, otherwise update map for non infinite slopes and update answer accordingly.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()<=2){return points.size();}//two or less points are always in a straight line\\n        int infinite=0;//to handle points with infinite slope\\n        int ans=0;//to store the number of maxpoints in a line\\n        double slope;\\n    \\n    for(int i=0;i<points.size()-1;i++){//iterating over points\\n        unordered_map<double,int> mp;//to store the occurance of a slope\\n        for(int j=i;j<points.size();j++){//checking slope of the point with other points\\n            \\n            if(points[j][0]==points[i][0]){//if x coordinates are same\\n                infinite++; //increment for infinite slope\\n                ans=max({ans,infinite});//update answer\\n            }\\n            else{//if slope is not infinite\\n                slope=(double)(points[j][1]-points[i][1])/(double)(points[j][0]-points[i][0]);//calculate slope\\n                mp[slope]++;//update map\\n                ans=max({ans,mp[slope]+1});//update answer\\n            }   \\n        }\\n        infinite=0;//make it zero after iterating\\n    }    \\n    return ans;\\n    }\\n};\\n```\\n**Please upvote if it helps. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()<=2){return points.size();}//two or less points are always in a straight line\\n        int infinite=0;//to handle points with infinite slope\\n        int ans=0;//to store the number of maxpoints in a line\\n        double slope;\\n    \\n    for(int i=0;i<points.size()-1;i++){//iterating over points\\n        unordered_map<double,int> mp;//to store the occurance of a slope\\n        for(int j=i;j<points.size();j++){//checking slope of the point with other points\\n            \\n            if(points[j][0]==points[i][0]){//if x coordinates are same\\n                infinite++; //increment for infinite slope\\n                ans=max({ans,infinite});//update answer\\n            }\\n            else{//if slope is not infinite\\n                slope=(double)(points[j][1]-points[i][1])/(double)(points[j][0]-points[i][0]);//calculate slope\\n                mp[slope]++;//update map\\n                ans=max({ans,mp[slope]+1});//update answer\\n            }   \\n        }\\n        infinite=0;//make it zero after iterating\\n    }    \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020084,
                "title": "optimization-using-sorting-faster-than-official-solution-clean-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake cluster of points having same angle with respect to x-axis and return maximum cluster size.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to sort the points first which allows us to just go through next points from current point instead of checking all possible pair of points.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& pts) {\\n        if(pts.size() == 1) return 1;\\n        sort(pts.begin(), pts.end());\\n        int res = 2;\\n        for(int i = 0; i < pts.size()-1; i++) {\\n            unordered_map<double, int> mp;\\n            for(int j = i+1; j < pts.size(); j++) {\\n                double num = pts[j][1] - pts[i][1];\\n                double den = pts[j][0] - pts[i][0];\\n                if(j != i) mp[atan2(num, den)]++;\\n            } for(auto [k, v]: mp) res = max(res, v+1);\\n        } return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& pts) {\\n        if(pts.size() == 1) return 1;\\n        sort(pts.begin(), pts.end());\\n        int res = 2;\\n        for(int i = 0; i < pts.size()-1; i++) {\\n            unordered_map<double, int> mp;\\n            for(int j = i+1; j < pts.size(); j++) {\\n                double num = pts[j][1] - pts[i][1];\\n                double den = pts[j][0] - pts[i][0];\\n                if(j != i) mp[atan2(num, den)]++;\\n            } for(auto [k, v]: mp) res = max(res, v+1);\\n        } return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019999,
                "title": "line-slopes-c-good-code-quality-solution-short-simple-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs learnt in school if some set of points have a common slope then they are on the same line. The only condition is one point should be common which originates that line which have the same slope.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we used brute force way of solving the problem since the constraints are low.\\nWe basically tried every set of points and use a map to store how many points have same slope.\\nFinally we calculate maximum points having same slope and updated the result accordingly.\\n\\n```\\nCalculating slope for points (x1,y1) and (x2,y2)\\nSlope = (y2-y1)/(x2-x1)\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$ where N is number of points maximum 300 points\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1) return 1;\\n        int result=0;\\n        unordered_map<double,int> slopes;\\n        double slope = 0;\\n        for(int i=0;i<points.size();++i){\\n            for(int j=i+1;j<points.size();++j){\\n                slope = ((double)(points[j][1]-points[i][1])/(double)(points[j][0]-points[i][0]));\\n                cout<<slope<<\"\\\\n\";\\n                if((points[j][0]-points[i][0])==0){\\n                    slope=DBL_MAX;\\n                }\\n                slopes[slope]++;\\n            }\\n            for(auto [slope,cnt]:slopes){\\n                result = max(result,cnt+1);\\n            }\\n            slopes.clear();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nCalculating slope for points (x1,y1) and (x2,y2)\\nSlope = (y2-y1)/(x2-x1)\\n```\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1) return 1;\\n        int result=0;\\n        unordered_map<double,int> slopes;\\n        double slope = 0;\\n        for(int i=0;i<points.size();++i){\\n            for(int j=i+1;j<points.size();++j){\\n                slope = ((double)(points[j][1]-points[i][1])/(double)(points[j][0]-points[i][0]));\\n                cout<<slope<<\"\\\\n\";\\n                if((points[j][0]-points[i][0])==0){\\n                    slope=DBL_MAX;\\n                }\\n                slopes[slope]++;\\n            }\\n            for(auto [slope,cnt]:slopes){\\n                result = max(result,cnt+1);\\n            }\\n            slopes.clear();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3019734,
                "title": "typescript-beats-100-easy-to-understand-commented-solution",
                "content": "# Complexity\\n- Time complexity:\\n- O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction maxPoints(points: number[][]): number {\\n    if (points.length <= 2) return points.length;\\n\\n    const map = new Map<number, number>();\\n    let result: number = 0;\\n\\n    // y = mx + c\\n    for (let i = 0; i < points.length; i++) {\\n        const [x0, y0] = points[i];\\n\\n        // we will count each point with each and determine the largest number that can be put on one line (slope m)\\n        for (let j = i + 1; j < points.length; j++) {\\n            const [x1, y1] = points[j];\\n\\n            let m: number;\\n\\n            // => horizontal line\\n            if (x0 === x1) {\\n                m = Number.MAX_VALUE;\\n            // => vertical line\\n            } else if (y0 === y1) {\\n                m = 0;\\n            } else {\\n                m = (y0 - y1) / (x0 - x1);\\n            }\\n\\n            // new slope ? 2 points : +1 point to what we had\\n            const nextM: number = map.has(m) ? map.get(m) + 1 : 2;\\n            map.set(m, nextM);\\n            result = Math.max(result, nextM);\\n        }\\n        // we have finished counting the results relative to the point i and should clean up this trash\\n        map.clear();\\n        \\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction maxPoints(points: number[][]): number {\\n    if (points.length <= 2) return points.length;\\n\\n    const map = new Map<number, number>();\\n    let result: number = 0;\\n\\n    // y = mx + c\\n    for (let i = 0; i < points.length; i++) {\\n        const [x0, y0] = points[i];\\n\\n        // we will count each point with each and determine the largest number that can be put on one line (slope m)\\n        for (let j = i + 1; j < points.length; j++) {\\n            const [x1, y1] = points[j];\\n\\n            let m: number;\\n\\n            // => horizontal line\\n            if (x0 === x1) {\\n                m = Number.MAX_VALUE;\\n            // => vertical line\\n            } else if (y0 === y1) {\\n                m = 0;\\n            } else {\\n                m = (y0 - y1) / (x0 - x1);\\n            }\\n\\n            // new slope ? 2 points : +1 point to what we had\\n            const nextM: number = map.has(m) ? map.get(m) + 1 : 2;\\n            map.set(m, nextM);\\n            result = Math.max(result, nextM);\\n        }\\n        // we have finished counting the results relative to the point i and should clean up this trash\\n        map.clear();\\n        \\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3019565,
                "title": "c-solution-easy-and-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question we use the slope method of geometry\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the slope of every pair and store the number of pair for a particular slope using hash map.\\n2. Also check everytime if denominator is zero then assume the slope to be maximum value and store it. \\n3. For every pair find the number of points whose slope is same and update the mx variable. \\n\\n# Complexity\\n- Time complexity : O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if (points.size() == 1)\\n        return 1;\\n        int n = points.size();\\n        int mx = INT_MIN;\\n        for (int i = 0 ; i < n ; i++)\\n        {\\n            unordered_map<float ,int> slope;\\n            for (int j = i+1; j < n ; j++)\\n            {\\n                // if denominator is zero \\n                if (points[j][0]-points[i][0] == 0)\\n                {\\n                    slope[INT_MAX]++;\\n                }\\n                else\\n                {\\n                    float s = (points[j][1] - points[i][1])/((points[j][0]- points[i][0])*1.0);\\n                    slope[s]++;\\n                }\\n            }\\n            for (auto i : slope)\\n            mx = max(mx,i.second);      \\n        }\\n        // line is formed by two points and we increase the value by 1 only \\n        return mx+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if (points.size() == 1)\\n        return 1;\\n        int n = points.size();\\n        int mx = INT_MIN;\\n        for (int i = 0 ; i < n ; i++)\\n        {\\n            unordered_map<float ,int> slope;\\n            for (int j = i+1; j < n ; j++)\\n            {\\n                // if denominator is zero \\n                if (points[j][0]-points[i][0] == 0)\\n                {\\n                    slope[INT_MAX]++;\\n                }\\n                else\\n                {\\n                    float s = (points[j][1] - points[i][1])/((points[j][0]- points[i][0])*1.0);\\n                    slope[s]++;\\n                }\\n            }\\n            for (auto i : slope)\\n            mx = max(mx,i.second);      \\n        }\\n        // line is formed by two points and we increase the value by 1 only \\n        return mx+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018495,
                "title": "max-points-on-a-line-c-easy-code",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Slope - Two points : (x1,y1)  (x2,y2) slope : (y2-y1/x2-x1 )\\nunordered_map for storing number of pair of points having same slope.\\nCASE : where slope is infinite we have to store value INT_MAX and increase its frequency by one.\\n\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1||points.size()==2)\\n        return points.size();\\n        int mx=0;\\n        for(int i=0;i<points.size();i++){\\n        unordered_map<float,int> mp;\\n        for(int j=i+1;j<points.size();j++){\\n            if((points[j][0]-points[i][0])==0){\\n            mp[INT_MAX]++;\\n             mx=max(mx,mp[INT_MAX]+1);\\n            }\\n            else{\\n            float x=((points[j][1]-points[i][1])*1.0/(points[j][0]-points[i][0]));\\n            mp[x]++;\\n            mx=max(mx,mp[x]+1);\\n            }\\n        }\\n        }\\n        return mx;\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1||points.size()==2)\\n        return points.size();\\n        int mx=0;\\n        for(int i=0;i<points.size();i++){\\n        unordered_map<float,int> mp;\\n        for(int j=i+1;j<points.size();j++){\\n            if((points[j][0]-points[i][0])==0){\\n            mp[INT_MAX]++;\\n             mx=max(mx,mp[INT_MAX]+1);\\n            }\\n            else{\\n            float x=((points[j][1]-points[i][1])*1.0/(points[j][0]-points[i][0]));\\n            mp[x]++;\\n            mx=max(mx,mp[x]+1);\\n            }\\n        }\\n        }\\n        return mx;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017961,
                "title": "c-overengineered-solution-no-floating-point-numbers",
                "content": "# Approach\\n- For each point `points[i]`:\\n- Initialise a hashmap\\n- For every subsequent point `points[j]` where `i < j`:\\n    - Calculate the gradient of the line from `points[i]` to `points[j]`\\n    - With the gradient as the key in the hashmap increment its value\\n    - Update the result as the maximum of its previous value and the count for the current gradient\\n- Return the max count\\n\\nSince the calculations are always done from one point to every subsequent point only the gradient is required as parallel lines cannot be created.\\n\\n# Implementation\\nOriginally I started with a Python3 implementation using the `fractions` library as a clean way to avoid floating point aritmetic and implementation of the GCD calculation:\\n```\\nfrom collections import defaultdict\\nfrom fractions import Fraction\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        r = 0\\n        for i in range(len(points)):\\n            # Count the number of lines with the same gradient\\n            lines = defaultdict(int)\\n            for j in range(i+1, len(points)):\\n                x1,x2 = points[i][0], points[j][0]\\n                y1,y2 = points[i][1], points[j][1]\\n                if x1-x2 == 0:\\n                    line_grad = float(\"inf\")\\n                else:\\n                    line_grad = Fraction((y1-y2), (x1-x2))\\n                lines[line_grad] += 1\\n                # track the max number of lines with the same gradient\\n                r = max(r, lines[line_grad])\\n        return r+1\\n```\\n\\nI decided to port this across to C++ and retain the use of a Fraction object as an exercise. I created my own `Fraction` structure with methods for determining the greatest common denominator and for comparison of two Fractions. \\n\\nThe GCD function is a simple implementation of [Stein\\'s Algorithm](https://en.wikipedia.org/wiki/Binary_GCD_algorithm).\\n\\nTo hash `Fraction` objects for use as a key in a `std::unordered_map` a bitwise XOR of the `int` hash outputs for the numerator and denominator is done.\\n\\nThe logic is the same as the above Python3 code. \\n\\nRuntime is around 20-40ms.\\n\\n# Code\\n```\\nstruct Fraction {\\n    int a;\\n    int b;\\n    Fraction(int a, int b) {\\n        if (a==0) {\\n            this->a = 0;\\n            this->b = 0;\\n            return;\\n        } else if (b==0) {\\n            this->a = INT_MAX;\\n            this->b = INT_MAX;\\n            return;\\n        }\\n        int divisor = this->gcd(abs(a),abs(b));\\n        this->a = a/divisor;\\n        this->b = b/divisor;\\n        if ((this->a > 0 && this->b < 0) || (this->a < 0 && this->b < 0)) {\\n            this->a *= -1;\\n            this->b *= -1;\\n        }\\n    }\\n    int gcd(int a, int b) {\\n        // Stein\\'s algorithm\\n        if (a==0) {\\n            return b;\\n        } else if (b==0) {\\n            return a;\\n        }\\n        int i = 0;\\n        int j = 0;\\n        while (a&1 == 0) {\\n            a >>= 1;\\n            i++;\\n        }\\n        while (b&1 == 0) {\\n            b >>= 1;\\n            j++;\\n        }\\n        int k = min(i,j);\\n        while (b!=0) {\\n            if (a > b) {\\n                swap(a,b);\\n            }\\n            b -= a;\\n            while (b&1 == 0) {\\n                b >>= 1;\\n            }\\n        }\\n        return a<<k;\\n    }\\n    bool operator==(const Fraction &other) const { \\n        return (this->a == other.a && this->b == other.b);\\n    }\\n};\\n\\nnamespace std {\\n    template <>\\n    struct hash<Fraction> {\\n        std::size_t operator()(const Fraction& k) const {\\n            using std::size_t;\\n            using std::hash;\\n            return hash<int>()(k.a) ^ hash<int>()(k.b);\\n        }\\n    };\\n}\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& ps) {\\n        int r = 0;\\n        unordered_map<Fraction, int> eq_cntr;\\n        for (int i = 0; i < ps.size(); i++) {\\n            eq_cntr.clear();\\n            for (int j = i+1; j < ps.size(); j++) {\\n                Fraction grad = Fraction(ps[i][1]-ps[j][1], ps[i][0]-ps[j][0]);\\n                eq_cntr[grad]++;\\n                r = max(r, eq_cntr[grad]);\\n            }\\n        }\\n        return r+1;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom fractions import Fraction\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        r = 0\\n        for i in range(len(points)):\\n            # Count the number of lines with the same gradient\\n            lines = defaultdict(int)\\n            for j in range(i+1, len(points)):\\n                x1,x2 = points[i][0], points[j][0]\\n                y1,y2 = points[i][1], points[j][1]\\n                if x1-x2 == 0:\\n                    line_grad = float(\"inf\")\\n                else:\\n                    line_grad = Fraction((y1-y2), (x1-x2))\\n                lines[line_grad] += 1\\n                # track the max number of lines with the same gradient\\n                r = max(r, lines[line_grad])\\n        return r+1\\n```\n```\\nstruct Fraction {\\n    int a;\\n    int b;\\n    Fraction(int a, int b) {\\n        if (a==0) {\\n            this->a = 0;\\n            this->b = 0;\\n            return;\\n        } else if (b==0) {\\n            this->a = INT_MAX;\\n            this->b = INT_MAX;\\n            return;\\n        }\\n        int divisor = this->gcd(abs(a),abs(b));\\n        this->a = a/divisor;\\n        this->b = b/divisor;\\n        if ((this->a > 0 && this->b < 0) || (this->a < 0 && this->b < 0)) {\\n            this->a *= -1;\\n            this->b *= -1;\\n        }\\n    }\\n    int gcd(int a, int b) {\\n        // Stein\\'s algorithm\\n        if (a==0) {\\n            return b;\\n        } else if (b==0) {\\n            return a;\\n        }\\n        int i = 0;\\n        int j = 0;\\n        while (a&1 == 0) {\\n            a >>= 1;\\n            i++;\\n        }\\n        while (b&1 == 0) {\\n            b >>= 1;\\n            j++;\\n        }\\n        int k = min(i,j);\\n        while (b!=0) {\\n            if (a > b) {\\n                swap(a,b);\\n            }\\n            b -= a;\\n            while (b&1 == 0) {\\n                b >>= 1;\\n            }\\n        }\\n        return a<<k;\\n    }\\n    bool operator==(const Fraction &other) const { \\n        return (this->a == other.a && this->b == other.b);\\n    }\\n};\\n\\nnamespace std {\\n    template <>\\n    struct hash<Fraction> {\\n        std::size_t operator()(const Fraction& k) const {\\n            using std::size_t;\\n            using std::hash;\\n            return hash<int>()(k.a) ^ hash<int>()(k.b);\\n        }\\n    };\\n}\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& ps) {\\n        int r = 0;\\n        unordered_map<Fraction, int> eq_cntr;\\n        for (int i = 0; i < ps.size(); i++) {\\n            eq_cntr.clear();\\n            for (int j = i+1; j < ps.size(); j++) {\\n                Fraction grad = Fraction(ps[i][1]-ps[j][1], ps[i][0]-ps[j][0]);\\n                eq_cntr[grad]++;\\n                r = max(r, eq_cntr[grad]);\\n            }\\n        }\\n        return r+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017945,
                "title": "c-hashing-mathematics-slope-of-a-line",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        \\n        int n=points.size();\\n        int ans=0;\\n        \\n        double d;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> mp;\\n            for(int j=0;j<n;j++){\\n                if(i==j)continue;\\n                if(points[i][0]==points[j][0]){\\n                    d=INT_MAX;// here slope is infinite \\n                }\\n                else{\\n                    d=(double)(points[i][1]-points[j][1])/(points[i][0]-points[j][0]);//slope of the line\\n                }\\n                mp[d]++;\\n                ans=max(ans,mp[d]);\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        \\n        int n=points.size();\\n        int ans=0;\\n        \\n        double d;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> mp;\\n            for(int j=0;j<n;j++){\\n                if(i==j)continue;\\n                if(points[i][0]==points[j][0]){\\n                    d=INT_MAX;// here slope is infinite \\n                }\\n                else{\\n                    d=(double)(points[i][1]-points[j][1])/(points[i][0]-points[j][0]);//slope of the line\\n                }\\n                mp[d]++;\\n                ans=max(ans,mp[d]);\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017845,
                "title": "explained-with-figures-c-code",
                "content": "* In this problem we have been asked about points on same line\\n* so we can use concept of slop here\\n* Let\\'s see what is slop when two points are on same line:\\n\\n![image](https://assets.leetcode.com/users/images/0c0cf5f3-2273-4b32-b4b7-137ca3054355_1673158155.5956109.png)\\n\\n* Now if we assume that one other point that is b(x3, y3) that is also lies on this line, but when it should be true??\\n\\t* It can be on this line when line xy only``` if slop of xb == slop of xy```\\n\\n![image](https://assets.leetcode.com/users/images/d8955fb8-4f94-404a-9e41-8e6b764fffb1_1673159850.7514677.png)\\n\\n\\n\\n\\n* Note\\n\\t* if there is only one pont then answer is 1\\n\\t* if there is only two points then one line can be drawn\\n\\nSo that\\'s our intution\\n```\\nwe will fix two points  and check for all other remaining points, is they are on same line or not\\n```\\n\\n### Algorithm\\n\\n```\\nn = points.size()\\nif(n <= 2) return n\\n\\nans = 2\\n\\nfor i = 0 to i < n\\n\\tfor j = i+1 to j < n\\n\\t\\tint curr = 2\\n\\t\\tfor k = 0 to k < n\\n\\t\\t\\tif k != i and k != j\\n\\t\\t\\t\\tint x1 = points[i][0]\\n\\t\\t\\t\\tint y1 = points[i][1]\\n\\t\\t\\t\\tint x2 = points[j][0]\\n\\t\\t\\t\\tint y2 = points[j][1]\\n\\t\\t\\t\\tint x3 = points[k][0]\\n\\t\\t\\t\\tint y3 = points[k][1]\\n\\t\\t\\t\\t////for decimal comparion issue we are doing cross multiplication\\n\\t\\t\\t\\tif((x2-x1)*(y3-y1) == (y2-y1)*(x3-x1))  \\n\\t\\t\\t\\t\\tcurr = curr + 1\\n\\t\\tans = max(ans, curr)\\n\\nreturn ans\\n```\\n\\n\\n### C++ Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) { \\n        int n = points.size();\\n        \\n        if(n <= 2) return n;\\n        \\n        int ans = 2; //we will fix two point and then check about other points to be on their line or not by slop concept\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                int curr = 2; //two point are fixed so\\n                for(int k = 0; k < n; k++){\\n                    if(k != i and k != j){ //i and j are fixed points so\\n                        int x1 = points[i][0];\\n                        int y1 = points[i][1];\\n                        int x2 = points[j][0];\\n                        int y2 = points[j][1];\\n                        int x3 = points[k][0];\\n                        int y3 = points[k][1];\\n                        if((x2-x1)*(y3-y1) == (y2-y1)*(x3-x1)) curr++;\\n                    }\\n                }\\n                ans = max(ans, curr);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n#### Upvote if you find it helpfull\\n\\nFollow me on [twitter](https://twitter.com/c_vipul_r)",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` if slop of xb == slop of xy```\n```\\nwe will fix two points  and check for all other remaining points, is they are on same line or not\\n```\n```\\nn = points.size()\\nif(n <= 2) return n\\n\\nans = 2\\n\\nfor i = 0 to i < n\\n\\tfor j = i+1 to j < n\\n\\t\\tint curr = 2\\n\\t\\tfor k = 0 to k < n\\n\\t\\t\\tif k != i and k != j\\n\\t\\t\\t\\tint x1 = points[i][0]\\n\\t\\t\\t\\tint y1 = points[i][1]\\n\\t\\t\\t\\tint x2 = points[j][0]\\n\\t\\t\\t\\tint y2 = points[j][1]\\n\\t\\t\\t\\tint x3 = points[k][0]\\n\\t\\t\\t\\tint y3 = points[k][1]\\n\\t\\t\\t\\t////for decimal comparion issue we are doing cross multiplication\\n\\t\\t\\t\\tif((x2-x1)*(y3-y1) == (y2-y1)*(x3-x1))  \\n\\t\\t\\t\\t\\tcurr = curr + 1\\n\\t\\tans = max(ans, curr)\\n\\nreturn ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) { \\n        int n = points.size();\\n        \\n        if(n <= 2) return n;\\n        \\n        int ans = 2; //we will fix two point and then check about other points to be on their line or not by slop concept\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                int curr = 2; //two point are fixed so\\n                for(int k = 0; k < n; k++){\\n                    if(k != i and k != j){ //i and j are fixed points so\\n                        int x1 = points[i][0];\\n                        int y1 = points[i][1];\\n                        int x2 = points[j][0];\\n                        int y2 = points[j][1];\\n                        int x3 = points[k][0];\\n                        int y3 = points[k][1];\\n                        if((x2-x1)*(y3-y1) == (y2-y1)*(x3-x1)) curr++;\\n                    }\\n                }\\n                ans = max(ans, curr);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017601,
                "title": "python3-itertools-combinations",
                "content": "https://leetcode.com/submissions/detail/873852672/  \\nRuntime: 111 ms, faster than 79.92% of Python3 online submissions for Max Points on a Line.  \\nMemory Usage: 38.4 MB, less than 6.75% of Python3 online submissions for Max Points on a Line.  \\n```\\nfrom itertools import combinations\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points)==1: return 1\\n        lines = dict()\\n        for (x1,y1),(x2,y2) in combinations(points, 2):\\n            if x1==x2:\\n                line = (x1, None)\\n            elif y1==y2:\\n                line = (None, y1)\\n            else:\\n                slope = (y1-y2)/(x1-x2)\\n                intercept = y1-slope*x1\\n                line = (slope, intercept) \\n            if line in lines:\\n                lines[line].add((x1,y1))\\n                lines[line].add((x2,y2))\\n            else:\\n                lines[line] = {(x1,y1),(x2,y2)}\\n        return sorted([len(v) for v in lines.values()])[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points)==1: return 1\\n        lines = dict()\\n        for (x1,y1),(x2,y2) in combinations(points, 2):\\n            if x1==x2:\\n                line = (x1, None)\\n            elif y1==y2:\\n                line = (None, y1)\\n            else:\\n                slope = (y1-y2)/(x1-x2)\\n                intercept = y1-slope*x1\\n                line = (slope, intercept) \\n            if line in lines:\\n                lines[line].add((x1,y1))\\n                lines[line].add((x2,y2))\\n            else:\\n                lines[line] = {(x1,y1),(x2,y2)}\\n        return sorted([len(v) for v in lines.values()])[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017503,
                "title": "2-solutions-9-ms-27-ms-2-different-approaches-explained-super-easy-java",
                "content": "# Explaination for Approach 1 :\\n```\\nFor each point p, calculate its slope with other points and use a \\nmap to record how many points have same slope, by which we can find \\nout how many points are on same line with p as their one point. \\nFor each point keep doing the same thing and update the maximum \\nnumber of point count found so far.\\n\\n1.if two point are (x1, y1) and (x2, y2) then their slope will \\nbe (y2 \\u2013 y1) / (x2 \\u2013 x1) which can be a double value and can cause \\nprecision problems. To get rid of the precision problems, we treat \\nslope as pair ((y2 \\u2013 y1), (x2 \\u2013 x1)) instead of ratio and reduce pair \\nby their gcd before inserting into map. In below code points which \\nare vertical or repeated are treated separately.\\n\\n2.If we use unordered_map in c++ or HashMap in Java for storing \\nthe slope pair, then total time complexity of solution will be \\nO(n^2) and space complexity will be O(n)\\n```\\n# Explaination for Approach 2 :\\n```\\n1.Find the line which two points create and store the points in \\nthe line as key in Hashtable\\n\\n2.After each iteration find and store the maximum size of the\\n points in that line\\n\\n3.getLine() creates a line by the form <slope, y-intercept> which\\n is actually means y=slope*x + (y-intercept). For slope = Infinity,\\n we store <null,x-intercept> which actually means x = (x-intercept).\\n```\\n# Request \\uD83D\\uDE0A :\\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D (Scroll Down for fastest [9 ms] approach).\\n```\\n# Approach 1 : 27 ms Solution\\n```\\nclass Solution \\n{\\n   public int maxPoints(int[][] points) \\n   {\\n        if (points.length <= 2) return points.length;\\n        int n = points.length;\\n        int maxPoint  = 0;//maxpoint\\n        int curMax, overlapPoints, verticalPoints;\\n        for (int i = 0; i < n - 1; i++) \\n        {\\n            curMax = overlapPoints = verticalPoints = 0;\\n            Map<String, Integer> slopeMap = new HashMap<>();\\n            for (int j = i + 1; j < n; j++) \\n            {\\n                if (points[i][0] == points[j][0]\\n                    && points[i][1] == points[j][1])\\n                    overlapPoints++;\\n \\n                // If x co-ordinate is same, then both\\n                // point are vertical to each other\\n                else if (points[i][0] == points[j][0])\\n                    verticalPoints++;\\n \\n                else {\\n                    int yDif = points[j][1] - points[i][1];\\n                    int xDif = points[j][0] - points[i][0];\\n                    int g = gcd(xDif, yDif);\\n                // divide by gcd to reduce the factor in slope\\n                \\n                xDif /= g;//for slope\\n                yDif /= g;//for slope\\n\\n                // Convert the pair into a string to use\\n                    // as dictionary key\\n                    String pair = (yDif) + \" \" + (xDif);\\n                    if (!slopeMap.containsKey(pair))\\n                        slopeMap.put(pair, 0);\\n \\n                    // increasing the frequency of current\\n                    // slope in map\\n                    slopeMap.put(pair,\\n                                 slopeMap.get(pair) + 1);\\n                    curMax = Math.max(curMax,\\n                                      slopeMap.get(pair));\\n                }\\n \\n                curMax = Math.max(curMax, verticalPoints);\\n            }\\n \\n            // updating global maximum by current point\\'s\\n            // maximum\\n            maxPoint = Math.max(maxPoint,\\n                                curMax + overlapPoints + 1);\\n            slopeMap.clear();\\n        }\\n \\n        return maxPoint;\\n    }\\n\\n    static int gcd(int x, int y) \\n    {\\n        if (y == 0) return x;\\n        return gcd(y, x % y);\\n    }\\n}\\n```\\n# Approach 2 : 9 ms Solution [Fastest]\\n```\\nclass Solution \\n{    \\n    Pair getLine(int[] a, int[] b)\\n    {//creates the <slope,y-intercept> pair for valid lines and creates <null, x-intercept> for vertical lines\\n        if(a[0]==b[0]) \\n            return new Pair<>(null,(double)a[0]);\\n        return new Pair<>((double)(a[1]-b[1])/(double)(a[0]-b[0]), a[1]-((double)(a[1]-b[1])/(double)(a[0]-b[0]))*a[0]);\\n    }\\n    \\n    public int maxPoints(int[][] points) \\n    {\\n        int len=points.length,i,j,maxSize=1;\\n        HashMap<Pair,HashSet<Integer>> map = new HashMap<Pair,HashSet<Integer>>();\\n        Pair<Double,Double> line;        \\n        for(i=0;i<len;i++)\\n        {\\n            for(j=i+1;j<len;j++)\\n            {\\n                line=getLine(points[i],points[j]);\\n                HashSet<Integer> set;\\n                set=map.containsKey(line)? map.get(line) : new HashSet<Integer>();\\n                set.add(i);\\n                set.add(j);\\n                map.put(line,set);//adding points to the line \\n                maxSize=Math.max(maxSize,set.size());//finding the maximum points in the same line\\n            }\\n        }        \\n        return maxSize;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nFor each point p, calculate its slope with other points and use a \\nmap to record how many points have same slope, by which we can find \\nout how many points are on same line with p as their one point. \\nFor each point keep doing the same thing and update the maximum \\nnumber of point count found so far.\\n\\n1.if two point are (x1, y1) and (x2, y2) then their slope will \\nbe (y2 \\u2013 y1) / (x2 \\u2013 x1) which can be a double value and can cause \\nprecision problems. To get rid of the precision problems, we treat \\nslope as pair ((y2 \\u2013 y1), (x2 \\u2013 x1)) instead of ratio and reduce pair \\nby their gcd before inserting into map. In below code points which \\nare vertical or repeated are treated separately.\\n\\n2.If we use unordered_map in c++ or HashMap in Java for storing \\nthe slope pair, then total time complexity of solution will be \\nO(n^2) and space complexity will be O(n)\\n```\n```\\n1.Find the line which two points create and store the points in \\nthe line as key in Hashtable\\n\\n2.After each iteration find and store the maximum size of the\\n points in that line\\n\\n3.getLine() creates a line by the form <slope, y-intercept> which\\n is actually means y=slope*x + (y-intercept). For slope = Infinity,\\n we store <null,x-intercept> which actually means x = (x-intercept).\\n```\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D (Scroll Down for fastest [9 ms] approach).\\n```\n```\\nclass Solution \\n{\\n   public int maxPoints(int[][] points) \\n   {\\n        if (points.length <= 2) return points.length;\\n        int n = points.length;\\n        int maxPoint  = 0;//maxpoint\\n        int curMax, overlapPoints, verticalPoints;\\n        for (int i = 0; i < n - 1; i++) \\n        {\\n            curMax = overlapPoints = verticalPoints = 0;\\n            Map<String, Integer> slopeMap = new HashMap<>();\\n            for (int j = i + 1; j < n; j++) \\n            {\\n                if (points[i][0] == points[j][0]\\n                    && points[i][1] == points[j][1])\\n                    overlapPoints++;\\n \\n                // If x co-ordinate is same, then both\\n                // point are vertical to each other\\n                else if (points[i][0] == points[j][0])\\n                    verticalPoints++;\\n \\n                else {\\n                    int yDif = points[j][1] - points[i][1];\\n                    int xDif = points[j][0] - points[i][0];\\n                    int g = gcd(xDif, yDif);\\n                // divide by gcd to reduce the factor in slope\\n                \\n                xDif /= g;//for slope\\n                yDif /= g;//for slope\\n\\n                // Convert the pair into a string to use\\n                    // as dictionary key\\n                    String pair = (yDif) + \" \" + (xDif);\\n                    if (!slopeMap.containsKey(pair))\\n                        slopeMap.put(pair, 0);\\n \\n                    // increasing the frequency of current\\n                    // slope in map\\n                    slopeMap.put(pair,\\n                                 slopeMap.get(pair) + 1);\\n                    curMax = Math.max(curMax,\\n                                      slopeMap.get(pair));\\n                }\\n \\n                curMax = Math.max(curMax, verticalPoints);\\n            }\\n \\n            // updating global maximum by current point\\'s\\n            // maximum\\n            maxPoint = Math.max(maxPoint,\\n                                curMax + overlapPoints + 1);\\n            slopeMap.clear();\\n        }\\n \\n        return maxPoint;\\n    }\\n\\n    static int gcd(int x, int y) \\n    {\\n        if (y == 0) return x;\\n        return gcd(y, x % y);\\n    }\\n}\\n```\n```\\nclass Solution \\n{    \\n    Pair getLine(int[] a, int[] b)\\n    {//creates the <slope,y-intercept> pair for valid lines and creates <null, x-intercept> for vertical lines\\n        if(a[0]==b[0]) \\n            return new Pair<>(null,(double)a[0]);\\n        return new Pair<>((double)(a[1]-b[1])/(double)(a[0]-b[0]), a[1]-((double)(a[1]-b[1])/(double)(a[0]-b[0]))*a[0]);\\n    }\\n    \\n    public int maxPoints(int[][] points) \\n    {\\n        int len=points.length,i,j,maxSize=1;\\n        HashMap<Pair,HashSet<Integer>> map = new HashMap<Pair,HashSet<Integer>>();\\n        Pair<Double,Double> line;        \\n        for(i=0;i<len;i++)\\n        {\\n            for(j=i+1;j<len;j++)\\n            {\\n                line=getLine(points[i],points[j]);\\n                HashSet<Integer> set;\\n                set=map.containsKey(line)? map.get(line) : new HashSet<Integer>();\\n                set.add(i);\\n                set.add(j);\\n                map.put(line,set);//adding points to the line \\n                maxSize=Math.max(maxSize,set.size());//finding the maximum points in the same line\\n            }\\n        }        \\n        return maxSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017433,
                "title": "c-97-faster-explained-with-edge-case",
                "content": "# Upvote if helpful.\\n# Intuition\\nSimple Geometry: (y2-y1)/(x2-x1)= slope of line passing two points.\\n\\n# Approach\\n```\\nFor every point we will calculate the slope of line which \\npasses through other points one by one and add the slope in the \\nmap to keep count of the max points of same slope.\\nhere slope will be key, count of slope points will be value.\\nEdge Case: if x2-x1 is 0 then it doesn\\'t matter what are the\\nvalues of y2 and y1 as slope will be INFINITY because we are\\ndividing by zero. \\nAt last return the mx+1 as we have to include the point for which\\nwe are calculating the slope counts.\\nDry run once You Will Understand Clearly.\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxPoints(vector<vector<int>>& points) {\\n        int mx=0;\\n        for(int i=0; i<points.size(); i++){\\n            unordered_map<float, int>mp;\\n            int x1= points[i][0];\\n            int y1= points[i][1];\\n            \\n            for(int j=0; j<points.size()&& j!=i; j++){\\n                 int x2= points[j][0];\\n                 int y2= points[j][1];\\n                 float slp;\\n                 if(x2-x1!=0){\\n                    slp= (float)(y2-y1)/(x2-x1);\\n                 }else{\\n                    slp=INT_MAX;\\n                 }\\n                 \\n                 mp[slp]++;\\n                 mx= max(mp[slp], mx);\\n            }\\n        }\\n        return mx+1;\\n    }\\n};\\n```\\n# Thank You.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Ordered Map",
                    "Geometry"
                ],
                "code": "```\\nFor every point we will calculate the slope of line which \\npasses through other points one by one and add the slope in the \\nmap to keep count of the max points of same slope.\\nhere slope will be key, count of slope points will be value.\\nEdge Case: if x2-x1 is 0 then it doesn\\'t matter what are the\\nvalues of y2 and y1 as slope will be INFINITY because we are\\ndividing by zero. \\nAt last return the mx+1 as we have to include the point for which\\nwe are calculating the slope counts.\\nDry run once You Will Understand Clearly.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int maxPoints(vector<vector<int>>& points) {\\n        int mx=0;\\n        for(int i=0; i<points.size(); i++){\\n            unordered_map<float, int>mp;\\n            int x1= points[i][0];\\n            int y1= points[i][1];\\n            \\n            for(int j=0; j<points.size()&& j!=i; j++){\\n                 int x2= points[j][0];\\n                 int y2= points[j][1];\\n                 float slp;\\n                 if(x2-x1!=0){\\n                    slp= (float)(y2-y1)/(x2-x1);\\n                 }else{\\n                    slp=INT_MAX;\\n                 }\\n                 \\n                 mp[slp]++;\\n                 mx= max(mp[slp], mx);\\n            }\\n        }\\n        return mx+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017021,
                "title": "straight-forward-solution-using-point-slope-and-y-intercept-eq",
                "content": "# Intuition\\n\\nWe can draw a line connecting any two points. If two or more points share the same slope and \"y intercept\" it should be on the same line. We can brute force by adding points to a set that maps to `${slope}, ${b}`. Although this answer doesn\\'t provide a great space complexity, it provides an alternative to finding angles. \\n\\nAs a specific edge-case we *need* to consider, if we have two points with the same x value, the slope will be messed up because we will have to divide by 0. Therefore I make sure to catch this and simply set b to be the x value (since any value with that x value will be on our vertical line). The same logic applies vertical lines, but can be handled by our normal logic.\\n\\nThe second code submission \"hacks\" the previous one by removing sets and increments an integer representing the number that should be in a given set, providing us with a slightly better time complexity.\\n\\nPlease let me know on best ways to optimize. \\uD83D\\uDE42\\n\\n\\n# Code\\n```\\nvar maxPoints = function(points) {\\n    if (points.length === 1) return 1 // edge case\\n    const slopes = {} // hashmap - {string: set}\\n    let maxSet = 0\\n\\n    for (let i = 0; i < points.length - 1; i++) {\\n        for (let j = i + 1; j < points.length; j++) {\\n            const [x1, y1] = points[i]\\n            const [x2, y2] = points[j]\\n\\n            let slope, b\\n\\n            if (x2 - x1 === 0) {\\n                slope = \\'undefined\\'\\n                b = x1 // or x2, the x values are the same\\n            } else { \\n                slope = (y2 - y1) / (x2 - x1)\\n                b = y1 - x1 * slope\\n            }\\n            const str = `${slope},${b}`\\n            if (str in slopes) {\\n                slopes[str].add(`${x1},${y1}`)\\n                slopes[str].add(`${x2},${y2}`)\\n                maxSet = Math.max(maxSet, slopes[str].size)\\n            } else {\\n                slopes[str] = new Set()\\n                slopes[str].add(`${x1},${y1}`)\\n                slopes[str].add(`${x2},${y2}`)\\n                maxSet = Math.max(maxSet, slopes[str].size)\\n            }\\n        }\\n    }\\n\\n    return maxSet\\n};\\n```\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\n\\nvar maxPoints = function(points) {\\n    if (points.length === 1) return 1 // edge case\\n    let max = 0\\n\\n    for (let i = 0; i < points.length - 1; i++) {\\n        let slopes = {}\\n        for (let j = i + 1; j < points.length; j++) {\\n            let [x1, y1] = points[i]\\n            let [x2, y2] = points[j]\\n\\n            let slope, b\\n            if (x2 - x1 === 0) {\\n                slope = \\'undefined\\'\\n                b = x1 // or x2, the x values are the same\\n            } else { \\n                slope = (y2 - y1) / (x2 - x1)\\n                b = y1 - x1 * slope\\n            }\\n\\n            let str = `${slope},${b}`\\n            if (str in slopes) {\\n                // since we are only examining one new point\\n                // we can increment by just one\\n                slopes[str]++\\n                max = Math.max(max, slopes[str])\\n            } else {\\n                // initialized to 2 since two points make a line\\n                slopes[str] = 2\\n                max = Math.max(max, slopes[str])\\n            }\\n        }\\n    }\\n\\n\\n    return max\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxPoints = function(points) {\\n    if (points.length === 1) return 1 // edge case\\n    const slopes = {} // hashmap - {string: set}\\n    let maxSet = 0\\n\\n    for (let i = 0; i < points.length - 1; i++) {\\n        for (let j = i + 1; j < points.length; j++) {\\n            const [x1, y1] = points[i]\\n            const [x2, y2] = points[j]\\n\\n            let slope, b\\n\\n            if (x2 - x1 === 0) {\\n                slope = \\'undefined\\'\\n                b = x1 // or x2, the x values are the same\\n            } else { \\n                slope = (y2 - y1) / (x2 - x1)\\n                b = y1 - x1 * slope\\n            }\\n            const str = `${slope},${b}`\\n            if (str in slopes) {\\n                slopes[str].add(`${x1},${y1}`)\\n                slopes[str].add(`${x2},${y2}`)\\n                maxSet = Math.max(maxSet, slopes[str].size)\\n            } else {\\n                slopes[str] = new Set()\\n                slopes[str].add(`${x1},${y1}`)\\n                slopes[str].add(`${x2},${y2}`)\\n                maxSet = Math.max(maxSet, slopes[str].size)\\n            }\\n        }\\n    }\\n\\n    return maxSet\\n};\\n```\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\n\\nvar maxPoints = function(points) {\\n    if (points.length === 1) return 1 // edge case\\n    let max = 0\\n\\n    for (let i = 0; i < points.length - 1; i++) {\\n        let slopes = {}\\n        for (let j = i + 1; j < points.length; j++) {\\n            let [x1, y1] = points[i]\\n            let [x2, y2] = points[j]\\n\\n            let slope, b\\n            if (x2 - x1 === 0) {\\n                slope = \\'undefined\\'\\n                b = x1 // or x2, the x values are the same\\n            } else { \\n                slope = (y2 - y1) / (x2 - x1)\\n                b = y1 - x1 * slope\\n            }\\n\\n            let str = `${slope},${b}`\\n            if (str in slopes) {\\n                // since we are only examining one new point\\n                // we can increment by just one\\n                slopes[str]++\\n                max = Math.max(max, slopes[str])\\n            } else {\\n                // initialized to 2 since two points make a line\\n                slopes[str] = 2\\n                max = Math.max(max, slopes[str])\\n            }\\n        }\\n    }\\n\\n\\n    return max\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2894265,
                "title": "beats-99-99-submissions-fastest-easy-approach-loop-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSIMPLE TRAVERSAL OF GRID USING 3 LOOPS.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCALCULATE THE SLOPE FOR EACH POINT ,KEEP A TRACK OF THE COUNT.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int m=points.length;\\n        if (m<2)\\n        {\\n            return m;\\n        }\\n        int max=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=i+1;j<m;j++)\\n            {\\n                int x1=points[i][0],y1=points[i][1],x2=points[j][0],y2=points[j][1];\\n                int count=2;\\n                for(int k=j+1;k<m;k++)\\n                {\\n                    int x3=points[k][0],y3=points[k][1];\\n                    if ((x2-x1)*(y3-y1)==(x3-x1)*(y2-y1))\\n                    {\\n                        count ++;\\n                    }\\n                }\\n                max=Math.max(count,max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int m=points.length;\\n        if (m<2)\\n        {\\n            return m;\\n        }\\n        int max=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=i+1;j<m;j++)\\n            {\\n                int x1=points[i][0],y1=points[i][1],x2=points[j][0],y2=points[j][1];\\n                int count=2;\\n                for(int k=j+1;k<m;k++)\\n                {\\n                    int x3=points[k][0],y3=points[k][1];\\n                    if ((x2-x1)*(y3-y1)==(x3-x1)*(y2-y1))\\n                    {\\n                        count ++;\\n                    }\\n                }\\n                max=Math.max(count,max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773865,
                "title": "java-math-solution",
                "content": "```\\nclass Solution {\\n//AvazbekYusupov \\n    public int maxPoints(int[][] points) {\\n    int maxPoints=0;\\n    if(points.length<=2){return points.length;}\\n    //HashMap<Double,Integer> map=new HashMap<>();\\n    for(int i=0;i<points.length;i++){\\n        HashMap<Double,Integer> map=new HashMap<>();\\n        \\n        for(int j=0;j<points.length;j++){\\n            if(i==j){continue;}\\n    \\n            int x1=points[i][0];\\n            int y1=points[i][1];\\n            \\n            int x2=points[j][0];\\n            int y2=points[j][1];\\n            \\n            \\n            double k=(double)(y2 - y1)/(double)(x2 - x1);\\n            \\n            map.put(k,map.getOrDefault(k,1) + 1);\\n            \\n            maxPoints=Math.max(maxPoints,map.get(k));\\n        }\\n    }\\n    return maxPoints;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n//AvazbekYusupov \\n    public int maxPoints(int[][] points) {\\n    int maxPoints=0;\\n    if(points.length<=2){return points.length;}\\n    //HashMap<Double,Integer> map=new HashMap<>();\\n    for(int i=0;i<points.length;i++){\\n        HashMap<Double,Integer> map=new HashMap<>();\\n        \\n        for(int j=0;j<points.length;j++){\\n            if(i==j){continue;}\\n    \\n            int x1=points[i][0];\\n            int y1=points[i][1];\\n            \\n            int x2=points[j][0];\\n            int y2=points[j][1];\\n            \\n            \\n            double k=(double)(y2 - y1)/(double)(x2 - x1);\\n            \\n            map.put(k,map.getOrDefault(k,1) + 1);\\n            \\n            maxPoints=Math.max(maxPoints,map.get(k));\\n        }\\n    }\\n    return maxPoints;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768312,
                "title": "python-easy-explanation-o-n-2",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        #if two pairs of points are on the same line they must have the same slope and intercept\\n        #we can calculate the slope and intercept for all pairs of points \\n        #we can keep track of points who belong to the same line (slope and intercept keys in dictionary)\\n        \\n        def calc_slope_interc(p1,p2): #return slope and intercept\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            \\n            #edge cases for horizontal and vertical lines\\n            \\n            if y1==y2: #horizontal\\n                return 0,y1\\n            if x1==x2: #vertical\\n                return None,x1 #slope not defined \\n            \\n            slope = (y2-y1)/(x2-x1)\\n            intercept = y2-slope*x2\\n            \\n            return (slope,intercept)\\n          \\n        #edge case one point\\n        if len(points)==1:\\n            return 1\\n        \\n        #dictionary that will keep track of the number of points that belong to the same line\\n        from collections import defaultdict\\n        tracker = defaultdict(lambda:set())#set of points (since same point can appear twice for different pairs)\\n                \\n        for i in range(len(points)-1):#calculate all pairs\\n            for j in range(i+1,len(points)):\\n                p1 = points[i]\\n                p2 = points[j]\\n                \\n                sl_int = calc_slope_interc(p1,p2)#slope and intercept for the line of the two points\\n                \\n                #add points to the set corresponding to line found\\n                #we add the index location of each datapoint\\n                tracker[sl_int].add(i)\\n                tracker[sl_int].add(j)\\n                \\n                \\n        #calculate no points per line\\n        #print(dict(tracker))\\n        no_points = [len(v) for k,v in tracker.items()] #len(v) give us the number of points for each line\\n        return max(no_points)\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        #if two pairs of points are on the same line they must have the same slope and intercept\\n        #we can calculate the slope and intercept for all pairs of points \\n        #we can keep track of points who belong to the same line (slope and intercept keys in dictionary)\\n        \\n        def calc_slope_interc(p1,p2): #return slope and intercept\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            \\n            #edge cases for horizontal and vertical lines\\n            \\n            if y1==y2: #horizontal\\n                return 0,y1\\n            if x1==x2: #vertical\\n                return None,x1 #slope not defined \\n            \\n            slope = (y2-y1)/(x2-x1)\\n            intercept = y2-slope*x2\\n            \\n            return (slope,intercept)\\n          \\n        #edge case one point\\n        if len(points)==1:\\n            return 1\\n        \\n        #dictionary that will keep track of the number of points that belong to the same line\\n        from collections import defaultdict\\n        tracker = defaultdict(lambda:set())#set of points (since same point can appear twice for different pairs)\\n                \\n        for i in range(len(points)-1):#calculate all pairs\\n            for j in range(i+1,len(points)):\\n                p1 = points[i]\\n                p2 = points[j]\\n                \\n                sl_int = calc_slope_interc(p1,p2)#slope and intercept for the line of the two points\\n                \\n                #add points to the set corresponding to line found\\n                #we add the index location of each datapoint\\n                tracker[sl_int].add(i)\\n                tracker[sl_int].add(j)\\n                \\n                \\n        #calculate no points per line\\n        #print(dict(tracker))\\n        no_points = [len(v) for k,v in tracker.items()] #len(v) give us the number of points for each line\\n        return max(no_points)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351664,
                "title": "cpp-simple-geometry-solution-using-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n            if(points.size()<=2)\\n                    return points.size();\\n            \\n            int ans=INT_MIN;\\n            \\n        for(int i=0;i<points.size();i++)\\n        {\\n                for(int j=i+1;j<points.size();j++)\\n                {\\n                        int dy=points[j][1]-points[i][1];\\n                        int dx=points[j][0]-points[i][0];\\n                                int count=0;\\n                        \\n                        //count from index 0 to size-1 of vector similar slope\\n                        for(int k=0;k<points.size();k++)\\n                        {\\n                                // here we do product due to errors in precision after decimal\\n                                // for example, here in int when we divide two large number \\n                                // then we got 0.00003 and 0.00004 but in (int) both are equal \\n                                // so we use multiplication instead of divide\\n                                \\n                                // (y-y1)(x1-x2)==(x-x1)(y1-y2)\\n                                \\n                                int a=dx*(points[k][1]-points[i][1]);\\n                                int b=dy*(points[k][0]-points[i][0]);\\n                                if(a==b)\\n                                        count++;\\n                        }\\n                                ans=max(ans,count);\\n                }\\n        }\\n                                return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n            if(points.size()<=2)\\n                    return points.size();\\n            \\n            int ans=INT_MIN;\\n            \\n        for(int i=0;i<points.size();i++)\\n        {\\n                for(int j=i+1;j<points.size();j++)\\n                {\\n                        int dy=points[j][1]-points[i][1];\\n                        int dx=points[j][0]-points[i][0];\\n                                int count=0;\\n                        \\n                        //count from index 0 to size-1 of vector similar slope\\n                        for(int k=0;k<points.size();k++)\\n                        {\\n                                // here we do product due to errors in precision after decimal\\n                                // for example, here in int when we divide two large number \\n                                // then we got 0.00003 and 0.00004 but in (int) both are equal \\n                                // so we use multiplication instead of divide\\n                                \\n                                // (y-y1)(x1-x2)==(x-x1)(y1-y2)\\n                                \\n                                int a=dx*(points[k][1]-points[i][1]);\\n                                int b=dy*(points[k][0]-points[i][0]);\\n                                if(a==b)\\n                                        count++;\\n                        }\\n                                ans=max(ans,count);\\n                }\\n        }\\n                                return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283775,
                "title": "java-easy-to-understand-with-explanation",
                "content": "Time Complexity : **O(N^2)**\\n**Logic:** \\n* Find the line which two points create and store the points in the line as key in Hashtable\\n* After each iteration find and store the maximum size of the points in that line\\n* `getLine()` creates a line by the form <slope, y-intercept> which is actually means y=slope*x + (y-intercept). For slope = Infinity, we store <null,x-intercept> which actually means x = (x-intercept).\\n\\n```\\nclass Solution {    \\n    Pair getLine(int[] a, int[] b){//creates the <slope,y-intercept> pair for valid lines and creates <null, x-intercept> for vertical lines\\n        if(a[0]==b[0]) \\n            return new Pair<>(null,(double)a[0]);\\n        return new Pair<>((double)(a[1]-b[1])/(double)(a[0]-b[0]), a[1]-((double)(a[1]-b[1])/(double)(a[0]-b[0]))*a[0]);\\n    }\\n    \\n    public int maxPoints(int[][] points) {\\n        int len=points.length,i,j,maxSize=1;\\n        HashMap<Pair,HashSet<Integer>> map = new HashMap<Pair,HashSet<Integer>>();\\n        Pair<Double,Double> line;        \\n        for(i=0;i<len;i++){\\n            for(j=i+1;j<len;j++){\\n                line=getLine(points[i],points[j]);\\n                HashSet<Integer> set;\\n                set=map.containsKey(line)? map.get(line) : new HashSet<Integer>();\\n                set.add(i);\\n                set.add(j);\\n                map.put(line,set);//adding points to the line \\n                maxSize=Math.max(maxSize,set.size());//finding the maximum points in the same line\\n            }\\n        }        \\n        return maxSize;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {    \\n    Pair getLine(int[] a, int[] b){//creates the <slope,y-intercept> pair for valid lines and creates <null, x-intercept> for vertical lines\\n        if(a[0]==b[0]) \\n            return new Pair<>(null,(double)a[0]);\\n        return new Pair<>((double)(a[1]-b[1])/(double)(a[0]-b[0]), a[1]-((double)(a[1]-b[1])/(double)(a[0]-b[0]))*a[0]);\\n    }\\n    \\n    public int maxPoints(int[][] points) {\\n        int len=points.length,i,j,maxSize=1;\\n        HashMap<Pair,HashSet<Integer>> map = new HashMap<Pair,HashSet<Integer>>();\\n        Pair<Double,Double> line;        \\n        for(i=0;i<len;i++){\\n            for(j=i+1;j<len;j++){\\n                line=getLine(points[i],points[j]);\\n                HashSet<Integer> set;\\n                set=map.containsKey(line)? map.get(line) : new HashSet<Integer>();\\n                set.add(i);\\n                set.add(j);\\n                map.put(line,set);//adding points to the line \\n                maxSize=Math.max(maxSize,set.size());//finding the maximum points in the same line\\n            }\\n        }        \\n        return maxSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229950,
                "title": "c-optimal-easy-solution-o-n-2",
                "content": "The Idea is to go to every point and see how many other points form same slope with this particular point, becuase if a set of points form same slope with this point all these lie on same line. As the constraints are low we can brute force our procedure by iterating withing O(N^2). But dont forget to handle the case where slope is 90, there the fraction becomes inf.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int maxi=INT_MIN;\\n        \\n        \\n        for(vector<int>x:points){\\n            map<double,int>mp;\\n            int f=0;\\n            for(vector<int>y:points){\\n                if(x!=y){\\n                    if(y[0]==x[0]){\\n                        f++;\\n                    }else{\\n                        double g=(double)(y[1]-x[1]);\\n                        g/=(double)(y[0]-x[0]);\\n                        g/=1.0;\\n                        // cout<<g<<\" \";\\n                        mp[g]++;\\n                    }\\n                }\\n            }\\n            // cout<<endl;\\n            \\n            maxi=max(maxi,f+1);\\n            for(auto p:mp){\\n                maxi=max(maxi,p.second+1);\\n            }\\n            \\n            // cout<<maxi<<x[0]<<x[1]<<\" \";\\n            mp.clear();\\n            \\n        }\\n        \\n        return maxi;\\n        // cout<<endl;\\n        \\n    }\\n};\\n```\\nPls Upvote if you liked the Solution",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int maxi=INT_MIN;\\n        \\n        \\n        for(vector<int>x:points){\\n            map<double,int>mp;\\n            int f=0;\\n            for(vector<int>y:points){\\n                if(x!=y){\\n                    if(y[0]==x[0]){\\n                        f++;\\n                    }else{\\n                        double g=(double)(y[1]-x[1]);\\n                        g/=(double)(y[0]-x[0]);\\n                        g/=1.0;\\n                        // cout<<g<<\" \";\\n                        mp[g]++;\\n                    }\\n                }\\n            }\\n            // cout<<endl;\\n            \\n            maxi=max(maxi,f+1);\\n            for(auto p:mp){\\n                maxi=max(maxi,p.second+1);\\n            }\\n            \\n            // cout<<maxi<<x[0]<<x[1]<<\" \";\\n            mp.clear();\\n            \\n        }\\n        \\n        return maxi;\\n        // cout<<endl;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2114360,
                "title": "c-simple-solution-using-slope-concepts-hashmap",
                "content": "For each points calcuting the slope with all remaing point and using a Hashmap to store the count of the slope in form of pair {y2-y1,x2-x1} \\nAfter scanning the hashmap to calculate the maximun count of a slope for the current points \\nAnd return the max+1\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        \\n        int ans=0;\\n        // sort all the value to make sure x2-x1 of the slope will all >=0\\n        sort(p.begin(),p.end());\\n        int n=p.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            // for each points calculating the slope and storing the\\n            // in form of pair {numrator,denomrator}\\n            map<pair<int,int>,int>m; \\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)  // continue the loop for same point\\n                    continue;\\n                \\n                \\n                // calculating the numrator and denomator\\n                int num=p[j][1]-p[i][1];\\n                int deno=p[j][0]-p[i][0];\\n                \\n                // taking the hcf of the value and dividing each with hcf so as to reduce \\n                int hcf=__gcd(deno,num); \\n                \\n                // if hcf is one makign hcf as 1 so as to deal with the edges cases\\n                if(hcf==0)\\n                    hcf=1;\\n                deno/=hcf;\\n                num/=hcf; \\n                \\n                // increamenting the slope which is stored in for of pair {numm,demo}\\n                m[{num,deno}]++;\\n                \\n            }\\n            \\n            // checking the map for the maximun repetaive slope \\n            for(auto i:m)\\n                ans=max(ans,i.second);\\n                \\n            \\n        }\\n        // return ans+1 so as to count the point itself \\n        return ans+1;\\n    }\\n};\\n```\\n\\nconsider upvote if you like it",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        \\n        int ans=0;\\n        // sort all the value to make sure x2-x1 of the slope will all >=0\\n        sort(p.begin(),p.end());\\n        int n=p.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            // for each points calculating the slope and storing the\\n            // in form of pair {numrator,denomrator}\\n            map<pair<int,int>,int>m; \\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)  // continue the loop for same point\\n                    continue;\\n                \\n                \\n                // calculating the numrator and denomator\\n                int num=p[j][1]-p[i][1];\\n                int deno=p[j][0]-p[i][0];\\n                \\n                // taking the hcf of the value and dividing each with hcf so as to reduce \\n                int hcf=__gcd(deno,num); \\n                \\n                // if hcf is one makign hcf as 1 so as to deal with the edges cases\\n                if(hcf==0)\\n                    hcf=1;\\n                deno/=hcf;\\n                num/=hcf; \\n                \\n                // increamenting the slope which is stored in for of pair {numm,demo}\\n                m[{num,deno}]++;\\n                \\n            }\\n            \\n            // checking the map for the maximun repetaive slope \\n            for(auto i:m)\\n                ans=max(ans,i.second);\\n                \\n            \\n        }\\n        // return ans+1 so as to count the point itself \\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970670,
                "title": "c-using-slope-directly-gcd-is-not-needed",
                "content": "```\\npublic class Solution {\\n    //\\u7528\\u659C\\u7387\\u6765\\u505A\\n    //\\u9700\\u8981\\u6CE8\\u610Fx\\u4E3A0\\u7684\\u60C5\\u51B5\\n    public int MaxPoints(int[][] points) {\\n        int result = 0;\\n        for(int i = 0; i < points.Length; i++)\\n        {\\n            Dictionary<double, int> dic = new Dictionary<double, int>();\\n            int max = 0;\\n            for(int j = i + 1; j < points.Length; j++)\\n            {\\n                double slope = this.GetSlope(points[i], points[j]);\\n                if(!dic.ContainsKey(slope))\\n                {\\n                    dic[slope] = 0;\\n                }\\n\\n                dic[slope]++;\\n                max = Math.Max(max, dic[slope]);\\n            }\\n            \\n            result = Math.Max(result, max + 1);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private double GetSlope(int[] point1, int[] point2)\\n    {\\n        double dx = point2[0] - point1[0];\\n        double dy = point2[1] - point1[1];\\n        \\n        if (dx == 0)\\n        {\\n            return Double.MaxValue;\\n        }\\n        \\n        return dy/dx;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    //\\u7528\\u659C\\u7387\\u6765\\u505A\\n    //\\u9700\\u8981\\u6CE8\\u610Fx\\u4E3A0\\u7684\\u60C5\\u51B5\\n    public int MaxPoints(int[][] points) {\\n        int result = 0;\\n        for(int i = 0; i < points.Length; i++)\\n        {\\n            Dictionary<double, int> dic = new Dictionary<double, int>();\\n            int max = 0;\\n            for(int j = i + 1; j < points.Length; j++)\\n            {\\n                double slope = this.GetSlope(points[i], points[j]);\\n                if(!dic.ContainsKey(slope))\\n                {\\n                    dic[slope] = 0;\\n                }\\n\\n                dic[slope]++;\\n                max = Math.Max(max, dic[slope]);\\n            }\\n            \\n            result = Math.Max(result, max + 1);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private double GetSlope(int[] point1, int[] point2)\\n    {\\n        double dx = point2[0] - point1[0];\\n        double dy = point2[1] - point1[1];\\n        \\n        if (dx == 0)\\n        {\\n            return Double.MaxValue;\\n        }\\n        \\n        return dy/dx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946802,
                "title": "sharing-my-simple-solution-with-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            map<pair<int,int>, int> mp;\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    int x = points[j][0] - points[i][0];\\n                    int y = points[j][1] - points[i][1];\\n                    int  p =__gcd(x,y);\\n                    x/=p;\\n                    y/=p;\\n                    mp[{x,y}]+=1;\\n                }\\n            }\\n            int cnt = 0;\\n            for(auto it: mp)\\n            {\\n                cnt = max(cnt , it.second);\\n            }\\n            ans = max(ans,1+cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            map<pair<int,int>, int> mp;\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    int x = points[j][0] - points[i][0];\\n                    int y = points[j][1] - points[i][1];\\n                    int  p =__gcd(x,y);\\n                    x/=p;\\n                    y/=p;\\n                    mp[{x,y}]+=1;\\n                }\\n            }\\n            int cnt = 0;\\n            for(auto it: mp)\\n            {\\n                cnt = max(cnt , it.second);\\n            }\\n            ans = max(ans,1+cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734310,
                "title": "golang-solution-with-illustration",
                "content": "The idea of this solution is that we start off with a point and then use all the other points to make a line from the start point to one of the other points. Then we can find the slope of the line. Then we can find which slope has the highest number of points.\\n\\n<iframe src=\"https://giphy.com/embed/up5IJe4uhceN2rlkCg\" width=\"480\" height=\"270\" frameBorder=\"0\" class=\"giphy-embed\" allowFullScreen></iframe><p><a href=\"https://giphy.com/gifs/up5IJe4uhceN2rlkCg\">GIF via GIPHY</a></p>\\n\\nIn the GIF above I only have shown one point as the start point, but we can do this with all the other points to get the maximum number of points on a line.\\n\\n``` go\\nfunc maxPoints(points [][]int) int {\\n    max := 0\\n    \\n    for i := 0; i < len(points); i++ {\\n        m := make(map[float64] int) // slope : number of points on the slope\\n        for j := 0; j < len(points); j++ {\\n            x1, x2, y1, y2 := points[i][0], points[j][0], points[i][1], points[j][1]\\n            \\n            slope := float64(y2 - y1) / float64(x2 - x1)\\n            m[slope]++\\n        }\\n        \\n        for _, b := range m {\\n            newB := (b + 1)\\n            if newB > max { max = newB }\\n        }\\n    }\\n    \\n    if len(points) == 1 { return 1 }\\n    \\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc maxPoints(points [][]int) int {\\n    max := 0\\n    \\n    for i := 0; i < len(points); i++ {\\n        m := make(map[float64] int) // slope : number of points on the slope\\n        for j := 0; j < len(points); j++ {\\n            x1, x2, y1, y2 := points[i][0], points[j][0], points[i][1], points[j][1]\\n            \\n            slope := float64(y2 - y1) / float64(x2 - x1)\\n            m[slope]++\\n        }\\n        \\n        for _, b := range m {\\n            newB := (b + 1)\\n            if newB > max { max = newB }\\n        }\\n    }\\n    \\n    if len(points) == 1 { return 1 }\\n    \\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1723868,
                "title": "c-solution-with-explanation-and-edge-cases-pointed-out",
                "content": "* **F**rom mathematics we know that formula of slope is (y2-y1)/(x2-x1) \\n*  so we can use double to store slope of the elements with respect to a particular point , but the problem is (x2-x1) can be 0 and not possible in denominator \\n*   so we use string \"dx_dy\" (dx = (x2-x1)/g , dy=(y2-y1)/g)\\n* g is the gcd , ex (2,4),(3,5) have same slope with (1,3) , but differences (dx,dy) are (1,1) & (2,2) so we need to divide with gcd , then both with become (1,1)\\n* the point that i want to mention is (1/2 == 2/4 ) gcd(1,2)=1 , gcd(2,4)=2 , but we get same nums on both side when divided with gcd\\n* note gcd(0,a) = a;\\n\\n\\n**Approach**\\n1) we will take one index i and tries to find max nums of index j lying in the same line by checking slope , we store the slope in map;\\n2) when dx=0 && dy=0 gcd will be 0 and cannot be in denominator so we will deal with it individually , dx=0 & dy=0 means these points are lying on same position as i , they will contribute to max points wrt i irrespective of slope, when this happens we will increase duplicate count\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            unordered_map<string,int> m;\\n            int dup = 1;\\n            int temp = 0;\\n            for(int j=i+1;j<n;j++){\\n                if(points[i][0]==points[j][0] && points[i][1]==points[j][1]){\\n                    dup++;\\n                }\\n                else{\\n                int dx = points[j][0]-points[i][0];\\n                int dy = points[j][1]-points[i][1];\\n                int g = __gcd(dx,dy);\\n                m[to_string(dx/g)+\\'_\\'+to_string(dy/g)]++;\\n                temp = max(temp,m[to_string(dx/g)+\\'_\\'+to_string(dy/g)]);\\n                }\\n            }\\n            ans = max(ans,temp+dup);\\n        }\\n        return ans;    \\n    }\\n};```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            unordered_map<string,int> m;\\n            int dup = 1;\\n            int temp = 0;\\n            for(int j=i+1;j<n;j++){\\n                if(points[i][0]==points[j][0] && points[i][1]==points[j][1]){\\n                    dup++;\\n                }\\n                else{\\n                int dx = points[j][0]-points[i][0];\\n                int dy = points[j][1]-points[i][1];\\n                int g = __gcd(dx,dy);\\n                m[to_string(dx/g)+\\'_\\'+to_string(dy/g)]++;\\n                temp = max(temp,m[to_string(dx/g)+\\'_\\'+to_string(dy/g)]);\\n                }\\n            }\\n            ans = max(ans,temp+dup);\\n        }\\n        return ans;    \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1705701,
                "title": "c-custom-class-as-key-for-unordered-map",
                "content": "As two points would inevitably form a line, we can put lines of all pairs into a hashmap, and count the number of pairs that form the same line.\\nTo do this, we have to come up with a representation of a line, and use it as the key to hashmap. I think the most intuitive approach of representing a line in 2D space is ```Ax+By+C=0```. For this problem, we have to make sure that the same line always have the same key, so we have some constraint for the coefficients. First, all coefficients are divided by their greatest common divisor as previous posts point out. Second, we should make sure that ```A>=0```. With these constraints, the same line will have the same coefficients. Then we can hash the coefficients to generate key.\\nI write a custom class Line to represent line, also the overload operator ```==``` and hash function is also needed.\\n```\\n#include <unordered_map>\\n#include <math.h>\\nclass Line { // Ax+By+C=0 to represent a line\\npublic:\\n    int A;\\n    int B;\\n    int C;\\n    Line(int a,int b,int c) : A(a), B(b), C(c) {}\\n    bool operator==(const Line &l) const {\\n        return A==l.A && B==l.B && C==l.C;\\n    }\\n};\\nclass LineHasher { // used the method of boost::combined_hash\\npublic:\\n    std::size_t operator() (const Line& a) const {\\n        std::size_t h = 0;\\n        h ^= std::hash<int>{}(a.A) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n        h ^= std::hash<int>{}(a.B) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n        h ^= std::hash<int>{}(a.C) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n        return h;\\n    }\\n};\\nclass Solution {\\nprivate:\\n    Line line(vector<int>& p1, vector<int>& p2){\\n        // might overflow when testcase range becomes larger\\n        int A = p2[1] - p1[1];\\n        int B = p1[0] - p2[0];\\n        int C = p1[0]*p2[1] - p2[0]*p1[1];\\n        int div = gcd(gcd(A,B),C);\\n        if((A<0) || (A==0 && B<0)){\\n            A = -A; B = -B; C = -C;\\n        }\\n        return Line(A/div,B/div,C/div);\\n    }\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        unordered_map<Line,int,LineHasher> lines;\\n        for(int i=0; i<points.size(); i++){\\n            for(int j=i+1; j<points.size(); j++){\\n                Line curline = line(points[i],points[j]);\\n                lines[curline] ++;\\n            }\\n        }\\n        int maxPair = 0;\\n        for(auto it=lines.begin(); it!=lines.end(); it++){\\n            maxPair = max(maxPair,it->second);\\n        }\\n        return sqrt(2*maxPair)+1; // pointNum*(pointNum-1)/2=pairNum\\n    }\\n};\\n```\\nThis method beat over 98%.\\nFollowing is a O(N^3) brute force intuitive method that turns out to be not very slow.\\n```\\n// check all 3 point group\\nclass Solution {\\nprivate:\\n    bool isLine(vector<int> &a, vector<int> &b, vector<int> &c){\\n        return (b[1]-a[1])*(c[0]-b[0])==(c[1]-b[1])*(b[0]-a[0]);\\n    }\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n==1) {return 1;}\\n        int maxP = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                int curP = 2;\\n                for(int k=j+1; k<n; k++){\\n                    if(isLine(points[i],points[j],points[k])){\\n                        curP ++;\\n                    }\\n                }\\n                maxP = max(maxP,curP);\\n            }\\n        }\\n        return maxP;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```Ax+By+C=0```\n```A>=0```\n```==```\n```\\n#include <unordered_map>\\n#include <math.h>\\nclass Line { // Ax+By+C=0 to represent a line\\npublic:\\n    int A;\\n    int B;\\n    int C;\\n    Line(int a,int b,int c) : A(a), B(b), C(c) {}\\n    bool operator==(const Line &l) const {\\n        return A==l.A && B==l.B && C==l.C;\\n    }\\n};\\nclass LineHasher { // used the method of boost::combined_hash\\npublic:\\n    std::size_t operator() (const Line& a) const {\\n        std::size_t h = 0;\\n        h ^= std::hash<int>{}(a.A) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n        h ^= std::hash<int>{}(a.B) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n        h ^= std::hash<int>{}(a.C) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n        return h;\\n    }\\n};\\nclass Solution {\\nprivate:\\n    Line line(vector<int>& p1, vector<int>& p2){\\n        // might overflow when testcase range becomes larger\\n        int A = p2[1] - p1[1];\\n        int B = p1[0] - p2[0];\\n        int C = p1[0]*p2[1] - p2[0]*p1[1];\\n        int div = gcd(gcd(A,B),C);\\n        if((A<0) || (A==0 && B<0)){\\n            A = -A; B = -B; C = -C;\\n        }\\n        return Line(A/div,B/div,C/div);\\n    }\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        unordered_map<Line,int,LineHasher> lines;\\n        for(int i=0; i<points.size(); i++){\\n            for(int j=i+1; j<points.size(); j++){\\n                Line curline = line(points[i],points[j]);\\n                lines[curline] ++;\\n            }\\n        }\\n        int maxPair = 0;\\n        for(auto it=lines.begin(); it!=lines.end(); it++){\\n            maxPair = max(maxPair,it->second);\\n        }\\n        return sqrt(2*maxPair)+1; // pointNum*(pointNum-1)/2=pairNum\\n    }\\n};\\n```\n```\\n// check all 3 point group\\nclass Solution {\\nprivate:\\n    bool isLine(vector<int> &a, vector<int> &b, vector<int> &c){\\n        return (b[1]-a[1])*(c[0]-b[0])==(c[1]-b[1])*(b[0]-a[0]);\\n    }\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n==1) {return 1;}\\n        int maxP = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                int curP = 2;\\n                for(int k=j+1; k<n; k++){\\n                    if(isLine(points[i],points[j],points[k])){\\n                        curP ++;\\n                    }\\n                }\\n                maxP = max(maxP,curP);\\n            }\\n        }\\n        return maxP;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1664049,
                "title": "java-comment-explanation",
                "content": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if (points == null) return 0;\\n        int length = points.length;\\n        if (length <= 2) return length;\\n        int result = 0;\\n        for (int i = 0;i<points.length;i++){\\n            Map<Double, Integer> map = new HashMap<>();\\n            int count = 1;\\n            int same = 0;\\n            for (int j = 0;j<points.length;j++){\\n                //pick non matching points\\n                if(j != i){\\n                    //first point\\n                    int firstX = points[i][0];\\n                    int firstY = points[i][1];\\n                    \\n                    //second point\\n                    int secondX = points[j][0];\\n                    int secondY = points[j][1];\\n                    \\n                    //if both points are same, increment same points\\n                    if (firstX == secondX && firstY == secondY){ \\n                        same++;\\n                        continue;\\n                    }\\n                    //if only x is different increment count\\n                    if (firstX == secondX) {\\n                        count++;                    \\n                        continue;\\n                    }\\n                    //for different points put in map the y/x\\n                    double k = (double)(secondY - firstY) / (double)(secondX - firstX);\\n                    map.put(k, map.getOrDefault(k, 1)+1);\\n                    //compute max with map value with number of same points\\n                    result = Math.max(result, map.get(k) + same);\\n                }\\n            }\\n            //update the result\\n            result = Math.max(result, count);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if (points == null) return 0;\\n        int length = points.length;\\n        if (length <= 2) return length;\\n        int result = 0;\\n        for (int i = 0;i<points.length;i++){\\n            Map<Double, Integer> map = new HashMap<>();\\n            int count = 1;\\n            int same = 0;\\n            for (int j = 0;j<points.length;j++){\\n                //pick non matching points\\n                if(j != i){\\n                    //first point\\n                    int firstX = points[i][0];\\n                    int firstY = points[i][1];\\n                    \\n                    //second point\\n                    int secondX = points[j][0];\\n                    int secondY = points[j][1];\\n                    \\n                    //if both points are same, increment same points\\n                    if (firstX == secondX && firstY == secondY){ \\n                        same++;\\n                        continue;\\n                    }\\n                    //if only x is different increment count\\n                    if (firstX == secondX) {\\n                        count++;                    \\n                        continue;\\n                    }\\n                    //for different points put in map the y/x\\n                    double k = (double)(secondY - firstY) / (double)(secondX - firstX);\\n                    map.put(k, map.getOrDefault(k, 1)+1);\\n                    //compute max with map value with number of same points\\n                    result = Math.max(result, map.get(k) + same);\\n                }\\n            }\\n            //update the result\\n            result = Math.max(result, count);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520467,
                "title": "java-easy-solution-with-explanation",
                "content": "```\\n/*\\n \\n1. Here are going calcluate slopes of each index with all other next elements and storing them in to hashmap and each index has own hashmap of slopes\\n2. After calculation of each index\\'s slopes we taking maximum number of slopes occur for each index\\n3.   Finally we will have max count of slopes \\n4.  and we are returning with +1 because =max no. of connected points + 1(that node itslef).\\n \\n Math formula for slope = (y2-y1)/(x2-x1)\\n \\n*/\\n\\n\\n\\nclass Solution {\\n    \\n   public  int maxPoints(int[][] points) {\\n\\n        int pLen = points.length;\\n        if (pLen < 3) {\\n            return pLen;\\n        }\\n\\n        HashMap<Double, Integer> hm;\\n\\n        int maxNoOfPoints = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < pLen; i++) {\\n\\n            hm = new HashMap<>();\\n            \\n            for (int j = i + 1; j < pLen; j++) {\\n                \\n                double slope = getSlope(points[i], points[j]);\\n                \\n                hm.put(slope,hm.getOrDefault(slope,0)+1);\\n\\n            }\\n\\n            for (Map.Entry<Double, Integer> entry : hm.entrySet()) {\\n                maxNoOfPoints = Math.max(maxNoOfPoints, entry.getValue());\\n\\n            }\\n                    \\n        }\\n\\n        return maxNoOfPoints+1;\\n\\n    }\\n\\n\\n     public static double getSlope(int[] cord1, int[] cord2) {\\n\\n        double mY = cord2[1] - cord1[1];\\n        double mX = cord2[0] - cord1[0];\\n        if (mY == 0) return 0; // edge case\\n        if (mX == 0) return Double.POSITIVE_INFINITY; // edge case\\n        return mY/mX;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n \\n1. Here are going calcluate slopes of each index with all other next elements and storing them in to hashmap and each index has own hashmap of slopes\\n2. After calculation of each index\\'s slopes we taking maximum number of slopes occur for each index\\n3.   Finally we will have max count of slopes \\n4.  and we are returning with +1 because =max no. of connected points + 1(that node itslef).\\n \\n Math formula for slope = (y2-y1)/(x2-x1)\\n \\n*/\\n\\n\\n\\nclass Solution {\\n    \\n   public  int maxPoints(int[][] points) {\\n\\n        int pLen = points.length;\\n        if (pLen < 3) {\\n            return pLen;\\n        }\\n\\n        HashMap<Double, Integer> hm;\\n\\n        int maxNoOfPoints = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < pLen; i++) {\\n\\n            hm = new HashMap<>();\\n            \\n            for (int j = i + 1; j < pLen; j++) {\\n                \\n                double slope = getSlope(points[i], points[j]);\\n                \\n                hm.put(slope,hm.getOrDefault(slope,0)+1);\\n\\n            }\\n\\n            for (Map.Entry<Double, Integer> entry : hm.entrySet()) {\\n                maxNoOfPoints = Math.max(maxNoOfPoints, entry.getValue());\\n\\n            }\\n                    \\n        }\\n\\n        return maxNoOfPoints+1;\\n\\n    }\\n\\n\\n     public static double getSlope(int[] cord1, int[] cord2) {\\n\\n        double mY = cord2[1] - cord1[1];\\n        double mX = cord2[0] - cord1[0];\\n        if (mY == 0) return 0; // edge case\\n        if (mX == 0) return Double.POSITIVE_INFINITY; // edge case\\n        return mY/mX;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324084,
                "title": "c-beats-95-on-runtime-and-81-on-memory-explanation",
                "content": "The main idea in my solution is that we iterate over points and create all possible pairs. For each pair we calculate parameters **k** and **b** of a linear function: *y = kx + b*. We store all possible lines (defined by pair **k**, **b**) and calculate how many pairs of points had those  **k** and **b**. At last, we return how many points were in those pairs.\\n\\nMain loop. To avoid taking the same point twice `i = 1..N-1`, but **j** starts from **i+1**: `j = i+1..N`\\n```\\n    for (std::size_t i=0; i<points.size()-1; ++i) {\\n        for (std::size_t j=i+1; j<points.size(); ++j) {\\n            auto line = makeLine(points[i], points[j]);\\n```\\n\\nIf the current line exists in a map, we\\'ll increase counter, otherwise - insert new line.\\nAt the same time we calculate `max` number of pairs, to avoid second loop after this one.\\n```\\n            auto lineIt = lines.find(line);\\n            if (lineIt == lines.end()) {\\n                lines.emplace(line, 1);\\n            } else {\\n                ++(lineIt->second);\\n                if (lineIt->second > max) {\\n                    max = lineIt->second;\\n                }\\n            }\\n```\\nAt the end of a loop we have a number of pairs. The formula for all possible pairs from **n** numbers is\\n*pairs = n (n-1) / 2*\\nHence **pairs** and **n** are >0 in our case, the reverse formula will be\\n*n = (1 + sqrt(1 + 8 * pairs)) / 2*\\n\\nOther notes.\\nTo be able to insert user-defined class **Line** into map, we must define **less** (operator < ) for this type.\\n```\\ntemplate<> struct less<Line>\\n{\\n    bool operator() (const Line& lhs, const Line& rhs) const\\n    {\\n        if (not lessFloat(lhs.k, rhs.k) and not lessFloat(rhs.k, lhs.k)) {\\n            return lessFloat(lhs.b, rhs.b);\\n        } else {\\n            return lessFloat(lhs.k, rhs.k);\\n        }\\n    }\\n};\\n```\\nTo compare two floating point values we must not use operator < , but instead compare them with a precision:\\n```\\ninline bool lessFloat(float a, float b) \\n{\\n    return (b - a) > ( (fabs(a) < fabs(b) ? abs(b) : fabs(a)) * 0.0001f);\\n}\\n``` \\n**makeLine** function calculates **k** with formula *k = (y2 - y1) / (x2 - x1)* and then calculates **b** : *b = y1 - kx1*.\\nThere\\'s a little edge case though: lines, that parallel to y-axis. According to math, they are not linear functions and we have a problem with a division by zero, because x1 == x2. We will store those lines with *k=infinity*. It\\'s okay with math and our sollution too.\\n```\\nLine makeLine(const vector<int>& lhs, const vector<int>& rhs)\\n{\\n    Line result;\\n    // x1 == x2\\n    if (lhs[0] == rhs[0]) {\\n        result.k = std::numeric_limits<float>::infinity();\\n        result.b = lhs[0]; // == x\\n    } else {\\n        // k = (y2 - y1) / (x2 - x1)\\n        result.k = (rhs[1] - lhs[1]) / float(rhs[0] - lhs[0]);\\n        // y1 - k * x1\\n        result.b = lhs[1] - result.k * lhs[0];        \\n    }\\n    return result;\\n}\\n```\\n \\n\\nPutting all together:\\n\\n```\\n#include <iostream>\\n#include <map>\\n#include <algorithm>\\n\\nstruct Line \\n{\\n    float k;\\n    float b;\\n};\\n\\ninline bool lessFloat(float a, float b) \\n{\\n    return (b - a) > ( (fabs(a) < fabs(b) ? abs(b) : fabs(a)) * 0.0001f);\\n}\\n\\ntemplate<> struct less<Line>\\n{\\n    bool operator() (const Line& lhs, const Line& rhs) const\\n    {\\n        if (not lessFloat(lhs.k, rhs.k) and not lessFloat(rhs.k, lhs.k)) {\\n            return lessFloat(lhs.b, rhs.b);\\n        } else {\\n            return lessFloat(lhs.k, rhs.k);\\n        }\\n    }\\n};\\n\\nusing Lines = std::map<Line, int>;\\n\\nLine makeLine(const vector<int>& lhs, const vector<int>& rhs)\\n{\\n    Line result;\\n    // x1 == x2\\n    if (lhs[0] == rhs[0]) {\\n        result.k = std::numeric_limits<float>::infinity();\\n        result.b = lhs[0]; // == x\\n    } else {\\n        // k = (y2 - y1) / (x2 - x1)\\n        result.k = (rhs[1] - lhs[1]) / float(rhs[0] - lhs[0]);\\n        // y1 - k * x1\\n        result.b = lhs[1] - result.k * lhs[0];        \\n    }\\n    return result;\\n}\\n\\nint maxPointsLine(const vector<vector<int>>& points) {\\n    if (points.size() == 1) {\\n        return 1;\\n    }\\n        \\n    Lines lines;\\n    auto max = 1;\\n    for (std::size_t i=0; i<points.size()-1; ++i) {\\n        for (std::size_t j=i+1; j<points.size(); ++j) {\\n            auto line = makeLine(points[i], points[j]);\\n            \\n            auto lineIt = lines.find(line);\\n            if (lineIt == lines.end()) {\\n                lines.emplace(line, 1);\\n            } else {\\n                ++(lineIt->second);\\n                if (lineIt->second > max) {\\n                    max = lineIt->second;\\n                }\\n            }\\n            \\n        }       \\n    }\\n    \\n    // x = (1 + sqrt(1 + 8 * pairs)) / 2\\n    return (1 + pow(1 + 8 * max, 0.5)) / 2;\\n}\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        return maxPointsLine(points);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n    for (std::size_t i=0; i<points.size()-1; ++i) {\\n        for (std::size_t j=i+1; j<points.size(); ++j) {\\n            auto line = makeLine(points[i], points[j]);\\n```\n```\\n            auto lineIt = lines.find(line);\\n            if (lineIt == lines.end()) {\\n                lines.emplace(line, 1);\\n            } else {\\n                ++(lineIt->second);\\n                if (lineIt->second > max) {\\n                    max = lineIt->second;\\n                }\\n            }\\n```\n```\\ntemplate<> struct less<Line>\\n{\\n    bool operator() (const Line& lhs, const Line& rhs) const\\n    {\\n        if (not lessFloat(lhs.k, rhs.k) and not lessFloat(rhs.k, lhs.k)) {\\n            return lessFloat(lhs.b, rhs.b);\\n        } else {\\n            return lessFloat(lhs.k, rhs.k);\\n        }\\n    }\\n};\\n```\n```\\ninline bool lessFloat(float a, float b) \\n{\\n    return (b - a) > ( (fabs(a) < fabs(b) ? abs(b) : fabs(a)) * 0.0001f);\\n}\\n```\n```\\nLine makeLine(const vector<int>& lhs, const vector<int>& rhs)\\n{\\n    Line result;\\n    // x1 == x2\\n    if (lhs[0] == rhs[0]) {\\n        result.k = std::numeric_limits<float>::infinity();\\n        result.b = lhs[0]; // == x\\n    } else {\\n        // k = (y2 - y1) / (x2 - x1)\\n        result.k = (rhs[1] - lhs[1]) / float(rhs[0] - lhs[0]);\\n        // y1 - k * x1\\n        result.b = lhs[1] - result.k * lhs[0];        \\n    }\\n    return result;\\n}\\n```\n```\\n#include <iostream>\\n#include <map>\\n#include <algorithm>\\n\\nstruct Line \\n{\\n    float k;\\n    float b;\\n};\\n\\ninline bool lessFloat(float a, float b) \\n{\\n    return (b - a) > ( (fabs(a) < fabs(b) ? abs(b) : fabs(a)) * 0.0001f);\\n}\\n\\ntemplate<> struct less<Line>\\n{\\n    bool operator() (const Line& lhs, const Line& rhs) const\\n    {\\n        if (not lessFloat(lhs.k, rhs.k) and not lessFloat(rhs.k, lhs.k)) {\\n            return lessFloat(lhs.b, rhs.b);\\n        } else {\\n            return lessFloat(lhs.k, rhs.k);\\n        }\\n    }\\n};\\n\\nusing Lines = std::map<Line, int>;\\n\\nLine makeLine(const vector<int>& lhs, const vector<int>& rhs)\\n{\\n    Line result;\\n    // x1 == x2\\n    if (lhs[0] == rhs[0]) {\\n        result.k = std::numeric_limits<float>::infinity();\\n        result.b = lhs[0]; // == x\\n    } else {\\n        // k = (y2 - y1) / (x2 - x1)\\n        result.k = (rhs[1] - lhs[1]) / float(rhs[0] - lhs[0]);\\n        // y1 - k * x1\\n        result.b = lhs[1] - result.k * lhs[0];        \\n    }\\n    return result;\\n}\\n\\nint maxPointsLine(const vector<vector<int>>& points) {\\n    if (points.size() == 1) {\\n        return 1;\\n    }\\n        \\n    Lines lines;\\n    auto max = 1;\\n    for (std::size_t i=0; i<points.size()-1; ++i) {\\n        for (std::size_t j=i+1; j<points.size(); ++j) {\\n            auto line = makeLine(points[i], points[j]);\\n            \\n            auto lineIt = lines.find(line);\\n            if (lineIt == lines.end()) {\\n                lines.emplace(line, 1);\\n            } else {\\n                ++(lineIt->second);\\n                if (lineIt->second > max) {\\n                    max = lineIt->second;\\n                }\\n            }\\n            \\n        }       \\n    }\\n    \\n    // x = (1 + sqrt(1 + 8 * pairs)) / 2\\n    return (1 + pow(1 + 8 * max, 0.5)) / 2;\\n}\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        return maxPointsLine(points);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1320314,
                "title": "python-44ms-with-hashtable",
                "content": "```\\ndef maxPoints(points):\\n    p_num = len(points)\\n    slope_dict = [{} for p in range(p_num)]\\n    \\n    max_points = 0\\n    for i in range(p_num-1):\\n        for j in range(i+1, p_num):\\n            x_dis = points[j][0]-points[i][0]\\n            if x_dis != 0:\\n                curr_slope = (points[j][1]-points[i][1])/x_dis\\n            else:\\n                curr_slope = float(\\'inf\\')\\n            \\n            if curr_slope not in slope_dict[i].keys():\\n                slope_dict[i][curr_slope] = 1\\n            else:\\n                slope_dict[i][curr_slope] += 1\\n        \\n        max_points = max(max_points, max(slope_dict[i].values()))\\n        \\n    return max_points+1\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\ndef maxPoints(points):\\n    p_num = len(points)\\n    slope_dict = [{} for p in range(p_num)]\\n    \\n    max_points = 0\\n    for i in range(p_num-1):\\n        for j in range(i+1, p_num):\\n            x_dis = points[j][0]-points[i][0]\\n            if x_dis != 0:\\n                curr_slope = (points[j][1]-points[i][1])/x_dis\\n            else:\\n                curr_slope = float(\\'inf\\')\\n            \\n            if curr_slope not in slope_dict[i].keys():\\n                slope_dict[i][curr_slope] = 1\\n            else:\\n                slope_dict[i][curr_slope] += 1\\n        \\n        max_points = max(max_points, max(slope_dict[i].values()))\\n        \\n    return max_points+1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1100560,
                "title": "swift-solution-y-mx-c",
                "content": "```\\nclass Solution {\\n    func maxPoints(_ points: [[Int]]) -> Int {\\n        if points.count < 2 {\\n            return 1\\n        }\\n        \\n        var bySlop: [Double: Int] = [:]\\n        var result = 0\\n        \\n        for i in 0..<points.count {\\n            let p1 = points[i]\\n            bySlop = [:]\\n            for j in 0..<points.count {\\n                if i == j { continue }\\n\\n                let p2 = points[j] \\n                \\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tStraight line formula\\n\\t\\t\\t\\t======================\\n\\t\\t\\t\\ty = mx + c\\n\\t\\t\\t\\tm = (y2 - y1)/(x2 - x1)\\n\\t\\t\\t\\t*/\\n                let yDiff = (p2[1] - p1[1])\\n                let xDiff = (p2[0] - p1[0])\\n\\n                let m: Double\\n                if xDiff == 0 && yDiff > 0 {\\n                    m = Double(Int.max)\\n                } else {\\n                    m = Double(yDiff)/Double(xDiff)\\n                }\\n\\n                var slopPoints = bySlop[m] ?? 0\\n                if slopPoints == 0 {\\n                    slopPoints = 2\\n                } else {\\n                    slopPoints += 1\\n                }\\n\\n                bySlop[m] = slopPoints\\n\\n                result = max(result, slopPoints)\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```\\n\\nTime = O(n^2)\\nSpace = O(s) - where `s` is maximum number of different slops\\n// I think i got it right with the complexities. Please correct me if im wrong.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func maxPoints(_ points: [[Int]]) -> Int {\\n        if points.count < 2 {\\n            return 1\\n        }\\n        \\n        var bySlop: [Double: Int] = [:]\\n        var result = 0\\n        \\n        for i in 0..<points.count {\\n            let p1 = points[i]\\n            bySlop = [:]\\n            for j in 0..<points.count {\\n                if i == j { continue }\\n\\n                let p2 = points[j] \\n                \\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tStraight line formula\\n\\t\\t\\t\\t======================\\n\\t\\t\\t\\ty = mx + c\\n\\t\\t\\t\\tm = (y2 - y1)/(x2 - x1)\\n\\t\\t\\t\\t*/\\n                let yDiff = (p2[1] - p1[1])\\n                let xDiff = (p2[0] - p1[0])\\n\\n                let m: Double\\n                if xDiff == 0 && yDiff > 0 {\\n                    m = Double(Int.max)\\n                } else {\\n                    m = Double(yDiff)/Double(xDiff)\\n                }\\n\\n                var slopPoints = bySlop[m] ?? 0\\n                if slopPoints == 0 {\\n                    slopPoints = 2\\n                } else {\\n                    slopPoints += 1\\n                }\\n\\n                bySlop[m] = slopPoints\\n\\n                result = max(result, slopPoints)\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963351,
                "title": "python-short-easy-o-n-2-time-o-n-space-using-fraction",
                "content": "Idea: For each point, calculate the num of points that make same slope with this point. Input also contains duplicates so handle them seperately.\\n```\\ndef maxPoints(self, points: List[List[int]]) -> int:\\n\\tans, INF = 0, 10**10\\n\\tfor x1, y1 in points:\\n\\t\\tslopes = defaultdict(int)\\n\\t\\tduplicates = 0\\n\\t\\tfor x2, y2 in points:\\n\\t\\t\\tif x1 == x2 and y1 == y2:\\n\\t\\t\\t\\tduplicates += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdy, dx = y2 - y1, x2 - x1\\n\\t\\t\\t\\tslope = Fraction(dy, dx) if dx else INF\\n\\t\\t\\t\\tslopes[slope] += 1\\n\\n\\t\\tpoints_on_line = max(slopes.values()) if slopes.values() else 0\\n\\t\\tans = max(points_on_line + duplicates, ans)\\n\\t\\t\\n\\treturn ans\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxPoints(self, points: List[List[int]]) -> int:\\n\\tans, INF = 0, 10**10\\n\\tfor x1, y1 in points:\\n\\t\\tslopes = defaultdict(int)\\n\\t\\tduplicates = 0\\n\\t\\tfor x2, y2 in points:\\n\\t\\t\\tif x1 == x2 and y1 == y2:\\n\\t\\t\\t\\tduplicates += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdy, dx = y2 - y1, x2 - x1\\n\\t\\t\\t\\tslope = Fraction(dy, dx) if dx else INF\\n\\t\\t\\t\\tslopes[slope] += 1\\n\\n\\t\\tpoints_on_line = max(slopes.values()) if slopes.values() else 0\\n\\t\\tans = max(points_on_line + duplicates, ans)\\n\\t\\t\\n\\treturn ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 928801,
                "title": "go-solution-with-notes",
                "content": "```\\n// y = kx + b\\n// for 2 points: (x1, y1), (x2, y2) we have a system:\\n// y1 = kx1 + b\\n// y2 = kx2 + b\\n// y1 - y2 = kx1 + b - (kx2 + b) = k*(x1 - x2)\\n\\n// k = (y1 - y2) / (x1 - x2) = p / q\\n//\\n// y = kx + b => b = y - kx\\n// b = y1 - k * x1 = y1 - p/q * x1 = (q*y1 - x1*p) / q\\n\\n// So in order to identify a line we must have:\\n// k and b where k = p/q, b = (q*y1 - x1*p) / q. \\n//\\n// in our case it is enough to store: [p, q, (q*y1-x1*p)]\\n\\ntype Line struct {\\n    p, q, b int64\\n}\\n\\nfunc maxPoints(points [][]int) int {\\n    xGroup := make(map[int]int)\\n    yGroup := make(map[int]int)\\n    res := 0\\n    \\n    for i := 0; i < len(points); i++ {\\n        x, y := points[i][0], points[i][1]\\n        xGroup[x]++\\n        yGroup[y]++\\n        \\n        res = max(max(res, xGroup[x]), yGroup[y])\\n    }\\n    \\n    for i := 0; i < len(points); i++ {\\n        // we reserve self point as a duplicate\\n        lines := map[Line]int{}\\n        duplicates := 1\\n        \\n        for j := i + 1; j < len(points); j++ {\\n            a, b := points[i], points[j]\\n            \\n            if a[0] == b[0] && a[1] == b[1] {\\n                duplicates++\\n            }\\n        }\\n        \\n        for j := i + 1; j < len(points); j++ {\\n            a, b := points[i], points[j]\\n            \\n            if a[0] == b[0] || a[1] == b[1] {\\n                continue\\n            }\\n            \\n            p, q := getSlope(a, b)\\n            line := Line{p: p, q: q, b: q * int64(a[1]) - p * int64(a[0])}\\n            \\n            lines[line]++\\n            res = max(res, lines[line] + duplicates)\\n        }\\n    }\\n    \\n    return res\\n}\\n\\n// y = kx + b\\n// for 2 points: (x1, y1), (x2, y2) we have a system:\\n// y1 = kx1 + b\\n// y2 = kx2 + b\\n// y1 - y2 = kx1 + b - (kx2 + b) = k*(x1 - x2)\\n// k = (y1 - y2) / (x1 - x2)\\n// \\n// we return the numerator and denominator of the p/q = ((y1 - y2) / gcd) / ((x1 - x2) / gcd)\\n// we do this in order to normalize the fraction: here is an example\\n// 2/3 and 10/15, gcd(2,3) = 1, gcd(10,15) = 5\\n// 2/3 = 10/5 = 10/5/15/5 = 2/3\\nfunc getSlope(a, b []int) (int64, int64) {\\n    deltaX, deltaY := int64(a[0] - b[0]), int64(a[1] - b[1])\\n\\n    if deltaX < 0 {\\n        deltaX = -deltaX\\n        deltaY = -deltaY\\n    }\\n\\n    g := gcd(deltaX, deltaY)\\n    return deltaX / g, deltaY / g\\n}\\n\\nfunc gcd(a, b int64) int64 {\\n    for b != 0 {\\n        a, b = b, a%b\\n    }\\n    \\n    return a\\n}\\n\\nfunc max(a, b int) int {\\n    if a < b {\\n        return b\\n    }\\n    \\n    return a\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// y = kx + b\\n// for 2 points: (x1, y1), (x2, y2) we have a system:\\n// y1 = kx1 + b\\n// y2 = kx2 + b\\n// y1 - y2 = kx1 + b - (kx2 + b) = k*(x1 - x2)\\n\\n// k = (y1 - y2) / (x1 - x2) = p / q\\n//\\n// y = kx + b => b = y - kx\\n// b = y1 - k * x1 = y1 - p/q * x1 = (q*y1 - x1*p) / q\\n\\n// So in order to identify a line we must have:\\n// k and b where k = p/q, b = (q*y1 - x1*p) / q. \\n//\\n// in our case it is enough to store: [p, q, (q*y1-x1*p)]\\n\\ntype Line struct {\\n    p, q, b int64\\n}\\n\\nfunc maxPoints(points [][]int) int {\\n    xGroup := make(map[int]int)\\n    yGroup := make(map[int]int)\\n    res := 0\\n    \\n    for i := 0; i < len(points); i++ {\\n        x, y := points[i][0], points[i][1]\\n        xGroup[x]++\\n        yGroup[y]++\\n        \\n        res = max(max(res, xGroup[x]), yGroup[y])\\n    }\\n    \\n    for i := 0; i < len(points); i++ {\\n        // we reserve self point as a duplicate\\n        lines := map[Line]int{}\\n        duplicates := 1\\n        \\n        for j := i + 1; j < len(points); j++ {\\n            a, b := points[i], points[j]\\n            \\n            if a[0] == b[0] && a[1] == b[1] {\\n                duplicates++\\n            }\\n        }\\n        \\n        for j := i + 1; j < len(points); j++ {\\n            a, b := points[i], points[j]\\n            \\n            if a[0] == b[0] || a[1] == b[1] {\\n                continue\\n            }\\n            \\n            p, q := getSlope(a, b)\\n            line := Line{p: p, q: q, b: q * int64(a[1]) - p * int64(a[0])}\\n            \\n            lines[line]++\\n            res = max(res, lines[line] + duplicates)\\n        }\\n    }\\n    \\n    return res\\n}\\n\\n// y = kx + b\\n// for 2 points: (x1, y1), (x2, y2) we have a system:\\n// y1 = kx1 + b\\n// y2 = kx2 + b\\n// y1 - y2 = kx1 + b - (kx2 + b) = k*(x1 - x2)\\n// k = (y1 - y2) / (x1 - x2)\\n// \\n// we return the numerator and denominator of the p/q = ((y1 - y2) / gcd) / ((x1 - x2) / gcd)\\n// we do this in order to normalize the fraction: here is an example\\n// 2/3 and 10/15, gcd(2,3) = 1, gcd(10,15) = 5\\n// 2/3 = 10/5 = 10/5/15/5 = 2/3\\nfunc getSlope(a, b []int) (int64, int64) {\\n    deltaX, deltaY := int64(a[0] - b[0]), int64(a[1] - b[1])\\n\\n    if deltaX < 0 {\\n        deltaX = -deltaX\\n        deltaY = -deltaY\\n    }\\n\\n    g := gcd(deltaX, deltaY)\\n    return deltaX / g, deltaY / g\\n}\\n\\nfunc gcd(a, b int64) int64 {\\n    for b != 0 {\\n        a, b = b, a%b\\n    }\\n    \\n    return a\\n}\\n\\nfunc max(a, b int) int {\\n    if a < b {\\n        return b\\n    }\\n    \\n    return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 901512,
                "title": "java-easy-solution",
                "content": "# class Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points == null )  return  0;\\n        int n= points.length;\\n         if(n <=2)  return  n;\\n         int res=0;\\n         Map<String,Integer> map = new HashMap<>();\\n         for(int i=0;i<n;i++){\\n             map.clear();\\n             int overlap =0,max=0;\\n             for(int  j=i+1;j<n;j++){\\n               int dx = points[j][0] - points[i][0];\\n               int dy = points[j][1]- points[i][1];\\n                if(dx ==0 && dy ==0){\\n                    overlap++;\\n                    continue;\\n                }\\n               int hcf = gcd (dx,dy);\\n               dx = dx/hcf;\\n               dy = dy/hcf;\\n               String key = dx+ \":\"+dy;\\n               map.put(key,map.getOrDefault(key,0)+1);\\n               max= Math.max(max,map.get(key));\\n             }\\n            res = Math.max(res,max+overlap+1);\\n         }\\n         return res;\\n    }\\n    private  static  int gcd(int a, int b ){\\n        if (b==0)\\n              return a;\\n        return  gcd(b,a%b);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points == null )  return  0;\\n        int n= points.length;\\n         if(n <=2)  return  n;\\n         int res=0;\\n         Map<String,Integer> map = new HashMap<>();\\n         for(int i=0;i<n;i++){\\n             map.clear();\\n             int overlap =0,max=0;\\n             for(int  j=i+1;j<n;j++){\\n               int dx = points[j][0] - points[i][0];\\n               int dy = points[j][1]- points[i][1];\\n                if(dx ==0 && dy ==0){\\n                    overlap++;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 732420,
                "title": "cpp-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b)\\n    {\\n        if(b==0) return a;\\n        else return gcd(b,a%b);\\n    }\\n    int maxPoints(vector<vector<int>>& points) {\\n         int res=0,res2=0;\\n        \\n        for(int i=0;i<points.size();i++)\\n        {\\n            int overlap=0,yaxis=0,curr=0;\\n            map<pair<int,int>,int> mp;\\n            for(int j=i+1;j<points.size();j++)\\n            {\\n                if(points[i]==points[j]) overlap++;\\n                else if(points[i][0]==points[j][0]) \\n                    yaxis++;\\n                else\\n                {\\n                    int x=(points[i][0]-points[j][0]);\\n                    int y=(points[i][1]-points[j][1]);\\n                    int g=__gcd(x,y); \\n                    mp[{x/g,y/g}]++;\\n                    curr=max(curr,mp[{x/g,y/g}]);\\n                    \\n                }\\n                curr=max(curr,yaxis);\\n                \\n            }\\n            \\n            res=max(res,curr+overlap+1);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b)\\n    {\\n        if(b==0) return a;\\n        else return gcd(b,a%b);\\n    }\\n    int maxPoints(vector<vector<int>>& points) {\\n         int res=0,res2=0;\\n        \\n        for(int i=0;i<points.size();i++)\\n        {\\n            int overlap=0,yaxis=0,curr=0;\\n            map<pair<int,int>,int> mp;\\n            for(int j=i+1;j<points.size();j++)\\n            {\\n                if(points[i]==points[j]) overlap++;\\n                else if(points[i][0]==points[j][0]) \\n                    yaxis++;\\n                else\\n                {\\n                    int x=(points[i][0]-points[j][0]);\\n                    int y=(points[i][1]-points[j][1]);\\n                    int g=__gcd(x,y); \\n                    mp[{x/g,y/g}]++;\\n                    curr=max(curr,mp[{x/g,y/g}]);\\n                    \\n                }\\n                curr=max(curr,yaxis);\\n                \\n            }\\n            \\n            res=max(res,curr+overlap+1);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707099,
                "title": "java-sol",
                "content": "```\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points.length<3) return points.length;\\n        int maxres =0;\\n        //\\u904D\\u5386\\u6BCF\\u4E2A\\u70B9\\uFF0C\\u6C42\\u5176\\u548C\\u5176\\u4ED6\\u70B9\\u7EC4\\u6210\\u7684\\u76F4\\u7EBF\\u659C\\u7387\\n        for(int i =0; i< points.length; i++){\\n            int same = 0;//\\u662F\\u91CD\\u590D\\u7684\\u70B9\\n            int temp_max =0;//\\u5728\\u67D0\\u6761\\u76F4\\u7EBF\\u4E0A\\u7684\\u6700\\u591A\\u70B9\\u6570\\uFF08\\u5C40\\u90E8\\u6700\\u5927\\u503C\\uFF09;\\u6BCF\\u6362\\u4E00\\u4E2A\\u70B9\\uFF0C\\u5C31\\u5F52\\u96F6\\n            HashMap<String,Integer> map = new HashMap<>();//\\u5B58\\u8BE5\\u6761\\u7EBF\\u4E0A\\u7684\\u659C\\u7387\\u548C\\u4E2A\\u6570\\n            for(int j= 0; j< points.length; j++){\\n                if(i!=j){//\\u4E0D\\u80FD\\u81EA\\u5DF1\\u548C\\u81EA\\u5DF1\\n                    int dx = points[i][0] - points[j][0];//points[i][0]\\u7B2Ci\\u4E2A\\u70B9\\u7684\\uFF0Cindex\\u4E3A0\\u7684\\u6570\\u503C\\uFF0C\\u5373x\\u503C\\u3002\\n                    int dy = points[i][1] - points[j][1];\\n                    if(dx==0 && dy==0){\\n                        same++;\\n                        continue;\\n                    }\\n                    //\\u82E5\\u6709\\u659C\\u7387\\uFF0C\\u8FDB\\u884C\\u7EA6\\u5206\\n                    int gcd = gcd(dx,dy);\\n                    String key = dx/gcd +\"/\" + dy/gcd;\\n                    map.put(key,map.getOrDefault(key,0)+1);\\n                    temp_max = Math.max(temp_max, map.get(key));\\n                }               \\n            }\\n            //same \\u4EE3\\u8868\\u548C\\u5F53\\u524D\\u7684\\u70B9\\u91CD\\u590D\\u7684\\u70B9, 1\\u4EE3\\u8868\\u5F53\\u524D\\u70B9\\n            maxres = Math.max(maxres,temp_max+same+1);\\n        }\\n        return maxres;\\n    }\\n    \\n    public int gcd(int a, int b){\\n        while(b!=0){\\n            int temp = a%b;\\n            a=b;\\n            b=temp;\\n        }\\n        return a;\\n    } \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points.length<3) return points.length;\\n        int maxres =0;\\n        //\\u904D\\u5386\\u6BCF\\u4E2A\\u70B9\\uFF0C\\u6C42\\u5176\\u548C\\u5176\\u4ED6\\u70B9\\u7EC4\\u6210\\u7684\\u76F4\\u7EBF\\u659C\\u7387\\n        for(int i =0; i< points.length; i++){\\n            int same = 0;//\\u662F\\u91CD\\u590D\\u7684\\u70B9\\n            int temp_max =0;//\\u5728\\u67D0\\u6761\\u76F4\\u7EBF\\u4E0A\\u7684\\u6700\\u591A\\u70B9\\u6570\\uFF08\\u5C40\\u90E8\\u6700\\u5927\\u503C\\uFF09;\\u6BCF\\u6362\\u4E00\\u4E2A\\u70B9\\uFF0C\\u5C31\\u5F52\\u96F6\\n            HashMap<String,Integer> map = new HashMap<>();//\\u5B58\\u8BE5\\u6761\\u7EBF\\u4E0A\\u7684\\u659C\\u7387\\u548C\\u4E2A\\u6570\\n            for(int j= 0; j< points.length; j++){\\n                if(i!=j){//\\u4E0D\\u80FD\\u81EA\\u5DF1\\u548C\\u81EA\\u5DF1\\n                    int dx = points[i][0] - points[j][0];//points[i][0]\\u7B2Ci\\u4E2A\\u70B9\\u7684\\uFF0Cindex\\u4E3A0\\u7684\\u6570\\u503C\\uFF0C\\u5373x\\u503C\\u3002\\n                    int dy = points[i][1] - points[j][1];\\n                    if(dx==0 && dy==0){\\n                        same++;\\n                        continue;\\n                    }\\n                    //\\u82E5\\u6709\\u659C\\u7387\\uFF0C\\u8FDB\\u884C\\u7EA6\\u5206\\n                    int gcd = gcd(dx,dy);\\n                    String key = dx/gcd +\"/\" + dy/gcd;\\n                    map.put(key,map.getOrDefault(key,0)+1);\\n                    temp_max = Math.max(temp_max, map.get(key));\\n                }               \\n            }\\n            //same \\u4EE3\\u8868\\u548C\\u5F53\\u524D\\u7684\\u70B9\\u91CD\\u590D\\u7684\\u70B9, 1\\u4EE3\\u8868\\u5F53\\u524D\\u70B9\\n            maxres = Math.max(maxres,temp_max+same+1);\\n        }\\n        return maxres;\\n    }\\n    \\n    public int gcd(int a, int b){\\n        while(b!=0){\\n            int temp = a%b;\\n            a=b;\\n            b=temp;\\n        }\\n        return a;\\n    } \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699380,
                "title": "the-question-is-problematic-duplicate-points",
                "content": "I believe I solved the problem but failed on this test case: [[0,0],[1,1],[0,0]]\\n\\nMy algorithm didn\\'t consider the situation that duplicate point exists. Duplicate points don\\'t make any sense.\\n\\n\\'\\'\\'\\n\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points)<=2:\\n            return len(points)\\n\\n        points = [(p[0],p[1]) for p in points]\\n\\n        def calcSlop(p1, p2):\\n            if p1[0]==p2[0]:\\n                return None\\n            else:\\n                return (p1[1]-p2[1])/(p1[0]-p2[0])\\n            \\n        lines = {calcSlop(points[0],points[1]):[{points[0],points[1]}]} # {slop: [line {points}]}\\n        visited = {points[0],points[1]}\\n\\n        for p in points[2:]:\\n            _visited = set()\\n            for pv in visited:\\n                if pv in _visited:\\n                    continue\\n                slop = calcSlop(p,pv)\\n                _processed = False\\n                if slop in lines:\\n                    for line in lines[slop]:\\n                        if pv in line:\\n                            line.add(p)\\n                            _visited = _visited.union(line)\\n                            _processed = True\\n                            break\\n                if not _processed:\\n                    if slop in lines:\\n                        lines[slop].append({p, pv})\\n                    else:\\n                        lines[slop] = [{p, pv}]\\n                _visited.add(pv)\\n            visited.add(p)\\n            \\n        max_lines = 0\\n        for lns in lines.values():\\n            for l in lns:\\n                if len(l) > max_lines:\\n                    max_lines = len(l)\\n        return max_lines\\n        \\n\\'\\'\\'",
                "solutionTags": [],
                "code": "I believe I solved the problem but failed on this test case: [[0,0],[1,1],[0,0]]\\n\\nMy algorithm didn\\'t consider the situation that duplicate point exists. Duplicate points don\\'t make any sense.\\n\\n\\'\\'\\'\\n\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points)<=2:\\n            return len(points)\\n\\n        points = [(p[0],p[1]) for p in points]\\n\\n        def calcSlop(p1, p2):\\n            if p1[0]==p2[0]:\\n                return None\\n            else:\\n                return (p1[1]-p2[1])/(p1[0]-p2[0])\\n            \\n        lines = {calcSlop(points[0],points[1]):[{points[0],points[1]}]} # {slop: [line {points}]}\\n        visited = {points[0],points[1]}\\n\\n        for p in points[2:]:\\n            _visited = set()\\n            for pv in visited:\\n                if pv in _visited:\\n                    continue\\n                slop = calcSlop(p,pv)\\n                _processed = False\\n                if slop in lines:\\n                    for line in lines[slop]:\\n                        if pv in line:\\n                            line.add(p)\\n                            _visited = _visited.union(line)\\n                            _processed = True\\n                            break\\n                if not _processed:\\n                    if slop in lines:\\n                        lines[slop].append({p, pv})\\n                    else:\\n                        lines[slop] = [{p, pv}]\\n                _visited.add(pv)\\n            visited.add(p)\\n            \\n        max_lines = 0\\n        for lns in lines.values():\\n            for l in lns:\\n                if len(l) > max_lines:\\n                    max_lines = len(l)\\n        return max_lines\\n        \\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 620863,
                "title": "java-clean-code-for-a-horrible-question",
                "content": "```java\\npublic int maxPoints(int[][] points) {\\n\\tif (points == null || points.length == 0) return 0;\\n\\n\\tint n = points.length;\\n\\tif (n < 2) return n;\\n\\n\\tSet<String> seen = new HashSet<>();\\n\\tint max = 1;\\n\\n\\tfor (int i = 0; i < n && !seen.contains(points[i][0] + \"-\" + points[i][1]); i++) {\\n\\n\\t\\tint[] a = points[i];\\n\\n\\t\\tint same = 0;\\n\\t\\tMap<Double, Integer> map = new HashMap<>();\\n\\t\\tint localMax = 1;\\n\\n\\t\\tfor (int j = i + 1; j < n; j++) {\\n\\t\\t\\tif (isSame(a, points[j])) {\\n\\t\\t\\t\\tsame++;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tdouble slope = getSlope(a, points[j]);\\n\\t\\t\\tmap.put(slope, map.getOrDefault(slope, 1) + 1);\\n\\t\\t\\tlocalMax = Math.max(localMax, map.get(slope));\\n\\t\\t}\\n\\n\\t\\tseen.add(a[0] + \"-\" + a[1]);\\n\\t\\tmax = Math.max(max, localMax + same);\\n\\t}\\n\\n\\treturn max;\\n}\\n\\nprivate boolean isSame(int[] a, int[] b) {\\n\\treturn a[0] == b[0] && a[1] == b[1];\\n}\\n\\nprivate double getSlope(int[] a, int[] b) {\\n\\tif (a[0] == b[0]) return Double.MAX_VALUE;\\n\\tif (a[1] == b[1]) return 0;\\n\\treturn ((double) b[0] - a[0]) / ((double) b[1] - a[1]);\\n}",
                "solutionTags": [],
                "code": "```java\\npublic int maxPoints(int[][] points) {\\n\\tif (points == null || points.length == 0) return 0;\\n\\n\\tint n = points.length;\\n\\tif (n < 2) return n;\\n\\n\\tSet<String> seen = new HashSet<>();\\n\\tint max = 1;\\n\\n\\tfor (int i = 0; i < n && !seen.contains(points[i][0] + \"-\" + points[i][1]); i++) {\\n\\n\\t\\tint[] a = points[i];\\n\\n\\t\\tint same = 0;\\n\\t\\tMap<Double, Integer> map = new HashMap<>();\\n\\t\\tint localMax = 1;\\n\\n\\t\\tfor (int j = i + 1; j < n; j++) {\\n\\t\\t\\tif (isSame(a, points[j])) {\\n\\t\\t\\t\\tsame++;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tdouble slope = getSlope(a, points[j]);\\n\\t\\t\\tmap.put(slope, map.getOrDefault(slope, 1) + 1);\\n\\t\\t\\tlocalMax = Math.max(localMax, map.get(slope));\\n\\t\\t}\\n\\n\\t\\tseen.add(a[0] + \"-\" + a[1]);\\n\\t\\tmax = Math.max(max, localMax + same);\\n\\t}\\n\\n\\treturn max;\\n}\\n\\nprivate boolean isSame(int[] a, int[] b) {\\n\\treturn a[0] == b[0] && a[1] == b[1];\\n}\\n\\nprivate double getSlope(int[] a, int[] b) {\\n\\tif (a[0] == b[0]) return Double.MAX_VALUE;\\n\\tif (a[1] == b[1]) return 0;\\n\\treturn ((double) b[0] - a[0]) / ((double) b[1] - a[1]);\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 522413,
                "title": "simple-python-solution-100-memory-efficent",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        def helper(currentPoint, points):\\n            slopes,duplicates,ans = {},0,0\\n            x1, y1 = currentPoint\\n            for x2, y2 in points:\\n                # If the points are same inc duplicate counter\\n                if x1 == x2 and y1 == y2:\\n                    duplicates += 1\\n                # else find the slop and add in dic\\n                else:\\n                    slope = (x2 - x1) / (y2 - y1) if y2 != y1 else \\'inf\\'\\n                    count = slopes.get(slope, 0) + 1\\n                    slopes[slope] = count\\n                    ans = max(ans, count)\\n            return ans + 1 + duplicates\\n        ans = 0\\n        while points:\\n            currentPoint = points.pop()\\n            ans = max(ans, helper(currentPoint, points))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        def helper(currentPoint, points):\\n            slopes,duplicates,ans = {},0,0\\n            x1, y1 = currentPoint\\n            for x2, y2 in points:\\n                # If the points are same inc duplicate counter\\n                if x1 == x2 and y1 == y2:\\n                    duplicates += 1\\n                # else find the slop and add in dic\\n                else:\\n                    slope = (x2 - x1) / (y2 - y1) if y2 != y1 else \\'inf\\'\\n                    count = slopes.get(slope, 0) + 1\\n                    slopes[slope] = count\\n                    ans = max(ans, count)\\n            return ans + 1 + duplicates\\n        ans = 0\\n        while points:\\n            currentPoint = points.pop()\\n            ans = max(ans, helper(currentPoint, points))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486725,
                "title": "python-3-fourteen-lines-beats-94",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, P: List[List[int]]) -> int:\\n        L, M, gcd = len(P), 1, math.gcd\\n        for i,(x1,y1) in enumerate(P):\\n            s, D = 1, collections.defaultdict(int, {0:0})\\n            for (x2,y2) in P[i+1:]:\\n                g = gcd(y2-y1, x2-x1)\\n                if g == 0:\\n                    s += 1\\n                    continue\\n                m = ((y2-y1)//g, (x2-x1)//g)\\n                if m[1] == 0: m = (1,0)\\n                if m[1] < 0: m = (-m[0],-m[1])\\n                D[m] += 1\\n            M = max(M, s + max(D.values()))\\n        return M if P else 0\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def maxPoints(self, P: List[List[int]]) -> int:\\n        L, M, gcd = len(P), 1, math.gcd\\n        for i,(x1,y1) in enumerate(P):\\n            s, D = 1, collections.defaultdict(int, {0:0}",
                "codeTag": "Java"
            },
            {
                "id": 312508,
                "title": "python3-clean-solution",
                "content": "```\\nfrom math import gcd\\nfrom collections import Counter\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points) < 2: return len(points)\\n        points = [tuple(x) for x in points]\\n        P = Counter(points)\\n        def slop(p1, p2):\\n            dx, dy = p2[0]-p1[0], p2[1]-p1[1]\\n            if dx == 0: return (0, 1)\\n            if dy == 0: return (1, 0)\\n            if dx < 0:\\n                dx = -dx\\n                dy = -dy\\n            g = gcd(dx, dy)\\n            return (dx//g, dy//g)\\n        lines = [Counter() for _ in range(len(points))]\\n        for i in range(1, len(points)):\\n            for j in range(i):\\n                if points[j] == points[i]: continue\\n                k = slop(points[j], points[i])\\n                lines[i][k] += 1\\n                lines[j][k] += 1\\n        ans = 0\\n        for i, l in enumerate(lines):\\n            ans = max(ans, max(l.values(), default = 0) + P[points[i]])\\n        return ans\\n                \\n        \\n            \\n            \\n",
                "solutionTags": [],
                "code": "```\\nfrom math import gcd\\nfrom collections import Counter\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points) < 2: return len(points)\\n        points = [tuple(x) for x in points]\\n        P = Counter(points)\\n        def slop(p1, p2):\\n            dx, dy = p2[0]-p1[0], p2[1]-p1[1]\\n            if dx == 0: return (0, 1)\\n            if dy == 0: return (1, 0)\\n            if dx < 0:\\n                dx = -dx\\n                dy = -dy\\n            g = gcd(dx, dy)\\n            return (dx//g, dy//g)\\n        lines = [Counter() for _ in range(len(points))]\\n        for i in range(1, len(points)):\\n            for j in range(i):\\n                if points[j] == points[i]: continue\\n                k = slop(points[j], points[i])\\n                lines[i][k] += 1\\n                lines[j][k] += 1\\n        ans = 0\\n        for i, l in enumerate(lines):\\n            ans = max(ans, max(l.values(), default = 0) + P[points[i]])\\n        return ans\\n                \\n        \\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 309382,
                "title": "wrong-bad-test-case-why-should-0-0-1-1-0-0-return-3",
                "content": "as per the submission result\\n```\\n[[0,0],[1,1],[0,0]]\\n```\\nshould result 3, but isnt point 0,0 is duplicated, how does it even make sense to output 3?",
                "solutionTags": [],
                "code": "```\\n[[0,0],[1,1],[0,0]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299085,
                "title": "explanation",
                "content": "> What are points `lie on the same straight line` like?\\n> \\n>The ratio of the \"vertical change\" to the \"horizontal change\" between (any) two distinct points on a line is identical, which is called **slope**. \\n\\n> For each point i, itself and another point j can identify a line, resulting in a slope. \\n> We map a slope to its frequency. Finally, frequency + 1 is the number of points on the line with the `slope`.\\n> \\n> As for the slope, we need to transfer it to a fraction in lowest terms.\\n\\n> Since `from point i to j`, and `from point j to i` is the same line. We can start j from i + 1.\\n\\n> There may be points overlapping with i. We maintain `overlap` and add it to total points at last.\\n```\\n    public int maxPoints(int[][] points) {\\n        if (points.length == 0) {\\n            return 0;\\n        }\\n        \\n        // Maximum points among slopes\\n        int max = 0;\\n        // Map slope to its frequency\\n        Map<String, Integer> kToFreq;\\n        \\n        for (int i = 0; i < points.length; i++) { // For each point i\\n            kToFreq = new HashMap<>(); \\n            int overlap = 0; // The number of points overlap with i\\n            \\n            for (int j = i + 1; j < points.length; j++) { // For each point j\\n                \\n                int yDiff = points[j][1] - points[i][1];\\n                int xDiff = points[j][0] - points[i][0];\\n                \\n                if (xDiff == 0 && yDiff == 0) { // Point j overlaps point i\\n                    overlap++;\\n                } else if (xDiff == 0) { // Point j and i are parallel\\n                    kToFreq.put(\"Max\", kToFreq.getOrDefault(\"Max\", 0) + 1);\\n                } else {\\n                    int sign = \\n                        ((xDiff > 0 && yDiff > 0) || (xDiff < 0 && yDiff < 0)) ? 1 : -1;\\n                    xDiff = Math.abs(xDiff);\\n                    yDiff = Math.abs(yDiff);\\n                    int gcd = getGCD(xDiff, yDiff);\\n                    String k = sign + \" \" + xDiff / gcd  + \"/\" + yDiff / gcd;\\n                    kToFreq.put(k, kToFreq.getOrDefault(k, 0) + 1);\\n                }\\n            }\\n            \\n            // Update max with max value in current map\\n            int curMax = 0;\\n            for (int freq : kToFreq.values()) {\\n                curMax = Math.max(curMax, freq);\\n            }\\n            max = Math.max(curMax + overlap + 1, max);\\n        }\\n        \\n        return max;\\n    }\\n\\n    private int getGCD(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return getGCD(b, a % b);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxPoints(int[][] points) {\\n        if (points.length == 0) {\\n            return 0;\\n        }\\n        \\n        // Maximum points among slopes\\n        int max = 0;\\n        // Map slope to its frequency\\n        Map<String, Integer> kToFreq;\\n        \\n        for (int i = 0; i < points.length; i++) { // For each point i\\n            kToFreq = new HashMap<>(); \\n            int overlap = 0; // The number of points overlap with i\\n            \\n            for (int j = i + 1; j < points.length; j++) { // For each point j\\n                \\n                int yDiff = points[j][1] - points[i][1];\\n                int xDiff = points[j][0] - points[i][0];\\n                \\n                if (xDiff == 0 && yDiff == 0) { // Point j overlaps point i\\n                    overlap++;\\n                } else if (xDiff == 0) { // Point j and i are parallel\\n                    kToFreq.put(\"Max\", kToFreq.getOrDefault(\"Max\", 0) + 1);\\n                } else {\\n                    int sign = \\n                        ((xDiff > 0 && yDiff > 0) || (xDiff < 0 && yDiff < 0)) ? 1 : -1;\\n                    xDiff = Math.abs(xDiff);\\n                    yDiff = Math.abs(yDiff);\\n                    int gcd = getGCD(xDiff, yDiff);\\n                    String k = sign + \" \" + xDiff / gcd  + \"/\" + yDiff / gcd;\\n                    kToFreq.put(k, kToFreq.getOrDefault(k, 0) + 1);\\n                }\\n            }\\n            \\n            // Update max with max value in current map\\n            int curMax = 0;\\n            for (int freq : kToFreq.values()) {\\n                curMax = Math.max(curMax, freq);\\n            }\\n            max = Math.max(curMax + overlap + 1, max);\\n        }\\n        \\n        return max;\\n    }\\n\\n    private int getGCD(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return getGCD(b, a % b);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275997,
                "title": "java-o-n-2-solution",
                "content": "Explanation: For each line (of the form y=Ax+B) delimited by two points, use the A and B as indexes of a Map<String,Set<int[]>>. Their numerator and denominator are used to avoid precision loss, they are also simplified with GCD. At the end, go through every set count the max number of points in a line. \\n\\nEdge cases: when two points are on the same X, a key of the form \"x-<value>\" is used.\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        Map<String,Set<int[]>> count = new HashMap<String,Set<int[]>>();\\n        for(int i = 0; i < points.length; i++) {\\n            for(int j = i+1; j < points.length; j++) {\\n                if (points[i][0] == points[j][0]) {\\n                    String key = String.format(\"x-%d\",points[j][0]);\\n                    if(!count.containsKey(key)) {\\n                        count.put(key, new HashSet<int[]>());\\n                    }\\n                    count.get(key).add(points[i]);\\n                    count.get(key).add(points[j]);\\n                } else {\\n                    String key = getFunc(points[i],points[j]);\\n                    if(!count.containsKey(key)) {\\n                        count.put(key, new HashSet<int[]>());\\n                    }\\n                    count.get(key).add(points[i]);\\n                    count.get(key).add(points[j]);\\n                }\\n            }\\n        }\\n        int max = points.length > 0 ? 1 : 0;\\n        for(Set<int[]> values : count.values()) {\\n            max = Math.max(max,values.size());\\n        }\\n        return max;\\n    }\\n    private String getFunc(int[] p1, int[] p2) {\\n        int aNum = p1[1]-p2[1];\\n        int aDen = p1[0]-p2[0];\\n        int gcdA = gcd(aNum,aDen);\\n        aNum /= gcdA;\\n        aDen /= gcdA;\\n        int bNum = (aDen*p1[1]) - (aNum*p1[0]);\\n        int bDen = aDen;\\n        int gcdB = gcd(bNum,bDen);\\n        bNum /= gcdB;\\n        bDen /= gcdB;\\n        return String.format(\"%d/%d-%d/%d\",aNum,aDen,bNum,bDen);\\n    }\\n    private int gcd(int a, int b) {\\n        if (b==0) return a;\\n        else return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        Map<String,Set<int[]>> count = new HashMap<String,Set<int[]>>();\\n        for(int i = 0; i < points.length; i++) {\\n            for(int j = i+1; j < points.length; j++) {\\n                if (points[i][0] == points[j][0]) {\\n                    String key = String.format(\"x-%d\",points[j][0]);\\n                    if(!count.containsKey(key)) {\\n                        count.put(key, new HashSet<int[]>());\\n                    }\\n                    count.get(key).add(points[i]);\\n                    count.get(key).add(points[j]);\\n                } else {\\n                    String key = getFunc(points[i],points[j]);\\n                    if(!count.containsKey(key)) {\\n                        count.put(key, new HashSet<int[]>());\\n                    }\\n                    count.get(key).add(points[i]);\\n                    count.get(key).add(points[j]);\\n                }\\n            }\\n        }\\n        int max = points.length > 0 ? 1 : 0;\\n        for(Set<int[]> values : count.values()) {\\n            max = Math.max(max,values.size());\\n        }\\n        return max;\\n    }\\n    private String getFunc(int[] p1, int[] p2) {\\n        int aNum = p1[1]-p2[1];\\n        int aDen = p1[0]-p2[0];\\n        int gcdA = gcd(aNum,aDen);\\n        aNum /= gcdA;\\n        aDen /= gcdA;\\n        int bNum = (aDen*p1[1]) - (aNum*p1[0]);\\n        int bDen = aDen;\\n        int gcdB = gcd(bNum,bDen);\\n        bNum /= gcdB;\\n        bDen /= gcdB;\\n        return String.format(\"%d/%d-%d/%d\",aNum,aDen,bNum,bDen);\\n    }\\n    private int gcd(int a, int b) {\\n        if (b==0) return a;\\n        else return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247110,
                "title": "rust-concise-o-n-2-solution-0-ms-with-explanation",
                "content": "```rust\\n/*\\n   straight-line expression: Ax + By + C = 0, given two points (x1,y1) and (x2,y2), then,\\n      A = y2 - y1, B = x1 - x2, C = x2y1 - x1y2\\n   (notice that A == 0 && B == 0 indicated that the given points is same)\\n   \\n   With this expression, We can express any straight-line using a 3-Tuple, this basic idea is \\n   for each points pair consists a line, we test if rest points are in this line, then we get an O(N^3)\\n   algorithm (Brute force). \\n   \\n   To optimize, introduce a HashSet to record the evaluated expressions, we get the O(N^2) solution.\\n   \\n   Moreover, take care of the following caveats in the test cases:\\n   \\n   1. some test cases cause i32 calucation overflow, so the code use i64 for line expression;\\n   2. some points contains same points, if we solve them in the loop, the worse case will be O(N^3), so we fold the same points before the main loop;\\n   3. Point do not implement the Hash trait, use 2-Tuple as intermidate data-structure during folding.\\n */\\n#[derive(PartialEq,Hash,Eq,Debug)]\\nstruct Line(i64, i64, i64);\\n\\nimpl Line {\\n    // Assumes that there is no same point\\n    fn new(p1: &Point, p2: &Point) -> Self {\\n        let x1 = p1.x as i64;\\n        let x2 = p2.x as i64;\\n        let y1 = p1.y as i64;\\n        let y2 = p2.y as i64;\\n        Line(y2-y1, x1-x2,  x2*y1 - x1*y2)\\n    }\\n    fn contains(&self, p: &Point) -> bool {\\n        self.0 * p.x as i64 + self.1 * p.y as i64 + self.2 == 0_i64\\n    }\\n}\\n\\nuse std::collections::HashSet;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn max_points(points: Vec<Point>) -> i32 {\\n        // fold same point, record the point count\\n        let points: Vec<(Point, i32)> = points.into_iter()\\n            .fold(HashMap::new(), |mut map, v| {\\n                *map.entry((v.x, v.y)).or_insert(0) += 1; map\\n            })\\n            .into_iter()\\n            .map(|(k,v)| { (Point::new(k.0, k.1), v) }) // Point did not implement Hash trait\\n            .collect();\\n\\n        // any two points in a straight-line, return quickly\\n        if points.len() < 3 {\\n            return points.into_iter().fold(0, |acc, v| { acc + v.1 });\\n        }\\n        let mut max = 2;\\n        let mut set: HashSet<Line> = HashSet::new();\\n        for i in 0..(points.len()-1) {\\n            for j in i+1..points.len() {\\n                let line = Line::new(&points[i].0, &points[j].0);\\n                if set.contains(&line) {\\n                    continue;\\n                }\\n                let mut curr = points[i].1 + points[j].1;\\n                for k in j+1..points.len() {\\n                    if line.contains(&points[k].0) {\\n                        curr += points[k].1;\\n                    }\\n                }\\n                max = i32::max(max, curr);\\n            }\\n        }\\n        max\\n    }\\n}\\n```\\n\\n\\u4E2D\\u6587\\uFF1A\\n\\u8981\\u56DE\\u987E\\u4E0B\\u9AD8\\u4E2D\\u6570\\u5B66\\uFF1A\\u5DF2\\u77E5\\u4E24\\u70B9, \\u6C42\\u89E3\\u4E00\\u822C\\u5F0F:\\n  \\n   * Ax + By + C = 0\\n   * A = y2 - y1, B = x1 - x2, C = x2y1 - x1y2\\n\\n \\u6709\\u8FD9\\u4E2A\\u77E5\\u8BC6\\u4E4B\\u540E\\uFF0C\\u5316\\u4E3A\\u4E00\\u822C\\u5F0F\\uFF0C\\u505A\\u4E09\\u5C42\\u904D\\u5386\\u5C31\\u884C\\uFF0C\\u518D\\u52A0\\u4E0A\\u4E00\\u4E2A HashSet\\uFF0C\\u907F\\u514D\\u5BF9\\u540C\\u4E00\\u76F4\\u7EBF\\u4E0A\\u70B9\\u7684\\u91CD\\u590D\\u8BA1\\u7B97\\uFF0C\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u53EF\\u4EE5\\u662F O(N^2)\\n \\n \\u6709\\u4E24\\u4E2A\\u5751\\u8981\\u6CE8\\u610F\\u907F\\u514D\\uFF1A\\n \\n   * \\u7ED9\\u7684 case \\u4F1A\\u5BFC\\u81F4 i32 \\u6EA2\\u51FA\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u7528\\u4E86 i64 \\u8868\\u793A\\n   * \\u7ED9\\u7684 case \\u91CC\\u6709\\u76F8\\u540C\\u7684\\u70B9\\uFF0C\\u76F4\\u63A5\\u5904\\u7406\\u76F8\\u540C\\u70B9\\u7684\\u8BDD\\u4F1A\\u5BFC\\u81F4\\u6700\\u574F\\u60C5\\u51B5\\u590D\\u6742\\u5EA6\\u5230 O(N^3)\\uFF0C\\u56E0\\u6B64\\u8981\\u5148\\u505A\\u4E00\\u6B21\\u8F6C\\u5316\\uFF0C\\u5F52\\u5E76\\u76F8\\u540C\\u7684\\u70B9\\n\\n \\u7528 Rust \\u5B9E\\u73B0\\u6709\\u53E6\\u4E00\\u70B9\\u6CE8\\u610F\\u7684\\uFF0C\\u7ED9\\u7684 Point \\u6CA1\\u6709\\u5B9E\\u73B0 Hash Trait\\uFF0C\\u8981\\u81EA\\u5DF1\\u8F6C\\u5316\\u4E00\\u4E0B",
                "solutionTags": [],
                "code": "```rust\\n/*\\n   straight-line expression: Ax + By + C = 0, given two points (x1,y1) and (x2,y2), then,\\n      A = y2 - y1, B = x1 - x2, C = x2y1 - x1y2\\n   (notice that A == 0 && B == 0 indicated that the given points is same)\\n   \\n   With this expression, We can express any straight-line using a 3-Tuple, this basic idea is \\n   for each points pair consists a line, we test if rest points are in this line, then we get an O(N^3)\\n   algorithm (Brute force). \\n   \\n   To optimize, introduce a HashSet to record the evaluated expressions, we get the O(N^2) solution.\\n   \\n   Moreover, take care of the following caveats in the test cases:\\n   \\n   1. some test cases cause i32 calucation overflow, so the code use i64 for line expression;\\n   2. some points contains same points, if we solve them in the loop, the worse case will be O(N^3), so we fold the same points before the main loop;\\n   3. Point do not implement the Hash trait, use 2-Tuple as intermidate data-structure during folding.\\n */\\n#[derive(PartialEq,Hash,Eq,Debug)]\\nstruct Line(i64, i64, i64);\\n\\nimpl Line {\\n    // Assumes that there is no same point\\n    fn new(p1: &Point, p2: &Point) -> Self {\\n        let x1 = p1.x as i64;\\n        let x2 = p2.x as i64;\\n        let y1 = p1.y as i64;\\n        let y2 = p2.y as i64;\\n        Line(y2-y1, x1-x2,  x2*y1 - x1*y2)\\n    }\\n    fn contains(&self, p: &Point) -> bool {\\n        self.0 * p.x as i64 + self.1 * p.y as i64 + self.2 == 0_i64\\n    }\\n}\\n\\nuse std::collections::HashSet;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn max_points(points: Vec<Point>) -> i32 {\\n        // fold same point, record the point count\\n        let points: Vec<(Point, i32)> = points.into_iter()\\n            .fold(HashMap::new(), |mut map, v| {\\n                *map.entry((v.x, v.y)).or_insert(0) += 1; map\\n            })\\n            .into_iter()\\n            .map(|(k,v)| { (Point::new(k.0, k.1), v) }) // Point did not implement Hash trait\\n            .collect();\\n\\n        // any two points in a straight-line, return quickly\\n        if points.len() < 3 {\\n            return points.into_iter().fold(0, |acc, v| { acc + v.1 });\\n        }\\n        let mut max = 2;\\n        let mut set: HashSet<Line> = HashSet::new();\\n        for i in 0..(points.len()-1) {\\n            for j in i+1..points.len() {\\n                let line = Line::new(&points[i].0, &points[j].0);\\n                if set.contains(&line) {\\n                    continue;\\n                }\\n                let mut curr = points[i].1 + points[j].1;\\n                for k in j+1..points.len() {\\n                    if line.contains(&points[k].0) {\\n                        curr += points[k].1;\\n                    }\\n                }\\n                max = i32::max(max, curr);\\n            }\\n        }\\n        max\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192288,
                "title": "very-easy-to-understand-java-code-with-a-lot-of-documentation",
                "content": "# Intro\\nIn order to get the count of points on the same line we\\'ll go through all points and compare them with the rest.\\n - We\\'ll refer to our point that will be compared to all others the **basePoint**\\n - We\\'ll every other point **secondPoint**\\n\\n# How does it work?\\n - in case the point is identical (same x and same y), then it\\'s also on the same vertical, horizontal and the same slope.\\n - remember when comparing to include the **basePoint** in your total, and include it **only once** in comparison \\n - for each basePoint create a Map to collect other points that lay on the same slope.\\n - don\\'t forget to reset the slopes map after each iteration.\\n\\n# Big O\\nfor each point in **N Points** you need to do **(N - 1) iterations ~= O(N)**\\ntime: **O(N^2)**  \\nyou need to create a map of worst case size O(N - 1) ~= O(N)\\nspace: **O(N)** \\n\\n```\\n    public int maxPoints(Point[] points) {\\n        if (points.length < 2) return points.length;\\n        int maxPoints = 0;\\n        HashMap<Double,Integer> slopes = new HashMap<>();\\n        double slope;\\n        int horizontal, vertical, identical;\\n        int count;\\n        int basePoint = 1; // just helper to understand the code below\\n        for (Point base: points) {\\n          identical = 0;\\n          vertical = 0;\\n          horizontal = 0;\\n          for (Point second: points) {\\n              if (base == second) continue;\\n              // identical point\\n              if (base.x == second.x && base.y == second.y) {\\n                identical++; // remember identical is horiz. vertical. and same slope (count it in all cases)\\n              // on the same vertical line\\n              } else if (base.x == second.x) {\\n                vertical++;\\n              // on the same horizontal line\\n              } else if (base.y == second.y) {\\n                horizontal++;\\n              // on a specific slope\\n              } else {\\n                slope = (double)(base.x - second.x)/(base.y - second.y); // calculate the slope\\n                count = slopes.getOrDefault(slope, 0) + 1; // get old count in addition to this one\\n                slopes.put(slope, count); // save the new slope\\n                maxPoints = Math.max(maxPoints, count + basePoint + identical); // compare the count + the base point + all identicals\\n              }              \\n          }\\n          maxPoints = Math.max(maxPoints, basePoint + horizontal + identical); // compare all horiz. + all identicals\\n          maxPoints = Math.max(maxPoints, basePoint + vertical + identical); // compare all vert. + all identicals\\n          slopes.clear();\\n        }\\n        \\n        return maxPoints;\\n    }\\n```\\n\\n# Follow up:\\nIn case of anything incorrectly mentioned here, please comment and I\\'ll adjust it.",
                "solutionTags": [],
                "code": "```\\n    public int maxPoints(Point[] points) {\\n        if (points.length < 2) return points.length;\\n        int maxPoints = 0;\\n        HashMap<Double,Integer> slopes = new HashMap<>();\\n        double slope;\\n        int horizontal, vertical, identical;\\n        int count;\\n        int basePoint = 1; // just helper to understand the code below\\n        for (Point base: points) {\\n          identical = 0;\\n          vertical = 0;\\n          horizontal = 0;\\n          for (Point second: points) {\\n              if (base == second) continue;\\n              // identical point\\n              if (base.x == second.x && base.y == second.y) {\\n                identical++; // remember identical is horiz. vertical. and same slope (count it in all cases)\\n              // on the same vertical line\\n              } else if (base.x == second.x) {\\n                vertical++;\\n              // on the same horizontal line\\n              } else if (base.y == second.y) {\\n                horizontal++;\\n              // on a specific slope\\n              } else {\\n                slope = (double)(base.x - second.x)/(base.y - second.y); // calculate the slope\\n                count = slopes.getOrDefault(slope, 0) + 1; // get old count in addition to this one\\n                slopes.put(slope, count); // save the new slope\\n                maxPoints = Math.max(maxPoints, count + basePoint + identical); // compare the count + the base point + all identicals\\n              }              \\n          }\\n          maxPoints = Math.max(maxPoints, basePoint + horizontal + identical); // compare all horiz. + all identicals\\n          maxPoints = Math.max(maxPoints, basePoint + vertical + identical); // compare all vert. + all identicals\\n          slopes.clear();\\n        }\\n        \\n        return maxPoints;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183843,
                "title": "strange-c-o-n-3-but-beats-99-75",
                "content": "Idea is just check every point triplet whether they form a 0 area triangle. As a result, no float introduced. It is O(n^3) but still beats 99.75% which is quite strange...\\n\\n```\\nstruct myHash {\\n    size_t operator()(const Point& p) const {\\n        return hash<int>()(p.x)^hash<int>()(p.y);\\n    }\\n};\\n\\nstruct myEq {\\n    bool operator()(const Point& p1, const Point& p2) const {\\n        return p1.x == p2.x && p1.y == p2.y;\\n    }\\n};\\n\\nclass Solution {\\n    inline long long area2(int i, int j, int k, vector<pair<Point,int>>& points) {\\n        return static_cast<long long>(points[i].first.x)*static_cast<long long>(points[j].first.y)\\n              -static_cast<long long>(points[i].first.y)*static_cast<long long>(points[j].first.x)\\n              +static_cast<long long>(points[j].first.x)*static_cast<long long>(points[k].first.y)\\n              -static_cast<long long>(points[j].first.y)*static_cast<long long>(points[k].first.x)\\n              +static_cast<long long>(points[k].first.x)*static_cast<long long>(points[i].first.y)\\n              -static_cast<long long>(points[k].first.y)*static_cast<long long>(points[i].first.x);\\n    }\\npublic:\\n    int maxPoints(vector<Point>& pts) {\\n        unordered_map<Point, int, myHash, myEq> ps;\\n        for (auto& p : pts) ps[p]++;\\n        int res = 0, n = ps.size();\\n        if (n < 3) return pts.size();\\n        vector<pair<Point, int>> points(ps.begin(), ps.end());\\n        for (int i = 0; i < n-2; ++i)\\n            for (int j = i+1; j < n-1; ++j) {\\n                int count = points[i].second+points[j].second;\\n                res = max(res, count);\\n                for (int k = j+1; k < n; ++k) \\n                    if (area2(i, j, k, points) == 0) {\\n                        count += points[k].second;\\n                        res = max(res, count);\\n                    }\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct myHash {\\n    size_t operator()(const Point& p) const {\\n        return hash<int>()(p.x)^hash<int>()(p.y);\\n    }\\n};\\n\\nstruct myEq {\\n    bool operator()(const Point& p1, const Point& p2) const {\\n        return p1.x == p2.x && p1.y == p2.y;\\n    }\\n};\\n\\nclass Solution {\\n    inline long long area2(int i, int j, int k, vector<pair<Point,int>>& points) {\\n        return static_cast<long long>(points[i].first.x)*static_cast<long long>(points[j].first.y)\\n              -static_cast<long long>(points[i].first.y)*static_cast<long long>(points[j].first.x)\\n              +static_cast<long long>(points[j].first.x)*static_cast<long long>(points[k].first.y)\\n              -static_cast<long long>(points[j].first.y)*static_cast<long long>(points[k].first.x)\\n              +static_cast<long long>(points[k].first.x)*static_cast<long long>(points[i].first.y)\\n              -static_cast<long long>(points[k].first.y)*static_cast<long long>(points[i].first.x);\\n    }\\npublic:\\n    int maxPoints(vector<Point>& pts) {\\n        unordered_map<Point, int, myHash, myEq> ps;\\n        for (auto& p : pts) ps[p]++;\\n        int res = 0, n = ps.size();\\n        if (n < 3) return pts.size();\\n        vector<pair<Point, int>> points(ps.begin(), ps.end());\\n        for (int i = 0; i < n-2; ++i)\\n            for (int j = i+1; j < n-1; ++j) {\\n                int count = points[i].second+points[j].second;\\n                res = max(res, count);\\n                for (int k = j+1; k < n; ++k) \\n                    if (area2(i, j, k, points) == 0) {\\n                        count += points[k].second;\\n                        res = max(res, count);\\n                    }\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47099,
                "title": "o-n-2-solution-with-explanation-of-all-steps",
                "content": "A simpler version of previous solutions given below. \\n\\n```\\n// https://leetcode.com/problems/max-points-on-a-line/description/\\n\\n/**\\n * Definition for a point.\\n * class Point {\\n *     int x;\\n *     int y;\\n *     Point() { x = 0; y = 0; }\\n *     Point(int a, int b) { x = a; y = b; }\\n * }\\n */\\nclass Solution {\\n    \\n    private int gcd(int a, int b) {\\n        if (b > a)\\n            return gcd(b, a);\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    }\\n\\n    private String getSlope(Point a, Point b) {\\n        int Y = b.y - a.y;\\n        int X = b.x - a.x;\\n        \\n        // Ensure a != b for below hacks to work\\n        // basically either it should be a vertical\\n        // line or a horizontal line and a and b\\n        // should be distinct points\\n        \\n        // hack for horizontal line point\\n        if (Y == 0)\\n            X = 1;\\n        \\n        // hack for vertical line point\\n        if (X == 0)\\n            Y = 1;\\n        \\n        // follow convention of -ve numerator\\n        // and +ve denominator so that -1/2 is same as 1/-2\\n        // for considering lines with same slopes\\n        if ((X < 0 && Y > 0) || (X < 0 && Y < 0)) {\\n            X = -X;\\n            Y = -Y;\\n        }\\n        \\n        // gcd can be calculated only for +ve numbers\\n        int g = gcd(Math.abs(X), Math.abs(Y));\\n        Y /= g;\\n        X /= g;\\n        \\n        return Y + \" \" + X;     // return slope as a pair of numerator, denominator\\n    }\\n    \\n    public int maxPoints(Point[] points) {\\n        if (points == null)\\n            return 0;\\n        if (points.length <= 2)\\n            return points.length;\\n        \\n        // track line segements in hashmap\\n        Map<String, Integer> map = new HashMap<>();\\n        int maxpt = 2;\\n        \\n        for (int i = 0; i < points.length; i++) {\\n            int samePoint = 0;\\n            int currMax = 0;\\n        \\n            for (int j = i + 1; j < points.length; j++) {\\n                \\n                if (points[i].x == points[j].x && points[i].y == points[j].y)\\n                    samePoint++;\\n                \\n                else {\\n                    String coeff = getSlope(points[i], points[j]);\\n                    System.out.println(coeff);\\n                    map.put(coeff, 1 + map.getOrDefault(coeff, 0));\\n                    currMax = Math.max(currMax, map.get(coeff));\\n                }\\n            }\\n            \\n            // currMax is count of maximum points[j] on a line passing through\\n            // points[i]. We still need to account for points[j] = points[i]\\n            // Also, up to this point we have take count of points[j] but the actual\\n            // number of points on a line should also include point[i] hence + 1\\n            maxpt = Math.max(maxpt, currMax + samePoint + 1);\\n            map.clear();    // clear slope->count map\\n        }\\n        return maxpt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// https://leetcode.com/problems/max-points-on-a-line/description/\\n\\n/**\\n * Definition for a point.\\n * class Point {\\n *     int x;\\n *     int y;\\n *     Point() { x = 0; y = 0; }\\n *     Point(int a, int b) { x = a; y = b; }\\n * }\\n */\\nclass Solution {\\n    \\n    private int gcd(int a, int b) {\\n        if (b > a)\\n            return gcd(b, a);\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    }\\n\\n    private String getSlope(Point a, Point b) {\\n        int Y = b.y - a.y;\\n        int X = b.x - a.x;\\n        \\n        // Ensure a != b for below hacks to work\\n        // basically either it should be a vertical\\n        // line or a horizontal line and a and b\\n        // should be distinct points\\n        \\n        // hack for horizontal line point\\n        if (Y == 0)\\n            X = 1;\\n        \\n        // hack for vertical line point\\n        if (X == 0)\\n            Y = 1;\\n        \\n        // follow convention of -ve numerator\\n        // and +ve denominator so that -1/2 is same as 1/-2\\n        // for considering lines with same slopes\\n        if ((X < 0 && Y > 0) || (X < 0 && Y < 0)) {\\n            X = -X;\\n            Y = -Y;\\n        }\\n        \\n        // gcd can be calculated only for +ve numbers\\n        int g = gcd(Math.abs(X), Math.abs(Y));\\n        Y /= g;\\n        X /= g;\\n        \\n        return Y + \" \" + X;     // return slope as a pair of numerator, denominator\\n    }\\n    \\n    public int maxPoints(Point[] points) {\\n        if (points == null)\\n            return 0;\\n        if (points.length <= 2)\\n            return points.length;\\n        \\n        // track line segements in hashmap\\n        Map<String, Integer> map = new HashMap<>();\\n        int maxpt = 2;\\n        \\n        for (int i = 0; i < points.length; i++) {\\n            int samePoint = 0;\\n            int currMax = 0;\\n        \\n            for (int j = i + 1; j < points.length; j++) {\\n                \\n                if (points[i].x == points[j].x && points[i].y == points[j].y)\\n                    samePoint++;\\n                \\n                else {\\n                    String coeff = getSlope(points[i], points[j]);\\n                    System.out.println(coeff);\\n                    map.put(coeff, 1 + map.getOrDefault(coeff, 0));\\n                    currMax = Math.max(currMax, map.get(coeff));\\n                }\\n            }\\n            \\n            // currMax is count of maximum points[j] on a line passing through\\n            // points[i]. We still need to account for points[j] = points[i]\\n            // Also, up to this point we have take count of points[j] but the actual\\n            // number of points on a line should also include point[i] hence + 1\\n            maxpt = Math.max(maxpt, currMax + samePoint + 1);\\n            map.clear();    // clear slope->count map\\n        }\\n        return maxpt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47105,
                "title": "c-solution-using-greatest-common-denominator",
                "content": "I have a solution but a few notes ported from the Java Solution by R:\\n\\n* I still don't quite understand while they allow duplicate points?  For that, I down-voted this one, because it needs to be fixed in my opinion.  Duplicate points don't exist in the 2D plane so this is a little weird.  In fact, there is an **infinite set** of points in the 2D plane, but it is a **set** which implies each point is unique.  To deal with this oddity, I labelled the variable \"undefined\" and just incremented it to pass the test cases (but, in reality, I wouldn't do that, but throw an InvalidOperationException or ArgumentException)\\n\\n* We are try to find points on a line (**y = mx + c**), where **m** is the **slope** and **c** is constant.  **m** is defined as deltaY/deltaX; **c** is derived from (y-y1=mx-x1) [e.g. (0,3) ==> c = 3]\\n\\n* The GCD was a very clever work-around from tracking the **slope**.  Any point on the same line will reduce down to the CGD (nice).  Giving credit to the Java Solution by R (nice).\\n\\n* The constant **c** was cleverly addressed, as well, by GCD for the same reason as above.\\n***\\n    /// <summary>\\n    /// Given a finite list (set would imply uniqueness) of points,\\n    /// compute the max number of points that lie on a straight \\n    /// line produced by the finite list; otherwise, max = infinity\\n    /// </summary>\\n    /// <example>\\n    /// {{0,0},{0,0}} produces 2\\n    /// {{0,0},{1,1},{1,-1}} = 2\\n    /// </example>\\n    public class Solution\\n    {\\n        private int GreatestCommonDenominator(int a, int b)\\n        {\\n            if (b == 0) return a;\\n            else\\n                return GreatestCommonDenominator(b, a % b);\\n        }\\n\\n        public int MaxPoints(Point[] points)\\n        {\\n            //Track from x0 and y0 \\n            Dictionary<int, Dictionary<int, int>> slopeMap = new Dictionary<int, Dictionary<int, int>>();\\n            int maxPoints = points.Length > 0 ? 1 : 0;\\n            \\n            for(int i = 0; i < points.Length; i++)\\n            {\\n                slopeMap.Clear();\\n                int localMax = 0, undefined = 0;\\n                for (int j = i + 1; j < points.Length; j++)\\n                {\\n                    int deltaX = points[j].x - points[i].x;\\n                    int deltaY = points[j].y - points[i].y;\\n\\n                    if(deltaX == 0 && deltaY == 0)\\n                    {\\n                        undefined++;\\n                        continue;\\n                    }\\n\\n                    int gcd = GreatestCommonDenominator(deltaY, deltaX);\\n\\n                    if (gcd != 0)\\n                    {\\n                        deltaX /= gcd;\\n                        deltaY /= gcd;\\n                    }\\n\\n                    if (!slopeMap.ContainsKey(deltaX))\\n                    {\\n                        slopeMap[deltaX] = new Dictionary<int, int>();\\n                    }\\n\\n                    if (!slopeMap[deltaX].ContainsKey(deltaY))\\n                    {\\n                        slopeMap[deltaX][deltaY] = 1;\\n                    }\\n                    else\\n                    {\\n                        slopeMap[deltaX][deltaY]++;\\n                    }\\n\\n                    localMax = Math.Max(localMax, slopeMap[deltaX][deltaY]);\\n                }\\n                maxPoints = Math.Max(maxPoints, localMax + undefined + 1);//+1 because I never added the initial point (x0,y0)\\n            }\\n\\n            return maxPoints;\\n        }\\n    }\\n***",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        private int GreatestCommonDenominator(int a, int b)\\n        {\\n            if (b == 0) return a;\\n            else\\n                return GreatestCommonDenominator(b, a % b);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 47188,
                "title": "6-liner-in-python-simple-solution-without-gcd",
                "content": "Simple math: a line can be uniquely represented by ```y=ax+b``` or ```x=c``` (vertical-line case).\\n\\nWe can iterate through all pairs of points and find the line that the 2 points are forming. The hash key tuple for the line is either ```(a, b)``` or ```(float('inf'), c)```.\\n\\nBy doing that, all points are grouped by unique lines.\\n\\nThen we count the number of unique points for each line and return the maximum.\\n```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        d = collections.defaultdict(set)\\n        for i in range(1, len(points)):\\n            for j in range(i):\\n                p1, p2 = points[i], points[j]\\n                d[(float('inf'), p1.x) if p1.x==p2.x else ((p1.y-p2.y)/float(p1.x-p2.x), (p1.x*p2.y-p2.x*p1.y)/float(p1.x-p2.x))] |= set([p1, p2])\\n        return max(len(s) for s in d.values()) if len(points)>1 else len(points)\\n```\\nOr the longer but easier-to-read version:\\n```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        d = collections.defaultdict(list)\\n        for i in range(1, len(points)):\\n            for j in range(i):\\n                p1, p2 = points[i], points[j]\\n                if p1.x == p2.x:\\n                    t = (float('inf'), p1.x)\\n                else:\\n                    t = ((p1.y-p2.y)/float(p1.x-p2.x), (p1.x*p2.y-p2.x*p1.y)/float(p1.x-p2.x))\\n                d[t] += [p1, p2]\\n        return max(len(set(l)) for l in d.values()) if len(points)>1 else len(points)\\n```",
                "solutionTags": [],
                "code": "```y=ax+b```\n```x=c```\n```(a, b)```\n```(float('inf'), c)```\n```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        d = collections.defaultdict(set)\\n        for i in range(1, len(points)):\\n            for j in range(i):\\n                p1, p2 = points[i], points[j]\\n                d[(float('inf'), p1.x) if p1.x==p2.x else ((p1.y-p2.y)/float(p1.x-p2.x), (p1.x*p2.y-p2.x*p1.y)/float(p1.x-p2.x))] |= set([p1, p2])\\n        return max(len(s) for s in d.values()) if len(points)>1 else len(points)\\n```\n```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        d = collections.defaultdict(list)\\n        for i in range(1, len(points)):\\n            for j in range(i):\\n                p1, p2 = points[i], points[j]\\n                if p1.x == p2.x:\\n                    t = (float('inf'), p1.x)\\n                else:\\n                    t = ((p1.y-p2.y)/float(p1.x-p2.x), (p1.x*p2.y-p2.x*p1.y)/float(p1.x-p2.x))\\n                d[t] += [p1, p2]\\n        return max(len(set(l)) for l in d.values()) if len(points)>1 else len(points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47258,
                "title": "c-code-with-hashmap-beating-96-others",
                "content": "    int maxPoints(vector<Point>& points) {\\n            int len = points.size(), ans = 0;\\n            if(len <= 2) return len;\\n            unordered_map<double, int> mp;\\n            for(int i = 0; i < len; i++){\\n                int dup = 1;    // To count the points exactly same with point i, including i itself.\\n                mp.clear();\\n                for(int j = i+1; j < len; j++){   // we start with j = i +1, because lines from i to k (k = 0,1,...,i-1) has already been considered in the previous steps.\\n                    if(points[i].x == points[j].x && points[i].y == points[j].y){\\n                            dup++;\\n                            continue;\\n                    }\\n                    else{\\n                        float slope = (points[i].x == points[j].x) ? INT_MAX : (float(points[i].y-points[j].y)/(points[i].x-points[j].x));\\n                        mp[slope]++;\\n                    }\\n                }\\n                ans = max(dup , ans);  // in case no element in the map.\\n                for (auto slope : mp)\\n                    if (slope.second + dup > ans) \\n                        ans = slope.second + dup; \\n            }\\n             return ans;\\n    }\\n\\nIdea: For one single point, we calculate the slopes to each of others and store them in a hash map. Take care of the case INT_MAX and duplicate.",
                "solutionTags": [],
                "code": "    int maxPoints(vector<Point>& points) {\\n            int len = points.size(), ans = 0;\\n            if(len <= 2) return len;\\n            unordered_map<double, int> mp;\\n            for(int i = 0; i < len; i++){\\n                int dup = 1;    // To count the points exactly same with point i, including i itself.\\n                mp.clear();\\n                for(int j = i+1; j < len; j++){   // we start with j = i +1, because lines from i to k (k = 0,1,...,i-1) has already been considered in the previous steps.\\n                    if(points[i].x == points[j].x && points[i].y == points[j].y){\\n                            dup++;\\n                            continue;\\n                    }\\n                    else{\\n                        float slope = (points[i].x == points[j].x) ? INT_MAX : (float(points[i].y-points[j].y)/(points[i].x-points[j].x));\\n                        mp[slope]++;\\n                    }\\n                }\\n                ans = max(dup , ans);  // in case no element in the map.\\n                for (auto slope : mp)\\n                    if (slope.second + dup > ans) \\n                        ans = slope.second + dup; \\n            }\\n             return ans;\\n    }\\n\\nIdea: For one single point, we calculate the slopes to each of others and store them in a hash map. Take care of the case INT_MAX and duplicate.",
                "codeTag": "Unknown"
            },
            {
                "id": 47297,
                "title": "my-java-solutions-for-your-reference-using-type-long-int-int-as-slope",
                "content": "    /**\\n     * Definition for a point.\\n     * class Point {\\n     *     int x;\\n     *     int y;\\n     *     Point() { x = 0; y = 0; }\\n     *     Point(int a, int b) { x = a; y = b; }\\n     * }\\n     */\\n    public class Solution {\\n        public int maxPoints(Point[] points) {\\n            if(points == null) return 0;\\n            int n = points.length;\\n            if(n <= 2) return n;\\n            Map<Long, Integer> map = new HashMap<>();\\n            int result = 0;\\n            for(int i = 0; i < n - 1; ++i){\\n                int localMax = 0, overlap = 0;\\n                map.clear();\\n                for(int j = i + 1; j < n; ++j){\\n                    if(points[i].x == points[j].x && points[i].y == points[j].y){\\n                        overlap++;\\n                    }else{`enter code here`\\n                        long k = slope(points[i].x - points[j].x, points[i].y - points[j].y);\\n                        int t = map.containsKey(k) ? map.get(k) + 1 : 1;\\n                        map.put(k, t);\\n                        localMax = t > localMax ? t : localMax;\\n                    }\\n                }\\n                localMax += overlap + 1;\\n                result = result < localMax ? localMax : result;\\n            }\\n            return result;\\n        }\\n        long slope(int a, int b){\\n            int c = gcd(a, b);\\n            if(c != 0){\\n                a /= c;\\n                b /= c;\\n            }\\n            long r = a;\\n            r = (r << 32) | b;\\n            return r;\\n        }\\n        int gcd(int a, int b){\\n            int r;\\n            while(b != 0){\\n                r = a % b;\\n                a = b;\\n                b = r;\\n            }\\n            return a;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxPoints(Point[] points) {\\n            if(points == null) return 0;\\n            int n = points.length;\\n            if(n <= 2) return n;\\n            Map<Long, Integer> map = new HashMap<>();\\n            int result = 0;\\n            for(int i = 0; i < n - 1; ++i){\\n                int localMax = 0, overlap = 0;\\n                map.clear();\\n                for(int j = i + 1; j < n; ++j){\\n                    if(points[i].x == points[j].x && points[i].y == points[j].y){\\n                        overlap++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 47344,
                "title": "why-y-kx-b-is-not-a-good-idea",
                "content": "How about define Line:\\n\\n    struct Line{\\n       double k;\\n       double b;\\n       bool isVerticalLine;\\n    }\\n\\nThen the problem is how to override the compare function for \"==\"? I used compare for sort before, but not for '=='.\\n\\n    struct lineComp{\\n        bool operator()(const Line &line1, const Line &line2){\\n            double eplison = 0.000001;\\n            if (line1.vLine && line2.vLine){\\n                return fabs(line1.b-line2.b) < eplison;\\n            }else if (line1.vLine || line2.vLine){\\n                return 1;\\n            }else\\n                return (fabs(line1.k - line2.k) < eplison ) && (fabs(line1.b - line2.b) < eplison) ;\\n        }\\n        \\n    };",
                "solutionTags": [],
                "code": "How about define Line:\\n\\n    struct Line{\\n       double k;\\n       double b;\\n       bool isVerticalLine;\\n    }\\n\\nThen the problem is how to override the compare function for \"==\"? I used compare for sort before, but not for '=='.\\n\\n    struct lineComp{\\n        bool operator()(const Line &line1, const Line &line2){\\n            double eplison = 0.000001;\\n            if (line1.vLine && line2.vLine){\\n                return fabs(line1.b-line2.b) < eplison;\\n            }else if (line1.vLine || line2.vLine){\\n                return 1;\\n            }else\\n                return (fabs(line1.k - line2.k) < eplison ) && (fabs(line1.b - line2.b) < eplison) ;\\n        }\\n        \\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3306665,
                "title": "python-o-n-2-solution-for-your-reference",
                "content": "```\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        def dic():\\n            return defaultdict(int);\\n        ans = 0;\\n        hmap = defaultdict(dic) \\n        n = len(points)\\n        for i in range(0,n):\\n            print(\"------------\")\\n            print(f\\'i:{i} point[i]:{points[i]} \\')\\n            hmap.clear();\\n            for j in range(i+1,n):\\n                x = points[i][0] - points[j][0]\\n                y = points[i][1] - points[j][1]\\n\\n                if(  y == 0 ):\\n                    hmap[0][0] += 1\\n                    if( hmap[0][0] > ans ):\\n                        ans = hmap[0][0];\\n                    continue;\\n                \\n                g = gcd(x,y);\\n\\n                x //= g\\n                y //= g\\n                # in case of negative slope one value can be negative (eg)\\n                # eg (1,-1) and (-1,1) will result in slop m = -1 but here \\n                if( y < 0 ):\\n                    x = -x \\n                    y = -y \\n                \\n                hmap[x][y] += 1\\n                print(f\\'j:{j} point[j]:{points[j]} x:{x} y:{y} hmap[{x}][{y}]:{hmap[x][y]}\\')\\n                if( hmap[x][y] > ans ):\\n                    ans = hmap[x][y];\\n            \\n        return ans+1;\\n\\n\\n                    \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        def dic():\\n            return defaultdict(int);\\n        ans = 0;\\n        hmap = defaultdict(dic) \\n        n = len(points)\\n        for i in range(0,n):\\n            print(\"------------\")\\n            print(f\\'i:{i} point[i]:{points[i]} \\')\\n            hmap.clear();\\n            for j in range(i+1,n):\\n                x = points[i][0] - points[j][0]\\n                y = points[i][1] - points[j][1]\\n\\n                if(  y == 0 ):\\n                    hmap[0][0] += 1\\n                    if( hmap[0][0] > ans ):\\n                        ans = hmap[0][0];\\n                    continue;\\n                \\n                g = gcd(x,y);\\n\\n                x //= g\\n                y //= g\\n                # in case of negative slope one value can be negative (eg)\\n                # eg (1,-1) and (-1,1) will result in slop m = -1 but here \\n                if( y < 0 ):\\n                    x = -x \\n                    y = -y \\n                \\n                hmap[x][y] += 1\\n                print(f\\'j:{j} point[j]:{points[j]} x:{x} y:{y} hmap[{x}][{y}]:{hmap[x][y]}\\')\\n                if( hmap[x][y] > ans ):\\n                    ans = hmap[x][y];\\n            \\n        return ans+1;\\n\\n\\n                    \\n\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3223792,
                "title": "java-easy-and-simple-o-n-2-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We loop all points and skip `i == j`\\n- calculate slope\\n- increment count for points that have same slope\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ Double for loop comparing all points\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ up to N number of points as slopes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if (points.length <= 2) { // if we have less than 2 points\\n            return points.length;\\n        }  \\n        int res = 0; \\n\\n        for (int i = 0; i < points.length; i++) {\\n            int[] p1 = points[i];\\n            Map<Double, Integer> map = new HashMap<>(); // <slope, count>\\n\\n            for (int j = 0; j < points.length; j++) {\\n                int[] p2 = points[j];\\n                if (p2 == p1) { // skip same points\\n                  continue;  \\n                }\\n                double slope = 0;\\n                if (p2[0] == p1[0]) { // vertical line\\n                    slope = Double.POSITIVE_INFINITY;\\n                } else {\\n                    slope = (p2[1] - p1[1]) / (double) (p2[0] - p1[0]);\\n                }\\n                map.put(slope, map.getOrDefault(slope, 1) + 1); // must have at least 1 + other number of points\\n                res = Math.max(res, map.get(slope));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if (points.length <= 2) { // if we have less than 2 points\\n            return points.length;\\n        }  \\n        int res = 0; \\n\\n        for (int i = 0; i < points.length; i++) {\\n            int[] p1 = points[i];\\n            Map<Double, Integer> map = new HashMap<>(); // <slope, count>\\n\\n            for (int j = 0; j < points.length; j++) {\\n                int[] p2 = points[j];\\n                if (p2 == p1) { // skip same points\\n                  continue;  \\n                }\\n                double slope = 0;\\n                if (p2[0] == p1[0]) { // vertical line\\n                    slope = Double.POSITIVE_INFINITY;\\n                } else {\\n                    slope = (p2[1] - p1[1]) / (double) (p2[0] - p1[0]);\\n                }\\n                map.put(slope, map.getOrDefault(slope, 1) + 1); // must have at least 1 + other number of points\\n                res = Math.max(res, map.get(slope));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047198,
                "title": "explained-java-tc-o-n2-sc-o-n",
                "content": "*Upvote if found helpful, comment for feedback or question.*\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor any 3 points to be in same line, or collinear, the slope of line formed between (point 1, point 2) should be equal to slope of line formed b/w (point 2, point 3) or (point 1, point 3).\\n\\nLet say there are 2 points (x1, y1), (x2, y2) respectively, then formula of slope - \\n\\n$$Slope, m = (y2 - y1) / (x2 - x1)$$\\n\\nWe can use this idea to maintain all the possible slopes forming from any given point, and maintain the counter for how many points lie in the respective slope.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if number of points given is equal to 1, if so, the answer can only be 1, hence return 1.\\n\\nVisualizing before step 2 - Let say we are charting the points that we are traversing (in  a graph) and first point has already been charted. From the 2nd point onwards, we will find the slope of current point with the existing points in graph. For example, \\n    For point 2, find slope with point 1.\\n    For point 3, find slope with point 1 and point 2, and so on.\\n\\n2.  Traverse from 2nd point to last, i,\\n\\n    2.1. Create a map which maintains all the slopes found and corresponding number of points in that slope.\\n\\n    *Note: Here we are maintaining local set of slopes, i.e., slopes that are forming from current point only, and not universal set of slopes found throughout. Universal set of slopes will cause problems in case of parallel lines.\\nFor example, consider points [[1,1],[2,3],[3,5],[4,1],[5,3]]. Slope b/w point 1, 2 and 3 is 2, number of points will be 3. But slope b/w point 4 and 5 is also 2 but they are not is same line. Maintaining a universal set of slopes will take counter for slope 2 to 5.\\nMaintaining a local set of slopes for every point allows us to consider only those points for counter that have same slope from current point.*\\n\\n    2.2. Calculate slope, from current point to all existing points,\\n    - Calculate slope keeping in mind divisibility with 0.\\n    - If slope already exists in map, increase its counter, else add slope to map with counter as 1.\\n    - Update max points if number of points for current slope is greater.\\n    \\n\\n3. Return max+1. This +1 is for the point with respect to which slopes were calculated. \\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int max = 1;\\n\\n        if(points.length<=1){\\n            return max;\\n        }\\n\\n        for(int i=1; i<points.length; i++){\\n            Map<Double, Integer> slopes = new HashMap();\\n            for(int j=0; j<i; j++){\\n                double slope = Double.MIN_VALUE;\\n                int denom = points[i][0] - points[j][0];\\n                int numer = points[i][1] - points[j][1];\\n                if(numer == 0){\\n                    slope = 0.0;\\n                }\\n                else if(denom != 0){\\n                    slope = numer / (double) denom ;\\n                }\\n                slopes.put(slope, slopes.getOrDefault(slope, 0) + 1);\\n                max = Math.max(max, slopes.get(slope));\\n            }\\n        }\\n\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int max = 1;\\n\\n        if(points.length<=1){\\n            return max;\\n        }\\n\\n        for(int i=1; i<points.length; i++){\\n            Map<Double, Integer> slopes = new HashMap();\\n            for(int j=0; j<i; j++){\\n                double slope = Double.MIN_VALUE;\\n                int denom = points[i][0] - points[j][0];\\n                int numer = points[i][1] - points[j][1];\\n                if(numer == 0){\\n                    slope = 0.0;\\n                }\\n                else if(denom != 0){\\n                    slope = numer / (double) denom ;\\n                }\\n                slopes.put(slope, slopes.getOrDefault(slope, 0) + 1);\\n                max = Math.max(max, slopes.get(slope));\\n            }\\n        }\\n\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029586,
                "title": "python-3-solution-using-hashmap-tc-o-n-2-sc-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each point, we need to find the slope of the line with all other points and maximum of points having same slope is the answer. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Return 1 if length of the points is 1.\\n- I have created a hashmap(i.e. cache in the code).\\n- For every point i\\'ve calculated the slope of the line that connects two points and stored in the cache with key in the form of key = (x-coordinate, y-coordinate, slope= $$(y2-y1/x2-x1)$$).\\n- If $$(x2-x1 = 0)$$ we get divide by zero error so, we store $$\"i\"$$ as our value. since the slope is infinity.\\n- If any other points make same slope with our point. we increment the value that the slope(key) represents in the cache.\\n- Finally, answer is the maximum of all the values in the dictionary +1 (Our first point and all the other points it has same slope with).\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points)==1:\\n            return 1\\n        cache = {}\\n        n = len(points)\\n        for i in range(n):\\n            point = points[i]\\n            for j in points:\\n                if point != j:\\n                    if (j[0]-point[0])==0:\\n                        slope = \"i\"\\n                    else:\\n                        slope = (j[1]-point[1])/(j[0]-point[0])\\n                    key = (point[0],point[1], slope)\\n                    if key in cache:\\n                        cache[key] += 1\\n                    else:\\n                        cache[key] = 1\\n        return max(cache.values()) + 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points)==1:\\n            return 1\\n        cache = {}\\n        n = len(points)\\n        for i in range(n):\\n            point = points[i]\\n            for j in points:\\n                if point != j:\\n                    if (j[0]-point[0])==0:\\n                        slope = \"i\"\\n                    else:\\n                        slope = (j[1]-point[1])/(j[0]-point[0])\\n                    key = (point[0],point[1], slope)\\n                    if key in cache:\\n                        cache[key] += 1\\n                    else:\\n                        cache[key] = 1\\n        return max(cache.values()) + 1\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1747022,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1566134,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1568114,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1747154,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1573923,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1566076,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1747026,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1567383,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1567216,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1568980,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1747022,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1566134,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1568114,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1747154,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1573923,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1566076,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1747026,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1567383,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1567216,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1568980,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1568033,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1567889,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1574589,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1568109,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1567890,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1570237,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1958361,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1747722,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1574165,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1569488,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1572576,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1568978,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1568979,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1571330,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1568056,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1748784,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1748449,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1748245,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1747094,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1747067,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1574346,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1573306,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1573046,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1572851,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1572623,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1572299,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1571936,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1571325,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1571326,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1571328,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1571329,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571331,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571332,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571333,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571334,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571335,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571336,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571921,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 2030851,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 2010854,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1980876,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1977646,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1963336,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1957297,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1873843,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1867591,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1804723,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1773680,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1770475,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1769740,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1766921,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1756362,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1751210,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1751020,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1749310,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1749196,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1748901,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1748838,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1748774,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1748759,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1748747,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748706,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748616,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748575,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748564,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748536,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748498,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748480,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748473,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748367,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748325,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748265,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748260,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748252,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748251,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748207,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748182,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748162,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748125,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748096,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748083,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1748067,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1748039,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1748023,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1748021,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1747941,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1747940,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1747935,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1747923,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1747762,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1747754,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747748,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747725,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747712,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747690,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747684,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747674,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747644,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747640,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747632,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747580,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747566,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747512,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747438,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747423,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747373,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747345,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747314,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747260,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747223,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747111,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1747101,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1747077,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1747052,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1747024,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1747004,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1746970,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1714333,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1687704,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1629653,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            }
        ]
    },
    {
        "title": "Group Shifted Strings",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1564974,
                "content": [
                    {
                        "username": "sherryxmhe",
                        "content": "I don't quite understand the question. Successive letter means in alphabet order or the next letter in the string. And is \"ba\" the result of shifting \"az\" to the right? And we can't shift \"az\" to the left because z is the last letter in the alphabet?"
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\\n\"b\"->\"a\" which is 1 step.  \\n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\\n\\nright now the question isn\\'t well phrased."
                    },
                    {
                        "username": "dav1de24",
                        "content": "There is no requirement to sort or order in any way the answers, yet you flag incorrect answers with a different order. Please make sure you ask the question correctly."
                    },
                    {
                        "username": "forgetboy",
                        "content": "Input:\\n[\"ab\",\"ba\"]\\n\\nOutput:\\n[[\"ab\",\"ba\"]]\\n\\nExpected:\\n[[\"ba\"],[\"ab\"]]\\n\\n\\nMy code submission is failing with the message above. As far as I can see, the expected result is incorrect. If not, can someone please explain to me why that's the case. Thanks."
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\n\"b\"->\"a\" which is 1 step.  \n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\n\n\nThis is why \"ba\" and \"ab\" are not part of the shifting sequence.\nThe transition for \"b\" -> \"a\" is is 25 shifts  i.e. b to z and then a to b.\nThe transition for \"a\" -> \"b\" is 1 step.\n\nright now the question isn't well phrased."
                    },
                    {
                        "username": "housj1228",
                        "content": "You cannot get \\'ba\\' by simply shifting \\'ab\\'"
                    },
                    {
                        "username": "ybn4aq",
                        "content": "You guys really need to do a better job at properly describing the problem. In a real interview, the interviewee would be able to ask clarifying questions about the setup of the problem. This description is way too short, and doesn\\'t really explain that you\\'re able to shift backwards."
                    },
                    {
                        "username": "yanggao",
                        "content": "do we have to follow the ascending or descending sequence? \"acef\" is not continuous."
                    },
                    {
                        "username": "lanzhuoqin",
                        "content": "I got this failling:\\nInput\\nstrings =\\n[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\\nOutput\\n[[\"abc\",\"bcd\",\"xyz\"],[\"acef\"],[\"az\"],[\"ba\"],[\"a\",\"z\"]]\\nExpected\\n[[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\\n\\n\\nCan you tell me why [\"az\",\"ba\"] is right?\\n\\'a\\' -> \\'z\\' seems reverse sequence of \\'b\\' -> \\'a\\'"
                    },
                    {
                        "username": "dealth",
                        "content": "The 25th char after ```a``` is ```z```, and the 25th char after ```b``` is ```a``` noting that implicitly each word in the string is cyclic from this ```We can keep shifting the string to form a sequence.``` "
                    }
                ]
            },
            {
                "id": 1566490,
                "content": [
                    {
                        "username": "sherryxmhe",
                        "content": "I don't quite understand the question. Successive letter means in alphabet order or the next letter in the string. And is \"ba\" the result of shifting \"az\" to the right? And we can't shift \"az\" to the left because z is the last letter in the alphabet?"
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\\n\"b\"->\"a\" which is 1 step.  \\n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\\n\\nright now the question isn\\'t well phrased."
                    },
                    {
                        "username": "dav1de24",
                        "content": "There is no requirement to sort or order in any way the answers, yet you flag incorrect answers with a different order. Please make sure you ask the question correctly."
                    },
                    {
                        "username": "forgetboy",
                        "content": "Input:\\n[\"ab\",\"ba\"]\\n\\nOutput:\\n[[\"ab\",\"ba\"]]\\n\\nExpected:\\n[[\"ba\"],[\"ab\"]]\\n\\n\\nMy code submission is failing with the message above. As far as I can see, the expected result is incorrect. If not, can someone please explain to me why that's the case. Thanks."
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\n\"b\"->\"a\" which is 1 step.  \n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\n\n\nThis is why \"ba\" and \"ab\" are not part of the shifting sequence.\nThe transition for \"b\" -> \"a\" is is 25 shifts  i.e. b to z and then a to b.\nThe transition for \"a\" -> \"b\" is 1 step.\n\nright now the question isn't well phrased."
                    },
                    {
                        "username": "housj1228",
                        "content": "You cannot get \\'ba\\' by simply shifting \\'ab\\'"
                    },
                    {
                        "username": "ybn4aq",
                        "content": "You guys really need to do a better job at properly describing the problem. In a real interview, the interviewee would be able to ask clarifying questions about the setup of the problem. This description is way too short, and doesn\\'t really explain that you\\'re able to shift backwards."
                    },
                    {
                        "username": "yanggao",
                        "content": "do we have to follow the ascending or descending sequence? \"acef\" is not continuous."
                    },
                    {
                        "username": "lanzhuoqin",
                        "content": "I got this failling:\\nInput\\nstrings =\\n[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\\nOutput\\n[[\"abc\",\"bcd\",\"xyz\"],[\"acef\"],[\"az\"],[\"ba\"],[\"a\",\"z\"]]\\nExpected\\n[[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\\n\\n\\nCan you tell me why [\"az\",\"ba\"] is right?\\n\\'a\\' -> \\'z\\' seems reverse sequence of \\'b\\' -> \\'a\\'"
                    },
                    {
                        "username": "dealth",
                        "content": "The 25th char after ```a``` is ```z```, and the 25th char after ```b``` is ```a``` noting that implicitly each word in the string is cyclic from this ```We can keep shifting the string to form a sequence.``` "
                    }
                ]
            },
            {
                "id": 1567932,
                "content": [
                    {
                        "username": "sherryxmhe",
                        "content": "I don't quite understand the question. Successive letter means in alphabet order or the next letter in the string. And is \"ba\" the result of shifting \"az\" to the right? And we can't shift \"az\" to the left because z is the last letter in the alphabet?"
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\\n\"b\"->\"a\" which is 1 step.  \\n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\\n\\nright now the question isn\\'t well phrased."
                    },
                    {
                        "username": "dav1de24",
                        "content": "There is no requirement to sort or order in any way the answers, yet you flag incorrect answers with a different order. Please make sure you ask the question correctly."
                    },
                    {
                        "username": "forgetboy",
                        "content": "Input:\\n[\"ab\",\"ba\"]\\n\\nOutput:\\n[[\"ab\",\"ba\"]]\\n\\nExpected:\\n[[\"ba\"],[\"ab\"]]\\n\\n\\nMy code submission is failing with the message above. As far as I can see, the expected result is incorrect. If not, can someone please explain to me why that's the case. Thanks."
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\n\"b\"->\"a\" which is 1 step.  \n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\n\n\nThis is why \"ba\" and \"ab\" are not part of the shifting sequence.\nThe transition for \"b\" -> \"a\" is is 25 shifts  i.e. b to z and then a to b.\nThe transition for \"a\" -> \"b\" is 1 step.\n\nright now the question isn't well phrased."
                    },
                    {
                        "username": "housj1228",
                        "content": "You cannot get \\'ba\\' by simply shifting \\'ab\\'"
                    },
                    {
                        "username": "ybn4aq",
                        "content": "You guys really need to do a better job at properly describing the problem. In a real interview, the interviewee would be able to ask clarifying questions about the setup of the problem. This description is way too short, and doesn\\'t really explain that you\\'re able to shift backwards."
                    },
                    {
                        "username": "yanggao",
                        "content": "do we have to follow the ascending or descending sequence? \"acef\" is not continuous."
                    },
                    {
                        "username": "lanzhuoqin",
                        "content": "I got this failling:\\nInput\\nstrings =\\n[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\\nOutput\\n[[\"abc\",\"bcd\",\"xyz\"],[\"acef\"],[\"az\"],[\"ba\"],[\"a\",\"z\"]]\\nExpected\\n[[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\\n\\n\\nCan you tell me why [\"az\",\"ba\"] is right?\\n\\'a\\' -> \\'z\\' seems reverse sequence of \\'b\\' -> \\'a\\'"
                    },
                    {
                        "username": "dealth",
                        "content": "The 25th char after ```a``` is ```z```, and the 25th char after ```b``` is ```a``` noting that implicitly each word in the string is cyclic from this ```We can keep shifting the string to form a sequence.``` "
                    }
                ]
            },
            {
                "id": 1958856,
                "content": [
                    {
                        "username": "sherryxmhe",
                        "content": "I don't quite understand the question. Successive letter means in alphabet order or the next letter in the string. And is \"ba\" the result of shifting \"az\" to the right? And we can't shift \"az\" to the left because z is the last letter in the alphabet?"
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\\n\"b\"->\"a\" which is 1 step.  \\n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\\n\\nright now the question isn\\'t well phrased."
                    },
                    {
                        "username": "dav1de24",
                        "content": "There is no requirement to sort or order in any way the answers, yet you flag incorrect answers with a different order. Please make sure you ask the question correctly."
                    },
                    {
                        "username": "forgetboy",
                        "content": "Input:\\n[\"ab\",\"ba\"]\\n\\nOutput:\\n[[\"ab\",\"ba\"]]\\n\\nExpected:\\n[[\"ba\"],[\"ab\"]]\\n\\n\\nMy code submission is failing with the message above. As far as I can see, the expected result is incorrect. If not, can someone please explain to me why that's the case. Thanks."
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\n\"b\"->\"a\" which is 1 step.  \n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\n\n\nThis is why \"ba\" and \"ab\" are not part of the shifting sequence.\nThe transition for \"b\" -> \"a\" is is 25 shifts  i.e. b to z and then a to b.\nThe transition for \"a\" -> \"b\" is 1 step.\n\nright now the question isn't well phrased."
                    },
                    {
                        "username": "housj1228",
                        "content": "You cannot get \\'ba\\' by simply shifting \\'ab\\'"
                    },
                    {
                        "username": "ybn4aq",
                        "content": "You guys really need to do a better job at properly describing the problem. In a real interview, the interviewee would be able to ask clarifying questions about the setup of the problem. This description is way too short, and doesn\\'t really explain that you\\'re able to shift backwards."
                    },
                    {
                        "username": "yanggao",
                        "content": "do we have to follow the ascending or descending sequence? \"acef\" is not continuous."
                    },
                    {
                        "username": "lanzhuoqin",
                        "content": "I got this failling:\\nInput\\nstrings =\\n[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\\nOutput\\n[[\"abc\",\"bcd\",\"xyz\"],[\"acef\"],[\"az\"],[\"ba\"],[\"a\",\"z\"]]\\nExpected\\n[[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\\n\\n\\nCan you tell me why [\"az\",\"ba\"] is right?\\n\\'a\\' -> \\'z\\' seems reverse sequence of \\'b\\' -> \\'a\\'"
                    },
                    {
                        "username": "dealth",
                        "content": "The 25th char after ```a``` is ```z```, and the 25th char after ```b``` is ```a``` noting that implicitly each word in the string is cyclic from this ```We can keep shifting the string to form a sequence.``` "
                    }
                ]
            },
            {
                "id": 1571492,
                "content": [
                    {
                        "username": "sherryxmhe",
                        "content": "I don't quite understand the question. Successive letter means in alphabet order or the next letter in the string. And is \"ba\" the result of shifting \"az\" to the right? And we can't shift \"az\" to the left because z is the last letter in the alphabet?"
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\\n\"b\"->\"a\" which is 1 step.  \\n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\\n\\nright now the question isn\\'t well phrased."
                    },
                    {
                        "username": "dav1de24",
                        "content": "There is no requirement to sort or order in any way the answers, yet you flag incorrect answers with a different order. Please make sure you ask the question correctly."
                    },
                    {
                        "username": "forgetboy",
                        "content": "Input:\\n[\"ab\",\"ba\"]\\n\\nOutput:\\n[[\"ab\",\"ba\"]]\\n\\nExpected:\\n[[\"ba\"],[\"ab\"]]\\n\\n\\nMy code submission is failing with the message above. As far as I can see, the expected result is incorrect. If not, can someone please explain to me why that's the case. Thanks."
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\n\"b\"->\"a\" which is 1 step.  \n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\n\n\nThis is why \"ba\" and \"ab\" are not part of the shifting sequence.\nThe transition for \"b\" -> \"a\" is is 25 shifts  i.e. b to z and then a to b.\nThe transition for \"a\" -> \"b\" is 1 step.\n\nright now the question isn't well phrased."
                    },
                    {
                        "username": "housj1228",
                        "content": "You cannot get \\'ba\\' by simply shifting \\'ab\\'"
                    },
                    {
                        "username": "ybn4aq",
                        "content": "You guys really need to do a better job at properly describing the problem. In a real interview, the interviewee would be able to ask clarifying questions about the setup of the problem. This description is way too short, and doesn\\'t really explain that you\\'re able to shift backwards."
                    },
                    {
                        "username": "yanggao",
                        "content": "do we have to follow the ascending or descending sequence? \"acef\" is not continuous."
                    },
                    {
                        "username": "lanzhuoqin",
                        "content": "I got this failling:\\nInput\\nstrings =\\n[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\\nOutput\\n[[\"abc\",\"bcd\",\"xyz\"],[\"acef\"],[\"az\"],[\"ba\"],[\"a\",\"z\"]]\\nExpected\\n[[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\\n\\n\\nCan you tell me why [\"az\",\"ba\"] is right?\\n\\'a\\' -> \\'z\\' seems reverse sequence of \\'b\\' -> \\'a\\'"
                    },
                    {
                        "username": "dealth",
                        "content": "The 25th char after ```a``` is ```z```, and the 25th char after ```b``` is ```a``` noting that implicitly each word in the string is cyclic from this ```We can keep shifting the string to form a sequence.``` "
                    }
                ]
            },
            {
                "id": 2004946,
                "content": [
                    {
                        "username": "sherryxmhe",
                        "content": "I don't quite understand the question. Successive letter means in alphabet order or the next letter in the string. And is \"ba\" the result of shifting \"az\" to the right? And we can't shift \"az\" to the left because z is the last letter in the alphabet?"
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\\n\"b\"->\"a\" which is 1 step.  \\n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\\n\\nright now the question isn\\'t well phrased."
                    },
                    {
                        "username": "dav1de24",
                        "content": "There is no requirement to sort or order in any way the answers, yet you flag incorrect answers with a different order. Please make sure you ask the question correctly."
                    },
                    {
                        "username": "forgetboy",
                        "content": "Input:\\n[\"ab\",\"ba\"]\\n\\nOutput:\\n[[\"ab\",\"ba\"]]\\n\\nExpected:\\n[[\"ba\"],[\"ab\"]]\\n\\n\\nMy code submission is failing with the message above. As far as I can see, the expected result is incorrect. If not, can someone please explain to me why that's the case. Thanks."
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\n\"b\"->\"a\" which is 1 step.  \n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\n\n\nThis is why \"ba\" and \"ab\" are not part of the shifting sequence.\nThe transition for \"b\" -> \"a\" is is 25 shifts  i.e. b to z and then a to b.\nThe transition for \"a\" -> \"b\" is 1 step.\n\nright now the question isn't well phrased."
                    },
                    {
                        "username": "housj1228",
                        "content": "You cannot get \\'ba\\' by simply shifting \\'ab\\'"
                    },
                    {
                        "username": "ybn4aq",
                        "content": "You guys really need to do a better job at properly describing the problem. In a real interview, the interviewee would be able to ask clarifying questions about the setup of the problem. This description is way too short, and doesn\\'t really explain that you\\'re able to shift backwards."
                    },
                    {
                        "username": "yanggao",
                        "content": "do we have to follow the ascending or descending sequence? \"acef\" is not continuous."
                    },
                    {
                        "username": "lanzhuoqin",
                        "content": "I got this failling:\\nInput\\nstrings =\\n[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\\nOutput\\n[[\"abc\",\"bcd\",\"xyz\"],[\"acef\"],[\"az\"],[\"ba\"],[\"a\",\"z\"]]\\nExpected\\n[[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\\n\\n\\nCan you tell me why [\"az\",\"ba\"] is right?\\n\\'a\\' -> \\'z\\' seems reverse sequence of \\'b\\' -> \\'a\\'"
                    },
                    {
                        "username": "dealth",
                        "content": "The 25th char after ```a``` is ```z```, and the 25th char after ```b``` is ```a``` noting that implicitly each word in the string is cyclic from this ```We can keep shifting the string to form a sequence.``` "
                    }
                ]
            }
        ]
    }
]