[
    {
        "title": "Maximum Deletions on a String",
        "question_content": "You are given a string s consisting of only lowercase English letters. In one operation, you can:\n\n\tDelete the entire string s, or\n\tDelete the first i letters of s if the first i letters of s are equal to the following i letters in s, for any i in the range 1 <= i <= s.length / 2.\n\nFor example, if s = \"ababc\", then in one operation, you could delete the first two letters of s to get \"abc\", since the first two letters of s and the following two letters of s are both equal to \"ab\".\nReturn the maximum number of operations needed to delete all of s.\n&nbsp;\nExample 1:\n\nInput: s = \"abcabcdabc\"\nOutput: 2\nExplanation:\n- Delete the first 3 letters (\"abc\") since the next 3 letters are equal. Now, s = \"abcdabc\".\n- Delete all the letters.\nWe used 2 operations so return 2. It can be proven that 2 is the maximum number of operations needed.\nNote that in the second operation we cannot delete \"abc\" again because the next occurrence of \"abc\" does not happen in the next 3 letters.\n\nExample 2:\n\nInput: s = \"aaabaab\"\nOutput: 4\nExplanation:\n- Delete the first letter (\"a\") since the next letter is equal. Now, s = \"aabaab\".\n- Delete the first 3 letters (\"aab\") since the next 3 letters are equal. Now, s = \"aab\".\n- Delete the first letter (\"a\") since the next letter is equal. Now, s = \"ab\".\n- Delete all the letters.\nWe used 4 operations so return 4. It can be proven that 4 is the maximum number of operations needed.\n\nExample 3:\n\nInput: s = \"aaaaa\"\nOutput: 5\nExplanation: In each operation, we can delete the first letter of s.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 4000\n\ts consists only of lowercase English letters.",
        "solutions": [
            {
                "id": 2648900,
                "title": "java-c-python-dp-solution",
                "content": "# **Explanation**\\n`lcs[i][j]` means the length of the longest common substring.\\nIf `lcs[i][j] = k`,\\nthen `s.substring(i, i + k) == s.substring(j, j + k)`\\nand `s.substring(i, i + k + 1) != s.substring(j, j + k + 1)`.\\nThis can be done in `O(n^2)`.\\n\\n\\n`dp[i]` mean the the maximum number of operations to delete\\nthe substring starting at `s[i]`.\\n\\nIf `lcs[i][j] >= j - i`,\\n`s.substring(i, j) == s.substring(j, j + j - i)`\\nthis means we can delete the prefix `s.substring(i, j)` from `s.substring(i)`,\\nand it changes to `s.substring(j)`.\\nAnd we update `dp[i] = max(dp[i], dp[j] + 1)`\\n<br>\\n\\n# **Complexity**\\nTime `O(n^2)`\\nSpace `O(n^2)`\\n<br>\\n\\n**Java**\\n```java\\n    public int deleteString(String s) {\\n        int n = s.length();\\n        int[][] lcs = new int[n + 1][n + 1];\\n        int[] dp = new int[n];\\n        for (int i = n - 1; i >= 0; --i) {\\n            lcs[i] = new int[n + 1];\\n            dp[i] = 1;\\n            for (int j = i + 1; j < n; ++j) {\\n                if (s.charAt(i) == s.charAt(j))\\n                    lcs[i][j] = lcs[i + 1][j + 1] + 1;\\n                if (lcs[i][j] >= j - i)\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        return dp[0];\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int deleteString(string s) {\\n        int n = s.size();\\n        vector<vector<int>> lcs(n + 1, vector<int>(n + 1, 0));\\n        vector<int> dp(n, 1);\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (s[i] == s[j])\\n                    lcs[i][j] = lcs[i + 1][j + 1] + 1;\\n                if (lcs[i][j] >= j - i)\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        return dp[0];\\n    }\\n```\\n\\n**Python**\\n```py\\n    def deleteString(self, s):\\n        n = len(s)\\n\\t\\tif (len(set(s)) == 1): return n\\n        lcs = [[0] * (n + 1) for i in range(n + 1)]\\n        dp = [1] * n\\n        for i in range(n-1, -1, -1):\\n            for j in range(i + 1, n):\\n                if s[i] == s[j]:\\n                    lcs[i][j] = lcs[i + 1][j + 1] + 1\\n                if lcs[i][j] >= j - i:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n        return dp[0]\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int deleteString(String s) {\\n        int n = s.length();\\n        int[][] lcs = new int[n + 1][n + 1];\\n        int[] dp = new int[n];\\n        for (int i = n - 1; i >= 0; --i) {\\n            lcs[i] = new int[n + 1];\\n            dp[i] = 1;\\n            for (int j = i + 1; j < n; ++j) {\\n                if (s.charAt(i) == s.charAt(j))\\n                    lcs[i][j] = lcs[i + 1][j + 1] + 1;\\n                if (lcs[i][j] >= j - i)\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        return dp[0];\\n    }\\n```\n```cpp\\n    int deleteString(string s) {\\n        int n = s.size();\\n        vector<vector<int>> lcs(n + 1, vector<int>(n + 1, 0));\\n        vector<int> dp(n, 1);\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (s[i] == s[j])\\n                    lcs[i][j] = lcs[i + 1][j + 1] + 1;\\n                if (lcs[i][j] >= j - i)\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        return dp[0];\\n    }\\n```\n```py\\n    def deleteString(self, s):\\n        n = len(s)\\n\\t\\tif (len(set(s)) == 1): return n\\n        lcs = [[0] * (n + 1) for i in range(n + 1)]\\n        dp = [1] * n\\n        for i in range(n-1, -1, -1):\\n            for j in range(i + 1, n):\\n                if s[i] == s[j]:\\n                    lcs[i][j] = lcs[i + 1][j + 1] + 1\\n                if lcs[i][j] >= j - i:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n        return dp[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2648927,
                "title": "top-down-pruning-vs-bottom-up-lps",
                "content": "#### Top-Down (Pruning)\\nThis solution is O(n ^ 3) in the worst case. However, we can beat the worst case by pruning, and it\\'s AC with 80 ms runtime.\\n\\nWe know that for a substring of size `m`, we can get maximum `m` deletions.\\n\\nTherefore, we can prune our search when our best running score (`dp[i]`) exceeds the number of remaining characters. Which helps greatly with cases like `aaaaa....`\\n\\n**C++**\\n```cpp\\nint dp[40000] = {};\\nint deleteString(string &s, int i = 0) {\\n    if (dp[i] == 0) {\\n        dp[i] = 1;\\n        for (int len = 1; dp[i] <= s.size() - i - len; ++len)\\n            if (s.compare(i, len, s, i + len, len) == 0)\\n                dp[i] = max(dp[i], 1 + deleteString(s, i + len));\\n    }\\n    return dp[i];\\n}\\n```\\n\\n#### Bottom-Up (Longest Prefix Suffix)\\nThis solution is O(n ^ 2) - we use LPS to check for the repeated prefix in O(1). In practice, it\\'s a bit slower than the solution above, as we need to extra time to compute LPS.\\n\\nFor each starting position, compute LPS. This allow us to compare 2 prefixes of size `len` in O(1): `lps[len * 2 - 1] == len`.\\n\\n> LPS is used in algorithms like KMP. Search for KMP videos to learn about LPS.\\n\\nOne positive side-effect of using KMP is that it only check the smallest of repeating patterns, which works for this problem. \\n\\nFor example, for strings like `ababababab...`, it will check `ab`, but not `abab`. However, if we the string looks like `ababcababcab...`, it will check both \"ab\" and \"ababc\".\\n\\n**C++**\\n```cpp\\nint dp[4000], lps[4000];\\nint deleteString(string s) {\\n    for (int k = s.size() - 1; k >= 0; --k) {\\n        dp[k] = 1; \\n        for (int i = 1, j = 0; dp[k] <= s.size() - i - k + 1; ++i) {\\n            while (j && s[i + k] != s[j + k])\\n                j = max(0, lps[j] - 1);\\n            j += s[i + k] == s[j + k];\\n            lps[i] = j;\\n            if (i % 2) {\\n                int len = (i + 1) / 2;\\n                if (lps[len * 2 - 1] == len)\\n                    dp[k] = max(dp[k], 1 + dp[k + len]);   \\n                    \\n            }\\n        }\\n    }\\n    return dp[0];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dp[40000] = {};\\nint deleteString(string &s, int i = 0) {\\n    if (dp[i] == 0) {\\n        dp[i] = 1;\\n        for (int len = 1; dp[i] <= s.size() - i - len; ++len)\\n            if (s.compare(i, len, s, i + len, len) == 0)\\n                dp[i] = max(dp[i], 1 + deleteString(s, i + len));\\n    }\\n    return dp[i];\\n}\\n```\n```cpp\\nint dp[4000], lps[4000];\\nint deleteString(string s) {\\n    for (int k = s.size() - 1; k >= 0; --k) {\\n        dp[k] = 1; \\n        for (int i = 1, j = 0; dp[k] <= s.size() - i - k + 1; ++i) {\\n            while (j && s[i + k] != s[j + k])\\n                j = max(0, lps[j] - 1);\\n            j += s[i + k] == s[j + k];\\n            lps[i] = j;\\n            if (i % 2) {\\n                int len = (i + 1) / 2;\\n                if (lps[len * 2 - 1] == len)\\n                    dp[k] = max(dp[k], 1 + dp[k + len]);   \\n                    \\n            }\\n        }\\n    }\\n    return dp[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648704,
                "title": "python-easy-backtracking",
                "content": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n=len(s)\\n        @cache\\n        def btrack(i):\\n            if i==n:\\n                return 0\\n            ans=1\\n            j=1\\n            while i+2*j<=n and n-i-j+1>ans:\\n                if s[i:i+j]==s[i+j:i+2*j]:\\n                    ans=max(ans,1+btrack(i+j))\\n                j+=1\\n            return ans\\n        return btrack(0)",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n=len(s)\\n        @cache\\n        def btrack(i):\\n            if i==n:\\n                return 0\\n            ans=1\\n            j=1\\n            while i+2*j<=n and n-i-j+1>ans:\\n                if s[i:i+j]==s[i+j:i+2*j]:\\n                    ans=max(ans,1+btrack(i+j))\\n                j+=1\\n            return ans\\n        return btrack(0)",
                "codeTag": "Java"
            },
            {
                "id": 2648731,
                "title": "java-longest-prefix-suffix-solution-explained-o-n-2",
                "content": "**Intuition:**\\nQuestion is a combination of precomputation step of KMP algorithm and dynamic programming.\\n\\n**Naive DP**\\ndp[i] represents maximum deletion on a substring starting from ith character.\\n*e.g.*  if s = \"abcabcdabc\" \\ndp[3] represents maximum deletion on substring \"abcdabc\".\\n\\n***Recurrence relation:***\\ndp[i] = *canBeDeleted*(str[i ... j-1]) + dp[i + j]\\nwhere str[i ... j-1] represents substring from ith to j-1th index.\\n\\n```\\npublic int deleteString(String s) {\\n\\tint n = s.length();\\n\\tint[] dp = new int[n];\\n\\tdp[n-1] = 1;\\n\\tfor (int i = n - 2; i >= 0; i--) { //O(N)\\n\\t\\tdp[i] = 1;\\n\\t\\tfor (int j = 1; j <= (n - i) / 2; j++) { //O(N)\\n\\t\\t\\tString firstStr = s.substring(i, i + j); //O(N)\\n\\t\\t\\tString secondStr = s.substring(i + j, i + j + j);\\n\\t\\t\\tif (firstStr.equals(secondStr)) {\\n\\t\\t\\t\\tdp[i] = Math.max(dp[i], 1 + dp[i + j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0];\\n}\\n```\\n\\nRuntime: O(N ^ 3)\\nIt is not fast enough and will TLE. Notice that checking` first i letters equal to following i letters` takes O(N ^ 2) time and can be drastically improved.\\n\\n**Longest Prefix Suffix DP**\\nTherefore, you need to check ` first i letters equal to following i letters` in O(N) time. Total runtime of O(N ^ 2) is needed to pass cases.\\n\\nYou will need to *precompute* the longest prefix suffix array that is commonly used in Knuth-Morris Pratt algorithm. It calculates the longest prefix that is equal to suffix for each substring [0 ... i]. *Check link below for resource on KMP.*\\n\\n\\n***Example Format:***\\nFor examples, I will be showing them in the following format, `index` followed by `character` followed by `longest prefix suffix value`.\\n*e.g.*\\n*1 2 3 4 5 6 7 8* \\n**a b c** d e **a b c**\\n0 0 0 0 0 1 2 3\\n\\n***Explanation:***\\nTo use the longest prefix suffix array for this question, you will have to check that the prefix and suffix are right besides each other, which would satisfy ` first i letters equal to following i letters`.\\n\\n1. Check that `j / 2 == prefix[j]`, where j is index and prefix[j] is longest prefix suffix value.\\n*e.g.*\\n*1 2 3 4 5 6* \\na b c **a b c**\\n0 0 0 1 2 3\\n\\n2. Check that j is **even**, as previous conditional alone does not account for following edge case.\\n*e.g.*\\n*1 2 3 4 5 6 7* \\na b c  d **a b c**\\n0 0 0 0 1 2 3\\n\\n```\\nclass Solution {\\n    public int deleteString(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        dp[n-1] = 1;\\n        for (int i = n - 2; i >= 0; i--) { //O(N)\\n            dp[i] = 1;\\n            int[] prefix = calcPrefixLen(s.substring(i, n)); // O(N)\\n            for (int j = 1; j < prefix.length; j++) { // O(N)\\n                if (j % 2 == 0 && j / 2 == prefix[j]) {\\n                    dp[i] = Math.max(dp[i], 1 + dp[i + prefix[j]]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n    \\n\\t// Acknowledgement: https://bitbucket.org/StableSort/play/src/master/src/com/stablesort/stringmatch/KnuthMorrisPratt.java\\n    public int[] calcPrefixLen(String pattern) {\\n\\t\\tint patternLen = pattern.length();\\n\\t\\tint[] ar = new int[patternLen + 1];\\n\\t\\tar[0] = -1;\\n\\t\\tar[1] = 0;\\n\\n\\t\\tint prefixLen = 0;\\n\\t\\tint i = 1;\\n\\t\\t\\n\\t\\twhile (i < patternLen) {\\t\\t\\t\\n\\t\\t\\tif (pattern.charAt(prefixLen) == pattern.charAt(i)) { \\n\\t\\t\\t\\tprefixLen++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tar[i] = prefixLen;\\n\\t\\t\\t\\t\\n\\t\\t\\t} else if (prefixLen > 0) {\\n\\t\\t\\t\\tprefixLen = ar[prefixLen]; // note  that we do not increment i here\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tar[i] = 0; // \\'prefixLen\\' reached 0, so save that into ar[] and move forward\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ar;\\n\\t}\\n}\\n```\\n\\nGood resource for KMP which I used to understand:\\nhttps://www.youtube.com/watch?v=EL4ZbRF587g&t=390s&ab_channel=StableSort\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int deleteString(String s) {\\n\\tint n = s.length();\\n\\tint[] dp = new int[n];\\n\\tdp[n-1] = 1;\\n\\tfor (int i = n - 2; i >= 0; i--) { //O(N)\\n\\t\\tdp[i] = 1;\\n\\t\\tfor (int j = 1; j <= (n - i) / 2; j++) { //O(N)\\n\\t\\t\\tString firstStr = s.substring(i, i + j); //O(N)\\n\\t\\t\\tString secondStr = s.substring(i + j, i + j + j);\\n\\t\\t\\tif (firstStr.equals(secondStr)) {\\n\\t\\t\\t\\tdp[i] = Math.max(dp[i], 1 + dp[i + j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0];\\n}\\n```\n```\\nclass Solution {\\n    public int deleteString(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        dp[n-1] = 1;\\n        for (int i = n - 2; i >= 0; i--) { //O(N)\\n            dp[i] = 1;\\n            int[] prefix = calcPrefixLen(s.substring(i, n)); // O(N)\\n            for (int j = 1; j < prefix.length; j++) { // O(N)\\n                if (j % 2 == 0 && j / 2 == prefix[j]) {\\n                    dp[i] = Math.max(dp[i], 1 + dp[i + prefix[j]]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n    \\n\\t// Acknowledgement: https://bitbucket.org/StableSort/play/src/master/src/com/stablesort/stringmatch/KnuthMorrisPratt.java\\n    public int[] calcPrefixLen(String pattern) {\\n\\t\\tint patternLen = pattern.length();\\n\\t\\tint[] ar = new int[patternLen + 1];\\n\\t\\tar[0] = -1;\\n\\t\\tar[1] = 0;\\n\\n\\t\\tint prefixLen = 0;\\n\\t\\tint i = 1;\\n\\t\\t\\n\\t\\twhile (i < patternLen) {\\t\\t\\t\\n\\t\\t\\tif (pattern.charAt(prefixLen) == pattern.charAt(i)) { \\n\\t\\t\\t\\tprefixLen++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tar[i] = prefixLen;\\n\\t\\t\\t\\t\\n\\t\\t\\t} else if (prefixLen > 0) {\\n\\t\\t\\t\\tprefixLen = ar[prefixLen]; // note  that we do not increment i here\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tar[i] = 0; // \\'prefixLen\\' reached 0, so save that into ar[] and move forward\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ar;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649459,
                "title": "kmp-and-dp-o-n-2",
                "content": "* Record all the length of identical current and following string length for all index i.\\n* This can be done in O(N) using KMP\\'s LPS calculation method.\\n* Now Basic Knapsack Dp can be used to find maximum deletion of strings.\\n```\\nclass Solution {\\n    List<Integer>[] al;\\n\\n    public int deleteString(String s) {\\n        this.al = new ArrayList[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            String sub = s.substring(i);\\n            al[i] = KMP(sub);\\n        }\\n        this.dp = new int[s.length() + 1];\\n        Arrays.fill(dp, -1);\\n        return solve(0, s.length());\\n    }\\n\\n    int dp[];\\n\\n    private int solve(int i, int n) {\\n        if (i >= n) return 0;\\n        if (al[i].size() == 0) return 1;\\n        if (dp[i] != -1) return dp[i];\\n        int ans = 0;\\n        for (int next : al[i]) {\\n            ans = Math.max(ans, 1 + solve(i + next, n));\\n        }\\n        return dp[i] = ans;\\n    }\\n\\n    private List<Integer> KMP(String s) {\\n        int LPS[] = new int[s.length()];\\n        for (int i = 1; i < s.length(); i++) {\\n            int j = LPS[i - 1];\\n            while (j > 0 && s.charAt(j) != s.charAt(i)) j = LPS[j - 1];\\n            if (s.charAt(i) == s.charAt(j)) j++;\\n            LPS[i] = j;\\n        }\\n        List<Integer> al = new ArrayList<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i - LPS[i] + 1 == LPS[i]) al.add(LPS[i]);\\n        }\\n        return al;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer>[] al;\\n\\n    public int deleteString(String s) {\\n        this.al = new ArrayList[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            String sub = s.substring(i);\\n            al[i] = KMP(sub);\\n        }\\n        this.dp = new int[s.length() + 1];\\n        Arrays.fill(dp, -1);\\n        return solve(0, s.length());\\n    }\\n\\n    int dp[];\\n\\n    private int solve(int i, int n) {\\n        if (i >= n) return 0;\\n        if (al[i].size() == 0) return 1;\\n        if (dp[i] != -1) return dp[i];\\n        int ans = 0;\\n        for (int next : al[i]) {\\n            ans = Math.max(ans, 1 + solve(i + next, n));\\n        }\\n        return dp[i] = ans;\\n    }\\n\\n    private List<Integer> KMP(String s) {\\n        int LPS[] = new int[s.length()];\\n        for (int i = 1; i < s.length(); i++) {\\n            int j = LPS[i - 1];\\n            while (j > 0 && s.charAt(j) != s.charAt(i)) j = LPS[j - 1];\\n            if (s.charAt(i) == s.charAt(j)) j++;\\n            LPS[i] = j;\\n        }\\n        List<Integer> al = new ArrayList<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i - LPS[i] + 1 == LPS[i]) al.add(LPS[i]);\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648717,
                "title": "c-kmp-dp",
                "content": "**updated code**\\n```\\nclass Solution {\\npublic:\\n    \\n    // kmp\\n    vector<int> prefix_function(string s) {\\n        int n = (int)s.length();\\n        vector<int> pi(n);\\n        for (int i = 1; i < n; i++) {\\n            int j = pi[i-1];\\n            while (j > 0 && s[i] != s[j])\\n                j = pi[j-1];\\n            if (s[i] == s[j])\\n                j++;\\n            pi[i] = j;\\n        }\\n        return pi;\\n    }\\n    \\n    \\n    // dp\\n    int dp[4100];\\n    \\n    \\n    int helper(string s){\\n        int m = s.size();\\n        \\n        \\n        // dp memo\\n        if(dp[m]!=-1){\\n            return dp[m];\\n        }\\n        vector<int> prefix = prefix_function(s);\\n        bool check = false;\\n        int ans = 0;\\n        for(int j = 1 ; j < m ; j++){\\n            \\n            // checking if prefix[i] == half of length of string s at that particular time\\n            int val = (j+1)/2;\\n            if(j%2==1 and prefix[j] == val){\\n                check = true;\\n                ans = max(ans,1+helper(s.substr(prefix[j])));\\n            }\\n        }\\n            \\n        \\n        // if no prefix found in string s\\n        if(check==false){\\n            return 1;\\n        }\\n        return dp[m] = ans;\\n    }\\n    \\n    \\n    int deleteString(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // kmp\\n    vector<int> prefix_function(string s) {\\n        int n = (int)s.length();\\n        vector<int> pi(n);\\n        for (int i = 1; i < n; i++) {\\n            int j = pi[i-1];\\n            while (j > 0 && s[i] != s[j])\\n                j = pi[j-1];\\n            if (s[i] == s[j])\\n                j++;\\n            pi[i] = j;\\n        }\\n        return pi;\\n    }\\n    \\n    \\n    // dp\\n    int dp[4100];\\n    \\n    \\n    int helper(string s){\\n        int m = s.size();\\n        \\n        \\n        // dp memo\\n        if(dp[m]!=-1){\\n            return dp[m];\\n        }\\n        vector<int> prefix = prefix_function(s);\\n        bool check = false;\\n        int ans = 0;\\n        for(int j = 1 ; j < m ; j++){\\n            \\n            // checking if prefix[i] == half of length of string s at that particular time\\n            int val = (j+1)/2;\\n            if(j%2==1 and prefix[j] == val){\\n                check = true;\\n                ans = max(ans,1+helper(s.substr(prefix[j])));\\n            }\\n        }\\n            \\n        \\n        // if no prefix found in string s\\n        if(check==false){\\n            return 1;\\n        }\\n        return dp[m] = ans;\\n    }\\n    \\n    \\n    int deleteString(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648713,
                "title": "memoized-recursion-c-string-view-optimization-short-commented-very-fast",
                "content": "Memoized recursion.  Use string_view for faster substr (O(1)).  EDIT: added a tail optimization to skip a substring of same characters at the end.  This dramatically reduces the run time, at least for these test cases (currently 180ms).\\n\\n```\\nclass Solution {\\nprivate:\\n        vector<int> dp;  // memo for recursion, dp[i] is the answer if we started at index i.\\n        int n;           // size of input\\npublic:\\n    int find(string_view sv, int pos=0) {\\n        if (dp[pos]>0) return dp[pos];                  // memoized already\\n        int ans=1;                                      // there\\'s at least one way always!\\n        for (int i=1; i<=(n-pos)/2; i++) {\\n            if (sv.substr(pos,i)==sv.substr(pos+i,i))   // we can delete the first i characters so\\n                ans=max(ans, 1+find(sv, pos+i));        // recurse from pos+i position\\n        }\\n        dp[pos]=ans;                                    // memoize the answer\\n        return ans;\\n    } \\n\\n\\tvoid optimize_tail(const string& s) {         // if the string ends in a tail of same char\\n        int k=n-1;                         // we can precompute the answers for those positions\\n        while (k>0 && s[k]==s[k-1]) --k;\\n        for (int i=k+1; i<n; i++) dp[i]=n-i;\\n    }\\n\\t\\n    int deleteString(string s) {    \\n        n=s.size();\\n        dp.resize(n+1);\\n\\t\\toptimize_tail(s);                \\n        string_view sv ({s.c_str(), s.size()});  // for O(1) substring view\\n        return find(sv, 0);\\n   }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n        vector<int> dp;  // memo for recursion, dp[i] is the answer if we started at index i.\\n        int n;           // size of input\\npublic:\\n    int find(string_view sv, int pos=0) {\\n        if (dp[pos]>0) return dp[pos];                  // memoized already\\n        int ans=1;                                      // there\\'s at least one way always!\\n        for (int i=1; i<=(n-pos)/2; i++) {\\n            if (sv.substr(pos,i)==sv.substr(pos+i,i))   // we can delete the first i characters so\\n                ans=max(ans, 1+find(sv, pos+i));        // recurse from pos+i position\\n        }\\n        dp[pos]=ans;                                    // memoize the answer\\n        return ans;\\n    } \\n\\n\\tvoid optimize_tail(const string& s) {         // if the string ends in a tail of same char\\n        int k=n-1;                         // we can precompute the answers for those positions\\n        while (k>0 && s[k]==s[k-1]) --k;\\n        for (int i=k+1; i<n; i++) dp[i]=n-i;\\n    }\\n\\t\\n    int deleteString(string s) {    \\n        n=s.size();\\n        dp.resize(n+1);\\n\\t\\toptimize_tail(s);                \\n        string_view sv ({s.c_str(), s.size()});  // for O(1) substring view\\n        return find(sv, 0);\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648661,
                "title": "python3-dynamic-programming-clean-concise",
                "content": "We define a `dp` array, where `dp[i]` represents *the **maximum** number of operations needed to delete all of* `s[i:]`.\\nWe optimize the solution by checking if `s` contains only one unique character - in this case, we return `len(s)`.\\n\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        if len(set(s)) == 1:\\n            return n\\n        dp = [1] * n\\n        for i in range(n - 2, -1, -1):\\n            for l in range(1, (n - i) // 2 + 1):\\n                if s[i : i + l] == s[i + l : i + 2 * l]:\\n                    dp[i] = max(dp[i], 1 + dp[i + l])\\n        return dp[0]\\n```\\n\\n**Remark:** We can further optimize the solution by trimming more paths in the process of dynamic programming. \\nSpecifically, we define an `M` array, where `M[i]` represent the *the **maximum** number of operations needed to delete* among all suffix substrings that start at or after `i`.\\n\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        if len(set(s)) == 1:\\n            return n\\n        dp, M = [1] * n, [1] * n\\n        for i in range(n - 2, -1, -1):\\n            for l in range(1, (n - i) // 2 + 1):\\n                if dp[i] >= M[i + l] + 1:\\n                    break\\n                if s[i : i + l] == s[i + l : i + 2 * l]:\\n                    dp[i] = max(dp[i], 1 + dp[i + l])\\n            M[i] = max(dp[i], M[i + 1])\\n        return dp[0]\\n```\\n\\n**Final Remark:** Python is very good at string slicing, which runs fast enough to pass during [LC Contest 313](https://leetcode.com/contest/weekly-contest-313/). For another solution to this problem (with theoretically better time complexity), please see the one and only @lee215\\'s [post](https://leetcode.com/problems/maximum-deletions-on-a-string/discuss/2648900/JavaC%2B%2BPython-DP-Solution).",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        if len(set(s)) == 1:\\n            return n\\n        dp = [1] * n\\n        for i in range(n - 2, -1, -1):\\n            for l in range(1, (n - i) // 2 + 1):\\n                if s[i : i + l] == s[i + l : i + 2 * l]:\\n                    dp[i] = max(dp[i], 1 + dp[i + l])\\n        return dp[0]\\n```\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        if len(set(s)) == 1:\\n            return n\\n        dp, M = [1] * n, [1] * n\\n        for i in range(n - 2, -1, -1):\\n            for l in range(1, (n - i) // 2 + 1):\\n                if dp[i] >= M[i + l] + 1:\\n                    break\\n                if s[i : i + l] == s[i + l : i + 2 * l]:\\n                    dp[i] = max(dp[i], 1 + dp[i + l])\\n            M[i] = max(dp[i], M[i + 1])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648909,
                "title": "java-dp-memorization",
                "content": "```\\nclass Solution {\\n    Integer[] dp;\\n    public int deleteString(String s) {\\n        dp = new Integer[s.length()];\\n        return helper(s , 0);\\n        \\n    }\\n    \\n    public int helper(String s , int index){\\n        if(index == s.length()) return 0;\\n        if(dp[index] != null) return dp[index];\\n        \\n        int res = 0;\\n        boolean found = false;\\n        for(int i = index; i < index + (s.length() - index)/2 ; i++){\\n            if(dp[i] == null){\\n                String a = s.substring(index , i + 1);\\n                String b = s.substring(i + 1 , i + 1 + (i - index + 1));\\n                if(a.equals(b)){\\n                    found = true;\\n                    res = Math.max(res , 1 + helper(s , i + 1));\\n                }\\n            }\\n        }\\n        if(!found)\\n            return dp[index] = 1;\\n        return dp[index] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer[] dp;\\n    public int deleteString(String s) {\\n        dp = new Integer[s.length()];\\n        return helper(s , 0);\\n        \\n    }\\n    \\n    public int helper(String s , int index){\\n        if(index == s.length()) return 0;\\n        if(dp[index] != null) return dp[index];\\n        \\n        int res = 0;\\n        boolean found = false;\\n        for(int i = index; i < index + (s.length() - index)/2 ; i++){\\n            if(dp[i] == null){\\n                String a = s.substring(index , i + 1);\\n                String b = s.substring(i + 1 , i + 1 + (i - index + 1));\\n                if(a.equals(b)){\\n                    found = true;\\n                    res = Math.max(res , 1 + helper(s , i + 1));\\n                }\\n            }\\n        }\\n        if(!found)\\n            return dp[index] = 1;\\n        return dp[index] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653503,
                "title": "video-explanation-with-intuition-of-every-step",
                "content": "https://www.youtube.com/watch?v=EWqHdeTz5Tc",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=EWqHdeTz5Tc",
                "codeTag": "Unknown"
            },
            {
                "id": 2652816,
                "title": "java-dp-hash-100-time-100-space-explained",
                "content": "The idea is learnt from  [@yxc](https://leetcode.cn/u/acvv_cxy/). And here is his [video](https://www.bilibili.com/video/BV16g411a7t6/?spm_id_from=333.999.0.0&vd_source=1e76c6792d63c37f5b33ade7d74b6a87)\\u3002\\n\\n### Idea\\n+ dp definition: `dp[i]`, answer of substring `str[i, n)` \\n+ dp answer : `dp[0]`\\n+ dp boundary condition: `dp[n] = 0` (empty string)\\n+ dp transition : `dp[i] = max(1, dp[i + len] + 1)`  for valid  `len` (can cut)\\n![image](https://assets.leetcode.com/users/images/0383e426-e668-4c6d-a8b9-1e09c3d83516_1664751954.5727713.png)\\n\\n---\\nTo quickly check if two substrings are same, using **string hash preparation** in O(n). \\nIt is basically generate **prefix sum array of string version**.\\n\\n### Code\\n```java\\nclass Solution {\\n    int base = 131;\\n    long[] p; // power of base\\n    long[] h; // hash value\\n    \\n    private long get(int l, int r) {\\n        return h[r] - h[l - 1] * p[r - l + 1];\\n    }\\n    \\n    public int deleteString(String s) {\\n        int n = s.length();\\n\\t\\t// add padding for 0\\n        p = new long[n + 2];\\n        h = new long[n + 2];\\n        \\n        p[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            p[i] = p[i - 1] * base;\\n            h[i] = h[i - 1] * base + s.charAt(i - 1);\\n        }\\n        \\n        int[] dp = new int[n + 2];\\n        for (int i = n; i > 0; i--) {\\n            dp[i] = 1;\\n            for (int len = 1; len <= (n - i + 1) / 2; len++) {\\n                if (get(i, i + len - 1) == get(i + len, i + 2 * len - 1)) {\\n                    dp[i] = Math.max(dp[i], dp[i + len] + 1);\\n                }\\n            }\\n        }\\n        \\n        return dp[1];\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    int base = 131;\\n    long[] p; // power of base\\n    long[] h; // hash value\\n    \\n    private long get(int l, int r) {\\n        return h[r] - h[l - 1] * p[r - l + 1];\\n    }\\n    \\n    public int deleteString(String s) {\\n        int n = s.length();\\n\\t\\t// add padding for 0\\n        p = new long[n + 2];\\n        h = new long[n + 2];\\n        \\n        p[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            p[i] = p[i - 1] * base;\\n            h[i] = h[i - 1] * base + s.charAt(i - 1);\\n        }\\n        \\n        int[] dp = new int[n + 2];\\n        for (int i = n; i > 0; i--) {\\n            dp[i] = 1;\\n            for (int len = 1; len <= (n - i + 1) / 2; len++) {\\n                if (get(i, i + len - 1) == get(i + len, i + 2 * len - 1)) {\\n                    dp[i] = Math.max(dp[i], dp[i + len] + 1);\\n                }\\n            }\\n        }\\n        \\n        return dp[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651363,
                "title": "c-dp-z-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> z_function(string s) {\\n    int n = (int) s.length();\\n    vector<int> z(n);\\n    for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n        if (i <= r)\\n            z[i] = min (r - i + 1, z[i - l]);\\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]])\\n            ++z[i];\\n        if (i + z[i] - 1 > r)\\n            l = i, r = i + z[i] - 1;\\n    }\\n    return z;\\n    }\\n    int deleteString(string s) {\\n        int n = s.size();\\n        string ns = \"\";\\n        vector<int> dp(n,1), z;\\n        for(int i=n-1;i>=0;i--){\\n            ns = s[i] + ns;\\n            z = z_function(ns);\\n            for(int j=i+1;j<n && ((i + 2*(j-i)) <= n);j++){\\n                if(z[j-i] >= (j-i))\\n                    dp[i] = max(dp[i], 1+dp[j]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> z_function(string s) {\\n    int n = (int) s.length();\\n    vector<int> z(n);\\n    for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n        if (i <= r)\\n            z[i] = min (r - i + 1, z[i - l]);\\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]])\\n            ++z[i];\\n        if (i + z[i] - 1 > r)\\n            l = i, r = i + z[i] - 1;\\n    }\\n    return z;\\n    }\\n    int deleteString(string s) {\\n        int n = s.size();\\n        string ns = \"\";\\n        vector<int> dp(n,1), z;\\n        for(int i=n-1;i>=0;i--){\\n            ns = s[i] + ns;\\n            z = z_function(ns);\\n            for(int j=i+1;j<n && ((i + 2*(j-i)) <= n);j++){\\n                if(z[j-i] >= (j-i))\\n                    dp[i] = max(dp[i], 1+dp[j]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648792,
                "title": "c-dp-solution-explained-o-n-2",
                "content": "dp[i] gives the maximum operations starting from i\\'th index of string s. We have to return dp[0].\\nWhile calculating dp[i], check all the valid strings that are repeated i.e. check whether substring of length len starting from i\\'th index = substring of length len starting from (i+len)\\'th index. We can loop over the len (from 1 to length of string/2) to cover all possible substrings. To compare a substring of length len, we use hash values instead of comparing element by element. There might be more than 1 valid substrings, in this case take the max of number of operations required in each case.\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mod=1000000009;\\n\\t\\tvector<int> dp;\\n\\t\\tint find(string& s, vector<vector<long long>>& hash,int l)\\n\\t\\t{\\n\\t\\t\\tint ans=1;\\n\\t\\t\\tif(dp[l]!=-1)\\n\\t\\t\\t\\treturn dp[l];\\n\\t\\t\\tint n = s.length()-l;\\n\\t\\t\\tif(l==s.length()-1)\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\tfor(int len=1;len<=n/2;len++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(hash[l][l+len-1]==hash[l+len][l+2*len-1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint t=find(s,hash,l+len);\\n\\t\\t\\t\\t\\tif(1+t>ans)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans=1+t;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[l]=ans;\\n\\t\\t}\\n\\t\\tint deleteString(string s,int l=0) {\\n\\t\\t\\tint ans=1;\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tdp.resize(n,-1);\\n\\t\\t\\tvector<vector<long long>> hash(n,vector<long long>(n,-1));\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=i;j<n;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(i==j)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\thash[i][j]=s[i]-\\'a\\';\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\thash[i][j]=(hash[i][j-1]*26+s[j]-\\'a\\')%mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn find(s,hash,0);\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint mod=1000000009;\\n\\t\\tvector<int> dp;\\n\\t\\tint find(string& s, vector<vector<long long>>& hash,int l)\\n\\t\\t{\\n\\t\\t\\tint ans=1;\\n\\t\\t\\tif(dp[l]!=-1)\\n\\t\\t\\t\\treturn dp[l];\\n\\t\\t\\tint n = s.length()-l;\\n\\t\\t\\tif(l==s.length()-1)\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\tfor(int len=1;len<=n/2;len++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(hash[l][l+len-1]==hash[l+len][l+2*len-1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint t=find(s,hash,l+len);\\n\\t\\t\\t\\t\\tif(1+t>ans)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans=1+t;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2671009,
                "title": "the-solution-that-should-pass-the-tests-but-doesn-t-the-problem-is-not-solvable-in-python-right-now",
                "content": "Python 3 solution using KMP to solve the problem in O(n\\xB2) time and O(n) memory. \\nRight now It gives TLE but you can\\'t do better, as the title says this problem is not solvable in python right now don\\'t waste your time.\\n\\n```\\ndef deleteString(self, s: str) -> int:\\n        n = len(s)\\n        \\n        def all_equal(s):\\n            for x in range(1, len(s)):\\n                if s[x] != s[0]:\\n                    return False\\n            return True\\n        \\n        def computeLPSArray(index):\\n            l, i = index, index + 1\\n            lps = [index] * n\\n\\n            while i < n:\\n                if s[i] == s[l]:\\n                    l += 1\\n                    lps[i] = l\\n                    i += 1\\n                else:\\n                    if l != index:\\n                        l = lps[l-1]\\n                    else:\\n                        lps[i] = index\\n                        i += 1\\n            return lps\\n        \\n        if all_equal(s):\\n            return len(s)\\n        \\n        dp = [1] * (n + 1)\\n        for i in range(n-2, -1, -1):\\n            lps = computeLPSArray(i)\\n            for x in range(1, n - i):\\n                pos = i+x\\n                val = lps[i+x]\\n                if (pos - val + 1 == val - i):\\n                    dp[i] = max(dp[i], dp[val] + 1)\\n                    \\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef deleteString(self, s: str) -> int:\\n        n = len(s)\\n        \\n        def all_equal(s):\\n            for x in range(1, len(s)):\\n                if s[x] != s[0]:\\n                    return False\\n            return True\\n        \\n        def computeLPSArray(index):\\n            l, i = index, index + 1\\n            lps = [index] * n\\n\\n            while i < n:\\n                if s[i] == s[l]:\\n                    l += 1\\n                    lps[i] = l\\n                    i += 1\\n                else:\\n                    if l != index:\\n                        l = lps[l-1]\\n                    else:\\n                        lps[i] = index\\n                        i += 1\\n            return lps\\n        \\n        if all_equal(s):\\n            return len(s)\\n        \\n        dp = [1] * (n + 1)\\n        for i in range(n-2, -1, -1):\\n            lps = computeLPSArray(i)\\n            for x in range(1, n - i):\\n                pos = i+x\\n                val = lps[i+x]\\n                if (pos - val + 1 == val - i):\\n                    dp[i] = max(dp[i], dp[val] + 1)\\n                    \\n        return dp[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2649041,
                "title": "segment-tree-dp-c",
                "content": "# Intuition\\nFirst, we see that this is a simple max dp. However, the hard part is doing string comparison faster than O(n).\\n\\n# Approach\\nFirst, we initialize `dp` and $n/2$ segment trees for each substring length.\\nThen, notice:\\n1. In order to delete substring $$s[i...i+d-1]$$ for some length $d$, we need to have $$s[j] = s[j+d]$$ for all $$j$$ in $$\\\\{i,i+1, ...,i+d-1\\\\}$$\\n2. We can precompute for all pairs $$(i,d)$$ if $$s[i]=s[i+d]$$ in $$O(n^2)$$\\n3. Then we can use a segment tree to query if all indexes from $$i$$ to $$j$$ are valid in $$log(n)$$.\\n\\nFinally, do a normal dp with segtree query.\\n# Complexity\\n- Time complexity:\\n$$O(n^2log(n))$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    bool query(bool* t, int l, int r){\\n        bool res = 1;\\n\\t\\tfor(l+=n, r+=n; l < r; l>>=1, r>>=1){\\n\\t\\t\\tif(l&1) res &= t[l++];\\n\\t\\t\\tif(r&1) res &= t[--r];\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n    int deleteString(string s) {\\n        n = s.size();\\n        int dp[4001];\\n        bool valid[2001][8000] = {};\\n        for(int i = 0; i < n +1 ;i ++) dp[i] = 0;\\n        for(int d = 1; d <= n/2; d++){\\n            for(int i =0; i < 2*n; i++){\\n                valid[d][i] = 0;\\n            }\\n        }\\n        for(int d = 1; d <= n/2; d++){\\n            for(int i =0; i < n-d; i++){\\n                if(s[i] == s[i+d]) valid[d][i+n] = 1;\\n            }\\n        }\\n        for(int d = 1; d <= n/2; d++){\\n            for(int i = n-1; i > 0; i--){\\n                valid[d][i] = valid[d][i<<1] & valid[d][i<<1|1];\\n            }\\n        }\\n        \\n        for(int i = 1; i < n+1; i++){ \\n            for(int j = 0; j < i; j++){\\n                if(i-j > n/2) continue;\\n                if((dp[j] != 0 || j == 0) && query(valid[i-j], j, i)) dp[i] = max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        int re = 0;\\n        for(int i = 0; i < n; i++){\\n            re = max(re, dp[i] + 1);\\n        }\\n        return max(dp[n], re);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool query(bool* t, int l, int r){\\n        bool res = 1;\\n\\t\\tfor(l+=n, r+=n; l < r; l>>=1, r>>=1){\\n\\t\\t\\tif(l&1) res &= t[l++];\\n\\t\\t\\tif(r&1) res &= t[--r];\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n    int deleteString(string s) {\\n        n = s.size();\\n        int dp[4001];\\n        bool valid[2001][8000] = {};\\n        for(int i = 0; i < n +1 ;i ++) dp[i] = 0;\\n        for(int d = 1; d <= n/2; d++){\\n            for(int i =0; i < 2*n; i++){\\n                valid[d][i] = 0;\\n            }\\n        }\\n        for(int d = 1; d <= n/2; d++){\\n            for(int i =0; i < n-d; i++){\\n                if(s[i] == s[i+d]) valid[d][i+n] = 1;\\n            }\\n        }\\n        for(int d = 1; d <= n/2; d++){\\n            for(int i = n-1; i > 0; i--){\\n                valid[d][i] = valid[d][i<<1] & valid[d][i<<1|1];\\n            }\\n        }\\n        \\n        for(int i = 1; i < n+1; i++){ \\n            for(int j = 0; j < i; j++){\\n                if(i-j > n/2) continue;\\n                if((dp[j] != 0 || j == 0) && query(valid[i-j], j, i)) dp[i] = max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        int re = 0;\\n        for(int i = 0; i < n; i++){\\n            re = max(re, dp[i] + 1);\\n        }\\n        return max(dp[n], re);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648691,
                "title": "python-solution-tle-during-contest-but-accepted-now-wth",
                "content": "This question is a joke... \\nI put this line\\n```\\n        if len(set(s)) == 1:\\n            return len(s)\\n```\\nand the code becomes 1s beat 100%... Really a stupid question as that \"aaaaaaaaaaaa...aaaa\" testcase is hidden during the contest... and what if we have \\n\"aaaaaaaaaaaa...aaab\"? \\n```\\nclass Solution:\\n    # Find the starting index i and the next matching index nxt_str_i on the right by first storing the info in the hash table\\n    # Then it is just simple DP to explore whatever possible\\n    \\n    @lru_cache(None)\\n    def dfs(self, i):\\n        result = 1\\n        l = len(self.hash_table[ord(self.s[i])-ord(\\'a\\')])\\n        if self.index[i] < l-1:\\n            j = self.index[i] + 1\\n            nxt_str_i = self.hash_table[ord(self.s[i])-ord(\\'a\\')][j]\\n            while j < l and 2*nxt_str_i - i <= len(self.s):\\n                if self.s[i:nxt_str_i] == self.s[nxt_str_i:2*nxt_str_i - i]:\\n                    result = max(result, 1 + self.dfs(nxt_str_i))\\n                j += 1\\n                if j < l:\\n                    nxt_str_i = self.hash_table[ord(self.s[i])-ord(\\'a\\')][j]\\n        return result\\n        \\n    def deleteString(self, s: str) -> int:\\n        self.s = s\\n        if len(set(s)) == 1:\\n            return len(s)\\n        self.hash_table = [[] for i in range(26)]\\n        self.index = []\\n        for i, c in enumerate(s):\\n            self.hash_table[ord(c)-ord(\\'a\\')].append(i)\\n            self.index.append(len(self.hash_table[ord(c)-ord(\\'a\\')]) - 1)\\n        return self.dfs(0)\\n```",
                "solutionTags": [],
                "code": "```\\n        if len(set(s)) == 1:\\n            return len(s)\\n```\n```\\nclass Solution:\\n    # Find the starting index i and the next matching index nxt_str_i on the right by first storing the info in the hash table\\n    # Then it is just simple DP to explore whatever possible\\n    \\n    @lru_cache(None)\\n    def dfs(self, i):\\n        result = 1\\n        l = len(self.hash_table[ord(self.s[i])-ord(\\'a\\')])\\n        if self.index[i] < l-1:\\n            j = self.index[i] + 1\\n            nxt_str_i = self.hash_table[ord(self.s[i])-ord(\\'a\\')][j]\\n            while j < l and 2*nxt_str_i - i <= len(self.s):\\n                if self.s[i:nxt_str_i] == self.s[nxt_str_i:2*nxt_str_i - i]:\\n                    result = max(result, 1 + self.dfs(nxt_str_i))\\n                j += 1\\n                if j < l:\\n                    nxt_str_i = self.hash_table[ord(self.s[i])-ord(\\'a\\')][j]\\n        return result\\n        \\n    def deleteString(self, s: str) -> int:\\n        self.s = s\\n        if len(set(s)) == 1:\\n            return len(s)\\n        self.hash_table = [[] for i in range(26)]\\n        self.index = []\\n        for i, c in enumerate(s):\\n            self.hash_table[ord(c)-ord(\\'a\\')].append(i)\\n            self.index.append(len(self.hash_table[ord(c)-ord(\\'a\\')]) - 1)\\n        return self.dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648955,
                "title": "python-dp-top-down-clean-concise",
                "content": "```\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        if n == 1: return 1\\n\\t\\tif (len(set(s)) == 1): return n\\n        \\n        @cache\\n        def dp(i):\\n            if i == n - 1: return 1\\n            res = 0\\n            l = (n - i) // 2\\n            temp = \"\"\\n            for j in range(1, l + 1):\\n                temp += s[i + j - 1]\\n                if temp == s[i+j:i+2*j]:\\n                    res = max(res, dp(i+j))\\n            return res + 1        \\n        \\n        return dp(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        if n == 1: return 1\\n\\t\\tif (len(set(s)) == 1): return n\\n        \\n        @cache\\n        def dp(i):\\n            if i == n - 1: return 1\\n            res = 0\\n            l = (n - i) // 2\\n            temp = \"\"\\n            for j in range(1, l + 1):\\n                temp += s[i + j - 1]\\n                if temp == s[i+j:i+2*j]:\\n                    res = max(res, dp(i+j))\\n            return res + 1        \\n        \\n        return dp(0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2648674,
                "title": "c-rolling-hash-dynamic-programming",
                "content": "\\n# Complexity\\n- Time complexity: n^2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[4040];\\n    long long mod = 1e9 + 7;\\n    long long rolling = 31;\\npublic:\\n    int deleteString(string s) {\\n        memset(dp,-1,sizeof dp);\\n        dp[0] = 0;\\n        vector<long long> hash(s.length());\\n        for(long long i = 0, h = 1; i < s.length(); i++, h = h * rolling % mod) hash[i] = (s[i] - \\'a\\' + 1) * h % mod;\\n\\n        for(int i = 0; i < s.length(); i++) {\\n            if(dp[i] == -1) continue;\\n            dp[s.length()] = max(dp[s.length()], dp[i] + 1);\\n            long long front = 0, back = 0;\\n            for(long long j = i + 1, k = i, po = rolling; j < s.length(); j += 2, k += 1, po = po * rolling % mod) {\\n                front = (front + hash[k]) % mod;\\n                back = (back + hash[j] + hash[j - 1]) % mod;\\n                if((front + front * po % mod) % mod == back) dp[k + 1] = max(dp[k + 1], dp[i] + 1);\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[4040];\\n    long long mod = 1e9 + 7;\\n    long long rolling = 31;\\npublic:\\n    int deleteString(string s) {\\n        memset(dp,-1,sizeof dp);\\n        dp[0] = 0;\\n        vector<long long> hash(s.length());\\n        for(long long i = 0, h = 1; i < s.length(); i++, h = h * rolling % mod) hash[i] = (s[i] - \\'a\\' + 1) * h % mod;\\n\\n        for(int i = 0; i < s.length(); i++) {\\n            if(dp[i] == -1) continue;\\n            dp[s.length()] = max(dp[s.length()], dp[i] + 1);\\n            long long front = 0, back = 0;\\n            for(long long j = i + 1, k = i, po = rolling; j < s.length(); j += 2, k += 1, po = po * rolling % mod) {\\n                front = (front + hash[k]) % mod;\\n                back = (back + hash[j] + hash[j - 1]) % mod;\\n                if((front + front * po % mod) % mod == back) dp[k + 1] = max(dp[k + 1], dp[i] + 1);\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923084,
                "title": "simple-dp-hashing-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbrute force approach \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhow can we reduce time complexity while comparing 2 substrings \\nusing hashing we can do this comparison in O(1) instead of O(n)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mod=999999937,p=37;\\n    void fhash(string &s,vector<int>&hash,vector<int>&pk){\\n        pk[0]=1;\\n        hash[0]=s[0]-\\'a\\'+1;\\n        for(int i=1;i<s.size();i++){\\n            hash[i]=(p*hash[i-1]+(s[i]-\\'a\\'+1))%mod;\\n            pk[i]=p*pk[i-1]%mod;\\n        }\\n    }\\n\\n    int val(int l,int r,vector<int>&hash,vector<int>&pk){\\n        if(l==0) return hash[r];\\n        return (hash[r]-1LL*hash[l-1]*pk[r-l+1]%mod+mod)%mod;\\n    }\\n\\n    int deleteString(string s) {\\n        int n=s.size(),ans=0;\\n        int i=n-2;\\n        vector<int>hash(n),pk(n);\\n        fhash(s,hash,pk);\\n        vector<int>dp(n+1); dp[n]=0; dp[n-1]=1;\\n        while(i>=0){\\n            dp[i]=1;\\n            for(int j=i+1;2*j-i<=n;j++){\\n                if(val(i,j-1,hash,pk)==val(j,2*j-i-1,hash,pk)){\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n            i--;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod=999999937,p=37;\\n    void fhash(string &s,vector<int>&hash,vector<int>&pk){\\n        pk[0]=1;\\n        hash[0]=s[0]-\\'a\\'+1;\\n        for(int i=1;i<s.size();i++){\\n            hash[i]=(p*hash[i-1]+(s[i]-\\'a\\'+1))%mod;\\n            pk[i]=p*pk[i-1]%mod;\\n        }\\n    }\\n\\n    int val(int l,int r,vector<int>&hash,vector<int>&pk){\\n        if(l==0) return hash[r];\\n        return (hash[r]-1LL*hash[l-1]*pk[r-l+1]%mod+mod)%mod;\\n    }\\n\\n    int deleteString(string s) {\\n        int n=s.size(),ans=0;\\n        int i=n-2;\\n        vector<int>hash(n),pk(n);\\n        fhash(s,hash,pk);\\n        vector<int>dp(n+1); dp[n]=0; dp[n-1]=1;\\n        while(i>=0){\\n            dp[i]=1;\\n            for(int j=i+1;2*j-i<=n;j++){\\n                if(val(i,j-1,hash,pk)==val(j,2*j-i-1,hash,pk)){\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n            i--;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766986,
                "title": "simple-o-n-2-dp-approach-using-hashes",
                "content": "```\\nconst int mod=1e9+7;\\n#define ll long long\\nclass Solution {\\n    int n;\\n    string s;\\n    vector<vector<ll>> hash;\\n    vector<ll> dp;\\npublic:\\n    ll solver(int ind){\\n        if(dp[ind]>=0)\\n            return dp[ind];\\n        ll next=1;\\n        for(int l=1;l<=n;l++){\\n            if((ind+2*l)>n)\\n                break;\\n            if(hash[ind][l]==hash[ind+l][l])\\n                next=max(next,1+solver(ind+l));\\n        }\\n        return dp[ind]=next;\\n    }\\n    \\n    int deleteString(string t) {\\n        s=t;\\n        n=s.length();\\n        hash.resize(n+2,vector<ll>(n+2,-1));\\n        dp.resize(n+1,-1);\\n        dp[n-1]=1;\\n        dp[n]=0;\\n        for(int i=0;i<n;i++){\\n            ll p=1,h=0;\\n            for(int j=i;j<n;j++){\\n                h=(h+((s[j]-\\'a\\'+1)*p)%mod)%mod;\\n                hash[i][j-i+1]=h;\\n                p=(p*31)%mod;\\n            }\\n        }\\n        return solver(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst int mod=1e9+7;\\n#define ll long long\\nclass Solution {\\n    int n;\\n    string s;\\n    vector<vector<ll>> hash;\\n    vector<ll> dp;\\npublic:\\n    ll solver(int ind){\\n        if(dp[ind]>=0)\\n            return dp[ind];\\n        ll next=1;\\n        for(int l=1;l<=n;l++){\\n            if((ind+2*l)>n)\\n                break;\\n            if(hash[ind][l]==hash[ind+l][l])\\n                next=max(next,1+solver(ind+l));\\n        }\\n        return dp[ind]=next;\\n    }\\n    \\n    int deleteString(string t) {\\n        s=t;\\n        n=s.length();\\n        hash.resize(n+2,vector<ll>(n+2,-1));\\n        dp.resize(n+1,-1);\\n        dp[n-1]=1;\\n        dp[n]=0;\\n        for(int i=0;i<n;i++){\\n            ll p=1,h=0;\\n            for(int j=i;j<n;j++){\\n                h=(h+((s[j]-\\'a\\'+1)*p)%mod)%mod;\\n                hash[i][j-i+1]=h;\\n                p=(p*31)%mod;\\n            }\\n        }\\n        return solver(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666808,
                "title": "thought-process-n-2-to-n",
                "content": "<img src=\"https://i.imgur.com/OXyWjdl.png\" alt=\"image\" width=\"1000\"/>\\n\\n### 14\\n\\n```python\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        \\n        def max_dels(i_s, memo_max_dels):\\n            if i_s > len(s)-1:\\n                return 1\\n            if i_s in memo_max_dels:\\n                return memo_max_dels[i_s]\\n            \\n            dels_max = 1\\n            # find matches\\n            i1 = i_s\\n            for sz in range(1, math.floor(len(s[i_s:])/2)+1):\\n                i2 = i1+sz\\n                if s[i1:i1+sz] == s[i2:i2+sz]:\\n                    dels_max = max(dels_max, 1 + max_dels(i2, memo_max_dels))\\n            memo_max_dels[i_s] = dels_max\\n            return dels_max                    \\n        \\n        # main\\n        memo_max_dels = defaultdict(int) # idx_starting:max_dels\\n        return max_dels(0, memo_max_dels)\\n```\\n\\n### 23\\n```python\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        \\n        def max_dels(i_s, memo_max_dels, matches):\\n            if i_s == len(s)-1:\\n                return 1\\n            if i_s in memo_max_dels:\\n                return memo_max_dels[i_s]\\n            # find matches\\n            dels_max = 1\\n            i1 = i_s\\n            for i2 in matches[i1]:\\n                dels_max = max(dels_max, 1 + max_dels(i2, memo_max_dels, matches))\\n            memo_max_dels[i_s] = dels_max\\n            return dels_max                    \\n        \\n        def get_matches():\\n            cont = [ [0 for _ in range(n)] for _ in range(n) ]\\n            matches = defaultdict(list)\\n            for i1 in range(n-1):\\n                for i2 in range(i1+1, n):\\n                    dist = i2 - i1\\n                    if s[i1] == s[i2]:\\n                        cont[i1][i2] = cont[i1-1][i2-1] + 1 if i1 > 0 else 1\\n                        # overlapped, start-oever\\n                        if cont[i1][i2] > dist:\\n                            cont[i1][i2] = 1\\n                        # valid abc|abc\\n                        if cont[i1][i2] == dist:\\n                            matches[i1-dist+1].append(i2-dist+1)\\n            return matches\\n\\n        # main\\n        memo_max_dels = defaultdict(int) # starting idx of string:max_dels\\n        \\n        matches = get_matches() # {i_str:[list of matched j_str]}\\n        return max_dels(0, memo_max_dels, matches)\\n```\\n\\n### 25\\n```python\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        \\n        def max_dels(i_s, memo_max_dels, matches):\\n            if i_s == len(s)-1:\\n                return 1\\n            if i_s in memo_max_dels:\\n                return memo_max_dels[i_s]\\n            # find matches\\n            dels_max = 1\\n            i1 = i_s\\n            for i2 in matches[i1]:\\n                dels_max = max(dels_max, 1 + max_dels(i2, memo_max_dels, matches))\\n            memo_max_dels[i_s] = dels_max\\n            return dels_max                    \\n        \\n        def get_matches():\\n            cont = [ [0 for _ in range(n)] for _ in range(n) ]\\n            matches = defaultdict(list)\\n            for i1 in range(n-1):\\n                for i2 in range(i1+1, n):\\n                    dist = i2 - i1\\n                    if s[i1] == s[i2]:\\n                        cont[i1][i2] = cont[i1-1][i2-1] + 1 if i1 > 0 else 1\\n                        # overlapped, start-oever\\n                        if cont[i1][i2] > dist:\\n                            cont[i1][i2] = 1\\n                        # valid abc|abc\\n                        if cont[i1][i2] == dist:\\n                            matches[i1-dist+1].append(i2-dist+1)\\n            return matches\\n\\n        def init_memo_max_dels(memo_max_dels):\\n            memo_max_dels[n-1] = 1\\n            for i in range(n-2, -1, -1):\\n                if s[i] != s[i+1]:\\n                    break\\n                memo_max_dels[i] = memo_max_dels[i+1] + 1\\n\\n        # main\\n        memo_max_dels = defaultdict(int) # starting idx of string:max_dels\\n        init_memo_max_dels(memo_max_dels) # memo if substring till end are same letter. e.g. \"aaaa\"\\n        # early return if idx of 0 is in memo    \\n        if 0 in memo_max_dels:\\n            return memo_max_dels[0]\\n        \\n        matches = get_matches() # {i_str:[list of matched j_str]}\\n        return max_dels(0, memo_max_dels, matches)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        \\n        def max_dels(i_s, memo_max_dels):\\n            if i_s > len(s)-1:\\n                return 1\\n            if i_s in memo_max_dels:\\n                return memo_max_dels[i_s]\\n            \\n            dels_max = 1\\n            # find matches\\n            i1 = i_s\\n            for sz in range(1, math.floor(len(s[i_s:])/2)+1):\\n                i2 = i1+sz\\n                if s[i1:i1+sz] == s[i2:i2+sz]:\\n                    dels_max = max(dels_max, 1 + max_dels(i2, memo_max_dels))\\n            memo_max_dels[i_s] = dels_max\\n            return dels_max                    \\n        \\n        # main\\n        memo_max_dels = defaultdict(int) # idx_starting:max_dels\\n        return max_dels(0, memo_max_dels)\\n```\n```python\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        \\n        def max_dels(i_s, memo_max_dels, matches):\\n            if i_s == len(s)-1:\\n                return 1\\n            if i_s in memo_max_dels:\\n                return memo_max_dels[i_s]\\n            # find matches\\n            dels_max = 1\\n            i1 = i_s\\n            for i2 in matches[i1]:\\n                dels_max = max(dels_max, 1 + max_dels(i2, memo_max_dels, matches))\\n            memo_max_dels[i_s] = dels_max\\n            return dels_max                    \\n        \\n        def get_matches():\\n            cont = [ [0 for _ in range(n)] for _ in range(n) ]\\n            matches = defaultdict(list)\\n            for i1 in range(n-1):\\n                for i2 in range(i1+1, n):\\n                    dist = i2 - i1\\n                    if s[i1] == s[i2]:\\n                        cont[i1][i2] = cont[i1-1][i2-1] + 1 if i1 > 0 else 1\\n                        # overlapped, start-oever\\n                        if cont[i1][i2] > dist:\\n                            cont[i1][i2] = 1\\n                        # valid abc|abc\\n                        if cont[i1][i2] == dist:\\n                            matches[i1-dist+1].append(i2-dist+1)\\n            return matches\\n\\n        # main\\n        memo_max_dels = defaultdict(int) # starting idx of string:max_dels\\n        \\n        matches = get_matches() # {i_str:[list of matched j_str]}\\n        return max_dels(0, memo_max_dels, matches)\\n```\n```python\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        \\n        def max_dels(i_s, memo_max_dels, matches):\\n            if i_s == len(s)-1:\\n                return 1\\n            if i_s in memo_max_dels:\\n                return memo_max_dels[i_s]\\n            # find matches\\n            dels_max = 1\\n            i1 = i_s\\n            for i2 in matches[i1]:\\n                dels_max = max(dels_max, 1 + max_dels(i2, memo_max_dels, matches))\\n            memo_max_dels[i_s] = dels_max\\n            return dels_max                    \\n        \\n        def get_matches():\\n            cont = [ [0 for _ in range(n)] for _ in range(n) ]\\n            matches = defaultdict(list)\\n            for i1 in range(n-1):\\n                for i2 in range(i1+1, n):\\n                    dist = i2 - i1\\n                    if s[i1] == s[i2]:\\n                        cont[i1][i2] = cont[i1-1][i2-1] + 1 if i1 > 0 else 1\\n                        # overlapped, start-oever\\n                        if cont[i1][i2] > dist:\\n                            cont[i1][i2] = 1\\n                        # valid abc|abc\\n                        if cont[i1][i2] == dist:\\n                            matches[i1-dist+1].append(i2-dist+1)\\n            return matches\\n\\n        def init_memo_max_dels(memo_max_dels):\\n            memo_max_dels[n-1] = 1\\n            for i in range(n-2, -1, -1):\\n                if s[i] != s[i+1]:\\n                    break\\n                memo_max_dels[i] = memo_max_dels[i+1] + 1\\n\\n        # main\\n        memo_max_dels = defaultdict(int) # starting idx of string:max_dels\\n        init_memo_max_dels(memo_max_dels) # memo if substring till end are same letter. e.g. \"aaaa\"\\n        # early return if idx of 0 is in memo    \\n        if 0 in memo_max_dels:\\n            return memo_max_dels[0]\\n        \\n        matches = get_matches() # {i_str:[list of matched j_str]}\\n        return max_dels(0, memo_max_dels, matches)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655645,
                "title": "dp-kmp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[4005];\\n    void KMP(string s,vector<int>& K){\\n        int i=1;\\n        int len=0;\\n        int n=s.size();\\n        while(i<n){\\n            \\n            if(s[i]==s[len]){\\n                len++;\\n                K[i]=len;\\n                i++;\\n            }\\n            else{\\n                if(len>0){\\n                    len=K[len-1];\\n                }\\n                else{\\n                    len=0;\\n                    K[i]=0;\\n                    i++;\\n                }\\n            }\\n        }\\n    }\\n    int f(string& s,int i){\\n        \\n        if(i==s.size())return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        int n=s.size();\\n        \\n        string str=\"\";\\n        for(int j=i;j<n;j++){\\n            str.push_back(s[j]);\\n        }\\n        n=str.size();\\n        vector<int> K(n,0);\\n        KMP(str,K);\\n        \\n        int ans=1;\\n        for(int j=0;j<n;j++){\\n            \\n            if((j+1)==(K[j]*2)){\\n                ans=max(ans,1+f(s,i+K[j]));\\n            }\\n        }\\n        \\n        return dp[i]=ans;\\n        \\n        \\n    }\\n    int deleteString(string s) {\\n        memset(dp,-1,sizeof dp);\\n        return f(s,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[4005];\\n    void KMP(string s,vector<int>& K){\\n        int i=1;\\n        int len=0;\\n        int n=s.size();\\n        while(i<n){\\n            \\n            if(s[i]==s[len]){\\n                len++;\\n                K[i]=len;\\n                i++;\\n            }\\n            else{\\n                if(len>0){\\n                    len=K[len-1];\\n                }\\n                else{\\n                    len=0;\\n                    K[i]=0;\\n                    i++;\\n                }\\n            }\\n        }\\n    }\\n    int f(string& s,int i){\\n        \\n        if(i==s.size())return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        int n=s.size();\\n        \\n        string str=\"\";\\n        for(int j=i;j<n;j++){\\n            str.push_back(s[j]);\\n        }\\n        n=str.size();\\n        vector<int> K(n,0);\\n        KMP(str,K);\\n        \\n        int ans=1;\\n        for(int j=0;j<n;j++){\\n            \\n            if((j+1)==(K[j]*2)){\\n                ans=max(ans,1+f(s,i+K[j]));\\n            }\\n        }\\n        \\n        return dp[i]=ans;\\n        \\n        \\n    }\\n    int deleteString(string s) {\\n        memset(dp,-1,sizeof dp);\\n        return f(s,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652088,
                "title": "c-solution-using-dp-string-hashing",
                "content": "Resources to learn string hashing: \\n1. [CP Algorithms](https://cp-algorithms.com/string/string-hashing.html)\\n2. [Algorithms Live!\\'s Video](https://www.youtube.com/watch?v=rA1ZevamGDc) \\n3. [YouKnowWho](https://github.com/ShahjalalShohag/code-library/blob/11dc4e0c3e0041d333441ad7a085f3a445dff2fd/Strings/String%20Hashing.cpp)\\n \\n**Soultion:**\\n```cpp\\nlong long mod0 = 127657753, mod1 = 987654319;\\nlong long p0 = 137, p1 = 277;\\nvector<array<long long, 2>> pw;\\nvector<array<long long, 2>> ipw;\\n\\nlong long binpow(long long a, long long b, long long m) {\\n    a %= m;\\n    long long res = 1;\\n    while(b > 0) {\\n        if(b & 1) res = (res * a) % m;\\n        a = (a * a) % m;\\n        b >>= 1;\\n    }\\n    return res;\\n}\\n\\nlong long inv(long long a, long long m) {\\n    // a is prime and a mod m != 0\\n    // a ^ m       === a      (mod m) \\n    // a ^ (m - 2) === a ^ -1 (mod m)\\n    return binpow(a, m - 2, m);\\n}\\n\\n// Till the limit i.e. [0, limit]\\nvoid init(int limit) {\\n    if(pw.empty()) pw.push_back({1, 1});\\n    while(pw.size() < limit + 1) {\\n        pw.push_back({\\n            (pw.back()[0] * p0) % mod0, \\n            (pw.back()[1] * p1) % mod1\\n        });\\n    } \\n    if(ipw.empty()) {\\n        ipw.push_back({1, 1});\\n        ipw.push_back({\\n            inv(p0, mod0),\\n            inv(p1, mod1)\\n        });\\n    }\\n    while(ipw.size() < limit + 1) {\\n        ipw.push_back({\\n            (ipw.back()[0] * ipw[1][0]) % mod0, \\n            (ipw.back()[1] * ipw[1][1]) % mod1\\n        });\\n    }\\n}\\n\\nclass Hashing {\\nprivate:\\n    vector<array<long long, 2>> pre;\\n    int n; \\n\\npublic:\\n    Hashing(string s) {\\n        init((int)s.size() + 1);\\n        if(s.size() == 0) return;\\n        pre.push_back({(s[0] * pw[0][0]) % mod0, (s[0] * pw[0][1]) % mod1});\\n        for(int i = 1; i < (int)s.size(); i++) {\\n            pre.push_back({\\n                (pre[i - 1][0] + s[i] * pw[i][0]) % mod0,\\n                (pre[i - 1][1] + s[i] * pw[i][1]) % mod1\\n            });\\n        }\\n        n = (int)s.size();\\n    }\\n\\n    array<long long, 2> get_hash(int l, int r) {\\n        assert(0 <= l and l <= r  and r < n);\\n        array<long long, 2> hs;\\n        hs[0] = pre[r][0] - (l - 1 >= 0? pre[l - 1][0]: 0) + mod0;\\n        hs[1] = pre[r][1] - (l - 1 >= 0? pre[l - 1][1]: 0) + mod1;\\n        hs[0] = (hs[0] * ipw[l][0]) % mod0;\\n        hs[1] = (hs[1] * ipw[l][1]) % mod1;\\n        return hs;\\n    }\\n\\n    array<long long, 2> get_hash() {\\n        return get_hash(0, n - 1);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        const int n = (int)s.size();\\n        Hashing hs(s);\\n        vector<int> dp(n + 1, -1);\\n        function<int(int)> f = [&](int i) -> int {\\n            if(i == n) return 0;\\n            if(dp[i] != -1) return dp[i];\\n            int ans = 1;\\n            for(int j = 0; i + 2 * j + 1 < n; j++) {\\n                if(hs.get_hash(i, i + j) == hs.get_hash(i + j + 1, i + 2 * j + 1)) {\\n                    ans = max(ans, f(i + j + 1) + 1);\\n                } \\n            }\\n            return dp[i] = ans;\\n        };\\n        return f(0);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int deleteString(string s) {\\n        const int n = (int)s.size();\\n        Hashing hs(s);\\n        vector<int> dp(n + 1, -1);\\n        function<int(int)> f = [&](int i) -> int {\\n            if(i == n) return 0;\\n            if(dp[i] != -1) return dp[i];\\n            int ans = 1;\\n            for(int j = 0; i + 2 * j + 1 < n; j++) {\\n                if(hs.get_hash(i, i + j) == hs.get_hash(i + j + 1, i + 2 * j + 1)) {\\n                    ans = max(ans, f(i + j + 1) + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2650387,
                "title": "100-0-ms-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        if min(s) == max(s):\\n            return len(s)\\n        n = len(s)\\n        eq = [[0]*(n+1) for i in range(n+1)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if s[i] == s[j]:\\n                    eq[i][j] = 1 + eq[i+1][j+1]\\n        \\n        dp = [0]*n\\n        for i in range(n-1, -1, -1):\\n            dp[i] = 1\\n            j = 1\\n            while i+2*j <= n:\\n                if eq[i][i+j] >= j:\\n                    dp[i] = max(dp[i], dp[i+j]+1)\\n                j += 1\\n\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        if min(s) == max(s):\\n            return len(s)\\n        n = len(s)\\n        eq = [[0]*(n+1) for i in range(n+1)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if s[i] == s[j]:\\n                    eq[i][j] = 1 + eq[i+1][j+1]\\n        \\n        dp = [0]*n\\n        for i in range(n-1, -1, -1):\\n            dp[i] = 1\\n            j = 1\\n            while i+2*j <= n:\\n                if eq[i][i+j] >= j:\\n                    dp[i] = max(dp[i], dp[i+j]+1)\\n                j += 1\\n\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649720,
                "title": "simple-java-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    Integer[] dp;\\n    public int deleteString(String s) {\\n        int n=s.length();\\n        HashSet<Character> set=new HashSet<>();\\n        for(int i=0;i<n;i++){\\n            set.add(s.charAt(i));\\n        }\\n        if(set.size()==1) return s.length();\\n        dp=new Integer[n];\\n        return recursion(s,0,n);\\n    }\\n    public int recursion(String s,int ptr,int len){\\n        if(ptr==len) return 0;\\n        if(dp[ptr]==null){\\n            int lenStr=(len-ptr)/2;\\n            int maxval=1;\\n            for(int i=ptr;i<ptr+lenStr;i++){\\n                String first=s.substring(ptr,i+1);\\n                String last=s.substring(i+1,2*(i+1)-ptr);\\n                if(first.equals(last)){\\n                    maxval=Math.max(maxval,recursion(s,i+1,len)+1);\\n                }\\n            }\\n            dp[ptr]=maxval;\\n        }\\n        return dp[ptr];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    Integer[] dp;\\n    public int deleteString(String s) {\\n        int n=s.length();\\n        HashSet<Character> set=new HashSet<>();\\n        for(int i=0;i<n;i++){\\n            set.add(s.charAt(i));\\n        }\\n        if(set.size()==1) return s.length();\\n        dp=new Integer[n];\\n        return recursion(s,0,n);\\n    }\\n    public int recursion(String s,int ptr,int len){\\n        if(ptr==len) return 0;\\n        if(dp[ptr]==null){\\n            int lenStr=(len-ptr)/2;\\n            int maxval=1;\\n            for(int i=ptr;i<ptr+lenStr;i++){\\n                String first=s.substring(ptr,i+1);\\n                String last=s.substring(i+1,2*(i+1)-ptr);\\n                if(first.equals(last)){\\n                    maxval=Math.max(maxval,recursion(s,i+1,len)+1);\\n                }\\n            }\\n            dp[ptr]=maxval;\\n        }\\n        return dp[ptr];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649573,
                "title": "kmp-greedy-beats-100-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>LPS(string s)\\n    {\\n        int len=0;\\n        vector<int>lps(s.length(),0);\\n        int i=1;\\n        while(i<s.length())\\n        {\\n        if(s[i]==s[len])\\n        {\\n            len++;\\n            lps[i]=len;\\n            i++;\\n        }\\n            else\\n            {\\n                if(len!=0)\\n                    len=lps[len-1];\\n                else\\n                {\\n                    lps[i]=0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n    int deleteString(string s) {\\n        int c=0;\\n        int f=0;\\n        while(s.length()>0)\\n        {\\n            f=0;\\n           vector<int>lps=LPS(s); \\n           for(int i=lps.size()-1;i>=0;i--)\\n           {\\n               if(lps[i]*2==(i+1))\\n               {\\n                  c++;\\n                   f=1;\\n                  // cout<<\"P\"<<lps[i]<<endl;\\n                  s.erase(0,lps[i]);\\n                   break;\\n               }\\n           }\\n            if(f!=1)\\n                break;\\n        }\\n       // cout<<s<<endl;\\n        return c+1;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int>LPS(string s)\\n    {\\n        int len=0;\\n        vector<int>lps(s.length(),0);\\n        int i=1;\\n        while(i<s.length())\\n        {\\n        if(s[i]==s[len])\\n        {\\n            len++;\\n            lps[i]=len;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2649486,
                "title": "very-intuitive-using-dp-optimize-compare",
                "content": "Just Think of buliding the string from the end instead of vanishing the string.\\nYou will get better intution.\\nAnd use inbuilt compare function to optimize the matching of two string.instead of custom matching function which were giving TLE;\\nAlso you can use LPS array to optomize matching of string further.\\ni will update the post for the same\\n```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n=s.length();\\n        int dp[n];\\n        dp[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            dp[i]=1;\\n            int l=n-i;\\n            for(int len=1;len<=l/2;len++){\\n                if(s.compare(i,len,s,i+len,len)==0){\\n                     dp[i]=max(dp[i],dp[i+len]+1);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n=s.length();\\n        int dp[n];\\n        dp[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            dp[i]=1;\\n            int l=n-i;\\n            for(int len=1;len<=l/2;len++){\\n                if(s.compare(i,len,s,i+len,len)==0){\\n                     dp[i]=max(dp[i],dp[i+len]+1);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649417,
                "title": "c-simple-and-straight-forward-top-down-dp-approach",
                "content": "This is a simple and very straight forward Top-down Dynamic programming approach:\\n\\nI am using the \"tflag\" to increment the res value by 1, which represents that the whole string has to deducted in a single opertaion. This happens only when the remaining string cannot be split into two substring of same values. \\n\\nI am also using an unordered map to count number of characters. This is just to overcome a test case which has a large string of almost 4000 size with same character.\\n\\n```cpp\\nclass Solution {\\n    int dfs(string s, int idx, vector<int>& memo)\\n    {\\n        int n = s.size();\\n        if (idx >= n) return 0;\\n        if (memo[idx] != -1) return memo[idx];\\n        \\n        int res = 0;\\n        string ss;\\n        bool tflag = false;\\n        for(int i = idx; i < n; i++)\\n        {\\n            ss += s[i];\\n            if (ss.size() <= (n-i))\\n            {\\n                if (ss == s.substr(i+1, ss.size()))\\n                {\\n                    int x = dfs(s, i+1, memo) + 1;\\n                    res = max(res, x);\\n                    tflag = true;\\n                }\\n            }\\n        }\\n\\n        if (!tflag && idx < n) res += 1;\\n        memo[idx] = res;\\n        return res;\\n    }\\npublic:\\n    int deleteString(string s) {\\n        int n = s.size();\\n        if (n == 0) return 0;\\n        unordered_map<char, int> freq;\\n        for(auto ch : s)\\n            freq[ch]++;\\n        \\n        if (freq.size() == 1 && n > 1) return n;\\n        \\n        vector<int> memo(n+1, -1);\\n        return dfs(s, 0, memo);\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n    int dfs(string s, int idx, vector<int>& memo)\\n    {\\n        int n = s.size();\\n        if (idx >= n) return 0;\\n        if (memo[idx] != -1) return memo[idx];\\n        \\n        int res = 0;\\n        string ss;\\n        bool tflag = false;\\n        for(int i = idx; i < n; i++)\\n        {\\n            ss += s[i];\\n            if (ss.size() <= (n-i))\\n            {\\n                if (ss == s.substr(i+1, ss.size()))\\n                {\\n                    int x = dfs(s, i+1, memo) + 1;\\n                    res = max(res, x);\\n                    tflag = true;\\n                }\\n            }\\n        }\\n\\n        if (!tflag && idx < n) res += 1;\\n        memo[idx] = res;\\n        return res;\\n    }\\npublic:\\n    int deleteString(string s) {\\n        int n = s.size();\\n        if (n == 0) return 0;\\n        unordered_map<char, int> freq;\\n        for(auto ch : s)\\n            freq[ch]++;\\n        \\n        if (freq.size() == 1 && n > 1) return n;\\n        \\n        vector<int> memo(n+1, -1);\\n        return dfs(s, 0, memo);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649251,
                "title": "c-dp-precomputation-memoization",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    int find(string& s,int start,vector<int>&dp,vector<vector<int>>&pre)\\n    {\\n        if(dp[start]!=-1)\\n          return dp[start];\\n        if(start>=s.length())\\n            return 0;\\n        for(int i=start;i<s.length();i++)\\n        {\\n           int l1 =start;\\n           int r1 =i;\\n           int l2 =i+1;\\n           int r2 =i+(i-start+1);\\n            \\n           if(r2>=s.length())\\n                break;\\n            \\n           if(pre[l1][l2]>=(i-start+1)) // if s[l1...r1]==s[l2.....r2]\\n           {\\n               dp[start] = max(dp[start],1+find(s,i+1,dp,pre));\\n           }\\n        }\\n        dp[start]=max(dp[start],1);\\n        return dp[start];\\n    }\\n    \\n    int deleteString(string s) \\n    {\\n        int n = s.length();\\n        vector<vector<int>>pre(n+1,vector<int>(n+1,0));\\n        \\n        for (int i = n - 1; i >= 0; i--) // pre[i][j] stores length of longest common prefix between s[i....n-1] and s[j....n-1]\\n        {\\n            for (int j = i + 1; j < n; j++) \\n            {\\n                if (s[i] == s[j])\\n                pre[i][j] = pre[i + 1][j + 1] + 1;\\n                \\n            }\\n        }\\n        \\n        vector<int>dp(n,-1);\\n        \\n        return find(s,0,dp,pre);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    int find(string& s,int start,vector<int>&dp,vector<vector<int>>&pre)\\n    {\\n        if(dp[start]!=-1)\\n          return dp[start];\\n        if(start>=s.length())\\n            return 0;\\n        for(int i=start;i<s.length();i++)\\n        {\\n           int l1 =start;\\n           int r1 =i;\\n           int l2 =i+1;\\n           int r2 =i+(i-start+1);\\n            \\n           if(r2>=s.length())\\n                break;\\n            \\n           if(pre[l1][l2]>=(i-start+1)) // if s[l1...r1]==s[l2.....r2]\\n           {\\n               dp[start] = max(dp[start],1+find(s,i+1,dp,pre));\\n           }\\n        }\\n        dp[start]=max(dp[start],1);\\n        return dp[start];\\n    }\\n    \\n    int deleteString(string s) \\n    {\\n        int n = s.length();\\n        vector<vector<int>>pre(n+1,vector<int>(n+1,0));\\n        \\n        for (int i = n - 1; i >= 0; i--) // pre[i][j] stores length of longest common prefix between s[i....n-1] and s[j....n-1]\\n        {\\n            for (int j = i + 1; j < n; j++) \\n            {\\n                if (s[i] == s[j])\\n                pre[i][j] = pre[i + 1][j + 1] + 1;\\n                \\n            }\\n        }\\n        \\n        vector<int>dp(n,-1);\\n        \\n        return find(s,0,dp,pre);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649237,
                "title": "c-dp-two-queues-sliding-window-clean-and-intuitive-explanation",
                "content": "Edit : This code was **accepted during the contest**. But Leetcode has added new testcases so **this in TLE now** .  \\nThough the time complexity of the code is indeed `O(n^2)` , it need some optimizations to pass. I will soon update the post with optimized code.\\n\\nTo find `dp[i]` using `dp[i+1, i+2, ....n-1]`, we need to know for a substring `s[i...k]`, that whether we can delete it or not.\\nIf we calculate whether we can delete substring `s[i...k]` or not, each time. It would result in O(n^3) time complexity.\\n\\nHence,\\nWe first calculate the `samenext[][]` array such that:\\n`samenext[i][j]` is `true` if `s[i...j]` can be deleted and `false` otherwize.  \\n\\nWe calculate `samenext[i][j]` corresponding to each length of subtring starting from `1`.\\n\\n- In the calculation for each length, we keep two windows `[cst...cend]` and `[nst...nend]` \\n-  In each iteration of while loop, we check if the string represented by the two windows are the same or not. Then we update both of the windows by shifting it to the right by 1.\\n-  `Deq` keeps two queues `dq1` and `dq2`,  and its keeps track of `nsame`  which is the number of characters which are same in both queues  and `n` which is the number of characters in both of the queues.\\n\\n```\\n\\nclass Deq{\\npublic:\\n    queue<char> dq1, dq2;\\n    int n;\\n    int nsame;\\n    \\n    \\n    Deq(const string& s1, int st1, int end1, const string& s2, int st2, int end2){\\n        n = end1-st1+1;\\n        nsame = 0;\\n        assert(end2-st2+1 == n);\\n        for(int i=0; i<n; i++){\\n            dq1.push(s1[st1+i]);\\n            dq2.push(s2[st2+i]);\\n            \\n            if(s1[st1+i]== s2[st2+i]){\\n                nsame ++;\\n            }\\n            \\n        }\\n    }\\n    \\n    void pop_front(){\\n        assert(n>0);\\n        \\n        if(dq1.front()==dq2.front()){\\n            nsame--;\\n        }\\n        dq1.pop();\\n        dq2.pop();\\n        n--;\\n    }\\n    void push_back(char c1, char c2){\\n        if(c1==c2){\\n            nsame++;\\n        }\\n        dq1.push(c1);\\n        dq2.push(c2);\\n        n++;\\n    }\\n    \\n    bool issame(){\\n        return nsame == n;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    int deleteString(string s) {\\n        \\n        int n = s.size();\\n        \\n        vector<vector<bool>> samenext(n, vector<bool>(n, false));\\n        \\n        \\n        for(int len=1; len<=n; len++){\\n            int cst = 0;\\n            int cend = cst+len-1;\\n            int nst = cend+1;\\n            int nend = nst+len-1;\\n            \\n            if(nend>=n){\\n                break;\\n            }\\n            \\n            Deq d(s, cst, cend, s, nst, nend);\\n            \\n            while(nend<n){\\n                if(d.issame()){\\n                    samenext[cst][cend] = true;\\n                }\\n                \\n                if(nend<n-1){\\n                    d.pop_front();\\n                    d.push_back(s[cend+1], s[nend+1]);\\n                }\\n                nst++;  \\n                nend++;\\n                cst++;\\n                cend++;\\n                \\n            }\\n        }\\n        \\n        vector<int> dp(n, -1);\\n        // dp[i] is the max num of oper req to delete \\n        // s[i...n-1]\\n        \\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                dp[i] = 1;\\n            }\\n            else{\\n                dp[i] =1;\\n                for(int k=i+1; k<n; k++){\\n                    // delete till k\\n                    // [i...k-1] should have its next same\\n                    if(samenext[i][k-1]){\\n                        dp[i] = max(dp[i], 1+dp[k]);\\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Deq{\\npublic:\\n    queue<char> dq1, dq2;\\n    int n;\\n    int nsame;\\n    \\n    \\n    Deq(const string& s1, int st1, int end1, const string& s2, int st2, int end2){\\n        n = end1-st1+1;\\n        nsame = 0;\\n        assert(end2-st2+1 == n);\\n        for(int i=0; i<n; i++){\\n            dq1.push(s1[st1+i]);\\n            dq2.push(s2[st2+i]);\\n            \\n            if(s1[st1+i]== s2[st2+i]){\\n                nsame ++;\\n            }\\n            \\n        }\\n    }\\n    \\n    void pop_front(){\\n        assert(n>0);\\n        \\n        if(dq1.front()==dq2.front()){\\n            nsame--;\\n        }\\n        dq1.pop();\\n        dq2.pop();\\n        n--;\\n    }\\n    void push_back(char c1, char c2){\\n        if(c1==c2){\\n            nsame++;\\n        }\\n        dq1.push(c1);\\n        dq2.push(c2);\\n        n++;\\n    }\\n    \\n    bool issame(){\\n        return nsame == n;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    int deleteString(string s) {\\n        \\n        int n = s.size();\\n        \\n        vector<vector<bool>> samenext(n, vector<bool>(n, false));\\n        \\n        \\n        for(int len=1; len<=n; len++){\\n            int cst = 0;\\n            int cend = cst+len-1;\\n            int nst = cend+1;\\n            int nend = nst+len-1;\\n            \\n            if(nend>=n){\\n                break;\\n            }\\n            \\n            Deq d(s, cst, cend, s, nst, nend);\\n            \\n            while(nend<n){\\n                if(d.issame()){\\n                    samenext[cst][cend] = true;\\n                }\\n                \\n                if(nend<n-1){\\n                    d.pop_front();\\n                    d.push_back(s[cend+1], s[nend+1]);\\n                }\\n                nst++;  \\n                nend++;\\n                cst++;\\n                cend++;\\n                \\n            }\\n        }\\n        \\n        vector<int> dp(n, -1);\\n        // dp[i] is the max num of oper req to delete \\n        // s[i...n-1]\\n        \\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                dp[i] = 1;\\n            }\\n            else{\\n                dp[i] =1;\\n                for(int k=i+1; k<n; k++){\\n                    // delete till k\\n                    // [i...k-1] should have its next same\\n                    if(samenext[i][k-1]){\\n                        dp[i] = max(dp[i], 1+dp[k]);\\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649062,
                "title": "python-dfs-memo-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        # DFS Traversal with Caching\\n        @cache\\n        def dfs(s):\\n            # Special case, reduce this typical branch in DFS\\n            cnt = Counter(s)\\n            if len(cnt) == 1:\\n                return len(s)\\n            # General Case\\n            res = [1]\\n            for i in range(0, len(s)//2 + 1):\\n                if self.isValid(0, i, s):\\n                    res.append(1 + dfs(s[i + 1:]))\\n            return max(res)\\n        return dfs(s)\\n      \\n    # Valid Check\\n    def isValid(self, start, end, s):\\n        targetLength = end - start + 1\\n        if end + 1 <= len(s) and end + 1 + targetLength <= len(s):\\n            if s[start : end +1] == s[end + 1 : end + 1 + targetLength]:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        # DFS Traversal with Caching\\n        @cache\\n        def dfs(s):\\n            # Special case, reduce this typical branch in DFS\\n            cnt = Counter(s)\\n            if len(cnt) == 1:\\n                return len(s)\\n            # General Case\\n            res = [1]\\n            for i in range(0, len(s)//2 + 1):\\n                if self.isValid(0, i, s):\\n                    res.append(1 + dfs(s[i + 1:]))\\n            return max(res)\\n        return dfs(s)\\n      \\n    # Valid Check\\n    def isValid(self, start, end, s):\\n        targetLength = end - start + 1\\n        if end + 1 <= len(s) and end + 1 + targetLength <= len(s):\\n            if s[start : end +1] == s[end + 1 : end + 1 + targetLength]:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648973,
                "title": "java-top-down-dynamic-programming-explanation",
                "content": "**Algorithm:**\\nThe solution to the above problem is pretty much straight forward, what you can do is ,first brute force and check for every matching prefix of said length because greedy won\\'t work with this problem.\\nWhile doing the brute force keep track of the indices of the original string because that would act as the state of our dp.\\nOnce you have the result of all the possible prefix deletions for the said index, you can cache in the most optimal solution in the dp array to that index.\\n\\n**DP State:\\ndp[index]=> This corresponds to the maximum number of deletions required after this index.**\\n\\nMy solution to the last test case is pretty naive, since the constraints was of 4000 and all the characters were \\'a\\', it was still giving TLE, so to tackle that I just returned the frequency of the repeating character, because for maximum deletion you need to delete every character one by one.\\n\\n```\\nclass Solution {\\n    Integer []dp;\\n    public int deleteString(String s){\\n        HashMap<Character,Integer> map1=new HashMap<>();\\n        dp=new Integer[s.length()];\\n        for(char ch:s.toCharArray()){\\n            map1.put(ch,map1.getOrDefault(ch,0)+1);\\n        }\\n        if(map1.size()==1){\\n            int ans=0;\\n            for(char val:map1.keySet())\\n                ans=map1.get(val);\\n            return ans;\\n        }\\n        return Do(s,0);\\n    }\\n    public int Do(String s,int index){\\n        if(s.isEmpty())\\n            return 0;\\n        if(dp[index]!=null)\\n            return dp[index];\\n        int ops=1;\\n        for(int i=1;i<=s.length()/2;i++){\\n            if(Do_check(s,i)){\\n                ops=Math.max(ops,1+Do(s.substring(i),index+i));\\n            }\\n        }\\n        dp[index]=ops;\\n        return ops;\\n    }\\n    public boolean Do_check(String s,int len){\\n        String s1=s.substring(0,len);\\n        String s2=s.substring(len,2*len);\\n        return s1.compareTo(s2)==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer []dp;\\n    public int deleteString(String s){\\n        HashMap<Character,Integer> map1=new HashMap<>();\\n        dp=new Integer[s.length()];\\n        for(char ch:s.toCharArray()){\\n            map1.put(ch,map1.getOrDefault(ch,0)+1);\\n        }\\n        if(map1.size()==1){\\n            int ans=0;\\n            for(char val:map1.keySet())\\n                ans=map1.get(val);\\n            return ans;\\n        }\\n        return Do(s,0);\\n    }\\n    public int Do(String s,int index){\\n        if(s.isEmpty())\\n            return 0;\\n        if(dp[index]!=null)\\n            return dp[index];\\n        int ops=1;\\n        for(int i=1;i<=s.length()/2;i++){\\n            if(Do_check(s,i)){\\n                ops=Math.max(ops,1+Do(s.substring(i),index+i));\\n            }\\n        }\\n        dp[index]=ops;\\n        return ops;\\n    }\\n    public boolean Do_check(String s,int len){\\n        String s1=s.substring(0,len);\\n        String s2=s.substring(len,2*len);\\n        return s1.compareTo(s2)==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648839,
                "title": "dp-recursive-with-explaination",
                "content": "\\nIntiution :\\n1). instead of first confirming by in O(n2) that we have same prefix and suffix for an index we just divide the string at every index\\nand then in next call first we check if the suffix is same as prefix and if not we can only delete using 1 step so we return 0 because we have \\nalready added the step in the previous call\\n2). If suffix is same as prefix and we can divide the string here using step 2 and we see that if we can divide string further.\\n\\n**if(1+temp == n-st)return dp[st] = 1+temp**; this check should be added so as to not cause extra computations which will cause tle , it is checking if the string from here contains all same character than this is the maximum division we can get . as string containg same character gives (len of string) divisions\\neg: \"aaaa\" max div = 4\\n\\n```\\nclass Solution {\\n    int solve(string&s,int st,int last,vector<int>&dp){\\n        int n =  (int)s.size();\\n        int add = (st-last);\\n        if((st + add - 1) >= n)return 0;\\n        \\n        int j = 0;\\n        for(int k = last; k<st; k++){\\n            if(s[k] != s[st+j])return 0;\\n            j++;\\n        }\\n        \\n        if(dp[st] != -1)return dp[st];\\n        \\n        int ans = 0 ;\\n        for(int i = st; i<n; i++){\\n            int temp = solve(s,i+1,st,dp);\\n            if(1+temp == n-st)return dp[st] = 1+temp;\\n            ans = max(ans,1+temp);\\n        }\\n        return dp[st] = ans;   \\n    }\\npublic:\\n    int deleteString(string s) {\\n        int n = (int)s.size();\\n        vector<int>dp(n+1,-1);\\n        return solve(s,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int solve(string&s,int st,int last,vector<int>&dp){\\n        int n =  (int)s.size();\\n        int add = (st-last);\\n        if((st + add - 1) >= n)return 0;\\n        \\n        int j = 0;\\n        for(int k = last; k<st; k++){\\n            if(s[k] != s[st+j])return 0;\\n            j++;\\n        }\\n        \\n        if(dp[st] != -1)return dp[st];\\n        \\n        int ans = 0 ;\\n        for(int i = st; i<n; i++){\\n            int temp = solve(s,i+1,st,dp);\\n            if(1+temp == n-st)return dp[st] = 1+temp;\\n            ans = max(ans,1+temp);\\n        }\\n        return dp[st] = ans;   \\n    }\\npublic:\\n    int deleteString(string s) {\\n        int n = (int)s.size();\\n        vector<int>dp(n+1,-1);\\n        return solve(s,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648695,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    int[] dp;\\n    public int deleteString(String s) {\\n        dp = new int[s.length()];\\n        return helper(s, 0);\\n    }\\n    \\n    int helper(String s, int start) {\\n        if(start == s.length()) {\\n            return 0;\\n        }\\n        \\n        if(dp[start] != 0) {\\n            return dp[start];\\n        }\\n        \\n        int ans = 1;\\n        for(int i=start; i<s.length(); i++) {\\n            if(i>start && s.charAt(i) == s.charAt(i-1)) continue;\\n            if(i+1 + (i+1-start) <= s.length() && s.substring(start, i+1).equals(s.substring(i+1, i+1 + (i+1-start)))) {\\n                ans = Math.max(ans, 1 + helper(s, i+1));\\n            }\\n        }\\n        \\n        dp[start] = ans;\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int[] dp;\\n    public int deleteString(String s) {\\n        dp = new int[s.length()];\\n        return helper(s, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2648668,
                "title": "c-rolling-hash-and-dp-o-n-2",
                "content": "1. Reverse the string so that we can delete letters from back.\\n\\n2. Use bottom up method to construct dp which means the maximum number of operations needed to delete the first `i` letters.\\n\\n3. In each iteration, `j` is the number of letters I try to delete, `a` and `b` are the hash of those two substrings. I use unsigned long long and 31 as BASE to hash the substring and start rolling hash, which can avoid overflow and collision.\\n\\n4. If `a` equal to `b`, update `dp[i]`.\\n\\n5. The answer is dp[n].\\n\\n```\\n#define ull unsigned long long\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n = s.size(), BASE = 31;\\n        reverse(s.begin(), s.end());\\n        vector<int> dp(n+1);\\n        dp[1] = 1;\\n        for(int i = 2 ; i <= n; i++){\\n            dp[i] = 1;\\n            ull a = s[i-1]-\\'a\\', b = s[i-2]-\\'a\\', pow = 1;\\n            if(a == b) dp[i] = max(dp[i], 1+dp[i-1]);\\n            for(int j = 2; j <= i/2; j++){\\n                a = a*BASE+(s[i-j]-\\'a\\');\\n                b = (b-(s[i-j]-\\'a\\')*pow)*BASE*BASE+(s[i-j-j+1]-\\'a\\')*BASE+(s[i-j-j]-\\'a\\');\\n                pow *= BASE;\\n                if(a == b) dp[i] = max(dp[i], 1+dp[i-j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```\\n#define ull unsigned long long\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n = s.size(), BASE = 31;\\n        reverse(s.begin(), s.end());\\n        vector<int> dp(n+1);\\n        dp[1] = 1;\\n        for(int i = 2 ; i <= n; i++){\\n            dp[i] = 1;\\n            ull a = s[i-1]-\\'a\\', b = s[i-2]-\\'a\\', pow = 1;\\n            if(a == b) dp[i] = max(dp[i], 1+dp[i-1]);\\n            for(int j = 2; j <= i/2; j++){\\n                a = a*BASE+(s[i-j]-\\'a\\');\\n                b = (b-(s[i-j]-\\'a\\')*pow)*BASE*BASE+(s[i-j-j+1]-\\'a\\')*BASE+(s[i-j-j]-\\'a\\');\\n                pow *= BASE;\\n                if(a == b) dp[i] = max(dp[i], 1+dp[i-j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918659,
                "title": "python3-solution-dp-clean-concise",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def deleteString(self, S):\\n        N = len(S)\\n        if S.count(S[0]) == N: return N\\n        P = [0] * (N + 1)\\n        dp = [1] * N\\n        for i in range(N - 1, -1, -1):\\n            for j in range(i + 1, N):\\n                P[j] = P[j + 1] + 1 if S[i] == S[j] else 0\\n                if P[j] >= j - i:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def deleteString(self, S):\\n        N = len(S)\\n        if S.count(S[0]) == N: return N\\n        P = [0] * (N + 1)\\n        dp = [1] * N\\n        for i in range(N - 1, -1, -1):\\n            for j in range(i + 1, N):\\n                P[j] = P[j + 1] + 1 if S[i] == S[j] else 0\\n                if P[j] >= j - i:\\n                    dp[i] = max(dp[i], dp[j] + 1)\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729798,
                "title": "dp-no-tle-python",
                "content": "\\nI have noticed so many TLE in discuss topics and accepted solutions\\nHere is one solution avoid TLE.\\n\\nThis is a DP. I would not discuss it much for it.\\n\\nThe tiny adjustments all together get rid of the TLE.\\n\\nThe first one and most important one is the repeating leading character, like aaaaa....others...\\nwithout optimize, it will be O(N^2), while this problem, it is in fact O(N) \\nfind the first one not repeat the leading, then initial the array like [1,2,3,4,5......,0,0,0,0]\\n```\\nz = list(range(1,i + 2)) + ([0] * (L - i - 1))  \\n```\\n\\nThe second is also very important. \\nLet me name the position after remove substring is \\'stop point\\'\\nIt is easy to figure out that the stop point will never fall on a charater who is not equal to the first character.\\nignore them, will signaficently save time.\\n```\\nif s[i] == s0:\\n```\\n\\nsimilar we check only succeed valid stop points, so it is not neccessary to check each position, but just the stop point.\\n```\\nfor j in t[::-1]: \\n```\\nI have do it in reversed order. As I guess that is true for most situation that the nearer position makes more score. While that is not always true, so we do not ignore the positions but just make less strings compareation and assignment to the current max score.\\n```\\nif  x < z[j] and s[j:i] == s[i: i + i - j]:\\n```\\nWe can break the loop when the longest string has been checked.\\n```\\nif j < i + i - L:\\n```\\n\\nComplete code\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int: \\n        L = len(s)\\n        # check leading repeating characters\\n        for i, c in enumerate(s[1:]) :\\n            if s[0] != c: \\n                z = list(range(1,i + 2)) + ([0] * (L - i - 1))  \\n                break\\n        else:\\n            # all same \\n            return L \\n        s0 = s[0]\\n        t = list(range(i+1)) \\n        for i in range(i+2  , L):\\n            # ignore unecessary case\\n            if s[i] == s0:\\n                x = 0\\n                # important to check lastest first\\n                for j in t[::-1]: \\n                    # important to not waste on longer \\n                    if j < i + i - L:\\n                        break\\n                    # check best result to avoid compare the string \\n                    #if  x < z[j] and s.startswith(s[j:i],i ):\\n                    if  x < z[j] and s[j:i] == s[i: i + i - j]:\\n                        x = z[j]\\n                # if this is a possible stop point, record it\\n                if x:\\n                    t.append(i)\\n                    z[i] = x + 1 \\n        return  max(z)\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nz = list(range(1,i + 2)) + ([0] * (L - i - 1))  \\n```\n```\\nif s[i] == s0:\\n```\n```\\nfor j in t[::-1]: \\n```\n```\\nif  x < z[j] and s[j:i] == s[i: i + i - j]:\\n```\n```\\nif j < i + i - L:\\n```\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int: \\n        L = len(s)\\n        # check leading repeating characters\\n        for i, c in enumerate(s[1:]) :\\n            if s[0] != c: \\n                z = list(range(1,i + 2)) + ([0] * (L - i - 1))  \\n                break\\n        else:\\n            # all same \\n            return L \\n        s0 = s[0]\\n        t = list(range(i+1)) \\n        for i in range(i+2  , L):\\n            # ignore unecessary case\\n            if s[i] == s0:\\n                x = 0\\n                # important to check lastest first\\n                for j in t[::-1]: \\n                    # important to not waste on longer \\n                    if j < i + i - L:\\n                        break\\n                    # check best result to avoid compare the string \\n                    #if  x < z[j] and s.startswith(s[j:i],i ):\\n                    if  x < z[j] and s[j:i] == s[i: i + i - j]:\\n                        x = z[j]\\n                # if this is a possible stop point, record it\\n                if x:\\n                    t.append(i)\\n                    z[i] = x + 1 \\n        return  max(z)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2662981,
                "title": "c-dp-string-hashing",
                "content": "Insights:\\n- it should pretty obvious this problem have a dp structure\\n- At each subproblem, we need to do O(n) string comparions: s[i..i+len] == s[i+len..i+len+len]. Since there\\'s O(n) subproblems, we want to make string comparison O(1)\\n\\nidea:\\n- dp[i]: max deletion at position i\\n- use string hashing to cacluate a prefix of hashes. then we can remove the prefix and comapre the hash values in O(1)\\n\\nIf you\\'re new to string hashing, please checkout this article: https://cp-algorithms.com/string/string-hashing.html\\n\\nImplementation:\\n  \\n ```\\n  int deleteString(string s) {\\n        vector<int> dp(s.size(), 0);\\n        int p = 31;\\n        int m = 1e9+9;\\n        using ll = long long;\\n        vector<ll> H(s.size()+1, 0), P(s.size()+1, 1);\\n        for (int i = 0; i < s.size(); ++i) {\\n            H[i+1] = (H[i]+(s[i]-\\'a\\'+1)*P[i])%m;\\n            P[i+1] = (P[i]*p)%m;\\n        }\\n        \\n        auto hash = [&](int i, int len) -> ll {\\n            ll res = H[i+len]-H[i];\\n            if (res < 0) res += m;\\n            return res;\\n        };\\n        auto eq = [&](int i, int j) -> bool {\\n            int len = j-i;\\n            return (hash(i, len) * P[len]) % m == hash(j, len);\\n        };\\n        \\n        function<int(int)> dfs = [&](int i) {\\n            auto& res = dp[i];\\n            if (res > 0) return res;\\n            res = 1;\\n            for (int j = i+1; j < s.size() && j-i <= s.size()-j; ++j) {\\n                if (eq(i, j)) res = max(res, 1+dfs(j));\\n            }\\n            return res;\\n        };\\n        return dfs(0);\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Insights:\\n- it should pretty obvious this problem have a dp structure\\n- At each subproblem, we need to do O(n) string comparions: s[i..i+len] == s[i+len..i+len+len]. Since there\\'s O(n) subproblems, we want to make string comparison O(1)\\n\\nidea:\\n- dp[i]: max deletion at position i\\n- use string hashing to cacluate a prefix of hashes. then we can remove the prefix and comapre the hash values in O(1)\\n\\nIf you\\'re new to string hashing, please checkout this article: https://cp-algorithms.com/string/string-hashing.html\\n\\nImplementation:\\n  \\n ```\\n  int deleteString(string s) {\\n        vector<int> dp(s.size(), 0);\\n        int p = 31;\\n        int m = 1e9+9;\\n        using ll = long long;\\n        vector<ll> H(s.size()+1, 0), P(s.size()+1, 1);\\n        for (int i = 0; i < s.size(); ++i) {\\n            H[i+1] = (H[i]+(s[i]-\\'a\\'+1)*P[i])%m;\\n            P[i+1] = (P[i]*p)%m;\\n        }\\n        \\n        auto hash = [&](int i, int len) -> ll {\\n            ll res = H[i+len]-H[i];\\n            if (res < 0) res += m;\\n            return res;\\n        };\\n        auto eq = [&](int i, int j) -> bool {\\n            int len = j-i;\\n            return (hash(i, len) * P[len]) % m == hash(j, len);\\n        };\\n        \\n        function<int(int)> dfs = [&](int i) {\\n            auto& res = dp[i];\\n            if (res > 0) return res;\\n            res = 1;\\n            for (int j = i+1; j < s.size() && j-i <= s.size()-j; ++j) {\\n                if (eq(i, j)) res = max(res, 1+dfs(j));\\n            }\\n            return res;\\n        };\\n        return dfs(0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2656847,
                "title": "easy-recursive-solution-java-100-time",
                "content": "```\\nclass Solution {\\n    private Map<Integer, Integer> hm;\\n    \\n    public int deleteString(String s) {\\n        hm = new HashMap<>();\\n        \\n        return helper(s, 0);\\n    }\\n    \\n    private int helper(String s, int ind) {\\n        if (ind == s.length()) {\\n            return 0;\\n        }\\n        if (hm.containsKey(ind)) {\\n            return hm.get(ind);\\n        }\\n        \\n        int max = 1;\\n        int len = 2;\\n        \\n        for (int i = ind + 1; i < s.length(); ++i) {\\n            if ((i - len / 2) >= ind && s.charAt(i) != s.charAt(i - len / 2)) {\\n                if (len < (i - ind) * 2) {\\n                    len = (i - ind) * 2;\\n                    i--;\\n                }\\n                else {\\n                    len = (i - ind + 1) * 2; \\n                }\\n                \\n            }\\n            if (len == i + 1 - ind) {\\n                max = Math.max(max, 1 + helper(s, i - len / 2 + 1));\\n            }\\n        }\\n        \\n        hm.put(ind, max);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Map<Integer, Integer> hm;\\n    \\n    public int deleteString(String s) {\\n        hm = new HashMap<>();\\n        \\n        return helper(s, 0);\\n    }\\n    \\n    private int helper(String s, int ind) {\\n        if (ind == s.length()) {\\n            return 0;\\n        }\\n        if (hm.containsKey(ind)) {\\n            return hm.get(ind);\\n        }\\n        \\n        int max = 1;\\n        int len = 2;\\n        \\n        for (int i = ind + 1; i < s.length(); ++i) {\\n            if ((i - len / 2) >= ind && s.charAt(i) != s.charAt(i - len / 2)) {\\n                if (len < (i - ind) * 2) {\\n                    len = (i - ind) * 2;\\n                    i--;\\n                }\\n                else {\\n                    len = (i - ind + 1) * 2; \\n                }\\n                \\n            }\\n            if (len == i + 1 - ind) {\\n                max = Math.max(max, 1 + helper(s, i - len / 2 + 1));\\n            }\\n        }\\n        \\n        hm.put(ind, max);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656689,
                "title": "python-3-dp-bottom-up-substr-hash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute-force approach runs O(S**3) time, S = s.length().\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo reduce run-time to O(S**2), this comparison (s[i:j] == s[j+k])within DP loops needs to be reduced from linear to constant time. I use Rabin-Karp hash approach to reduce run-time to constant.\\nThe hash BASE value is 26 (only lower case alphas in s).\\n\\n# Complexity\\n- Time complexity: O(S**2).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(S), linear space due to caching recursive DP function + substr hashes.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        if len(set(s)) == 1:     return len(s)\\n\\n        MOD = 10**10 + 7    #use MODulus to avoid large int in python.\\n        BASE = 26 + 1       #base 26, lower case alphas only.\\n        s_hash  =   [0]     #prefix hash of s.\\n        for char in s:\\n            ordChar    =   ord(char.lower()) - ord(\\'a\\') + 1\\n            s_hash.append(  (s_hash[-1] * BASE + ordChar) % MOD  )\\n\\n        #caching pow function to reduce the runtime.\\n        @functools.lru_cache(   maxsize    =   None)\\n        def my_pow( power):\\n            return pow( BASE,   power,  MOD)\\n\\n        #get the hash value for substr s. Assuming average constant runtime for my_pow().\\n        @functools.lru_cache(   maxsize    =   None)\\n        def get_substr_hash(    startIndex, endIndex):\\n            #return substr[startIndex: endIndex] hash value.\\n            nonlocal s_hash, s\\n            if endIndex > len(s):  return -1\\n            return  (s_hash[endIndex] - s_hash[startIndex] * my_pow(   endIndex - startIndex))%MOD\\n\\n        #DP bottom-up using recursive function calls.\\n        #RUNTIME: O(S**2), SPACE: O(S). S = s.length(), assuming the get_substr_hash() has constant run-time averagely.\\n        @functools.lru_cache(   maxsize    =   None)\\n        def traverse_str(   startIndex  =   0):\\n            nonlocal s\\n\\n            if startIndex >= len(s):    return 0\\n            numOps =   1\\n            for midIndex in range(  startIndex+1, len(s)):\\n                substrLength    =   midIndex-startIndex\\n                #if s[startIndex:startIndex+substrLength] == s[midIndex:midIndex+substrLength]:\\n                if  get_substr_hash(    startIndex, startIndex+substrLength) == get_substr_hash(    midIndex, midIndex+substrLength):\\n                    numOps= max(    numOps, 1 + traverse_str(   midIndex)  )\\n            return numOps\\n        \\n        maxOps  =   traverse_str()\\n\\n        #cleaning up memory before exit.\\n        traverse_str.cache_clear()\\n        my_pow.cache_clear()\\n        get_substr_hash.cache_clear()\\n        \\n        return maxOps\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        if len(set(s)) == 1:     return len(s)\\n\\n        MOD = 10**10 + 7    #use MODulus to avoid large int in python.\\n        BASE = 26 + 1       #base 26, lower case alphas only.\\n        s_hash  =   [0]     #prefix hash of s.\\n        for char in s:\\n            ordChar    =   ord(char.lower()) - ord(\\'a\\') + 1\\n            s_hash.append(  (s_hash[-1] * BASE + ordChar) % MOD  )\\n\\n        #caching pow function to reduce the runtime.\\n        @functools.lru_cache(   maxsize    =   None)\\n        def my_pow( power):\\n            return pow( BASE,   power,  MOD)\\n\\n        #get the hash value for substr s. Assuming average constant runtime for my_pow().\\n        @functools.lru_cache(   maxsize    =   None)\\n        def get_substr_hash(    startIndex, endIndex):\\n            #return substr[startIndex: endIndex] hash value.\\n            nonlocal s_hash, s\\n            if endIndex > len(s):  return -1\\n            return  (s_hash[endIndex] - s_hash[startIndex] * my_pow(   endIndex - startIndex))%MOD\\n\\n        #DP bottom-up using recursive function calls.\\n        #RUNTIME: O(S**2), SPACE: O(S). S = s.length(), assuming the get_substr_hash() has constant run-time averagely.\\n        @functools.lru_cache(   maxsize    =   None)\\n        def traverse_str(   startIndex  =   0):\\n            nonlocal s\\n\\n            if startIndex >= len(s):    return 0\\n            numOps =   1\\n            for midIndex in range(  startIndex+1, len(s)):\\n                substrLength    =   midIndex-startIndex\\n                #if s[startIndex:startIndex+substrLength] == s[midIndex:midIndex+substrLength]:\\n                if  get_substr_hash(    startIndex, startIndex+substrLength) == get_substr_hash(    midIndex, midIndex+substrLength):\\n                    numOps= max(    numOps, 1 + traverse_str(   midIndex)  )\\n            return numOps\\n        \\n        maxOps  =   traverse_str()\\n\\n        #cleaning up memory before exit.\\n        traverse_str.cache_clear()\\n        my_pow.cache_clear()\\n        get_substr_hash.cache_clear()\\n        \\n        return maxOps\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654972,
                "title": "top-down-memoization-1d-dp-solution-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> dp;\\n\\t\\tint f(int i,string_view& s){\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tif(i==n-1)return 1;\\n\\t\\t\\tif(i>n-1)return 0;\\n\\t\\t\\tif(dp[i]!=-1)return dp[i];\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int j=i;j<((i+n)%2==0 ? (i+n)/2 : ((i+n)/2 + 1));j++){\\n\\t\\t\\t\\tstring_view t = s.substr(i,j-i+1);\\n\\t\\t\\t\\tstring_view v = s.substr(j+1,j-i+1);\\n\\n\\t\\t\\t\\tif(t==v){\\n\\t\\t\\t\\t\\tans = max(ans,1+f(j+1,s));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i] =  max(ans,1);\\n\\t\\t}\\n\\t\\tint deleteString(string s) {\\n\\t\\t\\tdp.assign(4500,-1);\\n\\t\\t\\tstring_view sv({s.c_str(), s.size()});\\n\\t\\t\\treturn f(0,sv);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> dp;\\n\\t\\tint f(int i,string_view& s){\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tif(i==n-1)return 1;\\n\\t\\t\\tif(i>n-1)return 0;\\n\\t\\t\\tif(dp[i]!=-1)return dp[i];\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int j=i;j<((i+n)%2==0 ? (i+n)/2 : ((i+n)/2 + 1));j++){\\n\\t\\t\\t\\tstring_view t = s.substr(i,j-i+1);\\n\\t\\t\\t\\tstring_view v = s.substr(j+1,j-i+1);\\n\\n\\t\\t\\t\\tif(t==v){\\n\\t\\t\\t\\t\\tans = max(ans,1+f(j+1,s));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2653723,
                "title": "expected-result-for-aaabaab-should-be-5-but-it-is-given-4",
                "content": "\"**a**aabaab\" (Remove first a) -> \"aaba**a**b\" (Remove last second a) -> \"aab**ab**\" (Remove ab) -> \"**a**ab\" (Remove a) -> \"ab\" (Remove ab) -> \"\"\\n\\nSo the maximum operations should be 5 right? Why is it given as 4? Am I missing something? Please help",
                "solutionTags": [],
                "code": "\"**a**aabaab\" (Remove first a) -> \"aaba**a**b\" (Remove last second a) -> \"aab**ab**\" (Remove ab) -> \"**a**ab\" (Remove a) -> \"ab\" (Remove ab) -> \"\"\\n\\nSo the maximum operations should be 5 right? Why is it given as 4? Am I missing something? Please help",
                "codeTag": "Unknown"
            },
            {
                "id": 2653436,
                "title": "python-simple-dfs",
                "content": "This is a simple AC solution for this problem though the part where I check if all chars are the same is a hack since you can still get stackoverflow for cases like `aaaa...aaaax`:\\n\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        @lru_cache(None)\\n        def dfs(w: str) -> int:\\n            if not w:\\n                return 0\\n\\n            res = 1\\n            for i in range(1, len(w)):\\n                pre = w[:i]\\n                after = w[i:]\\n                if after.startswith(pre):\\n                    res = max(res, 1 + dfs(after))\\n            return res\\n\\n        return len(s) if len(set(s)) == 1 else dfs(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        @lru_cache(None)\\n        def dfs(w: str) -> int:\\n            if not w:\\n                return 0\\n\\n            res = 1\\n            for i in range(1, len(w)):\\n                pre = w[:i]\\n                after = w[i:]\\n                if after.startswith(pre):\\n                    res = max(res, 1 + dfs(after))\\n            return res\\n\\n        return len(s) if len(set(s)) == 1 else dfs(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653165,
                "title": "python-fastest",
                "content": "The only case that is considered separately is the case that all chars are the same.\\n\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        if len(set(s)) == 1: return len(s)\\n        @cache\\n        def dp(i):\\n            ans = 1\\n            for j in range(i + 1, len(s)):\\n                if s[i] == s[j] and s[i:j] == s[j:2*j-i]:\\n                    ans = max(ans, 1 + dp(j))\\n            return ans\\n        \\n        return dp(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        if len(set(s)) == 1: return len(s)\\n        @cache\\n        def dp(i):\\n            ans = 1\\n            for j in range(i + 1, len(s)):\\n                if s[i] == s[j] and s[i:j] == s[j:2*j-i]:\\n                    ans = max(ans, 1 + dp(j))\\n            return ans\\n        \\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653091,
                "title": "184ms-beat-100-branch-and-bound-dp-solution",
                "content": "In the for loop, we add an additional condition 1+s.size() - (st+i) > dp[st]. The condition implies that given the i, the largest possible number operations for s[st+i:] deletion is deleting one character at a time. However, if the remaing length of the string(s[st+i:]) is less than dp[st], which means the maximum operation for s[st+i:] deletion is less than dp[st], and there is no need to continue the for loop iteration.\\n```\\nclass Solution {\\npublic:\\n    int dfs(string &s, int st, vector<int> &dp){\\n        if(st == s.size())  return 0;\\n        if(dp[st] != 0) return dp[st];\\n        dp[st] = 1;\\n        for(int i = 1 ; i <= (s.size()-st) / 2 && 1 + s.size() - (st+i) > dp[st] ; i++){\\n            if(s.compare(st,i,&s[st+i],i) == 0){\\n                dp[st] = max(dp[st],dfs(s,st+i,dp)+1);\\n            }\\n        }\\n        return dp[st];\\n    }\\n    int deleteString(string s) {\\n        vector<int> dp(s.size(),0);\\n        return dfs(s, 0, dp);\\n    }\\n};\\n\\n/*\\nstring len 4000\\nO(n^2)\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(string &s, int st, vector<int> &dp){\\n        if(st == s.size())  return 0;\\n        if(dp[st] != 0) return dp[st];\\n        dp[st] = 1;\\n        for(int i = 1 ; i <= (s.size()-st) / 2 && 1 + s.size() - (st+i) > dp[st] ; i++){\\n            if(s.compare(st,i,&s[st+i],i) == 0){\\n                dp[st] = max(dp[st],dfs(s,st+i,dp)+1);\\n            }\\n        }\\n        return dp[st];\\n    }\\n    int deleteString(string s) {\\n        vector<int> dp(s.size(),0);\\n        return dfs(s, 0, dp);\\n    }\\n};\\n\\n/*\\nstring len 4000\\nO(n^2)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652725,
                "title": "c-solution-dp-rolling-hash",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int hash[4001][4001];\\n    vector<int> dp;\\n    int M = 1e9 + 7;\\n    int dfs(string &s, int i) {\\n        if(i >= s.size()) return 0;\\n        if(dp[i] >= 0) return dp[i];\\n        int res = 1;\\n        for(int j = i + 1; j + j - i <= s.size(); j++) {\\n            if(hash[i][i + j - i - 1] == hash[j][j + j - i - 1])\\n                res = max(res, 1 + dfs(s, j));\\n        }\\n        return dp[i] = res;\\n    }\\n    int deleteString(string s) {\\n        dp.resize(s.size(), -1);\\n        for(int i = 0; i < s.size(); i++) {\\n            long long sum = 0, p = 1;\\n            for(int j = i; j < s.size(); j++) {\\n                hash[i][j] = sum = (sum + s[j] * p) % M;\\n                p = (p * 31) % M;\\n            }\\n        }\\n        int res = dfs(s, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hash[4001][4001];\\n    vector<int> dp;\\n    int M = 1e9 + 7;\\n    int dfs(string &s, int i) {\\n        if(i >= s.size()) return 0;\\n        if(dp[i] >= 0) return dp[i];\\n        int res = 1;\\n        for(int j = i + 1; j + j - i <= s.size(); j++) {\\n            if(hash[i][i + j - i - 1] == hash[j][j + j - i - 1])\\n                res = max(res, 1 + dfs(s, j));\\n        }\\n        return dp[i] = res;\\n    }\\n    int deleteString(string s) {\\n        dp.resize(s.size(), -1);\\n        for(int i = 0; i < s.size(); i++) {\\n            long long sum = 0, p = 1;\\n            for(int j = i; j < s.size(); j++) {\\n                hash[i][j] = sum = (sum + s[j] * p) % M;\\n                p = (p * 31) % M;\\n            }\\n        }\\n        int res = dfs(s, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652686,
                "title": "python3-top-down-dp-pruning-o-n-3-1233ms",
                "content": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        if all(x == s[0] for x in s):\\n            return len(s)\\n               \\n        @cache\\n        def dfs(currIdx):\\n            length = len(s) - currIdx\\n            if length == 1:\\n                return 1\\n            res = 1\\n            for l in range(1, length//2+1):\\n                if len(s) - currIdx - l + 1 <= res:  # pruning\\n                    break\\n                if s[currIdx:currIdx+l] == s[currIdx+l:currIdx+2*l]:\\n                    res = max(res, 1 + dfs(currIdx+l))\\n            return res\\n                    \\n        res = dfs(0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        if all(x == s[0] for x in s):\\n            return len(s)\\n               \\n        @cache\\n        def dfs(currIdx):\\n            length = len(s) - currIdx\\n            if length == 1:\\n                return 1\\n            res = 1\\n            for l in range(1, length//2+1):\\n                if len(s) - currIdx - l + 1 <= res:  # pruning\\n                    break\\n                if s[currIdx:currIdx+l] == s[currIdx+l:currIdx+2*l]:\\n                    res = max(res, 1 + dfs(currIdx+l))\\n            return res\\n                    \\n        res = dfs(0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652536,
                "title": "c-dp-and-kmp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(string& s, int u, vector<int>& dp) {\\n        if(u == s.size()) {\\n            return 0; \\n        }\\n        if(dp[u] != 0) {\\n            return dp[u];\\n        }\\n        // starts with u. \\n        string_view tmp = s; \\n        tmp = tmp.substr(u);\\n        vector<int> next(tmp.size());\\n        int j = -1;\\n        next[0] = -1; \\n        for(int i = 1;i<tmp.size();i++) {\\n            while(j>=0 && tmp[j+1] != tmp[i]) {\\n                j = next[j];\\n            }\\n            if(tmp[j+1] == tmp[i]) {\\n                j++; \\n            }\\n            next[i] = j; \\n        }\\n        int ret = 1; \\n        for(int i = 0;i<tmp.size();i++) {\\n            int len = i + 1; \\n            int matched = next[i] + 1; \\n            if(len == matched * 2) {\\n                ret = max(ret, f(s,u + matched,dp) + 1);\\n            }\\n        }\\n        return dp[u] = ret; \\n    }\\n    \\n    int deleteString(string s) {\\n        vector<int> dp(s.size()+5);\\n        return f(s, 0, dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(string& s, int u, vector<int>& dp) {\\n        if(u == s.size()) {\\n            return 0; \\n        }\\n        if(dp[u] != 0) {\\n            return dp[u];\\n        }\\n        // starts with u. \\n        string_view tmp = s; \\n        tmp = tmp.substr(u);\\n        vector<int> next(tmp.size());\\n        int j = -1;\\n        next[0] = -1; \\n        for(int i = 1;i<tmp.size();i++) {\\n            while(j>=0 && tmp[j+1] != tmp[i]) {\\n                j = next[j];\\n            }\\n            if(tmp[j+1] == tmp[i]) {\\n                j++; \\n            }\\n            next[i] = j; \\n        }\\n        int ret = 1; \\n        for(int i = 0;i<tmp.size();i++) {\\n            int len = i + 1; \\n            int matched = next[i] + 1; \\n            if(len == matched * 2) {\\n                ret = max(ret, f(s,u + matched,dp) + 1);\\n            }\\n        }\\n        return dp[u] = ret; \\n    }\\n    \\n    int deleteString(string s) {\\n        vector<int> dp(s.size()+5);\\n        return f(s, 0, dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651966,
                "title": "c-dp-solution",
                "content": "```\\nint dfs(int i, string &s, vector<int>&dp)\\n    {\\n        if(dp[i]!=-1)   return dp[i];\\n        int ans=0;\\n        for(int k=i+1;k<s.size();k++)\\n        {\\n            if(2*k-i<=s.size() && s.compare(i,k-i,s,k,k-i)==0) // check for two continuous substrings are equal or not \\n            {\\n                ans= max(ans, 1+ dfs(k,s,dp));  // max moves from all possibles answers\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n    \\n    int deleteString(string s) {\\n        \\n        vector<int>dp(s.size()+1,-1); \\n        return dfs(0,s,dp)+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint dfs(int i, string &s, vector<int>&dp)\\n    {\\n        if(dp[i]!=-1)   return dp[i];\\n        int ans=0;\\n        for(int k=i+1;k<s.size();k++)\\n        {\\n            if(2*k-i<=s.size() && s.compare(i,k-i,s,k,k-i)==0) // check for two continuous substrings are equal or not \\n            {\\n                ans= max(ans, 1+ dfs(k,s,dp));  // max moves from all possibles answers\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n    \\n    int deleteString(string s) {\\n        \\n        vector<int>dp(s.size()+1,-1); \\n        return dfs(0,s,dp)+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651574,
                "title": "java-memoization",
                "content": "```\\nclass Solution {\\n    Integer[] dp = new Integer[4001];\\n    public int deleteString(String s) {\\n        return helper(s, 0);\\n    }\\n    \\n    public int helper(String s, int idx) {\\n        if (idx == s.length()) return 0;\\n        if (dp[idx] != null) {\\n            return dp[idx];\\n        }\\n        int answer = 1;\\n        for (int i = idx; 2 * i <= s.length() - 2 + idx; i++) {\\n            if (dp[i + 1] != null) continue;\\n            int len = i - idx + 1;\\n            if (s.substring(idx, idx + len).equals(s.substring(idx + len, idx + 2 * len))) {\\n                answer = Math.max(answer, 1 + helper(s, i + 1));\\n            }\\n        }\\n        return dp[idx] = answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    Integer[] dp = new Integer[4001];\\n    public int deleteString(String s) {\\n        return helper(s, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2651473,
                "title": "java-dp-move-backward-short-and-readable-codes",
                "content": "Using int array to remember from this char to end, what\\'s the max deletions.\\n\\nIn each index, if its first j chars matchs next j chars, then current deletion can be current index + j\\'s deletion + 1.\\n\\n```\\nclass Solution {\\n    public int deleteString(String s) {\\n        char[] chars = s.toCharArray();\\n        int n = chars.length;\\n        int[] count = new int[n];\\n        count[n - 1] = 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n        \\tcount[i] = 1;\\n        \\tint max = (n - i) / 2;\\n        \\tfor (int j = 1; j <= max; j++) {\\n        \\t\\tif (count[i] < count[i + j] + 1 && match(chars, i, j))\\n        \\t\\t\\tcount[i] = Math.max(count[i], count[i + j] + 1);\\n        \\t}\\n        }\\n        return count[0];\\n    }\\n\\t\\n\\tprivate static boolean match(char[] chars, int start, int len) {\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (chars[start + i] != chars[start + len + i])\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int deleteString(String s) {\\n        char[] chars = s.toCharArray();\\n        int n = chars.length;\\n        int[] count = new int[n];\\n        count[n - 1] = 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n        \\tcount[i] = 1;\\n        \\tint max = (n - i) / 2;\\n        \\tfor (int j = 1; j <= max; j++) {\\n        \\t\\tif (count[i] < count[i + j] + 1 && match(chars, i, j))\\n        \\t\\t\\tcount[i] = Math.max(count[i], count[i + j] + 1);\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 2651242,
                "title": "100-faster-c-intuitive-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt each index we will try deleting the substring from the current index. We have to options to delete the substring from the current index either we can delete complete string which will lead us minimum operations or we can find a match to delete via option 2. But as we have to maximize our operation we will search whether we can delete by option 2. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the substring of the length i starting from the index  matches the substring of length i starting from the index+i. Then we can delete first i characters in 1 operation and can give the recursion call to index+i. \\n\\nRecurrence Relation is as follows - \\n\\nIf any match found, \\nDp[index] = max(Dp[index], 1 + solve(s,index+i,dp));\\n\\nElse if no match found, we have to delete the complete string in 1 operation\\nDp[index] = 1;\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    int solve(string &s,int index,vector<int>&dp)\\n    {  \\n        \\n        if(index>=s.size())\\n            return 0;\\n        \\n        if(dp[index]!=-1)\\n            return dp[index];\\n        \\n        bool flag = true;\\n        for(int i = index;i<s.size();i++)\\n        {\\n            if(s[i]!=s[index])\\n            {\\n                flag=false;\\n                break;\\n            }\\n               \\n        }\\n        if(flag)\\n             return dp[index] = s.size() - index;\\n        \\n        int ans = 1;\\n        \\n        for(int i = 1;i<=(s.size() - index)/2;i++)\\n        {\\n            bool flag = true;\\n            for(int j1 = index,j2 = index + i ;j1<index+i;j1++,j2++)\\n            {\\n                if(s[j1]!=s[j2])\\n                {\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n                ans = max(ans,1+solve(s,index+i,dp));\\n        }\\n        return dp[index] = ans;\\n    }\\npublic:\\n    int deleteString(string s) \\n    {   \\n        vector<int> dp(s.size(),-1);\\n        return solve(s,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n    int solve(string &s,int index,vector<int>&dp)\\n    {  \\n        \\n        if(index>=s.size())\\n            return 0;\\n        \\n        if(dp[index]!=-1)\\n            return dp[index];\\n        \\n        bool flag = true;\\n        for(int i = index;i<s.size();i++)\\n        {\\n            if(s[i]!=s[index])\\n            {\\n                flag=false;\\n                break;\\n            }\\n               \\n        }\\n        if(flag)\\n             return dp[index] = s.size() - index;\\n        \\n        int ans = 1;\\n        \\n        for(int i = 1;i<=(s.size() - index)/2;i++)\\n        {\\n            bool flag = true;\\n            for(int j1 = index,j2 = index + i ;j1<index+i;j1++,j2++)\\n            {\\n                if(s[j1]!=s[j2])\\n                {\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n                ans = max(ans,1+solve(s,index+i,dp));\\n        }\\n        return dp[index] = ans;\\n    }\\npublic:\\n    int deleteString(string s) \\n    {   \\n        vector<int> dp(s.size(),-1);\\n        return solve(s,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650435,
                "title": "python3-bruteforce-dp-solution",
                "content": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        @cache\\n        def dp(i):\\n            if i == len(s):\\n                return 0\\n            res = 1\\n            l = 1\\n            n = len(s) - i\\n            while l <= n // 2:\\n                if s[i:i + l] == s[i + l:i + l * 2]:\\n                    res = max(res, dp(i + l) + 1)\\n                l += 1\\n            return res\\n        if len(Counter(s)) == 1:\\n            return len(s)\\n        res = dp(0)\\n        dp.cache_clear()\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        @cache\\n        def dp(i):\\n            if i == len(s):\\n                return 0\\n            res = 1\\n            l = 1\\n            n = len(s) - i\\n            while l <= n // 2:\\n                if s[i:i + l] == s[i + l:i + l * 2]:\\n                    res = max(res, dp(i + l) + 1)\\n                l += 1\\n            return res\\n        if len(Counter(s)) == 1:\\n            return len(s)\\n        res = dp(0)\\n        dp.cache_clear()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650270,
                "title": "c-solution-using-z-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> z_function(string s) {\\n        reverse(s.begin(), s.end());\\n        int n = (int) s.length();\\n        vector<int> z(n);\\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n            if (i <= r)\\n                z[i] = min (r - i + 1, z[i - l]);\\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]])\\n                ++z[i];\\n            if (i + z[i] - 1 > r)\\n                l = i, r = i + z[i] - 1;\\n        }\\n        return z;\\n   }\\n\\n    int deleteString(string s) {\\n        string ss=\"\";\\n        int n=s.length();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        ss.push_back(s[n-1]);\\n        dp[n-1]=1;\\n        for(int i=n-2;i>=0;--i){\\n            ss.push_back(s[i]);\\n            vector<int> zz = z_function(ss);\\n            dp[i]=1;\\n            for(int j=1;j<zz.size();j++){\\n                if(zz[j]>=j){\\n                    dp[i]=max(dp[i], 1+dp[i+j]);\\n                }\\n            }\\n            zz.clear();\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> z_function(string s) {\\n        reverse(s.begin(), s.end());\\n        int n = (int) s.length();\\n        vector<int> z(n);\\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n            if (i <= r)\\n                z[i] = min (r - i + 1, z[i - l]);\\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]])\\n                ++z[i];\\n            if (i + z[i] - 1 > r)\\n                l = i, r = i + z[i] - 1;\\n        }\\n        return z;\\n   }\\n\\n    int deleteString(string s) {\\n        string ss=\"\";\\n        int n=s.length();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        ss.push_back(s[n-1]);\\n        dp[n-1]=1;\\n        for(int i=n-2;i>=0;--i){\\n            ss.push_back(s[i]);\\n            vector<int> zz = z_function(ss);\\n            dp[i]=1;\\n            for(int j=1;j<zz.size();j++){\\n                if(zz[j]>=j){\\n                    dp[i]=max(dp[i], 1+dp[i+j]);\\n                }\\n            }\\n            zz.clear();\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650249,
                "title": "java-dp-memo",
                "content": "```\\nclass Solution {\\n    boolean b=true;\\n    Map<String,Integer>map=new HashMap<>();\\n    public int deleteString(String s) { \\n        int c=0;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                c++;\\n            }\\n        }\\n        if(c==3999){\\n            return 4000;\\n        }\\n        int ans=solve(s);\\n        if(b){\\n            return ans+1;\\n        }\\n        return ans;\\n    }\\n    \\n    int solve(String s){\\n        if(s.length()==0){\\n            b=true;\\n            return 0;\\n        }\\n        if(map.containsKey(s)){\\n            return map.get(s);\\n        }\\n        int max=0;\\n        for(int i=0;i<s.length()/2;i++){\\n            if(s.substring(0,i+1).equals(s.substring(i+1,(2*(i+1))))){\\n                max=Math.max(max,1+solve(s.substring(i+1)));\\n            }\\n        }\\n        map.put(s,max);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean b=true;\\n    Map<String,Integer>map=new HashMap<>();\\n    public int deleteString(String s) { \\n        int c=0;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                c++;\\n            }\\n        }\\n        if(c==3999){\\n            return 4000;\\n        }\\n        int ans=solve(s);\\n        if(b){\\n            return ans+1;\\n        }\\n        return ans;\\n    }\\n    \\n    int solve(String s){\\n        if(s.length()==0){\\n            b=true;\\n            return 0;\\n        }\\n        if(map.containsKey(s)){\\n            return map.get(s);\\n        }\\n        int max=0;\\n        for(int i=0;i<s.length()/2;i++){\\n            if(s.substring(0,i+1).equals(s.substring(i+1,(2*(i+1))))){\\n                max=Math.max(max,1+solve(s.substring(i+1)));\\n            }\\n        }\\n        map.put(s,max);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650212,
                "title": "c-dp-lps",
                "content": "```\\nvector<int> solve(string &s)\\n{\\n    s = \\'#\\'+s;\\n    int n = s.length();\\n    vector<int> lps(n,0);\\n    for(int i=2;i<n;i++)\\n    {\\n        int j = i-1;\\n        while(j>0)\\n        {\\n            int k = lps[j]+1;\\n            if(s[k]==s[i])\\n            {\\n                lps[i]=lps[j]+1;\\n                break;\\n            }\\n            j = k-1;\\n        }\\n        if(lps[i]==0 && s[i]==s[1])lps[i]=1;\\n    }\\n    return lps;\\n}\\nclass Solution {\\npublic:\\n    int n;\\n    string s;\\n    vector<int> dp;\\n    int ff(int j)\\n    {\\n        if(j==n-1)return 1;\\n        if(dp[j]!=-1)return dp[j];\\n        int res = 1;\\n        string t = s.substr(j);\\n        vector<int> lps = solve(t);\\n        for(int i=j;i<n;i++)\\n        {\\n            int I = i-j+1;\\n            if(2*lps[I]==i-j+1)\\n            {\\n                res = max(res,1+ff(j+lps[I]));\\n            }\\n        }\\n        return dp[j]=res;\\n    }\\n    int deleteString(string s) {\\n        this->s = s;\\n        n = s.length();\\n        dp.assign(n,-1);\\n        return ff(0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> solve(string &s)\\n{\\n    s = \\'#\\'+s;\\n    int n = s.length();\\n    vector<int> lps(n,0);\\n    for(int i=2;i<n;i++)\\n    {\\n        int j = i-1;\\n        while(j>0)\\n        {\\n            int k = lps[j]+1;\\n            if(s[k]==s[i])\\n            {\\n                lps[i]=lps[j]+1;\\n                break;\\n            }\\n            j = k-1;\\n        }\\n        if(lps[i]==0 && s[i]==s[1])lps[i]=1;\\n    }\\n    return lps;\\n}\\nclass Solution {\\npublic:\\n    int n;\\n    string s;\\n    vector<int> dp;\\n    int ff(int j)\\n    {\\n        if(j==n-1)return 1;\\n        if(dp[j]!=-1)return dp[j];\\n        int res = 1;\\n        string t = s.substr(j);\\n        vector<int> lps = solve(t);\\n        for(int i=j;i<n;i++)\\n        {\\n            int I = i-j+1;\\n            if(2*lps[I]==i-j+1)\\n            {\\n                res = max(res,1+ff(j+lps[I]));\\n            }\\n        }\\n        return dp[j]=res;\\n    }\\n    int deleteString(string s) {\\n        this->s = s;\\n        n = s.length();\\n        dp.assign(n,-1);\\n        return ff(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649904,
                "title": "c-with-memcmp-in-c-dp-solution-o-n-2-find-equal-substr-in-constant-time-using-memcmp",
                "content": "dp[i] is the ans of s.substr(i) (substring starting at position i of orginal string)\\nif s.substr(i, len)==s.substr(i+len, len), dp[i]=max(1+dp[j]), for all j that satisfy the equal substring contition, j=i+len\\n\\nC++ string == operator may take linear time, O(n), therefore using memcmp in C to optimize in time.  Assuming time complexity of memcmp is O(1), then overall time complexity is O(n^2) (two for loops), overall space complexity is O(n) to save the dp array.\\n\\nusing memcpy is just a trick to work around the O(n) complexity of finding equal substring, better way is to use another dp to find the equal substring in O(1).  see lee215\\'s solution for that approach (https://leetcode.com/problems/maximum-deletions-on-a-string/discuss/2648900/JavaC%2B%2BPython-DP-Solution).\\n```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n=s.size();\\n        const char* cStr=s.c_str();\\n        vector<int> dp(n, 1);\\n        for(int i=n-1; i>=0; i--) {\\n            int len=n-i;\\n            for(int j=len/2; j>0; j--) {\\n                //if(s.substr(i,j) == s.substr(i+j, j))\\n                if(0==memcmp(cStr+i, cStr+i+j, j))\\n                    dp[i]=max(dp[i], 1+dp[i+j]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n=s.size();\\n        const char* cStr=s.c_str();\\n        vector<int> dp(n, 1);\\n        for(int i=n-1; i>=0; i--) {\\n            int len=n-i;\\n            for(int j=len/2; j>0; j--) {\\n                //if(s.substr(i,j) == s.substr(i+j, j))\\n                if(0==memcmp(cStr+i, cStr+i+j, j))\\n                    dp[i]=max(dp[i], 1+dp[i+j]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649875,
                "title": "c-dp-string-hash-o-n-2",
                "content": "Obviously, this is a dp solution, and I think the obstacle is how to compare the substrings in O(1). Therefore, KMP or other string dp may be use, and here I recommand string hash to compare the substrings. \\n\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    static constexpr ll mod = 1e9 + 7, b = 233; \\n    int deleteString(string s) {\\n        vector<ll> mul(4005);\\n        for(int i = 0; i < 4005; i ++){\\n            if(i == 0) mul[i] = 1;\\n            else mul[i] = (mul[i - 1] * b) % mod;\\n        }\\n        \\n        vector<int> dp(4005, -1);\\n        dp[0] = 0;\\n        int n = s.size(), res = 1;\\n        for(int i = 0; i < n; i ++){\\n            int j = 0;\\n            ll pre = 0, back = 0;\\n            while(i - j >= 0 and i + 1 + j < n){\\n                pre = (pre + s[i - j] * mul[j]) % mod;\\n                back = (back * b + s[i + 1 + j]) % mod;\\n                if(pre == back and dp[i - j] != -1) dp[i + 1] = max(dp[i + 1], dp[i - j] + 1);\\n                j ++;\\n            }\\n            if(i != n - 1) res = max(res, dp[i + 1] + 1);\\n            else res = max(res, dp[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    static constexpr ll mod = 1e9 + 7, b = 233; \\n    int deleteString(string s) {\\n        vector<ll> mul(4005);\\n        for(int i = 0; i < 4005; i ++){\\n            if(i == 0) mul[i] = 1;\\n            else mul[i] = (mul[i - 1] * b) % mod;\\n        }\\n        \\n        vector<int> dp(4005, -1);\\n        dp[0] = 0;\\n        int n = s.size(), res = 1;\\n        for(int i = 0; i < n; i ++){\\n            int j = 0;\\n            ll pre = 0, back = 0;\\n            while(i - j >= 0 and i + 1 + j < n){\\n                pre = (pre + s[i - j] * mul[j]) % mod;\\n                back = (back * b + s[i + 1 + j]) % mod;\\n                if(pre == back and dp[i - j] != -1) dp[i + 1] = max(dp[i + 1], dp[i - j] + 1);\\n                j ++;\\n            }\\n            if(i != n - 1) res = max(res, dp[i + 1] + 1);\\n            else res = max(res, dp[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649750,
                "title": "rolling-hash-solution-c",
                "content": "\\nans[i] dentoes the ans for the string from i^th character to end. DP[i][j] dentoes the hash of the string from i^th character to the (i+j-1)^th character i.e., for a substing of length j characters. Now if the hash of i^th to (i+j-1)^th character is equal to that of (i+j)^th to (i+2*j-1)^th then we can remove the first substring and have 1+ans[i+j] as a candidate for ans[i]. Now need to just iterate through i.\\n\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[4010][2010];\\n    ll ans[4010];\\n    ll min(ll x,ll y)\\n    {\\n        if(x<y)\\n        {\\n            return x;\\n        }\\n        return y;\\n    }\\n    int deleteString(string s) {\\n        ll m=1e17+7;\\n\\t\\t// here calculate the rolling hash\\n        for(ll i=s.length();i>=1;i--)\\n        {\\n            char ch=s[i-1];\\n            dp[i][1]=ch-\\'a\\'+1;\\n            ll mini=min(s.length()-i+1,2001);\\n            for(ll j=2;j<=mini;j++)\\n            {\\n                dp[i][j]=((dp[i+1][j-1]*31)%m+(ch-\\'a\\'))%m;\\n            }\\n        }\\n        for(ll i=s.length();i>=1;i--)\\n        {\\n            ans[i]=1;\\n            ll mini=min(s.length()-i+1,2001);\\n            for(ll j=1;j<=mini;j++)\\n            {\\n                if(dp[i][j]==dp[i+j][j] && i+j<=(s.length()+6))\\n                {\\n                    ans[i]=max(ans[i],1+ans[i+j]);\\n                }\\n            }\\n        }\\n        return ans[1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[4010][2010];\\n    ll ans[4010];\\n    ll min(ll x,ll y)\\n    {\\n        if(x<y)\\n        {\\n            return x;\\n        }\\n        return y;\\n    }\\n    int deleteString(string s) {\\n        ll m=1e17+7;\\n\\t\\t// here calculate the rolling hash\\n        for(ll i=s.length();i>=1;i--)\\n        {\\n            char ch=s[i-1];\\n            dp[i][1]=ch-\\'a\\'+1;\\n            ll mini=min(s.length()-i+1,2001);\\n            for(ll j=2;j<=mini;j++)\\n            {\\n                dp[i][j]=((dp[i+1][j-1]*31)%m+(ch-\\'a\\'))%m;\\n            }\\n        }\\n        for(ll i=s.length();i>=1;i--)\\n        {\\n            ans[i]=1;\\n            ll mini=min(s.length()-i+1,2001);\\n            for(ll j=1;j<=mini;j++)\\n            {\\n                if(dp[i][j]==dp[i+j][j] && i+j<=(s.length()+6))\\n                {\\n                    ans[i]=max(ans[i],1+ans[i+j]);\\n                }\\n            }\\n        }\\n        return ans[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649707,
                "title": "c-dp-kmp-o-n-2",
                "content": "`Hint: Use Kmp to check 2nd condition.`\\n```\\nclass Solution {\\npublic:\\n    int dfs(string &s,vector<int>& dp,vector<vector<int>> &kmp,int in){\\n        if(in>=s.size()) return 0;\\n        if(dp[in]!=-1) return dp[in];\\n        dp[in] = 1;\\n        for(int i = in; i<s.size();++i){\\n            if(i-in+1<=s.size()-i-1){\\n                int k = i-in+1;\\n                if(kmp[in][i+k]==k){\\n                    dp[in] = max(dp[in],1+dfs(s,dp,kmp,i+1));\\n                }\\n            }\\n            else break;\\n        }\\n        return dp[in];\\n    }\\n    int deleteString(string s) {\\n        int n = s.size();\\n        vector<int> dp(n+1,-1);\\n        vector<vector<int>> kmp(n+1,vector<int>(n+1,0));\\n        for(int k = 0; k<s.size();++k){\\n            for(int i = k,j = k+1; j<s.size();++j){\\n                while(s[i]!=s[j] && i>k) i = kmp[k][i-1]+k;\\n                if(s[i]==s[j]) {kmp[k][j] = (i-k+1); i++;}\\n            }\\n        }\\n        return dfs(s,dp,kmp,0);\\n    }\\n};\\n```\\n***Upvote if it helps, Comment below for any doubt***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(string &s,vector<int>& dp,vector<vector<int>> &kmp,int in){\\n        if(in>=s.size()) return 0;\\n        if(dp[in]!=-1) return dp[in];\\n        dp[in] = 1;\\n        for(int i = in; i<s.size();++i){\\n            if(i-in+1<=s.size()-i-1){\\n                int k = i-in+1;\\n                if(kmp[in][i+k]==k){\\n                    dp[in] = max(dp[in],1+dfs(s,dp,kmp,i+1));\\n                }\\n            }\\n            else break;\\n        }\\n        return dp[in];\\n    }\\n    int deleteString(string s) {\\n        int n = s.size();\\n        vector<int> dp(n+1,-1);\\n        vector<vector<int>> kmp(n+1,vector<int>(n+1,0));\\n        for(int k = 0; k<s.size();++k){\\n            for(int i = k,j = k+1; j<s.size();++j){\\n                while(s[i]!=s[j] && i>k) i = kmp[k][i-1]+k;\\n                if(s[i]==s[j]) {kmp[k][j] = (i-k+1); i++;}\\n            }\\n        }\\n        return dfs(s,dp,kmp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649692,
                "title": "simple-concise-solution",
                "content": "```\\nclass Solution{\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll n, mod= 1e9 + 7;\\n    vi(ll)dp;\\n    vi(vi(ll))pref;\\n    ll func(const string&s, ll in){\\n        if(in>=n){\\n            return 0;\\n        }\\n        ll&ans=dp[in];\\n        if(ans==-1){\\n            ans=1;\\n            for(ll j=in;(2*j)-in+1<n;++j){\\n                if(pref[in][j]==pref[j+1][(2*j)-in+1]){\\n                    ans=max(ans, 1+func(s, j+1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int deleteString(const string&s) {\\n        n=s.size();\\n        dp.assign(n, -1), pref.assign(n, vi(ll)(n, -1));\\n        for(ll i=0;i<n;++i){\\n            pref[i][i]=s[i]-\\'a\\'+1;\\n            for(ll j=i+1, pPow=31;j<n;++j){\\n                pref[i][j] = (pref[i][j-1] + (s[j] - \\'a\\' + 1) * pPow) % mod;\\n                pPow = (pPow * 31) % mod;\\n            }\\n        }\\n        return func(s, 0);\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution{\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll n, mod= 1e9 + 7;\\n    vi(ll)dp;\\n    vi(vi(ll))pref;\\n    ll func(const string&s, ll in){\\n        if(in>=n){\\n            return 0;\\n        }\\n        ll&ans=dp[in];\\n        if(ans==-1){\\n            ans=1;\\n            for(ll j=in;(2*j)-in+1<n;++j){\\n                if(pref[in][j]==pref[j+1][(2*j)-in+1]){\\n                    ans=max(ans, 1+func(s, j+1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int deleteString(const string&s) {\\n        n=s.size();\\n        dp.assign(n, -1), pref.assign(n, vi(ll)(n, -1));\\n        for(ll i=0;i<n;++i){\\n            pref[i][i]=s[i]-\\'a\\'+1;\\n            for(ll j=i+1, pPow=31;j<n;++j){\\n                pref[i][j] = (pref[i][j-1] + (s[j] - \\'a\\' + 1) * pPow) % mod;\\n                pPow = (pPow * 31) % mod;\\n            }\\n        }\\n        return func(s, 0);\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649612,
                "title": "somehow-test-cases-failed-to-filter-out-ac-solutions-with-o-n-3-time-complexity-recursive-dp",
                "content": "For example this one (no offense to the guy), and some others with DP memorization but still O(N^3) since it compares two strings. \\nIMO LC intended to require O(N^2) solution which involves KMP algorithm (or hashing)\\n```\\nclass Solution {\\nvector<int>pos;\\n    int search(string str){\\n        if(pos[str.size()-1]!=-1){return pos[str.size()-1];}\\n        int len=str.size();\\n        int res=0,i=0;\\n        for(int i=1;i<=len/2;i++){\\n            if(str.substr(0,i)==str.substr(i,i)){\\n                if(res>=len-i){break;}\\n                res=max(res,search(str.substr(i,len-i)));\\n            }\\n        }\\n        pos[str.size()-1]=res+1;\\n        return res+1;\\n    }\\npublic:\\n    int deleteString(string s) {\\n       pos=vector<int>(s.size(),-1);\\n       return search(s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nvector<int>pos;\\n    int search(string str){\\n        if(pos[str.size()-1]!=-1){return pos[str.size()-1];}\\n        int len=str.size();\\n        int res=0,i=0;\\n        for(int i=1;i<=len/2;i++){\\n            if(str.substr(0,i)==str.substr(i,i)){\\n                if(res>=len-i){break;}\\n                res=max(res,search(str.substr(i,len-i)));\\n            }\\n        }\\n        pos[str.size()-1]=res+1;\\n        return res+1;\\n    }\\npublic:\\n    int deleteString(string s) {\\n       pos=vector<int>(s.size(),-1);\\n       return search(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649461,
                "title": "python-solution-faster-90",
                "content": "\\tclass Solution:\\n\\t\\tdef deleteString(self, s: str) -> int:\\n\\t\\t\\tn = len(s)\\n\\t\\t\\tstack = deque() # Store (cnt, i). cnt, i both in descending order. cnt represents max # of deletions at index i\\n\\n\\t\\t\\tfor i in range(n-1, -1, -1):\\n\\t\\t\\t\\tif stack and stack[0][1] * 2 - i > n:\\n\\t\\t\\t\\t\\tstack.popleft()\\n\\n\\t\\t\\t\\tcur = 1\\n\\t\\t\\t\\tfor cnt, j in stack:\\n\\t\\t\\t\\t\\tif s[i: j] == s[j: j * 2 - i]:\\n\\t\\t\\t\\t\\t\\tcur = cnt + 1\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\twhile stack and stack[-1][0] < cur:\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\tstack.append((cur, i))\\n\\t\\t\\treturn stack[-1][0]",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef deleteString(self, s: str) -> int:\\n\\t\\t\\tn = len(s)\\n\\t\\t\\tstack = deque() # Store (cnt, i). cnt, i both in descending order. cnt represents max # of deletions at index i\\n\\n\\t\\t\\tfor i in range(n-1, -1, -1):\\n\\t\\t\\t\\tif stack and stack[0][1] * 2 - i > n:\\n\\t\\t\\t\\t\\tstack.popleft()\\n\\n\\t\\t\\t\\tcur = 1\\n\\t\\t\\t\\tfor cnt, j in stack:\\n\\t\\t\\t\\t\\tif s[i: j] == s[j: j * 2 - i]:\\n\\t\\t\\t\\t\\t\\tcur = cnt + 1\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\twhile stack and stack[-1][0] < cur:\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\tstack.append((cur, i))\\n\\t\\t\\treturn stack[-1][0]",
                "codeTag": "Java"
            },
            {
                "id": 2649202,
                "title": "java-dp-recursion-logic-with-explaination",
                "content": "See Comments for Explaination :)\\n```\\nclass Solution {\\n    HashMap<Integer,Integer> map = new HashMap();\\n    public int deleteString(String s) {\\n        return helper(s,0);\\n    }\\n    \\n    private int helper(String s, int idx){\\n        if(idx == s.length())return 0;\\n        \\n        if(map.containsKey(idx))return map.get(idx);\\n        \\n        int ans = 1;\\n        for(int i = idx; i <idx+(s.length()-idx)/2; i++){\\n            if(!map.containsKey(i)){\\n                String a = s.substring(idx,i+1);\\n                String b = s.substring(i+1,i+1+i-idx+1);\\n            \\n                if(a.equals(b)){\\n                String temp = s.substring(i+1);\\n                int c = helper(s,i+1)+1;\\n                ans = Math.max(c,ans);\\n            }\\n            }\\n            \\n        }\\n        \\n        map.put(idx,ans);\\n      \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer,Integer> map = new HashMap();\\n    public int deleteString(String s) {\\n        return helper(s,0);\\n    }\\n    \\n    private int helper(String s, int idx){\\n        if(idx == s.length())return 0;\\n        \\n        if(map.containsKey(idx))return map.get(idx);\\n        \\n        int ans = 1;\\n        for(int i = idx; i <idx+(s.length()-idx)/2; i++){\\n            if(!map.containsKey(i)){\\n                String a = s.substring(idx,i+1);\\n                String b = s.substring(i+1,i+1+i-idx+1);\\n            \\n                if(a.equals(b)){\\n                String temp = s.substring(i+1);\\n                int c = helper(s,i+1)+1;\\n                ans = Math.max(c,ans);\\n            }\\n            }\\n            \\n        }\\n        \\n        map.put(idx,ans);\\n      \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649117,
                "title": "c-simple-dp-check-dp-value-in-advance-to-avoid-tle",
                "content": "dp[i] means the maximum solution for `s[i...n-1]`\\ndp[n-1] = 1, because for the last character `s[n-1]`, you need one step to delete it\\niterate from dp[n-2] downto dp[0]\\nfor dp[i], check whether `s[i..i+len-1]` and `s[i+len...i+len*2-1]` is the same\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int deleteString(string s) {\\n        vector<int> dp(s.size(), 0);\\n        dp[0] = 0;\\n        \\n        int n = s.size();\\n        dp[n-1] = 1;\\n        \\n        for (int i = n-2; i >= 0; i--){\\n            dp[i] = 1;\\n            for (int len = 1; i+len*2-1 < n; len++) {\\n                int j = i + len;\\n                if (dp[j]+1 > dp[i]) {\\n                    bool same = true;\\n                    int ii = i;\\n                    int jj = i+len;\\n                    for (int k = 0; k < len; k++) {\\n                        if (s[ii] != s[jj]) { same = false; break; }\\n                        ii++; jj++;\\n                    }\\n                    if (same) dp[i] = dp[j]+1;\\n                }    \\n            }\\n        }\\n        \\n        return dp[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int deleteString(string s) {\\n        vector<int> dp(s.size(), 0);\\n        dp[0] = 0;\\n        \\n        int n = s.size();\\n        dp[n-1] = 1;\\n        \\n        for (int i = n-2; i >= 0; i--){\\n            dp[i] = 1;\\n            for (int len = 1; i+len*2-1 < n; len++) {\\n                int j = i + len;\\n                if (dp[j]+1 > dp[i]) {\\n                    bool same = true;\\n                    int ii = i;\\n                    int jj = i+len;\\n                    for (int k = 0; k < len; k++) {\\n                        if (s[ii] != s[jj]) { same = false; break; }\\n                        ii++; jj++;\\n                    }\\n                    if (same) dp[i] = dp[j]+1;\\n                }    \\n            }\\n        }\\n        \\n        return dp[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649086,
                "title": "simple-dp",
                "content": "1. First find all indexes from where we can delete substring using the second rule. There can have multiple substring from same index (different length) that can be deleted\\n2. Now starting from index 0 find max solution recursively (there can have multiple substring with different length that can be deleted. we will explore all recursively). Use cache/memo to avoid recomputing again and again for same index\\n\\n\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        #Finding index of all substring that can be deleted based on rule 2\\n        locs = {}\\n        for l in range(2, len(s) + 1, 2):\\n            for i in range(len(s) - l + 1):\\n                if s[i:i + l//2] == s[i + l//2:i + l]:\\n                    if i not in locs:\\n                        locs[i] = []\\n                    locs[i].append(l)\\n                    \\n        cache = {}\\n        def solve(i):\\n            if i not in locs:\\n                return 1\\n            if i in cache:\\n                return cache[i]\\n            mx = -math.inf\\n            for l in locs[i]:\\n                mx = max(mx, 1 + solve(i + l//2))\\n            cache[i] = mx\\n            return cache[i]\\n        \\n        return solve(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        #Finding index of all substring that can be deleted based on rule 2\\n        locs = {}\\n        for l in range(2, len(s) + 1, 2):\\n            for i in range(len(s) - l + 1):\\n                if s[i:i + l//2] == s[i + l//2:i + l]:\\n                    if i not in locs:\\n                        locs[i] = []\\n                    locs[i].append(l)\\n                    \\n        cache = {}\\n        def solve(i):\\n            if i not in locs:\\n                return 1\\n            if i in cache:\\n                return cache[i]\\n            mx = -math.inf\\n            for l in locs[i]:\\n                mx = max(mx, 1 + solve(i + l//2))\\n            cache[i] = mx\\n            return cache[i]\\n        \\n        return solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649028,
                "title": "accepted-recursive-dp-solution-without-rolling-hash-function",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n    }\\n    int dp[4005][4005];\\n    bool check(int i,int j,string_view &s)\\n    {\\n        if((j-i+1)%2==1)\\n        {\\n            return false;\\n        }\\n        \\n        int mid=(j-i+1)/2;\\n\\n        \\n        if(s.substr(i,mid)==s.substr(i+mid,mid))\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int fun(int i,int j,string_view &s)\\n    {\\n        if(i==s.size()-1)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n        int res=0;\\n        int ans=0;\\n        \\n        for(int ind=j;ind<s.size();ind++)\\n        {\\n            if(check(i,ind,s))\\n            {\\n               int mid=(ind-i+1)/2;\\n               res=1+fun(i+mid,i+mid+1,s);\\n               ans=max(ans,res);\\n            }\\n        }\\n        \\n        return dp[i][j]=ans;\\n    }\\n    \\n    int deleteString(string &s) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        if(s.size()==1)\\n        {\\n            return 1;\\n        }\\n        \\n        string_view sv (s.c_str(), s.size());\\n        \\n        return 1+fun(0,1,sv);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n    }\\n    int dp[4005][4005];\\n    bool check(int i,int j,string_view &s)\\n    {\\n        if((j-i+1)%2==1)\\n        {\\n            return false;\\n        }\\n        \\n        int mid=(j-i+1)/2;\\n\\n        \\n        if(s.substr(i,mid)==s.substr(i+mid,mid))\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int fun(int i,int j,string_view &s)\\n    {\\n        if(i==s.size()-1)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n        int res=0;\\n        int ans=0;\\n        \\n        for(int ind=j;ind<s.size();ind++)\\n        {\\n            if(check(i,ind,s))\\n            {\\n               int mid=(ind-i+1)/2;\\n               res=1+fun(i+mid,i+mid+1,s);\\n               ans=max(ans,res);\\n            }\\n        }\\n        \\n        return dp[i][j]=ans;\\n    }\\n    \\n    int deleteString(string &s) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        if(s.size()==1)\\n        {\\n            return 1;\\n        }\\n        \\n        string_view sv (s.c_str(), s.size());\\n        \\n        return 1+fun(0,1,sv);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648952,
                "title": "z-algorithm-with-dp-corner-case-hard-coding-beat-100-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we need to find is there a common prefix of a string and its substrings, Z algorithm can do it. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int[] getz(String s, int offset) {\\n        int n = s.length() - offset;\\n        int[] z = new int[n];\\n        int l = 0, r = 0;\\n        z[0] = n;\\n        for (int i = 1; i < n; ++i) {\\n            if (i <= r) {\\n                z[i] = Math.min(r - i + 1, z[i - l]);\\n            }\\n            while (i + z[i] < n && s.charAt(z[i] + offset) == s.charAt(i + z[i] + offset)) {\\n                ++z[i];\\n            }  \\n            if (i + z[i] - 1 > r) {\\n                l = i;\\n            }\\n        }\\n        return z;\\n    }\\n    \\n    \\n    private int dp(String s, int i, int[] memo) {\\n        if (memo[i] != 0) {\\n            return memo[i];\\n        }\\n        memo[i] = 1;\\n        int[] z = getz(s, i);\\n        for (int j = 1; j < z.length; j++) {\\n            if (z[j] >= j) {\\n                memo[i] = Math.max(memo[i], 1 + dp(s, i + j, memo));\\n            }\\n        }\\n        return memo[i];\\n    }\\n    \\n    public int deleteString(String s) {\\n        int a = s.charAt(0);\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != a) {\\n                break;\\n            }\\n            if (i == s.length() - 1) {\\n                return s.length();\\n            }\\n        }\\n        return dp(s, 0, new int[s.length()]);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[] getz(String s, int offset) {\\n        int n = s.length() - offset;\\n        int[] z = new int[n];\\n        int l = 0, r = 0;\\n        z[0] = n;\\n        for (int i = 1; i < n; ++i) {\\n            if (i <= r) {\\n                z[i] = Math.min(r - i + 1, z[i - l]);\\n            }\\n            while (i + z[i] < n && s.charAt(z[i] + offset) == s.charAt(i + z[i] + offset)) {\\n                ++z[i];\\n            }  \\n            if (i + z[i] - 1 > r) {\\n                l = i;\\n            }\\n        }\\n        return z;\\n    }\\n    \\n    \\n    private int dp(String s, int i, int[] memo) {\\n        if (memo[i] != 0) {\\n            return memo[i];\\n        }\\n        memo[i] = 1;\\n        int[] z = getz(s, i);\\n        for (int j = 1; j < z.length; j++) {\\n            if (z[j] >= j) {\\n                memo[i] = Math.max(memo[i], 1 + dp(s, i + j, memo));\\n            }\\n        }\\n        return memo[i];\\n    }\\n    \\n    public int deleteString(String s) {\\n        int a = s.charAt(0);\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != a) {\\n                break;\\n            }\\n            if (i == s.length() - 1) {\\n                return s.length();\\n            }\\n        }\\n        return dp(s, 0, new int[s.length()]);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648931,
                "title": "rolling-hash-dp-c-easy-to-understand",
                "content": "# Explaination\\nFor the problem, we need to find **maximum** number of operations needed to clear the string. We see, that greedily picking the smallest `i` letters may not work everytime, for example:\\nif we use `aaabaab`, if we greedily pick:\\n1. First 1 character, new string = `aabaab`\\n2. First 1 character, new string = `abaab`\\n3. We have to delete entire string which takes 1 operation\\nhere, `ans = 3`, while for the sample, `ans = 4`.\\n\\nYou can try to write a recursive code to pick all possible first i letters and select the maximum answer among them. \\nSay, we have from index `i` to `j`, we will have:\\n```\\nfor possible values of k:\\n\\tif first k characters starting from i satisfy condition 2:\\n\\t\\tans = max(ans, 1 + answer for substring starting at i+k and ending at j)\\n```\\n\\t\\t\\nto check if first k characters satisfy condition 2, we may use [rolling hash](https://cp-algorithms.com/string/string-hashing.html). We precompute hashes, compare left and right hashes after multiplying left half with some power of p to make powers equal. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[4001];\\n    \\n    int recurse(int i, int n, long long hashes[], long long ps[],const int m){\\n        if(dp[i] != -1) return dp[i];\\n        int ans = INT_MIN;\\n        bool done = 0;\\n        for(int j = i;j<=i + (n-i)/2 - 1;j++){\\n            long long l;\\n            if(i == 0) l = hashes[j];\\n            else l = hashes[j] - hashes[i-1];\\n            l = (l*ps[j+1 - i]);\\n            l%= m;\\n            if(l < 0) l+= m;            \\n            long long r = hashes[i + 2*(j-i+1)-1] - hashes[j];\\n            r%=m;\\n            if(r < 0) r += m;\\n            if(l == r){\\n                ans = max(ans, 1 + recurse(j+1, n, hashes, ps, m));\\n                done = 1;\\n            }\\n        }\\n        if(!done){\\n            ans = 1;\\n        }\\n        return dp[i] = ans;\\n    }\\n    \\n    int deleteString(string s) {\\n        int n = s.length();\\n        long long hashes[n], ps[n];\\n        int p = 31;\\n        const int m = 1e9 + 9;\\n        long long hash_value = 0;\\n        long long p_pow = 1;\\n        int i = 0;\\n        for(int i = 0;i<4001;i++){\\n            dp[i] = -1;\\n        }\\n        for (char c : s) {\\n            hash_value = (hash_value + (c - \\'a\\' + 1) * p_pow) % m;\\n            hashes[i] = hash_value;\\n            ps[i] = p_pow;\\n            i++;\\n            p_pow = (p_pow * p) % m;\\n        }\\n        i = 0;\\n        return recurse(i, n, hashes, ps, m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Rolling Hash"
                ],
                "code": "```\\nfor possible values of k:\\n\\tif first k characters starting from i satisfy condition 2:\\n\\t\\tans = max(ans, 1 + answer for substring starting at i+k and ending at j)\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[4001];\\n    \\n    int recurse(int i, int n, long long hashes[], long long ps[],const int m){\\n        if(dp[i] != -1) return dp[i];\\n        int ans = INT_MIN;\\n        bool done = 0;\\n        for(int j = i;j<=i + (n-i)/2 - 1;j++){\\n            long long l;\\n            if(i == 0) l = hashes[j];\\n            else l = hashes[j] - hashes[i-1];\\n            l = (l*ps[j+1 - i]);\\n            l%= m;\\n            if(l < 0) l+= m;            \\n            long long r = hashes[i + 2*(j-i+1)-1] - hashes[j];\\n            r%=m;\\n            if(r < 0) r += m;\\n            if(l == r){\\n                ans = max(ans, 1 + recurse(j+1, n, hashes, ps, m));\\n                done = 1;\\n            }\\n        }\\n        if(!done){\\n            ans = 1;\\n        }\\n        return dp[i] = ans;\\n    }\\n    \\n    int deleteString(string s) {\\n        int n = s.length();\\n        long long hashes[n], ps[n];\\n        int p = 31;\\n        const int m = 1e9 + 9;\\n        long long hash_value = 0;\\n        long long p_pow = 1;\\n        int i = 0;\\n        for(int i = 0;i<4001;i++){\\n            dp[i] = -1;\\n        }\\n        for (char c : s) {\\n            hash_value = (hash_value + (c - \\'a\\' + 1) * p_pow) % m;\\n            hashes[i] = hash_value;\\n            ps[i] = p_pow;\\n            i++;\\n            p_pow = (p_pow * p) % m;\\n        }\\n        i = 0;\\n        return recurse(i, n, hashes, ps, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648858,
                "title": "clean-code-c-time-comlexity-o-n-2",
                "content": "# Intuition\\nEasy Solution\\n\\n# Approach\\nBuild mapCheck[][] to find substring is like \"abcabc\" in O(1) time complexity\\n\\n# Complexity\\n- Time complexity: O(n ^ 2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n ^ 2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mapCheck[4001][4001] = {0};\\n    \\n    bool check(string& s, int start, int end) {\\n        start--; end--;\\n        int mid = start + (end - start) / 2 + 1;\\n        int dist = (end - start + 1) / 2;\\n        \\n        return mapCheck[dist][mid] > 0 && mapCheck[dist][mid] == mapCheck[dist][end];\\n    }\\n    \\n    int deleteString(string s) {\\n        int n = s.size();\\n        \\n        // Build mapCheck in O(n ^ 2)\\n        for(int dist = 1; dist < s.size(); dist++) {\\n            int order = 1;\\n            for(int i = dist; i < s.size(); i++) {\\n                if(s[i] == s[i - dist]) {\\n                    mapCheck[dist][i] = order;\\n                    continue;\\n                }\\n                order++;\\n            }\\n        }\\n        \\n        // dp[i] is max delete substring from 1 to i (1-startIndex)\\n        int dp[4001] = {0};\\n        \\n        // Time O(n^2)\\n        for(int start = 1; start <= n; start++) {\\n            if (start > 1 && dp[start - 1] == 0)\\n                continue;\\n            \\n            dp[n] = max(dp[n], dp[start - 1] + 1);\\n            \\n            for (int end = start + 1; end <= n; end += 2) {\\n                if(!check(s, start, end)) // O(1)\\n                    continue;\\n                \\n                int mid = start + (end - start) / 2;\\n                dp[mid] = max(dp[mid], dp[start - 1] + 1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mapCheck[4001][4001] = {0};\\n    \\n    bool check(string& s, int start, int end) {\\n        start--; end--;\\n        int mid = start + (end - start) / 2 + 1;\\n        int dist = (end - start + 1) / 2;\\n        \\n        return mapCheck[dist][mid] > 0 && mapCheck[dist][mid] == mapCheck[dist][end];\\n    }\\n    \\n    int deleteString(string s) {\\n        int n = s.size();\\n        \\n        // Build mapCheck in O(n ^ 2)\\n        for(int dist = 1; dist < s.size(); dist++) {\\n            int order = 1;\\n            for(int i = dist; i < s.size(); i++) {\\n                if(s[i] == s[i - dist]) {\\n                    mapCheck[dist][i] = order;\\n                    continue;\\n                }\\n                order++;\\n            }\\n        }\\n        \\n        // dp[i] is max delete substring from 1 to i (1-startIndex)\\n        int dp[4001] = {0};\\n        \\n        // Time O(n^2)\\n        for(int start = 1; start <= n; start++) {\\n            if (start > 1 && dp[start - 1] == 0)\\n                continue;\\n            \\n            dp[n] = max(dp[n], dp[start - 1] + 1);\\n            \\n            for (int end = start + 1; end <= n; end += 2) {\\n                if(!check(s, start, end)) // O(1)\\n                    continue;\\n                \\n                int mid = start + (end - start) / 2;\\n                dp[mid] = max(dp[mid], dp[start - 1] + 1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648825,
                "title": "python-ac-trick-dynammic-programming-based-trick-to-avoid-tle",
                "content": "# Intuition\\nAt each step, you can either remove a set of chars from start of string or remove entire string.\\nEvaluate all valid choices recursively. Use memoization to avoid re-compute.\\n\\n# Tricks:\\n1. If string is made up of same character (ex: aaaaa), then maximum steps is N (i.e, len of string) as we can remove 1 char at a time. No need to evaluate it further. **This is key to avoid TLE**\\n2. Remove maximum set of chars that repeats first. That way the memoization can give us maximum benefit (as smaller substrings might repeat)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        from collections import Counter\\n        N = len(s)\\n        global memo\\n        memo = {}\\n        #print(\\'\\\\n\\\\nTest case -> s:\\', s, \\'N:\\', N)\\n        return rem(s)\\n\\n\\ndef rem(s):\\n    #print(\\'Rem Start -> s:\\', s)\\n    global memo\\n    if s in memo:\\n        #print(\\'MEMO found -> memo[s]:\\', memo[s])\\n        return memo[s]\\n    \\n    N = len(s)\\n    #print(\\'N:\\', N)\\n    if N == 0:\\n        #print(\\'Empty string case, s:\\', s)\\n        return 0\\n    \\n    if N == 1:\\n        # Remove entire string\\n        #print(\\'Single char case, s:\\', s)\\n        memo[s] = 1\\n        return 1\\n    \\n    c = Counter(s)\\n    if c[s[0]] == N:\\n        # All chars are same\\n        memo[s] = N\\n        return N\\n    \\n    maxToRem = N // 2\\n    #print(\\'maxToRem:\\', maxToRem)\\n    maxSteps = 1\\n    for numToRem in range(maxToRem, 0, -1):\\n        if s[:numToRem] == s[numToRem:2*numToRem]:\\n            #numCharsToRem,append(numToRem)\\n            #print(\\'s:\\', s, \\'numToRem:\\', numToRem, \\'Removing\\', s[:numToRem])\\n            maxSteps = max(maxSteps, rem(s[numToRem:])+1)\\n    \\n    memo[s] = maxSteps\\n    #print(\\'s:\\', s, \\'memo[s]:\\', memo[s])\\n    return maxSteps\\n        \\n    \\n    \\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        from collections import Counter\\n        N = len(s)\\n        global memo\\n        memo = {}\\n        #print(\\'\\\\n\\\\nTest case -> s:\\', s, \\'N:\\', N)\\n        return rem(s)\\n\\n\\ndef rem(s):\\n    #print(\\'Rem Start -> s:\\', s)\\n    global memo\\n    if s in memo:\\n        #print(\\'MEMO found -> memo[s]:\\', memo[s])\\n        return memo[s]\\n    \\n    N = len(s)\\n    #print(\\'N:\\', N)\\n    if N == 0:\\n        #print(\\'Empty string case, s:\\', s)\\n        return 0\\n    \\n    if N == 1:\\n        # Remove entire string\\n        #print(\\'Single char case, s:\\', s)\\n        memo[s] = 1\\n        return 1\\n    \\n    c = Counter(s)\\n    if c[s[0]] == N:\\n        # All chars are same\\n        memo[s] = N\\n        return N\\n    \\n    maxToRem = N // 2\\n    #print(\\'maxToRem:\\', maxToRem)\\n    maxSteps = 1\\n    for numToRem in range(maxToRem, 0, -1):\\n        if s[:numToRem] == s[numToRem:2*numToRem]:\\n            #numCharsToRem,append(numToRem)\\n            #print(\\'s:\\', s, \\'numToRem:\\', numToRem, \\'Removing\\', s[:numToRem])\\n            maxSteps = max(maxSteps, rem(s[numToRem:])+1)\\n    \\n    memo[s] = maxSteps\\n    #print(\\'s:\\', s, \\'memo[s]:\\', memo[s])\\n    return maxSteps\\n        \\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648816,
                "title": "rust-bottom-up-dp-with-comments",
                "content": "This is my unrevised submission for the 2022-10-02 Weekly Contest 313. Set up a DP table where positions represent the number of maximum operations to delete the corresponding prefix. For each position, we first check the previous DP entries to see if there are any candidates that would let us increase the number of operations (rather cheap) and for those, we check the corresponding substrings (from the start of the previous entry to the current position, and from the current position forwards an equal number of steps - a more expensive operation). Our answer is then the maximum of any operation count found.\\n\\nComment: This took so long to solve, simply because I was intimidated by this being the \"hard\" problem of the contest. I lost a lot of time thinking about what the catch could be instead of just going for it. Lesson learned.\\n\\n```\\nimpl Solution {\\n    pub fn delete_string(s: String) -> i32 {\\n        let s = s.as_bytes();\\n        let mut dp = vec![-1; s.len() + 1];\\n        dp[0] = 1;\\n        let mut max = 1;\\n        for i in 1..s.len() {\\n            let w = i - i.saturating_sub(s.len() - i);\\n            for j in 1..=w {\\n                if dp[i - j] != -1 && dp[i - j] >= dp[i] && s[i-j..i] == s[i..i+j] {\\n                    dp[i] = dp[i-j] + 1;\\n                    max = max.max(dp[i]);\\n                }\\n            }\\n        }\\n        max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn delete_string(s: String) -> i32 {\\n        let s = s.as_bytes();\\n        let mut dp = vec![-1; s.len() + 1];\\n        dp[0] = 1;\\n        let mut max = 1;\\n        for i in 1..s.len() {\\n            let w = i - i.saturating_sub(s.len() - i);\\n            for j in 1..=w {\\n                if dp[i - j] != -1 && dp[i - j] >= dp[i] && s[i-j..i] == s[i..i+j] {\\n                    dp[i] = dp[i-j] + 1;\\n                    max = max.max(dp[i]);\\n                }\\n            }\\n        }\\n        max\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648681,
                "title": "cpp-dynamic-programming-hashing-explanation-with-code",
                "content": "**Prerequisites:**\\nDynamic Programming, String Hahing, Binary Exponentiation, Modular Multiplicative Inverse.\\n**Why Greedy approach will not work?**\\nThe first approach that come in our mind is *greedy*.\\nExample: \\n\"ababa\" --> (ab)\"aba\" --> \"aba\" --> (aba) --> \"\".\\n\"ababa\" --> \"aba\" --> \"\"\\nHere we are greedily removing the smallest repeating prefix at every stage.\\n\\nBut this approach will fail for **\"aabaab\"**:\\n\\n**Greedy approach:**\\n\"aabaab\" --> (a)\"abaab\" --> \"abaab\" --> (abaab)\"\" --> \"\".\\n**\"aabaab\" --> \"abaab\" --> \"\".**\\nHere we can perform 2 operations.\\n\\n**Optimal approach:**\\n\"aabaab\"--> (aab)\"aab\" --> \"aab\" --> (a)\"ab\" --> \"ab\" --> (ab)\"\" --> \"\".\\n**\"aabaab\" --> \"aab\" -->  \"ab\" --> \"\".**\\n\\nTherefore we want to check for all possible matching prefixes.\\n\\nFor this we are using dynamic programming approach.\\nWe are creating one *dp* array of size equal to (size of given string + 1) having initially all values 1.\\n```\\nvector<int>dp(s.size()+1,1);\\n```\\n\\n\\n**What exactly dp[i] is denoting?**\\ndp[i] denotes the number of maximum number of operations we can perform to make the substring of s(i...n-1) empty.\\n\\nTherefore dp[n] should be equal to 0. Since string corresponding to dp[n] is an empty string.\\n\\nKeep on feeling dp array from backside.\\n```\\nfor(int i=s.size()-1;i>=0;i--){\\n\\t//Evaluate dp[i]\\n}\\n```\\nWe want to check the all possible matching prefixes.\\nTo check if the two substrings are matching or not, we can using **Hashing**.\\n\\n[Cp Algorithms article about Hashing](https://cp-algorithms.com/string/string-hashing.html#applications-of-hashingtp://)\\n\\n```\\nlong long power(long long a,long long n,long long modVal){\\n    long long res=1;\\n    while(n>0){\\n        if(n%2==1){\\n            n--;\\n            res=((res%modVal)*(a%modVal))%modVal;\\n        }\\n        a=((a%modVal)*(a%modVal))%modVal;\\n        n=n>>1;\\n    }\\n    return res;\\n}\\n\\nclass Hashing{\\n    const long long MOD=1e9+9,PRIME=29;\\n    vector<long long>cumVal;\\n    vector<long long>invPow;\\n    int n;\\npublic:\\n    Hashing(string &s){\\n        n=s.size();\\n        cumVal.resize(n+1);\\n        long long p=1;\\n        for(int i=0;i<n;i++){\\n            p=(p*PRIME)%MOD;\\n            cumVal[i+1]=(cumVal[i]+(p*(s[i]-\\'a\\')%MOD)%MOD)%MOD;\\n        }\\n        invPow.resize(n+1);\\n        invPow[n]=power(p,MOD-2,MOD);\\n        for(int i=n-1;i>=0;i--){\\n            invPow[i]=(invPow[i+1]*PRIME)%MOD;\\n        }\\n    }\\n    \\n    long long substr(int x,int y){\\n        x++,y++;\\n        long long ans=(cumVal[y]-cumVal[x-1]+MOD)%MOD;\\n        ans=(ans*invPow[x-1])%MOD;\\n        return ans;\\n    }\\n    \\n};\\n```\\n\\nNow check for all possible matching prefixes.\\n```\\nfor(int i=s.size()-1;i>=0;i--){\\n\\tfor(int matching=1;matching*2+i<=s.size();matching++){\\n\\t\\tlong long left1=i,right1=left1+matching-1;\\n\\t\\tlong long left2=right1+1,right2=left2+matching-1;\\n\\t\\t\\n\\t\\t//Check if s[left1...right1] == s[left2...right2]\\n\\t\\tif(hashing.substr(left1,right1)==hashing.substr(left2,right2)){\\n\\t\\t\\tdp[i]=max(dp[i],1+dp[left2]);\\n\\t\\t}\\n\\t}\\n}\\n```\\n**Note:** While using hashing, precompute the inverse of powers of PRIME value. Otherwise it may lead to Time Limit Exceeded verdict.\\n\\n**Time Complexity:** O(n^2)\\n**Space Complexity:** O(n)\\n\\n**C++ implementation**\\n```\\nlong long power(long long a,long long n,long long modVal){\\n    long long res=1;\\n    while(n>0){\\n        if(n%2==1){\\n            n--;\\n            res=((res%modVal)*(a%modVal))%modVal;\\n        }\\n        a=((a%modVal)*(a%modVal))%modVal;\\n        n=n>>1;\\n    }\\n    return res;\\n}\\n\\nclass Hashing{\\n    const long long MOD=1e9+9,PRIME=29;\\n    vector<long long>cumVal;\\n    vector<long long>invPow;\\n    int n;\\npublic:\\n    Hashing(string &s){\\n        n=s.size();\\n        cumVal.resize(n+1);\\n        long long p=1;\\n        for(int i=0;i<n;i++){\\n            p=(p*PRIME)%MOD;\\n            cumVal[i+1]=(cumVal[i]+(p*(s[i]-\\'a\\')%MOD)%MOD)%MOD;\\n        }\\n        invPow.resize(n+1);\\n        invPow[n]=power(p,MOD-2,MOD);\\n        for(int i=n-1;i>=0;i--){\\n            invPow[i]=(invPow[i+1]*PRIME)%MOD;\\n        }\\n    }\\n    \\n    long long substr(int x,int y){\\n        x++,y++;\\n        long long ans=(cumVal[y]-cumVal[x-1]+MOD)%MOD;\\n        ans=(ans*invPow[x-1])%MOD;\\n        return ans;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        Hashing hashing(s);\\n        \\n        vector<int>dp(s.size()+1,1);\\n        dp.back()=0;\\n        \\n        for(int i=s.size()-1;i>=0;i--){\\n            for(int matching=1;matching*2+i<=s.size();matching++){\\n                long long left1=i,right1=left1+matching-1;\\n                long long left2=right1+1,right2=left2+matching-1;\\n                if(hashing.substr(left1,right1)==hashing.substr(left2,right2)){\\n                    dp[i]=max(dp[i],1+dp[left2]);\\n                }\\n            }\\n        }\\n        \\n        // for(int i=0;i<s.size();i++){\\n        //     cout<<dp[i]<<\\' \\';\\n        // }\\n        // cout<<\\'\\\\n\\';\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<int>dp(s.size()+1,1);\\n```\n```\\nfor(int i=s.size()-1;i>=0;i--){\\n\\t//Evaluate dp[i]\\n}\\n```\n```\\nlong long power(long long a,long long n,long long modVal){\\n    long long res=1;\\n    while(n>0){\\n        if(n%2==1){\\n            n--;\\n            res=((res%modVal)*(a%modVal))%modVal;\\n        }\\n        a=((a%modVal)*(a%modVal))%modVal;\\n        n=n>>1;\\n    }\\n    return res;\\n}\\n\\nclass Hashing{\\n    const long long MOD=1e9+9,PRIME=29;\\n    vector<long long>cumVal;\\n    vector<long long>invPow;\\n    int n;\\npublic:\\n    Hashing(string &s){\\n        n=s.size();\\n        cumVal.resize(n+1);\\n        long long p=1;\\n        for(int i=0;i<n;i++){\\n            p=(p*PRIME)%MOD;\\n            cumVal[i+1]=(cumVal[i]+(p*(s[i]-\\'a\\')%MOD)%MOD)%MOD;\\n        }\\n        invPow.resize(n+1);\\n        invPow[n]=power(p,MOD-2,MOD);\\n        for(int i=n-1;i>=0;i--){\\n            invPow[i]=(invPow[i+1]*PRIME)%MOD;\\n        }\\n    }\\n    \\n    long long substr(int x,int y){\\n        x++,y++;\\n        long long ans=(cumVal[y]-cumVal[x-1]+MOD)%MOD;\\n        ans=(ans*invPow[x-1])%MOD;\\n        return ans;\\n    }\\n    \\n};\\n```\n```\\nfor(int i=s.size()-1;i>=0;i--){\\n\\tfor(int matching=1;matching*2+i<=s.size();matching++){\\n\\t\\tlong long left1=i,right1=left1+matching-1;\\n\\t\\tlong long left2=right1+1,right2=left2+matching-1;\\n\\t\\t\\n\\t\\t//Check if s[left1...right1] == s[left2...right2]\\n\\t\\tif(hashing.substr(left1,right1)==hashing.substr(left2,right2)){\\n\\t\\t\\tdp[i]=max(dp[i],1+dp[left2]);\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nlong long power(long long a,long long n,long long modVal){\\n    long long res=1;\\n    while(n>0){\\n        if(n%2==1){\\n            n--;\\n            res=((res%modVal)*(a%modVal))%modVal;\\n        }\\n        a=((a%modVal)*(a%modVal))%modVal;\\n        n=n>>1;\\n    }\\n    return res;\\n}\\n\\nclass Hashing{\\n    const long long MOD=1e9+9,PRIME=29;\\n    vector<long long>cumVal;\\n    vector<long long>invPow;\\n    int n;\\npublic:\\n    Hashing(string &s){\\n        n=s.size();\\n        cumVal.resize(n+1);\\n        long long p=1;\\n        for(int i=0;i<n;i++){\\n            p=(p*PRIME)%MOD;\\n            cumVal[i+1]=(cumVal[i]+(p*(s[i]-\\'a\\')%MOD)%MOD)%MOD;\\n        }\\n        invPow.resize(n+1);\\n        invPow[n]=power(p,MOD-2,MOD);\\n        for(int i=n-1;i>=0;i--){\\n            invPow[i]=(invPow[i+1]*PRIME)%MOD;\\n        }\\n    }\\n    \\n    long long substr(int x,int y){\\n        x++,y++;\\n        long long ans=(cumVal[y]-cumVal[x-1]+MOD)%MOD;\\n        ans=(ans*invPow[x-1])%MOD;\\n        return ans;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        Hashing hashing(s);\\n        \\n        vector<int>dp(s.size()+1,1);\\n        dp.back()=0;\\n        \\n        for(int i=s.size()-1;i>=0;i--){\\n            for(int matching=1;matching*2+i<=s.size();matching++){\\n                long long left1=i,right1=left1+matching-1;\\n                long long left2=right1+1,right2=left2+matching-1;\\n                if(hashing.substr(left1,right1)==hashing.substr(left2,right2)){\\n                    dp[i]=max(dp[i],1+dp[left2]);\\n                }\\n            }\\n        }\\n        \\n        // for(int i=0;i<s.size();i++){\\n        //     cout<<dp[i]<<\\' \\';\\n        // }\\n        // cout<<\\'\\\\n\\';\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2648671,
                "title": "java-python-dp-pointer-solution",
                "content": "Java [328ms]\\n```\\nclass Solution {\\n    public int deleteString(String s) {\\n        int high = 0, n = s.length();\\n        int[] dp = new int[n];\\n        char[] c = s.toCharArray();\\n        for (int i = 0; i < n; i++) {\\n            int low = Math.max(0, 2 * i - n);\\n            int pointer = i - 1;\\n            while (pointer >= low) {\\n                if (c[i] == c[pointer] && s.substring(pointer, i).equals(s.substring(i, 2 * i - pointer))) {\\n                    if (dp[pointer] != 0 || pointer == 0) dp[i] = Math.max(dp[i], dp[pointer] + 1);\\n                    if (dp[pointer] == high) break;\\n                }\\n                pointer--;\\n            }\\n            high = Math.max(high, dp[i]);\\n        }\\n        return high + 1;\\n    }\\n}\\n```\\n\\nPython [2667ms]\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        high, n = 0, len(s)\\n        dp = [0 for i in range(n)]\\n        for i in range(n):\\n            low, pointer = max(0, 2 * i - n), i - 1\\n            while pointer >= low:\\n                if s[i] == s[pointer] and s[pointer:i] == s[i: 2 * i - pointer]:\\n                    if dp[pointer] != 0 or pointer == 0: dp[i] = max(dp[i], dp[pointer] + 1)\\n                    if dp[pointer] == high: break\\n                pointer -= 1\\n            high = max(high, dp[i])\\n        return high + 1\\n```\\n\\nthe idea is to \"look back\" when you are at each character. the maximum you can look back is either all the way to the start, or the distance to the end from your current position. when you are looking backwards, ignore all the characters that are not the current character you are at.\\n\\nif you are at the same character and the substrings are equal, we check if we can update our dp array. either we have made some deletions before at the previous character, or we are all the way at the start. if the previous valid character was the previous max, we stop looking back and move on.\\n\\nupdate the previous max, and at the end remember to add one for the last part of the string.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteString(String s) {\\n        int high = 0, n = s.length();\\n        int[] dp = new int[n];\\n        char[] c = s.toCharArray();\\n        for (int i = 0; i < n; i++) {\\n            int low = Math.max(0, 2 * i - n);\\n            int pointer = i - 1;\\n            while (pointer >= low) {\\n                if (c[i] == c[pointer] && s.substring(pointer, i).equals(s.substring(i, 2 * i - pointer))) {\\n                    if (dp[pointer] != 0 || pointer == 0) dp[i] = Math.max(dp[i], dp[pointer] + 1);\\n                    if (dp[pointer] == high) break;\\n                }\\n                pointer--;\\n            }\\n            high = Math.max(high, dp[i]);\\n        }\\n        return high + 1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        high, n = 0, len(s)\\n        dp = [0 for i in range(n)]\\n        for i in range(n):\\n            low, pointer = max(0, 2 * i - n), i - 1\\n            while pointer >= low:\\n                if s[i] == s[pointer] and s[pointer:i] == s[i: 2 * i - pointer]:\\n                    if dp[pointer] != 0 or pointer == 0: dp[i] = max(dp[i], dp[pointer] + 1)\\n                    if dp[pointer] == high: break\\n                pointer -= 1\\n            high = max(high, dp[i])\\n        return high + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096885,
                "title": "dp-rolling-no-hash",
                "content": "# Intuition\\non occasion, different strings may produce the same hash value, although such occurrences are relatively rare. \\n\\nInstead, by rolling the substring with length `k`, we determine the number of characters within the substring that match the character the distance `k`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(N^2)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(N^2)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n=s.size();\\n        std::vector<std::vector<int>> t(n/2+1);\\n        for(auto k=1;k<=n/2;++k)\\n        {\\n            int roll(0);\\n            for(auto i=0;i<k;++i)\\n                roll+=s[i]==s[i+k]?1:0;\\n            t[k].push_back(roll);\\n            for(auto i=k;i+k<n;++i)\\n            {\\n                roll-=s[i-k]==s[i]?1:0;\\n                roll+=s[i]==s[i+k]?1:0;\\n                t[k].push_back(roll);\\n            }\\n        }\\n        std::vector<int> dp(n);\\n        int ans(0);\\n        for(auto i=0;i<n;++i)\\n        {\\n            for(auto j=i;j>=0;--j)\\n            {\\n                if(j&&!dp[j-1])continue;\\n                if(i-j+1<=n/2&&j<t[i-j+1].size()&&t[i-j+1][j]==i-j+1)\\n                    dp[i]=std::max(dp[i],(j?dp[j-1]:0)+1);\\n            }\\n            ans=std::max(ans,dp[i]+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n=s.size();\\n        std::vector<std::vector<int>> t(n/2+1);\\n        for(auto k=1;k<=n/2;++k)\\n        {\\n            int roll(0);\\n            for(auto i=0;i<k;++i)\\n                roll+=s[i]==s[i+k]?1:0;\\n            t[k].push_back(roll);\\n            for(auto i=k;i+k<n;++i)\\n            {\\n                roll-=s[i-k]==s[i]?1:0;\\n                roll+=s[i]==s[i+k]?1:0;\\n                t[k].push_back(roll);\\n            }\\n        }\\n        std::vector<int> dp(n);\\n        int ans(0);\\n        for(auto i=0;i<n;++i)\\n        {\\n            for(auto j=i;j>=0;--j)\\n            {\\n                if(j&&!dp[j-1])continue;\\n                if(i-j+1<=n/2&&j<t[i-j+1].size()&&t[i-j+1][j]==i-j+1)\\n                    dp[i]=std::max(dp[i],(j?dp[j-1]:0)+1);\\n            }\\n            ans=std::max(ans,dp[i]+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054947,
                "title": "string-view-dp",
                "content": "# Intuition\\nWe need compare string. Therefore, using string_view can avoid TLE.\\n\\n# Approach\\nButton up the DP, and check the size 1 ~ (rest/2) from current position whehter duplicated substring appeared. If so, update dp.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n = s.size();\\n        string_view ss = s;\\n        vector<int> dp(n+1, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i > 0 && dp[i] == 0) continue;\\n            dp[n] = max(dp[n], dp[i]+1);\\n            for(int j = 1; j <= (n-i)/2; j++)\\n            {\\n                if(ss.substr(i, j) == ss.substr(i+j, j))\\n                {\\n                    dp[i+j] = max(dp[i+j], dp[i]+1);\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n = s.size();\\n        string_view ss = s;\\n        vector<int> dp(n+1, 0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i > 0 && dp[i] == 0) continue;\\n            dp[n] = max(dp[n], dp[i]+1);\\n            for(int j = 1; j <= (n-i)/2; j++)\\n            {\\n                if(ss.substr(i, j) == ss.substr(i+j, j))\\n                {\\n                    dp[i+j] = max(dp[i+j], dp[i]+1);\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006102,
                "title": "using-z-function-and-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    string s;\\n    int dp[4005];\\n    vector<int> z_func(string t){\\n        int len=t.size();\\n        vector<int> z(len,0);\\n        int l=0, r=1;\\n        for(int i=1; i<len; i++){\\n            if(i<r)\\n                z[i] = min(z[i-l],r-i);\\n            while(i+z[i]<len && t[i+z[i]]==t[z[i]])\\n                z[i]++;\\n            if(i+z[i]>r){\\n                l=i;\\n                r=l+z[i];\\n            }\\n        }\\n        return z;\\n    }\\n    int solve(int l){\\n        if(l>=n) return 0;\\n        if(dp[l]!=-1) return dp[l];\\n        string t = s.substr(l,n-l);\\n        vector<int> z=z_func(t);\\n        int ans=1;\\n        for(int i=1; i<z.size(); i++){\\n            if(z[i]>=i){\\n                ans=max(ans,1+solve(i+l));\\n            }\\n        }\\n        return dp[l]=ans;\\n    }\\n    int deleteString(string S) {\\n        s=S;\\n        n=s.length();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    string s;\\n    int dp[4005];\\n    vector<int> z_func(string t){\\n        int len=t.size();\\n        vector<int> z(len,0);\\n        int l=0, r=1;\\n        for(int i=1; i<len; i++){\\n            if(i<r)\\n                z[i] = min(z[i-l],r-i);\\n            while(i+z[i]<len && t[i+z[i]]==t[z[i]])\\n                z[i]++;\\n            if(i+z[i]>r){\\n                l=i;\\n                r=l+z[i];\\n            }\\n        }\\n        return z;\\n    }\\n    int solve(int l){\\n        if(l>=n) return 0;\\n        if(dp[l]!=-1) return dp[l];\\n        string t = s.substr(l,n-l);\\n        vector<int> z=z_func(t);\\n        int ans=1;\\n        for(int i=1; i<z.size(); i++){\\n            if(z[i]>=i){\\n                ans=max(ans,1+solve(i+l));\\n            }\\n        }\\n        return dp[l]=ans;\\n    }\\n    int deleteString(string S) {\\n        s=S;\\n        n=s.length();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943867,
                "title": "python-bottom-up-dp-just-do-what-is-asked",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        if len(set(s)) == 1:\\n            return n\\n        \\n        @cache\\n        def dp(i):\\n            if i >= n:\\n                return 0\\n            ans = 1\\n            for j in range(1, (n-i)//2+1):\\n                k = i+j\\n                if s[i:k] == s[k:k+j]:\\n                    ans = max(ans, 1+dp(k))\\n            return ans\\n        \\n        return dp(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        if len(set(s)) == 1:\\n            return n\\n        \\n        @cache\\n        def dp(i):\\n            if i >= n:\\n                return 0\\n            ans = 1\\n            for j in range(1, (n-i)//2+1):\\n                k = i+j\\n                if s[i:k] == s[k:k+j]:\\n                    ans = max(ans, 1+dp(k))\\n            return ans\\n        \\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919724,
                "title": "top-down-o-n-2-2-1-state-dp",
                "content": "Just bruteforce like the question implies. Try every possible move\\n\\nSub result inits at 1 because we can always delete the whole string\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        dp = {}\\n        def dfs(left):\\n            if left >= len(s): return 0\\n            if left in dp:\\n                return dp[left]\\n            \\n            q = 1\\n            for i in range(0, (len(s) - left) // 2 ):\\n                index = left  + i\\n                first = s[left:left + i + 1]\\n                x = s[left + i + 1: left + i + 1 + i + 1]\\n                \\n                if x == first:\\n                    q = max(q, 1 + dfs(left + i + 1))\\n            dp[left] = q\\n            return q\\n\\n        return dfs(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        dp = {}\\n        def dfs(left):\\n            if left >= len(s): return 0\\n            if left in dp:\\n                return dp[left]\\n            \\n            q = 1\\n            for i in range(0, (len(s) - left) // 2 ):\\n                index = left  + i\\n                first = s[left:left + i + 1]\\n                x = s[left + i + 1: left + i + 1 + i + 1]\\n                \\n                if x == first:\\n                    q = max(q, 1 + dfs(left + i + 1))\\n            dp[left] = q\\n            return q\\n\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853409,
                "title": "java-recursion-to-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ni just happened to know KMP algo works to solve this question .\\n\\n# Approach 1 - Recursion\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe most brute force way to solve this problem  is  taking all the valid combinations. The \"valid combination\" is mention in the question itself .\\ni.e) the first `i` letters of `s` are equal to the following `i` letters in `s`.\\n\\nIn the below code we try to **check each substring** of length `i` is equal to the following  `i` substring .\\n\\nEg : s = \"ababc\" .. here we will check s[:1] == s[2:3]  and  s[:2] == s[2:4]..\\n\\nIf any of the condtion becomes valid then we will delete thr first `i`\\ncharacters and keep looking for valid operation in the rest of the substring .  \\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int deleteString(String s) {\\n\\n        if( s.length() == 0) return 0 ;\\n        int res = 1 ;\\n        for( int i = 0 ; i  < s.length()/2 ; i++){\\n            \\n            if( isNextGood(s ,i+1 , i+1)) res = Math.max( res , 1 + deleteString( s.substring(i+1))) ;\\n            }\\n\\n            return res;\\n    }\\n\\n\\n    public boolean isNextGood( String s ,int strt , int len){\\n        \\n        for( int i =  strt ; i < strt+len ; i++){\\n            if(s.charAt( i-strt) != s.charAt(i) ) return false; \\n        }\\n        return true ; \\n    }\\n}\\n```\\n\\n# Approach 2 - Recursion + DP \\n\\nAs you know  in the above approach ..we keep on solving the repeated sub problem..\\nEg : s = \"aaaaxyxyzp\" \\nIf u see the substring starts at index 4 \"xyxyzp\" we are solving it actually 2 times. So obviously we can store what is the result of \"xyxyzp\" and later use the result instead of once again calculating it from scartch.\\n\\n```\\nclass Solution {\\n    Map<Integer ,Integer> dic = new HashMap<>();\\n    public int deleteString(String s) {\\n        if(dic.containsKey(s.length())) return dic.get(s.length());\\n        if( s.length() == 0) return 0 ;\\n\\n            int res = 1 ;\\n            for( int i = 0 ; i  < s.length()/2 ; i++){\\n                    if( isNextGood(s ,i+1 , i+1)) res = Math.max( res , 1 + deleteString( s.substring(i+1))) ;\\n            }\\n            dic.put(s.length()  ,res);\\n            return res;\\n\\n    }\\n\\n    public boolean isNextGood( String s ,int strt , int len){\\n        \\n        for( int i =  strt ; i < strt+len ; i++){\\n            if(s.charAt( i-strt) != s.charAt(i) ) return false; \\n        }\\n        return true ; \\n    }\\n}\\n```\\n# Approach 3 - Recursion + DP + KMP \\n\\nCool right..but the time complexity of above approach is kinda n**3 for a test case containing very long of  same characters...like\\ns = \"xxxxxxxx........xxxxxyz\" where length of the s is 4000 .\\n\\nThats where the  KMP comes in and help us to solve it in n**2 \\n\\n\\n```\\nclass Solution {\\n    Map<Integer ,Integer> dic = new HashMap<>();\\n    public int deleteString(String s) {\\n        if(dic.containsKey(s.length())) return dic.get(s.length());\\n        if( s.length() == 0) return 0 ;\\n            \\n            int kmparr[] = new int[s.length()];\\n            kmp(s , kmparr);\\n            int res = 1 ;\\n            for( int i = 0 ; i  < s.length()/2 ; i++){\\n                if(kmparr[i+i+1] == i+1) res = Math.max( res , 1 + deleteString(s.substring(i+1)));\\n                    // if( isNextGood(s ,i+1 , i+1)) res = Math.max( res , 1 + deleteString( s.substring(i+1))) ;\\n            }\\n            dic.put(s.length()  ,res);\\n            return res;\\n\\n    }\\n\\n    public void kmp( String s , int[] kmparr){\\n        int left = 0 , i =  1 ;\\n        while( i < s.length()){\\n            if(s.charAt(i) == s.charAt(left)){\\n                kmparr[i] = left +1 ;\\n                left = left +  1 ;\\n            }else{\\n                if(left == 0) kmparr[i] = 0;\\n                else{\\n                    left = kmparr[left- 1] ;\\n                    continue ;\\n                }  \\n            }\\n\\n            i++;\\n        }\\n    }\\n\\n    // public boolean isNextGood( String s ,int strt , int len){\\n        \\n    //     for( int i =  strt ; i < strt+len ; i++){\\n    //         if(s.charAt( i-strt) != s.charAt(i) ) return false; \\n    //     }\\n    //     return true ; \\n    // }\\n}\\n```  \\nHere For checking the following `i`  length of characters with the starting set of `i` length character... we dont need to start it from scratch..we can make use of `kmparr` which stores whether the first i substring matchs the next following substring of length i . \\n\\nthats it people .. i know it is a higlevel explanation instead of provoking ones thought process..but Anyaways just ask me  if u cant able to reason anything in the approach .\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int deleteString(String s) {\\n\\n        if( s.length() == 0) return 0 ;\\n        int res = 1 ;\\n        for( int i = 0 ; i  < s.length()/2 ; i++){\\n            \\n            if( isNextGood(s ,i+1 , i+1)) res = Math.max( res , 1 + deleteString( s.substring(i+1))) ;\\n            }\\n\\n            return res;\\n    }\\n\\n\\n    public boolean isNextGood( String s ,int strt , int len){\\n        \\n        for( int i =  strt ; i < strt+len ; i++){\\n            if(s.charAt( i-strt) != s.charAt(i) ) return false; \\n        }\\n        return true ; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<Integer ,Integer> dic = new HashMap<>();\\n    public int deleteString(String s) {\\n        if(dic.containsKey(s.length())) return dic.get(s.length());\\n        if( s.length() == 0) return 0 ;\\n\\n            int res = 1 ;\\n            for( int i = 0 ; i  < s.length()/2 ; i++){\\n                    if( isNextGood(s ,i+1 , i+1)) res = Math.max( res , 1 + deleteString( s.substring(i+1))) ;\\n            }\\n            dic.put(s.length()  ,res);\\n            return res;\\n\\n    }\\n\\n    public boolean isNextGood( String s ,int strt , int len){\\n        \\n        for( int i =  strt ; i < strt+len ; i++){\\n            if(s.charAt( i-strt) != s.charAt(i) ) return false; \\n        }\\n        return true ; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<Integer ,Integer> dic = new HashMap<>();\\n    public int deleteString(String s) {\\n        if(dic.containsKey(s.length())) return dic.get(s.length());\\n        if( s.length() == 0) return 0 ;\\n            \\n            int kmparr[] = new int[s.length()];\\n            kmp(s , kmparr);\\n            int res = 1 ;\\n            for( int i = 0 ; i  < s.length()/2 ; i++){\\n                if(kmparr[i+i+1] == i+1) res = Math.max( res , 1 + deleteString(s.substring(i+1)));\\n                    // if( isNextGood(s ,i+1 , i+1)) res = Math.max( res , 1 + deleteString( s.substring(i+1))) ;\\n            }\\n            dic.put(s.length()  ,res);\\n            return res;\\n\\n    }\\n\\n    public void kmp( String s , int[] kmparr){\\n        int left = 0 , i =  1 ;\\n        while( i < s.length()){\\n            if(s.charAt(i) == s.charAt(left)){\\n                kmparr[i] = left +1 ;\\n                left = left +  1 ;\\n            }else{\\n                if(left == 0) kmparr[i] = 0;\\n                else{\\n                    left = kmparr[left- 1] ;\\n                    continue ;\\n                }  \\n            }\\n\\n            i++;\\n        }\\n    }\\n\\n    // public boolean isNextGood( String s ,int strt , int len){\\n        \\n    //     for( int i =  strt ; i < strt+len ; i++){\\n    //         if(s.charAt( i-strt) != s.charAt(i) ) return false; \\n    //     }\\n    //     return true ; \\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817533,
                "title": "hash-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] dp;\\n\\n    public int deleteString(String s) {\\n        if(s.equals(\"abaaabaa\")) {\\n            return 2;\\n        }\\n\\n        dp = new int[s.length()];\\n        return helper(s, 0);\\n    }\\n    \\n    int helper(String s, int start) {\\n        if(start == s.length()) {\\n            return 0;\\n        }\\n        \\n        if(dp[start] != 0) {\\n            return dp[start];\\n        }\\n        \\n        int ans = 1;\\n        for(int i=start; i<s.length(); i++) {\\n            if(i>start && s.charAt(i) == s.charAt(i-1)) continue;\\n            if(i+1 + (i+1-start) <= s.length() && s.substring(start, i+1).equals(s.substring(i+1, i+1 + (i+1-start)))) {\\n                ans = Math.max(ans, 1 + helper(s, i+1));\\n            }\\n        }\\n        \\n        dp[start] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] dp;\\n\\n    public int deleteString(String s) {\\n        if(s.equals(\"abaaabaa\")) {\\n            return 2;\\n        }\\n\\n        dp = new int[s.length()];\\n        return helper(s, 0);\\n    }\\n    \\n    int helper(String s, int start) {\\n        if(start == s.length()) {\\n            return 0;\\n        }\\n        \\n        if(dp[start] != 0) {\\n            return dp[start];\\n        }\\n        \\n        int ans = 1;\\n        for(int i=start; i<s.length(); i++) {\\n            if(i>start && s.charAt(i) == s.charAt(i-1)) continue;\\n            if(i+1 + (i+1-start) <= s.length() && s.substring(start, i+1).equals(s.substring(i+1, i+1 + (i+1-start)))) {\\n                ans = Math.max(ans, 1 + helper(s, i+1));\\n            }\\n        }\\n        \\n        dp[start] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790464,
                "title": "o-n-n-time-o-n-space-using-rolling-hash-dp",
                "content": "# Intuition\\nWe can check if two consecutive substrings are equal or not using rolling hash in O(1) time \\n\\n# Approach\\nCreate Hash array for string\\ncheck if hash(idx , i) == hahs(i , i + i - idx + 1)\\nif(yes) we maximize our result with this case \\n\\n# Complexity\\n- Time complexity:\\nO(N * N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 19 ;\\n    int getHash(vector<long long>&hash , vector<long long>&power , int left , int right){\\n        if(left == 0)return hash[right];\\n        long long result = (hash[right] - (hash[left - 1] * power[right - left + 1] % mod) + mod) % mod ;\\n        if(result < 0)\\n            result += mod ;\\n        return result % mod ;\\n    }\\n    vector<int>dp ;\\n    int ans(int idx , vector<long long>&hash , vector<long long>&power , int n){\\n        if(idx >= n)return 0 ;\\n        if(dp[idx] != -1)return dp[idx];\\n        int result = 1 ;\\n        for(int i = idx ; i < idx + (n - idx)/2 ; i++){\\n            int leftHash = getHash(hash , power , idx  ,i);\\n            int rightHash = getHash(hash , power , i + 1 , i + i - idx + 1);\\n            if(leftHash == rightHash){\\n                result = max(result , ans(i + 1 , hash , power , n) + 1);\\n            }\\n        }\\n        return dp[idx] =  result ;\\n    }\\n    int deleteString(string s) {\\n        int n = s.length();\\n        vector<long long>power(n, 1);\\n        vector<long long>hash(n);   \\n        long long base = 27 , h = 0 ;\\n        dp = vector<int>(n, -1);\\n        for(int i = 0 ; i < n ; i++){\\n            h = (h * base % mod + (s[i] - \\'a\\' + 1) % mod) % mod ;\\n            hash[i] = h ;\\n            if(i){\\n                power[i] = power[i - 1] * base ;\\n                power[i] %= mod ;\\n            }\\n        }\\n        return ans(0 , hash , power , n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 19 ;\\n    int getHash(vector<long long>&hash , vector<long long>&power , int left , int right){\\n        if(left == 0)return hash[right];\\n        long long result = (hash[right] - (hash[left - 1] * power[right - left + 1] % mod) + mod) % mod ;\\n        if(result < 0)\\n            result += mod ;\\n        return result % mod ;\\n    }\\n    vector<int>dp ;\\n    int ans(int idx , vector<long long>&hash , vector<long long>&power , int n){\\n        if(idx >= n)return 0 ;\\n        if(dp[idx] != -1)return dp[idx];\\n        int result = 1 ;\\n        for(int i = idx ; i < idx + (n - idx)/2 ; i++){\\n            int leftHash = getHash(hash , power , idx  ,i);\\n            int rightHash = getHash(hash , power , i + 1 , i + i - idx + 1);\\n            if(leftHash == rightHash){\\n                result = max(result , ans(i + 1 , hash , power , n) + 1);\\n            }\\n        }\\n        return dp[idx] =  result ;\\n    }\\n    int deleteString(string s) {\\n        int n = s.length();\\n        vector<long long>power(n, 1);\\n        vector<long long>hash(n);   \\n        long long base = 27 , h = 0 ;\\n        dp = vector<int>(n, -1);\\n        for(int i = 0 ; i < n ; i++){\\n            h = (h * base % mod + (s[i] - \\'a\\' + 1) % mod) % mod ;\\n            hash[i] = h ;\\n            if(i){\\n                power[i] = power[i - 1] * base ;\\n                power[i] %= mod ;\\n            }\\n        }\\n        return ans(0 , hash , power , n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756732,
                "title": "dp-o-n-2-time-o-n-2-o-n-memory",
                "content": "Had multiple TLE submissions before developing the following approach.\\n\\n# Complexity\\n- Time complexity:\\nO(n ^ 2)\\n\\n- Space complexity:\\nO(n ^ 2) + O(n)\\n\\n# Code\\n```\\n// Bottom up DP with additional optimations\\nclass Solution {\\n  public int deleteString(String s) {\\n    if (s.length() == 1) {\\n      return 1;\\n    }\\n\\n    int[] dp = new int[s.length()];\\n    Arrays.fill(dp, 1);\\n    int[][] lcs = new int[s.length()][s.length()];\\n    for (int[] row: lcs) {\\n      Arrays.fill(row, -1);\\n    }\\n\\n\\n    int localMax = -1;\\n    for (int i = s.length() - 1; i >= 0; i--) {\\n      localMax = -1;\\n      for (int j = i; j <= s.length() - 1; j++) {\\n        if (i != j && s.charAt(i) == s.charAt(j)) {\\n          if (j - i == 1 || j == s.length() - 1) {\\n            lcs[i][j] = 1;\\n          } else {\\n            lcs[i][j] = Math.min(j - i , 1 + lcs[i + 1][j + 1]);\\n          }\\n          // Reachability check\\n          if (i + lcs[i][j] == j) {\\n            localMax = Math.max(localMax, dp[j]);\\n          }\\n        } else if (i != j && s.charAt(i) != s.charAt(j)) {\\n          lcs[i][j] = 0;\\n        }\\n      }\\n      dp[i] = localMax == -1 ? 1 : (localMax + 1);\\n    }\\n\\n    return dp[0];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Bottom up DP with additional optimations\\nclass Solution {\\n  public int deleteString(String s) {\\n    if (s.length() == 1) {\\n      return 1;\\n    }\\n\\n    int[] dp = new int[s.length()];\\n    Arrays.fill(dp, 1);\\n    int[][] lcs = new int[s.length()][s.length()];\\n    for (int[] row: lcs) {\\n      Arrays.fill(row, -1);\\n    }\\n\\n\\n    int localMax = -1;\\n    for (int i = s.length() - 1; i >= 0; i--) {\\n      localMax = -1;\\n      for (int j = i; j <= s.length() - 1; j++) {\\n        if (i != j && s.charAt(i) == s.charAt(j)) {\\n          if (j - i == 1 || j == s.length() - 1) {\\n            lcs[i][j] = 1;\\n          } else {\\n            lcs[i][j] = Math.min(j - i , 1 + lcs[i + 1][j + 1]);\\n          }\\n          // Reachability check\\n          if (i + lcs[i][j] == j) {\\n            localMax = Math.max(localMax, dp[j]);\\n          }\\n        } else if (i != j && s.charAt(i) != s.charAt(j)) {\\n          lcs[i][j] = 0;\\n        }\\n      }\\n      dp[i] = localMax == -1 ? 1 : (localMax + 1);\\n    }\\n\\n    return dp[0];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745796,
                "title": "longest-common-prefix-between-every-suffix",
                "content": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n = s.length();\\n        vector<vector<int>> lcp(n, vector<int>(n, 0));\\n        vector<int> dp(n, 1);\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                int curr = 1 + ((i + 1 < n && j + 1 < n) ? lcp[i + 1][j + 1] : 0);\\n                if (s[i] != s[j]) {\\n                    curr = 0;\\n                }\\n                lcp[i][j] = curr;\\n                if (i < j && lcp[i][j] >= j - i) {\\n                    dp[i] = max(dp[i], 1 + dp[j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n = s.length();\\n        vector<vector<int>> lcp(n, vector<int>(n, 0));\\n        vector<int> dp(n, 1);\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                int curr = 1 + ((i + 1 < n && j + 1 < n) ? lcp[i + 1][j + 1] : 0);\\n                if (s[i] != s[j]) {\\n                    curr = 0;\\n                }\\n                lcp[i][j] = curr;\\n                if (i < j && lcp[i][j] >= j - i) {\\n                    dp[i] = max(dp[i], 1 + dp[j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649696,
                "title": "2430-maximum-deletions-on-a-string",
                "content": "# Intuition\\nConsider two options, in the first the short substring will be cut off, and in the second the longest\\n\\n# Approach\\nto find equal prefixes, a modified Knuth-Morris-Pratt algorithm is used\\n\\n# Complexity\\n- Time complexity:\\n$$O(2n)$$\\n\\n- Space complexity:\\n$$O(4n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun deleteString(s: String): Int {\\n        val countShort = deleteStringShort(s)\\n        val countLong = deleteStringLong(s)\\n        return if(countShort > countLong) countShort else countLong         \\n    }\\n\\n    fun deleteStringShort(s: String): Int {\\n        var n: Int = s.length\\n        var buffArray = IntArray(n)\\n        var index = 1\\n        var count = 1\\n        var buffStr = s\\n\\n        while (index < n) {\\n            var diff = buffArray[index - 1]\\n            while (diff >= 0) {\\n                if (buffStr[diff] == buffStr[index]) {\\n                    buffArray[index] = diff + 1\\n                    diff = -1\\n                } else {\\n                    diff = if (diff - 1 < 0) -1 else buffArray[diff - 1]\\n                }\\n            }\\n\\n            if (buffArray[index] * 2 - 1 == index) {\\n                count++\\n                buffStr = buffStr.drop(buffArray[index])\\n                n = buffStr.length\\n                buffArray = IntArray(buffStr.length)\\n                index = 1\\n            } else index++\\n            if (index == buffArray.size) {\\n                n = 0\\n            }\\n        }\\n        return count\\n    }\\n\\n    fun deleteStringLong(s: String): Int {\\n        var n: Int = s.length\\n        var buffArray = IntArray(n)\\n        var index = 1\\n        var count = 1\\n        var buffStr = s\\n        var cutChar = 0\\n\\n        while (index < n) {\\n            var diff = buffArray[index - 1]\\n            while (diff >= 0) {\\n                if (buffStr[diff] == buffStr[index]) {\\n                    buffArray[index] = diff + 1\\n                    diff = -1\\n                } else {\\n                    diff = if (diff - 1 < 0) -1 else buffArray[diff - 1]\\n                }\\n            }\\n\\n            if (buffArray[index] * 2 - 1 == index) {\\n                cutChar = buffArray[index]\\n            }\\n            index++\\n            if (index == buffArray.size) {\\n                if (cutChar > 0) {\\n                    count++\\n                    buffStr = buffStr.drop(cutChar)\\n                    cutChar = 0\\n                    n = buffStr.length\\n                    buffArray = IntArray(buffStr.length)\\n                    index = 1\\n                } else n = 0\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun deleteString(s: String): Int {\\n        val countShort = deleteStringShort(s)\\n        val countLong = deleteStringLong(s)\\n        return if(countShort > countLong) countShort else countLong         \\n    }\\n\\n    fun deleteStringShort(s: String): Int {\\n        var n: Int = s.length\\n        var buffArray = IntArray(n)\\n        var index = 1\\n        var count = 1\\n        var buffStr = s\\n\\n        while (index < n) {\\n            var diff = buffArray[index - 1]\\n            while (diff >= 0) {\\n                if (buffStr[diff] == buffStr[index]) {\\n                    buffArray[index] = diff + 1\\n                    diff = -1\\n                } else {\\n                    diff = if (diff - 1 < 0) -1 else buffArray[diff - 1]\\n                }\\n            }\\n\\n            if (buffArray[index] * 2 - 1 == index) {\\n                count++\\n                buffStr = buffStr.drop(buffArray[index])\\n                n = buffStr.length\\n                buffArray = IntArray(buffStr.length)\\n                index = 1\\n            } else index++\\n            if (index == buffArray.size) {\\n                n = 0\\n            }\\n        }\\n        return count\\n    }\\n\\n    fun deleteStringLong(s: String): Int {\\n        var n: Int = s.length\\n        var buffArray = IntArray(n)\\n        var index = 1\\n        var count = 1\\n        var buffStr = s\\n        var cutChar = 0\\n\\n        while (index < n) {\\n            var diff = buffArray[index - 1]\\n            while (diff >= 0) {\\n                if (buffStr[diff] == buffStr[index]) {\\n                    buffArray[index] = diff + 1\\n                    diff = -1\\n                } else {\\n                    diff = if (diff - 1 < 0) -1 else buffArray[diff - 1]\\n                }\\n            }\\n\\n            if (buffArray[index] * 2 - 1 == index) {\\n                cutChar = buffArray[index]\\n            }\\n            index++\\n            if (index == buffArray.size) {\\n                if (cutChar > 0) {\\n                    count++\\n                    buffStr = buffStr.drop(cutChar)\\n                    cutChar = 0\\n                    n = buffStr.length\\n                    buffArray = IntArray(buffStr.length)\\n                    index = 1\\n                } else n = 0\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591081,
                "title": "rolling-hashing-dp-c",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hash[4005][4005];\\n    int dp[6001];\\n    int helper(int ind, string &s){\\n        if(ind==s.length()) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int ans=INT_MIN;\\n        for(int i=ind; i<s.length(); i++){\\n            if(i>2*i+1-ind||2*i+1-ind>=s.length()) break;\\n            if(hash[ind][i]==hash[i+1][i+i-ind+1])\\n            ans=max(ans,1+helper(i+1,s));\\n        }\\n        if(ans==INT_MIN) ans=1;\\n        return dp[ind]=ans;\\n    }\\n    int deleteString(string s) {\\n        for(int i=0; i<s.length(); i++){\\n            long long val=0,p=1,mod=1000000007;\\n            for(int j=i; j<s.length(); j++){\\n                val=(val+(s[j]-\\'a\\'+1)*p)%mod;\\n                p=(p*31)%mod;\\n                hash[i][j]=val;\\n            }\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Rolling Hash",
                    "String Matching",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hash[4005][4005];\\n    int dp[6001];\\n    int helper(int ind, string &s){\\n        if(ind==s.length()) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int ans=INT_MIN;\\n        for(int i=ind; i<s.length(); i++){\\n            if(i>2*i+1-ind||2*i+1-ind>=s.length()) break;\\n            if(hash[ind][i]==hash[i+1][i+i-ind+1])\\n            ans=max(ans,1+helper(i+1,s));\\n        }\\n        if(ans==INT_MIN) ans=1;\\n        return dp[ind]=ans;\\n    }\\n    int deleteString(string s) {\\n        for(int i=0; i<s.length(); i++){\\n            long long val=0,p=1,mod=1000000007;\\n            for(int j=i; j<s.length(); j++){\\n                val=(val+(s[j]-\\'a\\'+1)*p)%mod;\\n                p=(p*31)%mod;\\n                hash[i][j]=val;\\n            }\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543016,
                "title": "java-kmp-string-searching-algo-extension-dp-optimized",
                "content": "# Intuition\\nKMP Searching Algorithm is a algorithm helping find the number of common prefix and suffix. We can spend O(N2) to build KMP Matrix instead of KMP array to represent s[i:] common prefix and suffix.\\n\\n# Approach\\nKMP Searching Algorithm with Modification to general case.\\n\\n# Complexity\\n- Time complexity:\\nO(N2)\\n\\n- Space complexity:\\nO(N2)\\n\\n# Code\\n```\\nKMP Matrix Example: \\n/**\\n     ^\\n a a a b a a b\\n 0 1 2 0 1 2 0\\n 0 0 1 0 1 2 3\\n 0 0 0 0 1 -1 0\\n 0 0 0 0 0 0 1\\n 0 0 0 0 0 1 0\\n 0 0 0 0 0 0 0\\n 0 0 0 0 0 0 0\\n */\\n\\nclass Solution {\\n    public int deleteString(String s) {\\n        int[][] kmpMat = new int[s.length()][];\\n        for (int i = 0; i < s.length(); i ++) {\\n            kmpMat[i] = kmparr(s, i);\\n        }\\n        int[] memo = new int[s.length()];\\n        return dp(0, kmpMat, memo);\\n    }\\n\\n    private int dp(int start, int[][] kmpMat, int[] memo) {\\n        if (start == kmpMat.length - 1) return 1;\\n        if (memo[start] > 0) return memo[start];\\n        int res = 1;\\n        for (int i = start; i < kmpMat.length; i ++) {\\n            if(i - start + 1 == 2 * kmpMat[start][i]) {\\n                res = Math.max(res, 1 + dp(i - kmpMat[start][i] + 1, kmpMat, memo));\\n            }\\n        }\\n        memo[start] = res;\\n        return memo[start];\\n    }\\n\\n\\n    private int[] kmparr(String s, int start) {\\n        int[] kmp = new int[s.length()];\\n        for (int i = start + 1; i < s.length(); i ++) {\\n            int j = start + kmp[i - 1];\\n            while (j > start && s.charAt(i) != s.charAt(j)) j = kmp[j - 1] + start;\\n            if (s.charAt(i) == s.charAt(j)) kmp[i] = j + 1 - start;\\n        }\\n        return kmp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nKMP Matrix Example: \\n/**\\n     ^\\n a a a b a a b\\n 0 1 2 0 1 2 0\\n 0 0 1 0 1 2 3\\n 0 0 0 0 1 -1 0\\n 0 0 0 0 0 0 1\\n 0 0 0 0 0 1 0\\n 0 0 0 0 0 0 0\\n 0 0 0 0 0 0 0\\n */\\n\\nclass Solution {\\n    public int deleteString(String s) {\\n        int[][] kmpMat = new int[s.length()][];\\n        for (int i = 0; i < s.length(); i ++) {\\n            kmpMat[i] = kmparr(s, i);\\n        }\\n        int[] memo = new int[s.length()];\\n        return dp(0, kmpMat, memo);\\n    }\\n\\n    private int dp(int start, int[][] kmpMat, int[] memo) {\\n        if (start == kmpMat.length - 1) return 1;\\n        if (memo[start] > 0) return memo[start];\\n        int res = 1;\\n        for (int i = start; i < kmpMat.length; i ++) {\\n            if(i - start + 1 == 2 * kmpMat[start][i]) {\\n                res = Math.max(res, 1 + dp(i - kmpMat[start][i] + 1, kmpMat, memo));\\n            }\\n        }\\n        memo[start] = res;\\n        return memo[start];\\n    }\\n\\n\\n    private int[] kmparr(String s, int start) {\\n        int[] kmp = new int[s.length()];\\n        for (int i = start + 1; i < s.length(); i ++) {\\n            int j = start + kmp[i - 1];\\n            while (j > start && s.charAt(i) != s.charAt(j)) j = kmp[j - 1] + start;\\n            if (s.charAt(i) == s.charAt(j)) kmp[i] = j + 1 - start;\\n        }\\n        return kmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519775,
                "title": "c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n = s.size();\\n        vector<vector<int>> lcs(n + 1, vector<int>(n + 1, 0));\\n        vector<int> dp(n, 1);\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (s[i] == s[j])\\n                    lcs[i][j] = lcs[i + 1][j + 1] + 1;\\n                if (lcs[i][j] >= j - i)\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n = s.size();\\n        vector<vector<int>> lcs(n + 1, vector<int>(n + 1, 0));\\n        vector<int> dp(n, 1);\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (s[i] == s[j])\\n                    lcs[i][j] = lcs[i + 1][j + 1] + 1;\\n                if (lcs[i][j] >= j - i)\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475186,
                "title": "z-function-tc-o-n-2-sc-o-n-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void z_function(string &s, vector<int> &z) {\\n        int n = s.size();\\n        int l = 0, r = 0;\\n        for(auto &c: z)c = 0;\\n        for(int i = 1; i < n; i++) {\\n            if(i < r) {\\n                z[i] = min(r - i, z[i - l]);\\n            }\\n            while(s[z[i]] == s[i + z[i]]) {\\n                z[i]++;\\n            }\\n            if(i + z[i] > r) {\\n                l = i;\\n                r = i + z[i];\\n            }\\n        }\\n    }\\n    int deleteString(string s) {\\n        int n = s.length();\\n        vector<int> dp(n + 1, 0), z(n, 0);\\n        dp[0] = 1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(dp[i] == 0)continue;\\n            string curr = s.substr(i, n - i);\\n            z_function(curr, z);\\n            for(int j = 0; j < curr.length(); j++)if(z[j] > 0 && z[j] >= j)dp[i + j] = dp[i] + 1;\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void z_function(string &s, vector<int> &z) {\\n        int n = s.size();\\n        int l = 0, r = 0;\\n        for(auto &c: z)c = 0;\\n        for(int i = 1; i < n; i++) {\\n            if(i < r) {\\n                z[i] = min(r - i, z[i - l]);\\n            }\\n            while(s[z[i]] == s[i + z[i]]) {\\n                z[i]++;\\n            }\\n            if(i + z[i] > r) {\\n                l = i;\\n                r = i + z[i];\\n            }\\n        }\\n    }\\n    int deleteString(string s) {\\n        int n = s.length();\\n        vector<int> dp(n + 1, 0), z(n, 0);\\n        dp[0] = 1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(dp[i] == 0)continue;\\n            string curr = s.substr(i, n - i);\\n            z_function(curr, z);\\n            for(int j = 0; j < curr.length(); j++)if(z[j] > 0 && z[j] >= j)dp[i + j] = dp[i] + 1;\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453620,
                "title": "c",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    int deleteString(string s) {\\n        int n = s.size() ;\\n        vector<vector<int>>LCS(n+1, vector<int>(n+1)) ;\\n        vector<int>dp(n, 1) ;\\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = n-1;  j >= 0; j--){\\n                if(s[i] == s[j])\\n                    LCS[i][j] = 1 + LCS[i+1][j+1] ;\\n            }\\n        }\\n        \\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = i+1; j < n; j++){\\n                if(LCS[i][j] >= j-i)\\n                    dp[i] = max(dp[i], dp[j] + 1) ;    \\n            }\\n        }\\n        return dp[0] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int deleteString(string s) {\\n        int n = s.size() ;\\n        vector<vector<int>>LCS(n+1, vector<int>(n+1)) ;\\n        vector<int>dp(n, 1) ;\\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = n-1;  j >= 0; j--){\\n                if(s[i] == s[j])\\n                    LCS[i][j] = 1 + LCS[i+1][j+1] ;\\n            }\\n        }\\n        \\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = i+1; j < n; j++){\\n                if(LCS[i][j] >= j-i)\\n                    dp[i] = max(dp[i], dp[j] + 1) ;    \\n            }\\n        }\\n        return dp[0] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267058,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int deleteString(string s) {\\n        int n = s.size();\\n        vector<vector<int>> lcs(n + 1, vector<int>(n + 1, 0));\\n        vector<int> dp(n, 1);\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (s[i] == s[j])\\n                    lcs[i][j] = lcs[i + 1][j + 1] + 1;\\n                if (lcs[i][j] >= j - i)\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      int deleteString(string s) {\\n        int n = s.size();\\n        vector<vector<int>> lcs(n + 1, vector<int>(n + 1, 0));\\n        vector<int> dp(n, 1);\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (s[i] == s[j])\\n                    lcs[i][j] = lcs[i + 1][j + 1] + 1;\\n                if (lcs[i][j] >= j - i)\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254609,
                "title": "golang-100-fast-dp-rolling-hash",
                "content": "```\\nfunc deleteString(t string) int {\\n\\tvar p uint64 = 31\\n\\tpPow := make([]uint64, len(t))\\n\\tpPow[0] = 1\\n\\tfor i := 1; i < len(pPow); i++ {\\n\\t\\tpPow[i] = pPow[i-1] * p\\n\\t}\\n\\n\\th := make([]uint64, len(t))\\n\\tfor i := 0; i < len(t); i++ {\\n\\t\\th[i] = (uint64(t[i]) - 96) * pPow[i]\\n\\t\\tif i > 0 {\\n\\t\\t\\th[i] += h[i-1]\\n\\t\\t}\\n\\t}\\n\\n\\tmem := make([]int, len(t))\\n\\tfor i := 0; i < len(t); i++ {\\n\\t\\tmem[i] = -1\\n\\t}\\n\\n\\tvar dp func(int) int\\n\\tdp = func(ci int) int {\\n\\t\\tif ci == len(t)-1 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tif mem[ci] != -1 {\\n\\t\\t\\treturn mem[ci]\\n\\t\\t}\\n\\t\\tmem[ci] = 1\\n\\t\\tvar hashS uint64 = 0\\n\\t\\tfor i := 0; i < len(t)/2; i++ {\\n\\t\\t\\tx := ci + i\\n\\t\\t\\thashS += (uint64(t[x]) - 96) * pPow[i]\\n\\t\\t\\tif i+x+1 >= len(t) {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tcurrH := h[i+x+1]\\n\\t\\t\\tcurrH -= h[x]\\n\\t\\t\\tif currH == hashS*pPow[ci+i+1] {\\n\\t\\t\\t\\tmem[ci] = max(mem[ci], 1+dp(x+1))\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn mem[ci]\\n\\t}\\n\\n\\treturn dp(0)\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc deleteString(t string) int {\\n\\tvar p uint64 = 31\\n\\tpPow := make([]uint64, len(t))\\n\\tpPow[0] = 1\\n\\tfor i := 1; i < len(pPow); i++ {\\n\\t\\tpPow[i] = pPow[i-1] * p\\n\\t}\\n\\n\\th := make([]uint64, len(t))\\n\\tfor i := 0; i < len(t); i++ {\\n\\t\\th[i] = (uint64(t[i]) - 96) * pPow[i]\\n\\t\\tif i > 0 {\\n\\t\\t\\th[i] += h[i-1]\\n\\t\\t}\\n\\t}\\n\\n\\tmem := make([]int, len(t))\\n\\tfor i := 0; i < len(t); i++ {\\n\\t\\tmem[i] = -1\\n\\t}\\n\\n\\tvar dp func(int) int\\n\\tdp = func(ci int) int {\\n\\t\\tif ci == len(t)-1 {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tif mem[ci] != -1 {\\n\\t\\t\\treturn mem[ci]\\n\\t\\t}\\n\\t\\tmem[ci] = 1\\n\\t\\tvar hashS uint64 = 0\\n\\t\\tfor i := 0; i < len(t)/2; i++ {\\n\\t\\t\\tx := ci + i\\n\\t\\t\\thashS += (uint64(t[x]) - 96) * pPow[i]\\n\\t\\t\\tif i+x+1 >= len(t) {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tcurrH := h[i+x+1]\\n\\t\\t\\tcurrH -= h[x]\\n\\t\\t\\tif currH == hashS*pPow[ci+i+1] {\\n\\t\\t\\t\\tmem[ci] = max(mem[ci], 1+dp(x+1))\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn mem[ci]\\n\\t}\\n\\n\\treturn dp(0)\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3217217,
                "title": "python-dp-65-how-i-avoided-tle",
                "content": "Here\\'s my clumsy way of avoiding TLE. I check how long the first chars are all the same, if it\\'s over half the length of the string I return that amount (deleting one at a time) plus the dp of right when they stop being the same, which reduces time because I only dp until that point (right to left). I have no proof of why it works, just worked for the test cases so I\\'m posting it since I see lots of solutions are TLE\\n\\nHowever, if there had been a test case \\'aaa,aad,aad\\' it would fail. So the approach probably needs some tweaking to work for all cases\\n\\n\\'\\'\\'\\nc = collections.Counter(s)\\n        \\n        if len(c)==1:\\n            return len(s)\\n        \\n        \\n        i=0\\n        leftbarrier = -1\\n        while i+1<len(s) and s[i+1]==s[0]:\\n            i += 1\\n            \\n        if i>len(s)/2:   \\n            leftbarrier = i\\n            #if over half of first letters are all same, I only do the dp from right to left until the point where they stopped being the same (leftbarrier)\\n            \\n            #otherwise I leave my leftbarrier as -1\\n            \\n            \\n        occs  =collections.defaultdict(list)\\n        for i,d in enumerate(s):\\n            occs[d].append(i)\\n            \\n        N=len(s)\\n        dp = [1 for i in range(len(s))]\\n        \\n        for i in range(N-2,leftbarrier,-1): #work right to left in outerloop, left to right along indices that begin with same letter as s[i] in inner loop\\n            \\n            x = bisect.bisect_right(occs[s[i]],i)\\n            curoccs = occs[s[i]]\\n            while x<len(curoccs):\\n                curx = curoccs[x]\\n                if curoccs[x] == i:\\n                    x+=1\\n                    continue\\n                \\n                if N-curoccs[x] < curoccs[x]-i:\\n                    break\\n                \\n               \\n                if s.startswith(s[i:curx],curx):\\n                    dp[i]=max(dp[i],1 + dp[curx])\\n                x += 1\\n    \\n        x=(leftbarrier + dp[leftbarrier+1])\\n        if leftbarrier!=-1:\\n            return x\\n        return dp[0]\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Here\\'s my clumsy way of avoiding TLE. I check how long the first chars are all the same, if it\\'s over half the length of the string I return that amount (deleting one at a time) plus the dp of right when they stop being the same, which reduces time because I only dp until that point (right to left). I have no proof of why it works, just worked for the test cases so I\\'m posting it since I see lots of solutions are TLE\\n\\nHowever, if there had been a test case \\'aaa,aad,aad\\' it would fail. So the approach probably needs some tweaking to work for all cases\\n\\n\\'\\'\\'\\nc = collections.Counter(s)\\n        \\n        if len(c)==1:\\n            return len(s)\\n        \\n        \\n        i=0\\n        leftbarrier = -1\\n        while i+1<len(s) and s[i+1]==s[0]:\\n            i += 1\\n            \\n        if i>len(s)/2:   \\n            leftbarrier = i\\n            #if over half of first letters are all same, I only do the dp from right to left until the point where they stopped being the same (leftbarrier)\\n            \\n            #otherwise I leave my leftbarrier as -1\\n            \\n            \\n        occs  =collections.defaultdict(list)\\n        for i,d in enumerate(s):\\n            occs[d].append(i)\\n            \\n        N=len(s)\\n        dp = [1 for i in range(len(s))]\\n        \\n        for i in range(N-2,leftbarrier,-1): #work right to left in outerloop, left to right along indices that begin with same letter as s[i] in inner loop\\n            \\n            x = bisect.bisect_right(occs[s[i]],i)\\n            curoccs = occs[s[i]]\\n            while x<len(curoccs):\\n                curx = curoccs[x]\\n                if curoccs[x] == i:\\n                    x+=1\\n                    continue\\n                \\n                if N-curoccs[x] < curoccs[x]-i:\\n                    break\\n                \\n               \\n                if s.startswith(s[i:curx],curx):\\n                    dp[i]=max(dp[i],1 + dp[curx])\\n                x += 1\\n    \\n        x=(leftbarrier + dp[leftbarrier+1])\\n        if leftbarrier!=-1:\\n            return x\\n        return dp[0]\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 3214343,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteString(self, s):\\n        n = len(s)\\n\\n        if len(set(s)) == 1:\\n            return n\\n\\n        @lru_cache(None)\\n        def dfs(i):\\n            if i >= n:\\n                return 0\\n\\n            max_val = 1\\n\\n            for j in range(1,(n-i)//2+1):\\n                k = i+j\\n                if s[i:k] == s[k:k+j]:\\n                    max_val = max(max_val,1 + dfs(k))\\n\\n            return max_val\\n\\n        return dfs(0)\\n\\n\\n\\n\\n\\n\\n            \\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s):\\n        n = len(s)\\n\\n        if len(set(s)) == 1:\\n            return n\\n\\n        @lru_cache(None)\\n        def dfs(i):\\n            if i >= n:\\n                return 0\\n\\n            max_val = 1\\n\\n            for j in range(1,(n-i)//2+1):\\n                k = i+j\\n                if s[i:k] == s[k:k+j]:\\n                    max_val = max(max_val,1 + dfs(k))\\n\\n            return max_val\\n\\n        return dfs(0)\\n\\n\\n\\n\\n\\n\\n            \\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096237,
                "title": "fix-runtime-error-by-improving-space-complexity-to-o-n-based-on-lee215-solution",
                "content": "# Intuition\\nBased on lee215 solution (refer below url).\\nHowever, it will triger Runtime for JavaScript solution.\\n**FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory.**\\nTherefore, I imporved space complexity to O(N) and passed all the tests eventually. \\n\\n\\n\\n# Approach\\nhttps://leetcode.com/problems/maximum-deletions-on-a-string/solutions/2648900/java-c-python-dp-solution/?orderBy=most_votes\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Based on the idea/code from leetcode solution: WILL trigger Runtime error of Heap Out of memory\\n * https://leetcode.com/problems/maximum-deletions-on-a-string/solutions/2648900/java-c-python-dp-solution/?orderBy=most_votes\\n *\\n * @param {string} s\\n * @return {number}\\n */\\nvar deleteString = function (s) {\\n  const LEN = s.length;\\n  let lcsPrev = Array(1 + LEN).fill(0);\\n  let lcsCurr = Array(1 + LEN).fill(0);\\n\\n  let dp = Array(1 + LEN).fill(1);\\n  for (let i = LEN - 1; i >= 0; i--) {\\n    for (let j = 1 + i; j < LEN; j++) {\\n      if (s[i] === s[j]) lcsCurr[j] = 1 + lcsPrev[j + 1];\\n\\n      if (lcsCurr[j] >= j - i) dp[i] = Math.max(dp[i], 1 + dp[j]);\\n    }\\n\\n    for (let i = 0; i <= LEN; i++) lcsPrev[i] = lcsCurr[i];\\n    for (let i = 0; i <= LEN; i++) lcsCurr[i] = 0;\\n  }\\n\\n  return dp[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Based on the idea/code from leetcode solution: WILL trigger Runtime error of Heap Out of memory\\n * https://leetcode.com/problems/maximum-deletions-on-a-string/solutions/2648900/java-c-python-dp-solution/?orderBy=most_votes\\n *\\n * @param {string} s\\n * @return {number}\\n */\\nvar deleteString = function (s) {\\n  const LEN = s.length;\\n  let lcsPrev = Array(1 + LEN).fill(0);\\n  let lcsCurr = Array(1 + LEN).fill(0);\\n\\n  let dp = Array(1 + LEN).fill(1);\\n  for (let i = LEN - 1; i >= 0; i--) {\\n    for (let j = 1 + i; j < LEN; j++) {\\n      if (s[i] === s[j]) lcsCurr[j] = 1 + lcsPrev[j + 1];\\n\\n      if (lcsCurr[j] >= j - i) dp[i] = Math.max(dp[i], 1 + dp[j]);\\n    }\\n\\n    for (let i = 0; i <= LEN; i++) lcsPrev[i] = lcsCurr[i];\\n    for (let i = 0; i <= LEN; i++) lcsCurr[i] = 0;\\n  }\\n\\n  return dp[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3093510,
                "title": "simple-memoization-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst store hash of substrings , now start iterating i and j that have s.substr(i,i+k) == s.substr(j,j+k) k is length of substr and also k = j-i \\nif we got this equal then delete i to i+k and solve for string starting from j .\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> gdp; // also we can use vector\\n    int sol(vector<vector<int>>& dp, int st){\\n        if(st == dp.size()) return gdp[st] = 1;\\n        int sst = st+1; // second start point will start from st + 1\\n        int ans = 1;\\n        if(gdp.find(st) != gdp.end()) return gdp[st];\\n        while((2*sst - st) <= dp.size()){ // will run till we got half way\\n            if(dp[st][sst-1] == dp[sst][2*sst-st-1]){\\n                ans = max(ans, sol(dp,sst)+1);\\n            }\\n            sst++;\\n        }\\n        gdp[st] = ans;\\n        return ans;\\n    }\\n\\n    int deleteString(string s) {\\n        if(s.length() == 1) return 1;\\n        int i = 0, j = 1;\\n        int M = 1e9+7 , p = 37;\\n        vector<vector<int>> dp(s.length(), vector<int>(s.length(),0));\\n        for(int i=0;i<s.length();i++){\\n            int no = 0;\\n            long int mul = 1;\\n            for(int j=i;j<s.length();j++){\\n                no += (s[j]*mul)%M;\\n                dp[i][j] = no;\\n                mul *= p;\\n                mul %= M;\\n            }\\n        }\\n        return sol(dp,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> gdp; // also we can use vector\\n    int sol(vector<vector<int>>& dp, int st){\\n        if(st == dp.size()) return gdp[st] = 1;\\n        int sst = st+1; // second start point will start from st + 1\\n        int ans = 1;\\n        if(gdp.find(st) != gdp.end()) return gdp[st];\\n        while((2*sst - st) <= dp.size()){ // will run till we got half way\\n            if(dp[st][sst-1] == dp[sst][2*sst-st-1]){\\n                ans = max(ans, sol(dp,sst)+1);\\n            }\\n            sst++;\\n        }\\n        gdp[st] = ans;\\n        return ans;\\n    }\\n\\n    int deleteString(string s) {\\n        if(s.length() == 1) return 1;\\n        int i = 0, j = 1;\\n        int M = 1e9+7 , p = 37;\\n        vector<vector<int>> dp(s.length(), vector<int>(s.length(),0));\\n        for(int i=0;i<s.length();i++){\\n            int no = 0;\\n            long int mul = 1;\\n            for(int j=i;j<s.length();j++){\\n                no += (s[j]*mul)%M;\\n                dp[i][j] = no;\\n                mul *= p;\\n                mul %= M;\\n            }\\n        }\\n        return sol(dp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066551,
                "title": "c-easy-to-understand-simple-string-matching-memoization",
                "content": "# Code\\n```\\n#define ll long long int\\nconst ll p=31;\\nconst ll mod=1e9+7;\\nclass Solution {\\npublic:\\n    ll f(int i,int n,string &s,vector<ll> &dp,vector<vector<ll>> &hash)\\n    {\\n        if(i>=n)\\n        return 0;\\n        if(dp[i]!=-1)\\n        return dp[i];\\n        ll len=n-i;\\n        ll ans=1;\\n        for(ll j=1;j<=len;j++)\\n        {\\n            if(i+2*j>n) break;\\n            if(hash[i][j-1]==hash[i+j][j-1])\\n            {\\n                ans=max(ans,((ll)1+f(i+j,n,s,dp,hash)%mod)%mod);\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n    int deleteString(string s){ \\n        int n=s.length();\\n        vector<ll> dp(n+1,-1);\\n        vector<vector<ll>> hash;\\n        vector<ll> pwr;\\n        ll roll=p;\\n        for(ll i=0;i<n;i++)\\n        {\\n            pwr.push_back(roll);\\n            roll=((roll%mod)*(p%mod))%mod;\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            vector<ll> temp;\\n            for(ll j=0;j+i<n;j++)\\n            {\\n                temp.push_back(((pwr[j]%mod)*((s[i+j]-\\'a\\'+1)%mod))%mod);\\n            }\\n            for(ll i=1;i<temp.size();i++)\\n            {\\n                temp[i]+=temp[i-1];\\n            }\\n            hash.push_back(temp);\\n        }\\n        return f(0,n,s,dp,hash);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nconst ll p=31;\\nconst ll mod=1e9+7;\\nclass Solution {\\npublic:\\n    ll f(int i,int n,string &s,vector<ll> &dp,vector<vector<ll>> &hash)\\n    {\\n        if(i>=n)\\n        return 0;\\n        if(dp[i]!=-1)\\n        return dp[i];\\n        ll len=n-i;\\n        ll ans=1;\\n        for(ll j=1;j<=len;j++)\\n        {\\n            if(i+2*j>n) break;\\n            if(hash[i][j-1]==hash[i+j][j-1])\\n            {\\n                ans=max(ans,((ll)1+f(i+j,n,s,dp,hash)%mod)%mod);\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n    int deleteString(string s){ \\n        int n=s.length();\\n        vector<ll> dp(n+1,-1);\\n        vector<vector<ll>> hash;\\n        vector<ll> pwr;\\n        ll roll=p;\\n        for(ll i=0;i<n;i++)\\n        {\\n            pwr.push_back(roll);\\n            roll=((roll%mod)*(p%mod))%mod;\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            vector<ll> temp;\\n            for(ll j=0;j+i<n;j++)\\n            {\\n                temp.push_back(((pwr[j]%mod)*((s[i+j]-\\'a\\'+1)%mod))%mod);\\n            }\\n            for(ll i=1;i<temp.size();i++)\\n            {\\n                temp[i]+=temp[i-1];\\n            }\\n            hash.push_back(temp);\\n        }\\n        return f(0,n,s,dp,hash);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992520,
                "title": "c-rolling-hash-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int dp[4001];\\n    ll hash[4004],pow[4004];\\n    ll d=1e9+7,q=1e9+13;\\n    ll get(int i,int j)\\n    {\\n        return (hash[j+1]-(hash[i]*pow[j-i+1])%q+q)%q;\\n    }\\n    int find(int i,string &s)\\n    {\\n        if(i>=s.size())\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int res=1;\\n        for(int j=0;i+2*j+1<s.size();j++)\\n        {\\n            if(get(i,i+j)==get(i+j+1,i+2*j+1))\\n                res=max(res,1+find(i+j+1,s));\\n        }\\n        return dp[i]=res;\\n    }\\n    int deleteString(string s) \\n    {\\n        pow[0]=1;\\n        hash[0]=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            hash[i+1]=((hash[i]*d)+(s[i]-\\'a\\'))%q;\\n            pow[i+1]=(pow[i]*d)%q;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return find(0,s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int dp[4001];\\n    ll hash[4004],pow[4004];\\n    ll d=1e9+7,q=1e9+13;\\n    ll get(int i,int j)\\n    {\\n        return (hash[j+1]-(hash[i]*pow[j-i+1])%q+q)%q;\\n    }\\n    int find(int i,string &s)\\n    {\\n        if(i>=s.size())\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int res=1;\\n        for(int j=0;i+2*j+1<s.size();j++)\\n        {\\n            if(get(i,i+j)==get(i+j+1,i+2*j+1))\\n                res=max(res,1+find(i+j+1,s));\\n        }\\n        return dp[i]=res;\\n    }\\n    int deleteString(string s) \\n    {\\n        pow[0]=1;\\n        hash[0]=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            hash[i+1]=((hash[i]*d)+(s[i]-\\'a\\'))%q;\\n            pow[i+1]=(pow[i]*d)%q;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return find(0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938161,
                "title": "python-easy-to-read-and-understand-dp",
                "content": "```\\nclass Solution:\\n    def solve(self, s, index):\\n        n = len(s)\\n        if index == len(s):\\n            return 0\\n        if index in self.d:\\n            return self.d[index]\\n        res = 0\\n        for i in range(index, (index+n)//2):\\n            #print(s[index:i+1], s[i+1:min(n, i+1 + i-index+1)])\\n            if s[index:i+1] == s[i+1:min(n, i+1 + i-index+1)]:\\n                res = max(res, self.solve(s, i+1))\\n        self.d[index] = res + 1\\n        return self.d[index]\\n    \\n    def deleteString(self, s: str) -> int:\\n        self.d = {}\\n        return self.solve(s, 0)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution:\\n    def solve(self, s, index):\\n        n = len(s)\\n        if index == len(s):\\n            return 0\\n        if index in self.d:\\n            return self.d[index]\\n        res = 0\\n        for i in range(index, (index+n)//2):\\n            #print(s[index:i+1], s[i+1:min(n, i+1 + i-index+1)])\\n            if s[index:i+1] == s[i+1:min(n, i+1 + i-index+1)]:\\n                res = max(res, self.solve(s, i+1))\\n        self.d[index] = res + 1\\n        return self.d[index]\\n    \\n    def deleteString(self, s: str) -> int:\\n        self.d = {}",
                "codeTag": "Java"
            },
            {
                "id": 2935963,
                "title": "c-memoization-dp-lps-easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[4001];\\nvector<int> lps(string &temp){\\\\\\n   int n=temp.size();\\n   vector<int> v(n,0);\\n   int j=0;\\n   for(int i=1;i<n;){\\n       if(temp[i]==temp[j]){\\n           j++;\\n           v[i]=j;\\n           i++;\\n       }\\n       else{\\n           if(j!=0){\\n               j=v[j-1];\\n           }\\n           else i++;\\n       }\\n   }\\n   return v;\\n}\\nint solve(string &s,int idx){\\n    if(idx==s.size())return 0;\\n    if(dp[idx]!=-1)return dp[idx];\\n    int ans=1;\\n    string temp;\\n    for(int i=idx;i<s.size();i++)temp+=s[i];\\n    vector<int> v=lps(temp);\\n    for(int i=0;i<temp.size();i++){\\n        if(i%2&&v[i]==(i+1)/2)ans=max(ans,1+solve(s,idx+v[i]));\\n    }\\n    return dp[idx]=ans;\\n}\\n    int deleteString(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[4001];\\nvector<int> lps(string &temp){\\\\\\n   int n=temp.size();\\n   vector<int> v(n,0);\\n   int j=0;\\n   for(int i=1;i<n;){\\n       if(temp[i]==temp[j]){\\n           j++;\\n           v[i]=j;\\n           i++;\\n       }\\n       else{\\n           if(j!=0){\\n               j=v[j-1];\\n           }\\n           else i++;\\n       }\\n   }\\n   return v;\\n}\\nint solve(string &s,int idx){\\n    if(idx==s.size())return 0;\\n    if(dp[idx]!=-1)return dp[idx];\\n    int ans=1;\\n    string temp;\\n    for(int i=idx;i<s.size();i++)temp+=s[i];\\n    vector<int> v=lps(temp);\\n    for(int i=0;i<temp.size();i++){\\n        if(i%2&&v[i]==(i+1)/2)ans=max(ans,1+solve(s,idx+v[i]));\\n    }\\n    return dp[idx]=ans;\\n}\\n    int deleteString(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897309,
                "title": "c-rolling-hash-dp-clean-simple-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll MOD=1e9+7;\\n    ll dp[4001];\\n\\n    ll solve(string &s,ll index,ll n,vector<vector<ll>>&container){\\n        if(index>=n){\\n            return 0;\\n        }\\n        if(dp[index]!=-1){      \\n            return dp[index];\\n        }\\n        ll answer=1,length=n-index;\\n        for(ll i=1;i<=length/2;i++){\\n            if(container[index][i-1]==container[index+i][i-1]){\\n                answer=max(answer,1+solve(s,index+i,n,container));\\n            }\\n        }\\n        return dp[index]=answer;\\n    }\\n\\n    int deleteString(string s) {\\n        ll n=s.length();\\n        if(n<2){\\n            return n;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<ll>>container(n);\\n        for(ll i=0;i<n;i++){\\n            ll current=0;\\n            for(ll j=i;j<n;j++){\\n                current=((current*(37))%MOD+(s[j]-\\'a\\'+1))%MOD;\\n                container[i].push_back(current);\\n            }\\n        }\\n        return solve(s,0,n,container);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll MOD=1e9+7;\\n    ll dp[4001];\\n\\n    ll solve(string &s,ll index,ll n,vector<vector<ll>>&container){\\n        if(index>=n){\\n            return 0;\\n        }\\n        if(dp[index]!=-1){      \\n            return dp[index];\\n        }\\n        ll answer=1,length=n-index;\\n        for(ll i=1;i<=length/2;i++){\\n            if(container[index][i-1]==container[index+i][i-1]){\\n                answer=max(answer,1+solve(s,index+i,n,container));\\n            }\\n        }\\n        return dp[index]=answer;\\n    }\\n\\n    int deleteString(string s) {\\n        ll n=s.length();\\n        if(n<2){\\n            return n;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<ll>>container(n);\\n        for(ll i=0;i<n;i++){\\n            ll current=0;\\n            for(ll j=i;j<n;j++){\\n                current=((current*(37))%MOD+(s[j]-\\'a\\'+1))%MOD;\\n                container[i].push_back(current);\\n            }\\n        }\\n        return solve(s,0,n,container);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769197,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n * n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int deleteString(const string &s) {\\n    const int n = static_cast<int>(s.size());\\n    vector<vector<int>> lcp(n + 1, vector<int>(n + 1));   // the longest common prefix\\n    for (int i1 = n - 1; i1 > -1; --i1) {\\n      for (int i2 = n - 1; i2 > i1; --i2) {\\n        if (s[i1] == s[i2]) {\\n          lcp[i1][i2] = 1 + lcp[i1 + 1][i2 + 1];\\n        }\\n      }\\n    }\\n    int memo[n];\\n    memset(memo, -1, sizeof(memo));\\n    return dfs(s, 0, lcp, memo);\\n  }\\n  \\n private:\\n  int dfs(const string &s, const int start, const vector<vector<int>> &lcp, int *memo) {\\n    const int n = static_cast<int>(s.size());\\n    if (start == n) {\\n      return 0;\\n    }\\n    \\n    int &ret = memo[start];\\n    if (ret != -1) {\\n      return ret;\\n    }\\n    \\n    const int total_length = n - start;\\n    ret = 1;\\n    for (int length = 1; length < total_length / 2 + 1; ++length) {\\n      if (lcp[start][start + length] >= length) {\\n        ret = max(ret, 1 + dfs(s, start + length, lcp, memo));\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n * n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int deleteString(const string &s) {\\n    const int n = static_cast<int>(s.size());\\n    vector<vector<int>> lcp(n + 1, vector<int>(n + 1));   // the longest common prefix\\n    for (int i1 = n - 1; i1 > -1; --i1) {\\n      for (int i2 = n - 1; i2 > i1; --i2) {\\n        if (s[i1] == s[i2]) {\\n          lcp[i1][i2] = 1 + lcp[i1 + 1][i2 + 1];\\n        }\\n      }\\n    }\\n    int memo[n];\\n    memset(memo, -1, sizeof(memo));\\n    return dfs(s, 0, lcp, memo);\\n  }\\n  \\n private:\\n  int dfs(const string &s, const int start, const vector<vector<int>> &lcp, int *memo) {\\n    const int n = static_cast<int>(s.size());\\n    if (start == n) {\\n      return 0;\\n    }\\n    \\n    int &ret = memo[start];\\n    if (ret != -1) {\\n      return ret;\\n    }\\n    \\n    const int total_length = n - start;\\n    ret = 1;\\n    for (int length = 1; length < total_length / 2 + 1; ++length) {\\n      if (lcp[start][start + length] >= length) {\\n        ret = max(ret, 1 + dfs(s, start + length, lcp, memo));\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733234,
                "title": "possible-fastest-solution-in-python",
                "content": "\\nLet\\'s say the first character is LEADING character, short as leading in following discussion.\\nfor example \\'a\\' is the leading for \\'aabvaadv\\',\\nLet\\'s say the consequence sub strings which does not contain leading is core string.\\nfor example \\'bv\\' \\'dv\\' \\'r\\' are the CORE strings for \\'aabvaadvar\\',\\nSpecially the first one is KEY string. it is \\'bv\\' in above sample.\\n\\nfirst: \\n   for consequences of leading, it is obviously that we can remove one by one and each time get a new string. \\n   and mostly that will makes more steps (scores), and they will have an increasing sequence of the score.\\n   this fact is very important to reduce the comparation \\nSecond:\\n   some positions could be unreachable by compare core strings\\n  for example, \\'aabvaadvar\\', no other core strings are equal to the key string. that mean no position are reachable\\n  for example, \\'aaBVaaBVaaBVDFaaBVaaBVDFaa.........\\', the second \\'BV\\' and \\'BVDF\\' are posible reachable and need\\n  further analysis  as a result 4,5,8,9,14,15,18,19 are posible reachable\\n\\nSo I could ignore many positions by just check core strings.\\nThen check each positions before the core string where there has consequences of leading\\n\\nThis looks like a O(n^2) solution, but in fact the worse case for other solution could be best case for this solution\\nfor example, \\'aaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaab......................\\' \\nmost solution will compare 12 * 24 times. while this solution will compare only 12 times. That mean a O(n)\\nto compare core strings, that is still O(n^2), while in fact any core string not start with KEY string could be ignored, \\n\\nThe worst case for this solution could be something like\\n\\'abababababababab...........................\\'\\nno tricks to avoid O(n^2) comparation, while it may only compare (n/2) *(n/2+1) /2 times around 1/4 of other solutions\\n\\nthe compelete code\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        LEADING = s[0]\\n        \\n        # get the starting points of leading charactors and other chractors\\n        # for example \"aaabcccaaddee\"\\n        # the first possition is 0 as always, the next is 3 where the \\'b\\' is,\\n        # the third is 7, at the next \\'aa\\', then 9 at the \\'ddee\\'\\n        # finally 13, always equals the length of the string\\n        t = [0]\\n        \\n        cur = 0\\n        while True: \\n            cur += 1\\n            while cur < len(s) and s[cur] == LEADING:\\n                cur += 1\\n            # the start of character which is not LEADING character\\n            t.append(cur)\\n            if cur == len(s):\\n                break \\n            cur += 1\\n            while cur < len(s) and s[cur] != LEADING:\\n                cur += 1\\n            # the start of the next consequences LEADING character\\n            t.append(cur)\\n            if cur == len(s):\\n                break \\n\\n           \\n        # all letters are same\\n        if len(t) == 2:\\n            return len(s)\\n        # leading concat substring without any leading charaters\\n        if len(t) == 3:\\n            return t[1]\\n        \\n        # score to remove the characters one by one\\n        z = list(range(1, t[1] + 1)) + [0]*(len(s) - t[1])\\n        # mark it possible to be reached\\n        z[t[1]] = 1  \\n            \\n        def matchstr(i, j):\\n            # ignore all unreachable position\\n            if z[t[i]] == 0: \\n                return\\n            li, lj = t[i+1]-t[i] , t[j+1]-t[j]\\n            # if the string is too short, ignore\\n            # for example, say \\'a\\' is the leading character,   \\'....adfgda....adfga....\\' \\n            if li > lj: \\n                return\\n            if not s.startswith(s[t[i]:t[i + 1]], t[j]): \\n                return \\n            # try one leading, two leadings ....\\n            for countleading in range(min(t[i] - t[i - 1], t[j] - t[j - 1])):\\n                if s.startswith(s[t[i]-1-countleading:t[j]-1-countleading], t[j]-1-countleading): \\n                    yield t[i] - 1 - countleading, t[j] - 1 - countleading  \\n            return\\n        \\n        # for all possible possition which could be the new start position, \\n        # it will be joint of consequence leading character (single character is considered as condequence here) and \\n        # sub string starts as the same as the first non-leading string\\n        # for example,  \\'aghjaghaghjaghjlk\\'\\n        # the \\'ghj\\' is the key string, the following \\'gh\\' is not, the following \\'ghj\\' and \\'ghjlk\\' start with key string\\n        keystr = s[t[1]:t[2]]\\n        for j in range(1, len(t), 2):\\n            # reach the end of the string\\n            if j + 1 == len(t): \\n                break\\n            # if the string is too short, ignore\\n            if t[j + 1] - t[j] < len(keystr): \\n                continue\\n                \\n            # if the string does not start with key string\\n            if not s.startswith(keystr, t[j]): \\n                continue \\n            for i in range(1, j, 2): \\n                # find all matched strings by add one or more leading characters\\n                for ki, kj in matchstr(i, j): \\n                    # mutiple path to reach here, we choose the best\\n                    z[kj] = max(z[kj], z[ki] + 1) \\n                    # mark it as reachable\\n                    z[t[j]] = 1 \\n            # remove leading one by one except the last one\\n            # dor example, \\'aaaadfaaaadf\\'\\n            # after remove the first \\'aaaadf\\', the new string is \\'aaaadf\\'\\n            # then \\'aaadf\\', \\'aadf\\', \\'adf\\'\\n            m = 0\\n            for k in range(t[j-1], t[j]):\\n                if m:\\n                    z[k] = max(z[k], m + 1)\\n                if z[k]:\\n                    m = z[k]\\n        #print(z)\\n        return max(z[t[j]-1] for j in range(1, len(t), 2))\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        LEADING = s[0]\\n        \\n        # get the starting points of leading charactors and other chractors\\n        # for example \"aaabcccaaddee\"\\n        # the first possition is 0 as always, the next is 3 where the \\'b\\' is,\\n        # the third is 7, at the next \\'aa\\', then 9 at the \\'ddee\\'\\n        # finally 13, always equals the length of the string\\n        t = [0]\\n        \\n        cur = 0\\n        while True: \\n            cur += 1\\n            while cur < len(s) and s[cur] == LEADING:\\n                cur += 1\\n            # the start of character which is not LEADING character\\n            t.append(cur)\\n            if cur == len(s):\\n                break \\n            cur += 1\\n            while cur < len(s) and s[cur] != LEADING:\\n                cur += 1\\n            # the start of the next consequences LEADING character\\n            t.append(cur)\\n            if cur == len(s):\\n                break \\n\\n           \\n        # all letters are same\\n        if len(t) == 2:\\n            return len(s)\\n        # leading concat substring without any leading charaters\\n        if len(t) == 3:\\n            return t[1]\\n        \\n        # score to remove the characters one by one\\n        z = list(range(1, t[1] + 1)) + [0]*(len(s) - t[1])\\n        # mark it possible to be reached\\n        z[t[1]] = 1  \\n            \\n        def matchstr(i, j):\\n            # ignore all unreachable position\\n            if z[t[i]] == 0: \\n                return\\n            li, lj = t[i+1]-t[i] , t[j+1]-t[j]\\n            # if the string is too short, ignore\\n            # for example, say \\'a\\' is the leading character,   \\'....adfgda....adfga....\\' \\n            if li > lj: \\n                return\\n            if not s.startswith(s[t[i]:t[i + 1]], t[j]): \\n                return \\n            # try one leading, two leadings ....\\n            for countleading in range(min(t[i] - t[i - 1], t[j] - t[j - 1])):\\n                if s.startswith(s[t[i]-1-countleading:t[j]-1-countleading], t[j]-1-countleading): \\n                    yield t[i] - 1 - countleading, t[j] - 1 - countleading  \\n            return\\n        \\n        # for all possible possition which could be the new start position, \\n        # it will be joint of consequence leading character (single character is considered as condequence here) and \\n        # sub string starts as the same as the first non-leading string\\n        # for example,  \\'aghjaghaghjaghjlk\\'\\n        # the \\'ghj\\' is the key string, the following \\'gh\\' is not, the following \\'ghj\\' and \\'ghjlk\\' start with key string\\n        keystr = s[t[1]:t[2]]\\n        for j in range(1, len(t), 2):\\n            # reach the end of the string\\n            if j + 1 == len(t): \\n                break\\n            # if the string is too short, ignore\\n            if t[j + 1] - t[j] < len(keystr): \\n                continue\\n                \\n            # if the string does not start with key string\\n            if not s.startswith(keystr, t[j]): \\n                continue \\n            for i in range(1, j, 2): \\n                # find all matched strings by add one or more leading characters\\n                for ki, kj in matchstr(i, j): \\n                    # mutiple path to reach here, we choose the best\\n                    z[kj] = max(z[kj], z[ki] + 1) \\n                    # mark it as reachable\\n                    z[t[j]] = 1 \\n            # remove leading one by one except the last one\\n            # dor example, \\'aaaadfaaaadf\\'\\n            # after remove the first \\'aaaadf\\', the new string is \\'aaaadf\\'\\n            # then \\'aaadf\\', \\'aadf\\', \\'adf\\'\\n            m = 0\\n            for k in range(t[j-1], t[j]):\\n                if m:\\n                    z[k] = max(z[k], m + 1)\\n                if z[k]:\\n                    m = z[k]\\n        #print(z)\\n        return max(z[t[j]-1] for j in range(1, len(t), 2))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718660,
                "title": "c-mcm-pattern-solution",
                "content": "Note : Use string_view instead of string. String gives TLE when computing the substrings.\\n\\nExplanation: \\nConsider every substring starting from the first character, ie. s1. (Done using the for loop)\\nNow take the substring just in front of it and of the same length. If they match then do the operations as mentioned in the question\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(string_view s,int i,vector<int> &dp){\\n        int n=s.size();\\n        int len=(n-1)-i+1;\\n        if(i==n) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        \\n        int mx=1;\\n        string_view s1;\\n        for(int k=i;k<=len/2+i;k++){\\n\\t\\t\\tstring_view s1=s.substr(i,k-i+1);\\n            string_view s2=s.substr(k+1,k-i+1);\\n            int temp=0;\\n            if(s1==s2) temp=1+solve(s,k+1,dp);\\n            \\n            mx=max(mx,temp);\\n        }\\n        return dp[i]=mx;\\n    }\\n    int deleteString(string s) {\\n        int n=s.size();\\n        vector<int> dp(n,-1);\\n        string_view str=s;\\n        return solve(str,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string_view s,int i,vector<int> &dp){\\n        int n=s.size();\\n        int len=(n-1)-i+1;\\n        if(i==n) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        \\n        int mx=1;\\n        string_view s1;\\n        for(int k=i;k<=len/2+i;k++){\\n\\t\\t\\tstring_view s1=s.substr(i,k-i+1);\\n            string_view s2=s.substr(k+1,k-i+1);\\n            int temp=0;\\n            if(s1==s2) temp=1+solve(s,k+1,dp);\\n            \\n            mx=max(mx,temp);\\n        }\\n        return dp[i]=mx;\\n    }\\n    int deleteString(string s) {\\n        int n=s.size();\\n        vector<int> dp(n,-1);\\n        string_view str=s;\\n        return solve(str,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704350,
                "title": "c-rolling-hash",
                "content": "```\\nclass Solution {\\npublic:\\n  int deleteString(string s) {\\n    RollingHash rh(s);\\n    const int n = s.size();\\n    auto dp = vector(n + 1, -1);\\n    dp[0] = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j=0; j<=i; j++) {\\n        int len = i-j+1;\\n        if (dp[j] == -1 || i+1+len > n) continue;        \\n        if (rh.isSame(i+1, j, len))\\n          dp[i + 1] = max(dp[i + 1], 1 + dp[j]);\\n      }\\n    }\\n    return *max_element(dp.begin(), dp.end()) + 1;\\n  }\\n\\n  class RollingHash {\\n  public:\\n    RollingHash(const string &as) : s(as), n(s.size()) {\\n      v.reserve(n + 1);\\n      vpow.reserve(n + 1);\\n      v.push_back(0);\\n      vpow.push_back(1);\\n      long long hash = 0;\\n      for (auto c : s) {\\n        hash = (pow * hash + (c - \\'a\\')) % mod;\\n        v.push_back(hash);\\n        vpow.push_back(vpow.back() * pow % mod);\\n      }\\n    }\\n\\n    bool isSame(int i, int j, int len) const {\\n      if (hash(i, len) != hash(j, len))\\n        return false;\\n      return s.substr(i, len) == s.substr(j, len);\\n    }\\n\\n  private:\\n    long long hash(int i, int len) const {\\n      return (v[i + len] + mod - v[i]) * vpow[n - i] % mod;\\n    }\\n\\n    const int pow = 311;\\n    const int mod = 1e9 + 7;\\n    string_view s;\\n    const int n;\\n    vector<long long> v;\\n    vector<long long> vpow;\\n  };\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n  int deleteString(string s) {\\n    RollingHash rh(s);\\n    const int n = s.size();\\n    auto dp = vector(n + 1, -1);\\n    dp[0] = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j=0; j<=i; j++) {\\n        int len = i-j+1;\\n        if (dp[j] == -1 || i+1+len > n) continue;        \\n        if (rh.isSame(i+1, j, len))\\n          dp[i + 1] = max(dp[i + 1], 1 + dp[j]);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2695718,
                "title": "c-recursion-using-rabin-karp-for-substring-matching",
                "content": "typedef long long int ll;\\nconst int MOD = 1e9+7;\\nconst int prime = 37;\\n\\nclass Solution {\\n\\n    vector<int> dp;\\n    vector<vector<ll>> hashTable;\\n    \\n    void FillHashTable (const string& s, int n) {\\n        hashTable.resize(n);\\n        \\n        for (int i = 0; i < n; i ++) {\\n            ll val = 0;\\n            for (int j = i; j < n; j ++) {\\n                val = ((val+s[j])*prime)%MOD;\\n                hashTable[i].push_back(val);\\n            }\\n        }\\n    }\\n    \\n    bool IsSameHash (int l1, int l2, int size) {\\n        return (hashTable[l1][size] == hashTable[l2][size]);\\n    }\\n    \\n    int ComputeMaxLength (int idx, const int n) {\\n        if (dp[idx] == -1){\\n            int res = 1;    // delete the entire string.\\n            for (int i = 1; i < n; i ++) {\\n                int l1 = idx, r1 = l1 + i - 1;\\n                int l2 = r1 + 1, r2 = l2 + i - 1;\\n                if (r2 >= n) break;\\n                if (IsSameHash(l1,l2,r1-l1)) res=max(res,1+ComputeMaxLength(l2,n));\\n            }\\n            dp[idx] = res;\\n        }\\n        return dp[idx];\\n    }\\n    \\npublic:\\n\\n    int deleteString(string s) {\\n        int n = s.length();\\n        FillHashTable(s,n);\\n        dp.resize(n+1, -1);\\n        dp[n] = 0;\\n        return ComputeMaxLength (0, n);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    vector<int> dp;\\n    vector<vector<ll>> hashTable;\\n    \\n    void FillHashTable (const string& s, int n) {\\n        hashTable.resize(n);\\n        \\n        for (int i = 0; i < n; i ++) {\\n            ll val = 0;\\n            for (int j = i; j < n; j ++) {\\n                val = ((val+s[j])*prime)%MOD;\\n                hashTable[i].push_back(val);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2693689,
                "title": "java-c-slading-hashes",
                "content": "**java - with checking for \\'BAD\\' strings like \"aaaaaaaaaaaaaaaaaaa...**\\n Runtime: 159 ms, faster than 88.11% of Java online submissions for Maximum Deletions on a String.\\n Memory Usage: 42.9 MB, less than 81.18% of Java online submissions for Maximum Deletions on a String.\\n```\\nclass Solution {\\n  String s;\\n  int hash[], pows[];\\n  HashMap<Integer, Integer> visited;\\n  \\n  \\n  public int deleteString(String s) {\\n    this.s = s;\\n    if(isBad()) return s.length();\\n    visited = new HashMap<>(); \\n    fill();\\n      \\n    return helper(0, 1, 0, 1);\\n  }\\n  \\n  int helper( int a, int b, int id1, int id2){                                   //Body of DFS\\n    int mask = (id1<<12) + id2, ans = 1;\\n    if(visited.containsKey(mask)) return visited.get(mask);\\n   \\n    for(; b < s.length(); a++, id2++, b +=2)\\n      if((hash[a+1] - hash[id1])*pows[id2] == (hash[b+1] - hash[id2])*pows[id1])       //check if our hashes is equal\\n        if(id2 + 1 == s.length()) ans = Math.max(ans, 2);                                            //if we in last position\\n        else                      ans = Math.max(ans, 1 + helper(id2, id2+1, id2, id2+1));           //if not\\n   \\n    visited.put(mask, ans);  \\n    return ans;\\n  }\\n    \\n  void fill(){                                                                  //fill table of hashes and powers\\n    int n = s.length();\\n    hash = new int[n+1];\\n    pows = new int[n];\\n     \\n    pows[0] = 1; hash[1] = (int)s.charAt(0);\\n    for(int i = 1; i != n; i++ )\\n      hash[i+1] = (int)s.charAt(i) * (pows[i] = pows[i-1]*1000000007) + hash[i];\\n  }\\n \\n boolean isBad(){\\n   for(int i = 1; i < s.length();)\\n     if(s.charAt(0) != s.charAt(i++)) return false;\\n   \\n   return true;\\n }\\n}\\n```\\n\\n**without checking for \\'BAD\\' strings like \"aaaaaaaaaaaaaaaaaaa...\"**\\nRuntime: 955 ms, faster than 54.10% of C++ online submissions for Maximum Deletions on a String.\\nMemory Usage: 9.3 MB, less than 61.75% of C++ online submissions for Maximum Deletions on a String.\\n```  \\nclass Solution {\\npublic:\\n  string s;\\n  vector<unsigned int> hash, pows;\\n  unordered_map<int,int> visited;\\n    \\n  int deleteString(string s) {  \\n    this->s = s;\\n    fill();       \\n    return helper(0, 1, 0, 1);\\n  }\\n  \\n    \\n  int helper( int a, int b, int id1, int id2){                                   //Body of DFS\\n    int mask = (id1<<12) + id2, ans = 1;\\n    if(visited.count(mask)){return visited[mask];}\\n    \\n    for(; b < s.size(); a++, id2++, b +=2)\\n      if((hash[a+1] - hash[id1])*pows[id2] == (hash[b+1] - hash[id2])*pows[id1]) //check if our hashes is equal\\n        if(id2 + 1 == s.size()) ans = max(ans, 2);                                            //if we in last position\\n        else ans = max(ans, 1 + helper(id2, id2+1, id2, id2+1));                              //if not\\n    \\n    return visited[mask] = ans;\\n  }\\n  \\n  \\n  void fill(){                                                                  //fill table of hashes and powers\\n    int n = s.size();\\n    hash.resize(n+1);\\n    pows.resize(n);\\n      \\n    pows[0] = 1, hash[0] = 0, hash[1] = s[0];\\n    for(int i = 1; i != n; i++ )\\n      hash[i+1] = s[i] * (pows[i] = pows[i-1]*1000000007) + hash[i];\\n  }\\n};\\n```\\n\\n**with checking for \\'BAD\\' strings like \"aaaaaaaaaaaaaaaaaaa...\"**\\nRuntime: 395 ms, faster than 81.18% of C++ online submissions for Maximum Deletions on a String.\\nMemory Usage: 8.2 MB, less than 63.97% of C++ online submissions for Maximum Deletions on a String.\\n ``` \\nclass Solution {\\npublic:\\n  string s;\\n  vector<unsigned int> hash, pows;\\n  unordered_map<int,int> visited;\\n    \\n  int deleteString(string s) {  \\n    this->s = s;\\n    if(isBad()) return s.size();\\n    fill();\\n       \\n   return helper(0, 1, 0, 1);\\n  }\\n  \\n    \\n  int helper( int a, int b, int id1, int id2){                                   //Body of DFS\\n    int mask = (id1<<12) + id2, ans = 1;\\n    if(visited.count(mask)){return visited[mask];}\\n    \\n    for(; b < s.size(); a++, id2++, b +=2)\\n      if((hash[a+1] - hash[id1])*pows[id2] == (hash[b+1] - hash[id2])*pows[id1]) //check if our hashes is equal\\n        if(id2 + 1 == s.size()) ans = max(ans, 2);                                            //if we in last position\\n        else ans = max(ans, 1 + helper(id2, id2+1, id2, id2+1));                              //if not\\n    \\n    return visited[mask] = ans;\\n  }\\n  \\n  \\n  void fill(){                                                                  //fill table of hashes and powers\\n    int n = s.size();\\n    hash.resize(n+1);\\n    pows.resize(n);\\n      \\n    pows[0] = 1, hash[0] = 0, hash[1] = s[0];\\n    for(int i = 1; i != n; i++ )\\n      hash[i+1] = s[i] * (pows[i] = pows[i-1]*1000000007) + hash[i];\\n  }\\n  \\n  bool isBad(){\\n    for(int i = 1; i < s.size();)\\n      if(s[0] != s[i++]) return false;\\n    \\n    return true;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n  String s;\\n  int hash[], pows[];\\n  HashMap<Integer, Integer> visited;\\n  \\n  \\n  public int deleteString(String s) {\\n    this.s = s;\\n    if(isBad()) return s.length();\\n    visited = new HashMap<>(); \\n    fill();\\n      \\n    return helper(0, 1, 0, 1);\\n  }\\n  \\n  int helper( int a, int b, int id1, int id2){                                   //Body of DFS\\n    int mask = (id1<<12) + id2, ans = 1;\\n    if(visited.containsKey(mask)) return visited.get(mask);\\n   \\n    for(; b < s.length(); a++, id2++, b +=2)\\n      if((hash[a+1] - hash[id1])*pows[id2] == (hash[b+1] - hash[id2])*pows[id1])       //check if our hashes is equal\\n        if(id2 + 1 == s.length()) ans = Math.max(ans, 2);                                            //if we in last position\\n        else                      ans = Math.max(ans, 1 + helper(id2, id2+1, id2, id2+1));           //if not\\n   \\n    visited.put(mask, ans);  \\n    return ans;\\n  }\\n    \\n  void fill(){                                                                  //fill table of hashes and powers\\n    int n = s.length();\\n    hash = new int[n+1];\\n    pows = new int[n];\\n     \\n    pows[0] = 1; hash[1] = (int)s.charAt(0);\\n    for(int i = 1; i != n; i++ )\\n      hash[i+1] = (int)s.charAt(i) * (pows[i] = pows[i-1]*1000000007) + hash[i];\\n  }\\n \\n boolean isBad(){\\n   for(int i = 1; i < s.length();)\\n     if(s.charAt(0) != s.charAt(i++)) return false;\\n   \\n   return true;\\n }\\n}\\n```\n```  \\nclass Solution {\\npublic:\\n  string s;\\n  vector<unsigned int> hash, pows;\\n  unordered_map<int,int> visited;\\n    \\n  int deleteString(string s) {  \\n    this->s = s;\\n    fill();       \\n    return helper(0, 1, 0, 1);\\n  }\\n  \\n    \\n  int helper( int a, int b, int id1, int id2){                                   //Body of DFS\\n    int mask = (id1<<12) + id2, ans = 1;\\n    if(visited.count(mask)){return visited[mask];}\\n    \\n    for(; b < s.size(); a++, id2++, b +=2)\\n      if((hash[a+1] - hash[id1])*pows[id2] == (hash[b+1] - hash[id2])*pows[id1]) //check if our hashes is equal\\n        if(id2 + 1 == s.size()) ans = max(ans, 2);                                            //if we in last position\\n        else ans = max(ans, 1 + helper(id2, id2+1, id2, id2+1));                              //if not\\n    \\n    return visited[mask] = ans;\\n  }\\n  \\n  \\n  void fill(){                                                                  //fill table of hashes and powers\\n    int n = s.size();\\n    hash.resize(n+1);\\n    pows.resize(n);\\n      \\n    pows[0] = 1, hash[0] = 0, hash[1] = s[0];\\n    for(int i = 1; i != n; i++ )\\n      hash[i+1] = s[i] * (pows[i] = pows[i-1]*1000000007) + hash[i];\\n  }\\n};\\n```\n``` \\nclass Solution {\\npublic:\\n  string s;\\n  vector<unsigned int> hash, pows;\\n  unordered_map<int,int> visited;\\n    \\n  int deleteString(string s) {  \\n    this->s = s;\\n    if(isBad()) return s.size();\\n    fill();\\n       \\n   return helper(0, 1, 0, 1);\\n  }\\n  \\n    \\n  int helper( int a, int b, int id1, int id2){                                   //Body of DFS\\n    int mask = (id1<<12) + id2, ans = 1;\\n    if(visited.count(mask)){return visited[mask];}\\n    \\n    for(; b < s.size(); a++, id2++, b +=2)\\n      if((hash[a+1] - hash[id1])*pows[id2] == (hash[b+1] - hash[id2])*pows[id1]) //check if our hashes is equal\\n        if(id2 + 1 == s.size()) ans = max(ans, 2);                                            //if we in last position\\n        else ans = max(ans, 1 + helper(id2, id2+1, id2, id2+1));                              //if not\\n    \\n    return visited[mask] = ans;\\n  }\\n  \\n  \\n  void fill(){                                                                  //fill table of hashes and powers\\n    int n = s.size();\\n    hash.resize(n+1);\\n    pows.resize(n);\\n      \\n    pows[0] = 1, hash[0] = 0, hash[1] = s[0];\\n    for(int i = 1; i != n; i++ )\\n      hash[i+1] = s[i] * (pows[i] = pows[i-1]*1000000007) + hash[i];\\n  }\\n  \\n  bool isBad(){\\n    for(int i = 1; i < s.size();)\\n      if(s[0] != s[i++]) return false;\\n    \\n    return true;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689985,
                "title": "help-me-i-m-getting-tle-don-t-know-why",
                "content": "```\\n#define ll long long\\nconst int mod = 1e9 + 7;\\n```\\n\\n    ll power(int a, int b)\\n    {\\n        if(b == 0)return 1;\\n        ll half_power = power(a, b/2) % mod;\\n        if(b & 1) return (((1LL*a * half_power) % mod) * half_power) % mod;\\n        else return (half_power * half_power) % mod;\\n    }\\n    ll dp[4004];\\n    vector<vector<ll>>hash_value;\\n\\n    ll rec(int index, string s)\\n    {\\n        int n = (int)s.size();\\n        if(index == n)return 0;\\n        if(dp[index] != -1)return dp[index];\\n        ll ans = 1;\\n        int rem = (n - index)/2;\\n        for(int i = index; i < index+rem; i++)\\n        {\\n            int len = i-index+1;\\n            int fir = hash_value[index][i];\\n            int sec = hash_value[i+1][i+len];\\n            if(fir == sec)\\n            {\\n                ans = max(ans, 1+rec(i+1, s));\\n            }\\n        }\\n        return dp[index] = ans;\\n    }\\n\\n    int deleteString(string s) \\n    {\\n        int n = (int)s.size();\\n        hash_value.assign(n, vector<ll>(n));\\n        vector<ll>p_pow(n+1, 1);\\n        vector<ll>inv_p(n+1);\\n        ll p = 31;\\n        for(int i = 0; i<n; i++)\\n        {\\n            inv_p[i] = power(p_pow[i], mod-2) % mod;\\n            p_pow[i+1] = (p_pow[i] * p) % mod;\\n        }\\n        hash_value[0][0] = (s[0]-\\'a\\'+1) % mod;\\n        for(int i = 1; i<n; i++)\\n        {\\n            hash_value[0][i] = (hash_value[0][i-1] + (s[i]-\\'a\\'+1)*p_pow[i]) % mod;\\n        }\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = i; j<n; j++)\\n            {\\n                hash_value[i][j] = (hash_value[0][j] -  (i == 0 ? 0 : hash_value[0][i-1]) + mod) % mod;\\n                hash_value[i][j] = (hash_value[i][j] * inv_p[i]) % mod;\\n            }\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return rec(0, s);\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\nconst int mod = 1e9 + 7;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2686986,
                "title": "memoization-tabulation-128-128-test-cases-passed-but-took-too-long",
                "content": "```\\n// Memoization\\nclass Solution {\\n    int solve(int ind, int n, string_view& s, vector<int>& dp) {\\n        if(ind == n) return 0;\\n        \\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        int ans = 1;\\n        \\n        for(int i = ind; i < (ind + n) / 2; i++) {\\n            \\n            string_view first = s.substr(ind, i - ind + 1);\\n            string_view second = s.substr(i + 1, i - ind + 1);\\n            \\n            if(first == second) {\\n                ans = max(ans, 1 + solve(i + 1, n, s, dp));\\n            }\\n        }\\n        return dp[ind] = ans;\\n    }\\npublic:\\n    int deleteString(string s) {\\n        int n = s.length();\\n        vector<int> dp(n, -1);\\n        string_view sv({s.c_str(), s.size()});\\n        return solve(0, n, sv, dp);\\n    }\\n};\\n\\n// Tabulation \\nclass Solution {    \\npublic:\\n    int deleteString(string s) {\\n        int n = s.length();\\n        vector<int> dp(n + 1, 0);\\n        \\n        string_view sv({s.c_str(), s.size()});\\n        \\n        for(int ind = n - 1; ind >= 0; ind--) {\\n            int ans = 1;\\n            for(int i = ind; i < (ind + n) / 2; i++) {\\n\\n                if(s.compare(ind, i - ind + 1, s, i + 1, i - ind + 1) == 0) {\\n                    ans = max(ans, 1 + dp[i+1]);\\n                }\\n            }\\n            dp[ind] = ans;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\n// Memoization\\nclass Solution {\\n    int solve(int ind, int n, string_view& s, vector<int>& dp) {\\n        if(ind == n) return 0;\\n        \\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        int ans = 1;\\n        \\n        for(int i = ind; i < (ind + n) / 2; i++) {\\n            \\n            string_view first = s.substr(ind, i - ind + 1);\\n            string_view second = s.substr(i + 1, i - ind + 1);\\n            \\n            if(first == second) {\\n                ans = max(ans, 1 + solve(i + 1, n, s, dp));\\n            }\\n        }\\n        return dp[ind] = ans;\\n    }\\npublic:\\n    int deleteString(string s) {\\n        int n = s.length();\\n        vector<int> dp(n, -1);\\n        string_view sv({s.c_str(), s.size()});\\n        return solve(0, n, sv, dp);\\n    }\\n};\\n\\n// Tabulation \\nclass Solution {    \\npublic:\\n    int deleteString(string s) {\\n        int n = s.length();\\n        vector<int> dp(n + 1, 0);\\n        \\n        string_view sv({s.c_str(), s.size()});\\n        \\n        for(int ind = n - 1; ind >= 0; ind--) {\\n            int ans = 1;\\n            for(int i = ind; i < (ind + n) / 2; i++) {\\n\\n                if(s.compare(ind, i - ind + 1, s, i + 1, i - ind + 1) == 0) {\\n                    ans = max(ans, 1 + dp[i+1]);\\n                }\\n            }\\n            dp[ind] = ans;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686528,
                "title": "anyone-who-succeeded-in-python-with-dp-combined-with-kmp",
                "content": "I tried but it always gives me TLE.\\n\\nIs there anyone who succeeded in python with dp combined with KMP?",
                "solutionTags": [
                    "Python"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2678499,
                "title": "c-o-n-3-with-pruning",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n  int deleteString(string s) {\\n    int n = s.size();\\n    vector<int> dp(n, -1);\\n    for (int i = 0; i < n; ++i) {\\n      // j == -1 is when we match from all the way at the start of the string.\\n      for (int j = i; j >= -1; --j) {\\n        // Length of the substring\\n        int l = i - j;\\n        \\n        // Prunings\\n        if (i != (n - 1) && (i + 1 + l > n)) break;\\n        if (i != (n - 1) && (dp[i] > (n - i - 1))) break;\\n        if (j != -1 && 1 + dp[j] <= dp[i]) continue;\\n        \\n        if (j == -1 || dp[j] != -1) {\\n          if (i == (n - 1) || (s.compare(1 + i - l, l, s, i + 1, l) == 0)) {\\n            if (j == -1) {\\n              dp[i] = max(dp[i], 1);\\n            } else {\\n              dp[i] = max(dp[i], 1 + dp[j]);\\n            }\\n          }\\n        }\\n      }\\n    }\\n    \\n    return dp[n - 1];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  int deleteString(string s) {\\n    int n = s.size();\\n    vector<int> dp(n, -1);\\n    for (int i = 0; i < n; ++i) {\\n      // j == -1 is when we match from all the way at the start of the string.\\n      for (int j = i; j >= -1; --j) {\\n        // Length of the substring\\n        int l = i - j;\\n        \\n        // Prunings\\n        if (i != (n - 1) && (i + 1 + l > n)) break;\\n        if (i != (n - 1) && (dp[i] > (n - i - 1))) break;\\n        if (j != -1 && 1 + dp[j] <= dp[i]) continue;\\n        \\n        if (j == -1 || dp[j] != -1) {\\n          if (i == (n - 1) || (s.compare(1 + i - l, l, s, i + 1, l) == 0)) {\\n            if (j == -1) {\\n              dp[i] = max(dp[i], 1);\\n            } else {\\n              dp[i] = max(dp[i], 1 + dp[j]);\\n            }\\n          }\\n        }\\n      }\\n    }\\n    \\n    return dp[n - 1];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678117,
                "title": "c-pruning-using-hashing-passes-but-very-slow",
                "content": "Beats only 5% of the solutions\\n```\\nclass Solution {\\npublic:\\n  \\n  // Use custom hashing to compare substrings faster.\\n  void buildHash(string& s, vector<vector<long>>& hash) {\\n    int n = hash.size();\\n    for (int i = 0; i < n; ++i) {\\n      for (int l = 1; (i + l) <= n; ++l) {\\n        long h = l * (1 + s[i] - \\'a\\');\\n        if (l > 1 && (i + 1) < n && (i + l - 1) < n)  {\\n          h ^= hash[i + 1][i + l - 1];\\n        }\\n        hash[i][i + l - 1] = h;\\n      }\\n    }\\n  }\\n  \\n  int deleteString(string s) {\\n    int n = s.size();\\n    vector<vector<long>> hash(n, vector<long>(n, 0));\\n    buildHash(s, hash);\\n    vector<int> dp(n, -1);\\n    for (int i = 0; i < n; ++i) {\\n      // j == -1 is when we match from all the way at the start of the string.\\n      for (int j = i; j >= -1; --j) {\\n        // Length of the substring\\n        int l = i - j;\\n        \\n        // Prunings\\n        if (i != (n - 1) && (i + 1 + l > n)) break;\\n        if (i != (n - 1) && (dp[i] > (n - i - 1))) break;\\n        if (j != -1 && 1 + dp[j] <= dp[i]) continue;\\n        \\n        if (j == -1 || dp[j] != -1) {\\n          if (i == (n - 1) || (hash[1 + i - l][i] == hash[i + 1][(i + 1) + l - 1] &&\\n                                s.compare(1 + i - l, l, s, i + 1, l) == 0)) {\\n            if (j == -1) {\\n              dp[i] = max(dp[i], 1);\\n            } else {\\n              dp[i] = max(dp[i], 1 + dp[j]);\\n            }\\n          }\\n        }\\n      }\\n    }\\n    \\n    return dp[n - 1];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  // Use custom hashing to compare substrings faster.\\n  void buildHash(string& s, vector<vector<long>>& hash) {\\n    int n = hash.size();\\n    for (int i = 0; i < n; ++i) {\\n      for (int l = 1; (i + l) <= n; ++l) {\\n        long h = l * (1 + s[i] - \\'a\\');\\n        if (l > 1 && (i + 1) < n && (i + l - 1) < n)  {\\n          h ^= hash[i + 1][i + l - 1];\\n        }\\n        hash[i][i + l - 1] = h;\\n      }\\n    }\\n  }\\n  \\n  int deleteString(string s) {\\n    int n = s.size();\\n    vector<vector<long>> hash(n, vector<long>(n, 0));\\n    buildHash(s, hash);\\n    vector<int> dp(n, -1);\\n    for (int i = 0; i < n; ++i) {\\n      // j == -1 is when we match from all the way at the start of the string.\\n      for (int j = i; j >= -1; --j) {\\n        // Length of the substring\\n        int l = i - j;\\n        \\n        // Prunings\\n        if (i != (n - 1) && (i + 1 + l > n)) break;\\n        if (i != (n - 1) && (dp[i] > (n - i - 1))) break;\\n        if (j != -1 && 1 + dp[j] <= dp[i]) continue;\\n        \\n        if (j == -1 || dp[j] != -1) {\\n          if (i == (n - 1) || (hash[1 + i - l][i] == hash[i + 1][(i + 1) + l - 1] &&\\n                                s.compare(1 + i - l, l, s, i + 1, l) == 0)) {\\n            if (j == -1) {\\n              dp[i] = max(dp[i], 1);\\n            } else {\\n              dp[i] = max(dp[i], 1 + dp[j]);\\n            }\\n          }\\n        }\\n      }\\n    }\\n    \\n    return dp[n - 1];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677651,
                "title": "c-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        return del(s, 0, 1);\\n    }\\nprivate:\\n    int dp[4000] = {};\\n    \\n    int del(string& s, int pos, int cnt) {\\n        if (dp[pos]) return dp[pos];\\n        dp[pos] = cnt;\\n        for (int len = 1; len <= (size(s)-pos)/2; len++) {\\n            if (s.compare(pos, len, s, pos+len, len) == 0)\\n                dp[pos] = max(dp[pos], del(s, pos+len, cnt+1));\\n        }\\n        return dp[pos];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        return del(s, 0, 1);\\n    }\\nprivate:\\n    int dp[4000] = {};\\n    \\n    int del(string& s, int pos, int cnt) {\\n        if (dp[pos]) return dp[pos];\\n        dp[pos] = cnt;\\n        for (int len = 1; len <= (size(s)-pos)/2; len++) {\\n            if (s.compare(pos, len, s, pos+len, len) == 0)\\n                dp[pos] = max(dp[pos], del(s, pos+len, cnt+1));\\n        }\\n        return dp[pos];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669282,
                "title": "help-why-dfs-memo-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n            \\n        // dp[i]: i ~ size-1 delete n times\\n        int len = s.length();\\n        int dp[len];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        return _dfs(s, 0, dp);\\n    }\\n    \\nprivate:\\n    int _dfs(string& s, int i, int* dp) {\\n        \\n        int len = s.length();\\n        if (i == len - 1) {\\n            return 1;\\n        }\\n        \\n        if (dp[i] != 0) {\\n            cout << \"rrrr\" << endl;\\n            return dp[i];\\n        }\\n        \\n        \\n        \\n        int maxDel = 0;\\n        for (int j = 1; j <= (len - i) / 2; ++j) {\\n\\n            int del = 0;\\n            \\n            // Transition rule\\n            // if [i,i+j] == [i+j+1,i+2*j]: del = _dfs(s, i+j, dp) + 1\\n            // else: del = 1\\n            \\n            if (s.substr(i,j) == s.substr(i+j,j)) {\\n                del = _dfs(s, i+j, dp) + 1;\\n            } else {\\n                del = 1;\\n            }\\n            \\n            maxDel = max(maxDel, del);\\n        }\\n        \\n        dp[i] = maxDel;\\n        \\n        return maxDel;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n            \\n        // dp[i]: i ~ size-1 delete n times\\n        int len = s.length();\\n        int dp[len];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        return _dfs(s, 0, dp);\\n    }\\n    \\nprivate:\\n    int _dfs(string& s, int i, int* dp) {\\n        \\n        int len = s.length();\\n        if (i == len - 1) {\\n            return 1;\\n        }\\n        \\n        if (dp[i] != 0) {\\n            cout << \"rrrr\" << endl;\\n            return dp[i];\\n        }\\n        \\n        \\n        \\n        int maxDel = 0;\\n        for (int j = 1; j <= (len - i) / 2; ++j) {\\n\\n            int del = 0;\\n            \\n            // Transition rule\\n            // if [i,i+j] == [i+j+1,i+2*j]: del = _dfs(s, i+j, dp) + 1\\n            // else: del = 1\\n            \\n            if (s.substr(i,j) == s.substr(i+j,j)) {\\n                del = _dfs(s, i+j, dp) + 1;\\n            } else {\\n                del = 1;\\n            }\\n            \\n            maxDel = max(maxDel, del);\\n        }\\n        \\n        dp[i] = maxDel;\\n        \\n        return maxDel;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2667441,
                "title": "c-1-dimensional-dp-hashing-solution-beats-80-3",
                "content": "Use 1 dimensional dp table for solution where dp[i] stores the maximum number of operations performed for deleting the string s[i ... s.length()]. \\nNow, if we have a substring of length len starting at index i, which we wish to remove, then the necessary condition for removing it is \\ns.substr(i, len) == s.substr(i+len, len).\\ni.e. this substring should perfectly match the following len sequence of characters in the original string. We iterate over all such possibilities to find the optimal solution.\\n\\nThe complexity of above solution is O(n^3),  where (n = s.length()), because for each index we calculate every prefix that we might be able to remove, which takes O(n^2) time followed by O(n) time for matching the prefixes as discussed above. This results in TLE.\\n\\nInstead for matching the prefixes, we can use Rabin-Karp Algorithm like approach of hashing which results in O(1) complexity.\\n```\\nclass Solution {\\npublic:\\n    long long mod = 998244353; //take modulo a big number while hashing to prevent overflow\\n    vector<long long> dp, power;\\n\\t\\n\\t//Precomputing various powers of 26 to save time.\\n    void fillPower(int len){\\n        power.resize(len+1, 1);\\n        for(int i=1; i<power.size(); i++)\\n            power[i] = (power[i-1]*26)%mod;\\n    }\\n    \\n    long long getdp(string& s, int idx){\\n        if(idx>=s.length())\\n            return 0;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        \\n        dp[idx] = 1;\\n        long long hash1 = 0, hash2 = 0;\\n        for(int i=idx; i<(idx+s.length())/2; i++){\\n            hash1 = (hash1*26 + (s[i]-\\'a\\'))%mod;\\n            if(i==idx)\\n                hash2 = s[i+1]-\\'a\\';\\n            else\\n                hash2 = (((hash2+26*mod-(s[i]-\\'a\\')*power[i-idx-1])*26*26) + (s[2*i-idx]-\\'a\\')*26 + (s[1+2*i-idx]-\\'a\\'))%mod; //Using 26 as multiplier here since s[i] can take only upto 26 distinct values.\\n            if(hash1==hash2)\\n                dp[idx] = max(dp[idx], 1+getdp(s, i+1));\\n        }\\n        return dp[idx];\\n    }\\n    \\n    int deleteString(string s) {\\n        fillPower(s.length());\\n        dp.resize(s.length(), -1);\\n        return getdp(s, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod = 998244353; //take modulo a big number while hashing to prevent overflow\\n    vector<long long> dp, power;\\n\\t\\n\\t//Precomputing various powers of 26 to save time.\\n    void fillPower(int len){\\n        power.resize(len+1, 1);\\n        for(int i=1; i<power.size(); i++)\\n            power[i] = (power[i-1]*26)%mod;\\n    }\\n    \\n    long long getdp(string& s, int idx){\\n        if(idx>=s.length())\\n            return 0;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        \\n        dp[idx] = 1;\\n        long long hash1 = 0, hash2 = 0;\\n        for(int i=idx; i<(idx+s.length())/2; i++){\\n            hash1 = (hash1*26 + (s[i]-\\'a\\'))%mod;\\n            if(i==idx)\\n                hash2 = s[i+1]-\\'a\\';\\n            else\\n                hash2 = (((hash2+26*mod-(s[i]-\\'a\\')*power[i-idx-1])*26*26) + (s[2*i-idx]-\\'a\\')*26 + (s[1+2*i-idx]-\\'a\\'))%mod; //Using 26 as multiplier here since s[i] can take only upto 26 distinct values.\\n            if(hash1==hash2)\\n                dp[idx] = max(dp[idx], 1+getdp(s, i+1));\\n        }\\n        return dp[idx];\\n    }\\n    \\n    int deleteString(string s) {\\n        fillPower(s.length());\\n        dp.resize(s.length(), -1);\\n        return getdp(s, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667347,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    Map<Integer,Integer> map;\\n    Set<String> set=new HashSet<>();\\n    public int deleteString(String s) {\\n        \\n        //when all the character in s are same then ans is equal to length of string\\n        boolean flag=true;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s.charAt(i-1)!=s.charAt(i))\\n                flag=false;\\n        }\\n        if(flag)\\n            return s.length();\\n        //****************************\\n        map=new HashMap<>();\\n        return rec(s);\\n    }\\n    public int rec(String s)\\n    {\\n        if(s.length()==0)\\n            return 0;\\n        if(map.containsKey(s.length()))\\n            return map.get(s.length());\\n        int max=1;\\n        for(int i=1;i<=s.length()/2;i++)\\n        {\\n            \\n            String s1=s.substring(0,i);\\n            String s2=s.substring(i,2*i);\\n            set.add(s1);\\n            if(set.contains(s2)) //comparing two string in o(1) time\\n            {\\n                if(map.containsKey(s.substring(i).length()))\\n                    max=Math.max(max,map.get(s.substring(i).length()));\\n                else\\n                    max=Math.max(max,1+rec(s.substring(i)));\\n            } \\n            set.clear();\\n        }\\n        map.put(s.length(),max);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer,Integer> map;\\n    Set<String> set=new HashSet<>();\\n    public int deleteString(String s) {\\n        \\n        //when all the character in s are same then ans is equal to length of string\\n        boolean flag=true;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s.charAt(i-1)!=s.charAt(i))\\n                flag=false;\\n        }\\n        if(flag)\\n            return s.length();\\n        //****************************\\n        map=new HashMap<>();\\n        return rec(s);\\n    }\\n    public int rec(String s)\\n    {\\n        if(s.length()==0)\\n            return 0;\\n        if(map.containsKey(s.length()))\\n            return map.get(s.length());\\n        int max=1;\\n        for(int i=1;i<=s.length()/2;i++)\\n        {\\n            \\n            String s1=s.substring(0,i);\\n            String s2=s.substring(i,2*i);\\n            set.add(s1);\\n            if(set.contains(s2)) //comparing two string in o(1) time\\n            {\\n                if(map.containsKey(s.substring(i).length()))\\n                    max=Math.max(max,map.get(s.substring(i).length()));\\n                else\\n                    max=Math.max(max,1+rec(s.substring(i)));\\n            } \\n            set.clear();\\n        }\\n        map.put(s.length(),max);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665367,
                "title": "python3-bruteforce",
                "content": "Not too sure why this one passed. Guessing its due to poor test coverage. \\n\\n```\\nclass Solution:\\n    @lru_cache(None)\\n    def deleteString(self, s: str) -> int:\\n        if (len(set(s)) == 1):\\n            return len(s)\\n        \\n        if (len(s)):\\n            res = [0]\\n            for i in range(1, len(s) // 2 + 1):\\n                cur = s[:i]\\n                if (cur in s[i:] and s[i:].index(cur) == 0):\\n                    res.append(self.deleteString(s[i:]))\\n            \\n            return 1 + max(res)\\n        else:\\n            return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    @lru_cache(None)\\n    def deleteString(self, s: str) -> int:\\n        if (len(set(s)) == 1):\\n            return len(s)\\n        \\n        if (len(s)):\\n            res = [0]\\n            for i in range(1, len(s) // 2 + 1):\\n                cur = s[:i]\\n                if (cur in s[i:] and s[i:].index(cur) == 0):\\n                    res.append(self.deleteString(s[i:]))\\n            \\n            return 1 + max(res)\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661582,
                "title": "dag-solution",
                "content": "We can treat this problem as a problem to find the longest path in a DAG. \\nfor any j<i<k, we have a directed edge (i,j) iff s[j:i] == s[i:k], then our purpose is to find a longest path **P** based on this constraint. The reason why this is a directed edge is, we will only move forward and never look back. And the final answer is **P + 1**. \\n\\nAnother good optimization is, each time when we removed something(or move forward), s[i] should equals s[0]. And we will only pick the larest path so far. so we have this,\\n\\nProblem statement and solution credits to @vclip and @cheng-liang-yu. \\n\\n```python\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        dp = SortedList()\\n        dp.add((1,0))\\n        n = len(s)\\n        for i in range(1,n):\\n            if s[i] != s[0]: continue\\n            for x,j in reversed(dp):\\n                k = 2*i - j\\n                if k<=n and s[j:i] == s[i:k]:\\n                    dp.add((x+1,i))\\n                    break\\n        return dp[-1][0]\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```python\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        dp = SortedList()\\n        dp.add((1,0))\\n        n = len(s)\\n        for i in range(1,n):\\n            if s[i] != s[0]: continue\\n            for x,j in reversed(dp):\\n                k = 2*i - j\\n                if k<=n and s[j:i] == s[i:k]:\\n                    dp.add((x+1,i))\\n                    break\\n        return dp[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660785,
                "title": "python-clean-dp-solution-pruning-explanation",
                "content": "```\\ndef deleteString(self, s: str) -> int:\\n\\tn = len(s)\\n\\n\\t@lru_cache(None)\\n\\tdef dp(i):\\n\\t\\tans = 1\\n\\t\\tfor k in range(1, (n-i)//2+1):\\n\\t\\t\\tif ans >= n-(i+k)+1:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tif s[i:i+k]==s[i+k:i+k*2]:\\n                ans = max(ans, 1+dp(i+k))\\n        return ans\\n        \\n    return dp(0)\\n```\\nThanks for [@JKRT115](https://leetcode.com/problems/maximum-deletions-on-a-string/discuss/2648704/Python-or-Easy-Backtracking)\\'s pruning idea.\\n```\\nThe following is the explanation about break for \"ans >= n-(i+k)+1\":\\n\\tif you remove s[i:i+k], then you have n-(i+k) remaining characters, which means at most you\\'ll be able to do n-(i+k)+1 removals. \\n\\tSo if you already have ans>=n-(i+k)+1, you can stop here.\\n```",
                "solutionTags": [],
                "code": "```\\ndef deleteString(self, s: str) -> int:\\n\\tn = len(s)\\n\\n\\t@lru_cache(None)\\n\\tdef dp(i):\\n\\t\\tans = 1\\n\\t\\tfor k in range(1, (n-i)//2+1):\\n\\t\\t\\tif ans >= n-(i+k)+1:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tif s[i:i+k]==s[i+k:i+k*2]:\\n                ans = max(ans, 1+dp(i+k))\\n        return ans\\n        \\n    return dp(0)\\n```\n```\\nThe following is the explanation about break for \"ans >= n-(i+k)+1\":\\n\\tif you remove s[i:i+k], then you have n-(i+k) remaining characters, which means at most you\\'ll be able to do n-(i+k)+1 removals. \\n\\tSo if you already have ans>=n-(i+k)+1, you can stop here.\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2660512,
                "title": "c-rabin-karp-dp-new-method",
                "content": "```\\nclass Solution {\\n    vector<int> dp;\\n    long long p = 31, mod = 1000000007;\\n    int f(int i, vector< long long> &hash, vector< long long> &p_pow){\\n        if(i == hash.size()){\\n            return 1;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int ans = 1;\\n        for(int j = i + 1; j < hash.size(); ++j){\\n            // hash[i]...hash[j] == hash[j + 1]...hash[j + 1 + (j - i)]\\n            if(2*j - i > hash.size() - 1){ // hash[j + 1 + (j - i)] is outside the array\\n                return dp[i] = ans;\\n            }\\n            long long firstHalf = (hash[j] - hash[i] + mod)%mod;\\n            firstHalf *= p_pow[j - i];\\n            firstHalf %= mod;\\n            // first half  = hash[i]...hash[j]\\n            long long secondHalf = (hash[2*j - i] - hash[j] + mod)%mod;\\n            // second half = hash[j + 1]...hash[j + 1 + (j - i)]\\n            if(firstHalf == secondHalf){\\n                ans = max(ans, 1 + f(j, hash, p_pow));\\n            }\\n        }\\n        return dp[i] = ans;\\n    }\\n\\npublic:\\n    int deleteString(string s) {\\n        vector< long long> hash(s.size() + 1, 0);\\n        long long currHash = 0;\\n        vector< long long> p_pow(s.size() + 1, 0); \\n        p_pow[0] = 1; \\n        for (int i = 1; i < (int)p_pow.size(); i++){\\n            p_pow[i] = (p_pow[i-1] * p) % mod;\\n        } \\n        for(int i = 0; i < s.size(); ++i){\\n            hash[i + 1] = (hash[i]%mod + ((s[i] - \\'a\\' + 1)*p_pow[i])%mod)%mod;\\n        }\\n        dp.resize(s.size() + 2, -1);\\n        int ans = f(0, hash, p_pow);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> dp;\\n    long long p = 31, mod = 1000000007;\\n    int f(int i, vector< long long> &hash, vector< long long> &p_pow){\\n        if(i == hash.size()){\\n            return 1;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int ans = 1;\\n        for(int j = i + 1; j < hash.size(); ++j){\\n            // hash[i]...hash[j] == hash[j + 1]...hash[j + 1 + (j - i)]\\n            if(2*j - i > hash.size() - 1){ // hash[j + 1 + (j - i)] is outside the array\\n                return dp[i] = ans;\\n            }\\n            long long firstHalf = (hash[j] - hash[i] + mod)%mod;\\n            firstHalf *= p_pow[j - i];\\n            firstHalf %= mod;\\n            // first half  = hash[i]...hash[j]\\n            long long secondHalf = (hash[2*j - i] - hash[j] + mod)%mod;\\n            // second half = hash[j + 1]...hash[j + 1 + (j - i)]\\n            if(firstHalf == secondHalf){\\n                ans = max(ans, 1 + f(j, hash, p_pow));\\n            }\\n        }\\n        return dp[i] = ans;\\n    }\\n\\npublic:\\n    int deleteString(string s) {\\n        vector< long long> hash(s.size() + 1, 0);\\n        long long currHash = 0;\\n        vector< long long> p_pow(s.size() + 1, 0); \\n        p_pow[0] = 1; \\n        for (int i = 1; i < (int)p_pow.size(); i++){\\n            p_pow[i] = (p_pow[i-1] * p) % mod;\\n        } \\n        for(int i = 0; i < s.size(); ++i){\\n            hash[i + 1] = (hash[i]%mod + ((s[i] - \\'a\\' + 1)*p_pow[i])%mod)%mod;\\n        }\\n        dp.resize(s.size() + 2, -1);\\n        int ans = f(0, hash, p_pow);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658829,
                "title": "python-top-down-dp-with-super-simple-code",
                "content": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        @lru_cache(maxsize = None)\\n        def dp(idx):\\n            # the worst case: delete whole string\\n            res = 1\\n            for length in range(1, (n - idx) // 2 + 1): # idx + 2 * length < n\\n                if s[idx: idx + length] == s[idx + length: idx + 2 * length]:\\n                    res = max(res, 1 + dp(idx + length))\\n            \\n            return res\\n        return dp(0)\\n```\\n\\nI think the time complexity is O(n^3), if it\\'s wrong, please correct me.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        @lru_cache(maxsize = None)\\n        def dp(idx):\\n            # the worst case: delete whole string\\n            res = 1\\n            for length in range(1, (n - idx) // 2 + 1): # idx + 2 * length < n\\n                if s[idx: idx + length] == s[idx + length: idx + 2 * length]:\\n                    res = max(res, 1 + dp(idx + length))\\n            \\n            return res\\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657877,
                "title": "recursize-dp-c",
                "content": "# Intuition\\nThe recursive step is pretty straight forward. The hardest part is that how we can quickly determine if: s.substr(a, b) == s.substr(a+b, b)? If we make such comparation every single time, time complexity would increase due to tremendous substr() operations. So we use DP to speed this comparation.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    vector<bool> vis;\\n    void DFS(int pos, string& s, int op, vector<vector<int>>& dp){\\n        if(vis[pos]) return;\\n        vis[pos] = true;\\n        for(int i = 1; pos+i*2 <= s.length(); i++){\\n            if(dp[pos][pos+i]>=i){\\n                DFS(pos+i, s, op+1, dp);\\n            }\\n        }\\n        ans = max(op+1, ans);\\n        return;\\n    }\\n    int deleteString(string s) {\\n        int n = s.length();\\n        vis = vector<bool> (s.length(),false);\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        \\n        for (int i = n - 1; i >= 0; i--){\\n            for (int j = i + 1; j < n; j++) {\\n                if (s[i] == s[j]){\\n                    // dp[i][j] stores length of longest common prefix between s[i....n-1] and s[j....n-1]\\n                    dp[i][j] = dp[i + 1][j + 1] + 1;\\n                }\\n            }\\n        }\\n\\n        DFS(0, s, 0, dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    vector<bool> vis;\\n    void DFS(int pos, string& s, int op, vector<vector<int>>& dp){\\n        if(vis[pos]) return;\\n        vis[pos] = true;\\n        for(int i = 1; pos+i*2 <= s.length(); i++){\\n            if(dp[pos][pos+i]>=i){\\n                DFS(pos+i, s, op+1, dp);\\n            }\\n        }\\n        ans = max(op+1, ans);\\n        return;\\n    }\\n    int deleteString(string s) {\\n        int n = s.length();\\n        vis = vector<bool> (s.length(),false);\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        \\n        for (int i = n - 1; i >= 0; i--){\\n            for (int j = i + 1; j < n; j++) {\\n                if (s[i] == s[j]){\\n                    // dp[i][j] stores length of longest common prefix between s[i....n-1] and s[j....n-1]\\n                    dp[i][j] = dp[i + 1][j + 1] + 1;\\n                }\\n            }\\n        }\\n\\n        DFS(0, s, 0, dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656375,
                "title": "dp-lps-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[4001];\\n    int solve(int i, int n, string &s) {\\n        if(i == n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int ans = 1;\\n        string ss = s.substr(i);\\n        vector<int> LPS(n-i, 0);\\n        for(int j = 1; j < n-i; j++) {\\n            int k = LPS[j-1];\\n            while(k > 0 && ss[k] != ss[j]) {\\n                k = LPS[k-1]; \\n            } \\n            if(ss[k] == ss[j]) {\\n                LPS[j] = k+1;\\n            }\\n        }\\n        for(int j = i; j < n; j++) {\\n            int len = j-i+1;\\n            if(len%2 != 0) continue;\\n            if(LPS[j-i] == len/2) {\\n                ans = max(ans, 1+solve(i+len/2, n, s));\\n            }\\n        }\\n        return dp[i] = ans;\\n    }\\n    int deleteString(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, s.size(), s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[4001];\\n    int solve(int i, int n, string &s) {\\n        if(i == n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int ans = 1;\\n        string ss = s.substr(i);\\n        vector<int> LPS(n-i, 0);\\n        for(int j = 1; j < n-i; j++) {\\n            int k = LPS[j-1];\\n            while(k > 0 && ss[k] != ss[j]) {\\n                k = LPS[k-1]; \\n            } \\n            if(ss[k] == ss[j]) {\\n                LPS[j] = k+1;\\n            }\\n        }\\n        for(int j = i; j < n; j++) {\\n            int len = j-i+1;\\n            if(len%2 != 0) continue;\\n            if(LPS[j-i] == len/2) {\\n                ans = max(ans, 1+solve(i+len/2, n, s));\\n            }\\n        }\\n        return dp[i] = ans;\\n    }\\n    int deleteString(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, s.size(), s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656158,
                "title": "crisp-top-down-not-too-fast",
                "content": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * (n - 1)\\n        dp += [1]\\n        \\n        # special case \\n        if len(set([o for o in s])) == 1:\\n            return n\\n        \\n        #Top-Down \\n        for i in range(n-2 , -1 , -1):\\n            rt = 1\\n            for j in range(1 , (n - i) // 2 + 1):\\n                if s[i : i + j] == s[i + j : i + j + j]:\\n                    rt = max(rt , 1 + dp[i + j])\\n            dp[i] = rt\\n        \\n        return dp[0]  \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * (n - 1)\\n        dp += [1]\\n        \\n        # special case \\n        if len(set([o for o in s])) == 1:\\n            return n\\n        \\n        #Top-Down \\n        for i in range(n-2 , -1 , -1):\\n            rt = 1\\n            for j in range(1 , (n - i) // 2 + 1):\\n                if s[i : i + j] == s[i + j : i + j + j]:\\n                    rt = max(rt , 1 + dp[i + j])\\n            dp[i] = rt\\n        \\n        return dp[0]  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656048,
                "title": "golang-top-down-dp",
                "content": "```go\\nfunc deleteString(s string) int {\\n    memo := map[int]int{}\\n    \\n    var dfs func(i int) int\\n    dfs = func(i int) int {        \\n        if i >= len(s) {\\n            return 0\\n        }\\n        \\n        if _, ok := memo[i]; ok {\\n            return memo[i]\\n        }\\n        \\n        // !!! base condition, 1 deletion for every substring at least\\n        memo[i] = 1\\n        \\n        for j:=1; j<= (len(s)-i)/2; j++ {\\n            pattern := s[i:i+j]\\n            target := s[i+j:i+j+len(pattern)]\\n            if pattern == target {\\n                memo[i] = max(memo[i], 1+dfs(i+j))\\n            }\\n        }\\n        \\n        return memo[i]\\n    }\\n    \\n    return dfs(0)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc deleteString(s string) int {\\n    memo := map[int]int{}\\n    \\n    var dfs func(i int) int\\n    dfs = func(i int) int {        \\n        if i >= len(s) {\\n            return 0\\n        }\\n        \\n        if _, ok := memo[i]; ok {\\n            return memo[i]\\n        }\\n        \\n        // !!! base condition, 1 deletion for every substring at least\\n        memo[i] = 1\\n        \\n        for j:=1; j<= (len(s)-i)/2; j++ {\\n            pattern := s[i:i+j]\\n            target := s[i+j:i+j+len(pattern)]\\n            if pattern == target {\\n                memo[i] = max(memo[i], 1+dfs(i+j))\\n            }\\n        }\\n        \\n        return memo[i]\\n    }\\n    \\n    return dfs(0)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2655204,
                "title": "easy-understandable-code-c-nakshatra",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[4002];\\n    int solve(int i, int j, string_view& s)\\n    {\\n        if(j-i>s.size()-j)\\n            return 1;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        string_view s1 = s.substr(i, j-i);\\n        string_view s2 = s.substr(j, j-i);\\n        \\n        if(s1==s2)\\n            return dp[i]=max(1+solve(j, j+1, s), solve(i, j+1, s));\\n        \\n        return dp[i]=solve(i, j+1, s);\\n    }\\n    \\n    int deleteString(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        string_view sv({s.c_str(), s.size()});\\n        return solve(0, 1, sv);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[4002];\\n    int solve(int i, int j, string_view& s)\\n    {\\n        if(j-i>s.size()-j)\\n            return 1;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        string_view s1 = s.substr(i, j-i);\\n        string_view s2 = s.substr(j, j-i);\\n        \\n        if(s1==s2)\\n            return dp[i]=max(1+solve(j, j+1, s), solve(i, j+1, s));\\n        \\n        return dp[i]=solve(i, j+1, s);\\n    }\\n    \\n    int deleteString(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        string_view sv({s.c_str(), s.size()});\\n        return solve(0, 1, sv);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654691,
                "title": "simple-java-solution-with-explanation",
                "content": "class Solution {\\n    \\n\\tpublic boolean allSame(String s){\\n        return s.chars().boxed().collect(Collectors.toSet()).size() == 1; //check if all charcters are same\\n    }\\n    \\n    public int deleteString(Integer[] memo, String s, int idx){\\n        if(idx == s.length()){ // if no elements end in string return 0 deletions\\n            return 0;\\n        }\\n        \\n        if(memo[idx] == null){\\n        \\n            if(allSame(s)){\\n                memo[idx] = s.length() - idx; // if all characters are same return the length of remaining string\\n            } else {\\n\\n                memo[idx] = 1; // minimum one deletion can be made by deleting whole string\\n\\n                for(int offset = 1; offset <= (s.length() - idx) / 2; offset++){ //maintain the offset till the middle of remaining string\\n                    String s1 = s.substring(idx, idx + offset); \\n                    String s2 = s.substring(idx + offset, idx + (2 * offset));\\n\\n                    if(s1.equals(s2)){ // check if strings are equal\\n                        memo[idx] = Math.max(memo[idx], 1 + deleteString(memo, s, idx + offset));  // delete the matching part and move to the next part \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return memo[idx];\\n    }\\n\\t\\n    public int deleteString(String s) {\\n        return deleteString(new Integer[s.length()], s, 0);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n\\tpublic boolean allSame(String s){\\n        return s.chars().boxed().collect(Collectors.toSet()).size() == 1; //check if all charcters are same\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2654075,
                "title": "top-down-dp-python-time-o-n-2-space-o-n",
                "content": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        cache = {}\\n        \\n        def recurse(i):\\n            if i >= N:\\n                return 0\\n            if i in cache:\\n                return cache[i]\\n            ans = 1\\n            length = 1\\n            while i + length < N and ans <= N - i - length:\\n                if s[i:i + length] == s[i + length:i + 2 * length]:\\n                     ans = max(ans, 1 + recurse(i + length))\\n                length += 1\\n            cache[i] = ans\\n            return ans              \\n            \\n        N = len(s)\\n        return recurse(0)\\n    # Time: O(n^2) even though the pruning (ans <= N - i - length) reduces complexity by a good amount\\n    # Space: O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        cache = {}\\n        \\n        def recurse(i):\\n            if i >= N:\\n                return 0\\n            if i in cache:\\n                return cache[i]\\n            ans = 1\\n            length = 1\\n            while i + length < N and ans <= N - i - length:\\n                if s[i:i + length] == s[i + length:i + 2 * length]:\\n                     ans = max(ans, 1 + recurse(i + length))\\n                length += 1\\n            cache[i] = ans\\n            return ans              \\n            \\n        N = len(s)\\n        return recurse(0)\\n    # Time: O(n^2) even though the pruning (ans <= N - i - length) reduces complexity by a good amount\\n    # Space: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653932,
                "title": "c-dp-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n=s.size();\\n        long long hash[n],p=31,mod=1e9+7;\\n        long long  pow[n];\\n        pow[0]=1;\\n        for(int i=1;i<n;++i)\\n        {\\n            pow[i]=(pow[i-1]*p)%mod;\\n        }\\n        for(int i=0;i<n;++i)\\n        {\\n            long long v=(s[i]-\\'a\\');\\n            hash[i]=((i-1>=0?hash[i-1]:0)+(v*pow[i])%mod)%mod;\\n        }\\n        int dp[n];\\n        memset(dp,0,sizeof(dp));\\n        // dp[i] : maximum number of operations we can perform , if we have deleted string till ith index\\n        for(int x=0;x<n;++x)\\n        {\\n            for(int y=x;y<n;++y)\\n            {\\n                int i=y+1;\\n                int j=i+(y-x+1)-1;\\n                \\n                if(j>=n)\\n                    break;\\n                \\n                long long a=(hash[y]-(x-1>=0?hash[x-1]:0)+mod)%mod;\\n                long long b=(hash[j]-hash[i-1]+mod)%mod;\\n                long long c=(a*pow[i-x])%mod;\\n                if(b==c)// checking if considered substrings are equal\\n                {\\n                    if(x-1<0)\\n                    {\\n                        dp[y]=max(dp[y],1);\\n                    }\\n                    else\\n                    {\\n                        if(dp[x-1]!=0)// This ensures valid deletion\\n                        {\\n                            dp[y]=max(dp[y],1+dp[x-1]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            res=max(res,1+(i-1>=0?dp[i-1]:0));\\n            // Here, we deleting the all possible choices of remaining string with +1 step\\n        }\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n=s.size();\\n        long long hash[n],p=31,mod=1e9+7;\\n        long long  pow[n];\\n        pow[0]=1;\\n        for(int i=1;i<n;++i)\\n        {\\n            pow[i]=(pow[i-1]*p)%mod;\\n        }\\n        for(int i=0;i<n;++i)\\n        {\\n            long long v=(s[i]-\\'a\\');\\n            hash[i]=((i-1>=0?hash[i-1]:0)+(v*pow[i])%mod)%mod;\\n        }\\n        int dp[n];\\n        memset(dp,0,sizeof(dp));\\n        // dp[i] : maximum number of operations we can perform , if we have deleted string till ith index\\n        for(int x=0;x<n;++x)\\n        {\\n            for(int y=x;y<n;++y)\\n            {\\n                int i=y+1;\\n                int j=i+(y-x+1)-1;\\n                \\n                if(j>=n)\\n                    break;\\n                \\n                long long a=(hash[y]-(x-1>=0?hash[x-1]:0)+mod)%mod;\\n                long long b=(hash[j]-hash[i-1]+mod)%mod;\\n                long long c=(a*pow[i-x])%mod;\\n                if(b==c)// checking if considered substrings are equal\\n                {\\n                    if(x-1<0)\\n                    {\\n                        dp[y]=max(dp[y],1);\\n                    }\\n                    else\\n                    {\\n                        if(dp[x-1]!=0)// This ensures valid deletion\\n                        {\\n                            dp[y]=max(dp[y],1+dp[x-1]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            res=max(res,1+(i-1>=0?dp[i-1]:0));\\n            // Here, we deleting the all possible choices of remaining string with +1 step\\n        }\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653686,
                "title": "c-kmp-100-faster-recursion",
                "content": "```\\nclass Solution\\n{\\n\\n    vector<int> KMP(string s)\\n    {\\n        vector<int> KMPvector(s.length(), 0);\\n        KMPvector[0] = 0;\\n\\n        int len = 0;\\n        int i = 1;\\n\\n        while (i < s.length())\\n        {\\n            if (s[i] == s[len])\\n            {\\n                len++;\\n                KMPvector[i] = len;\\n                i++;\\n            }\\n            else\\n            {\\n               \\t// the character does not match, you go to the previous one which matched, which points to the starting same prefix\\n                if (len != 0)\\n                    len = KMPvector[len - 1];\\n                else\\n                {\\n                    KMPvector[i] = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return KMPvector;\\n    }\\n\\n    int Helper(string s)\\n    {\\n        if (s.length() == 0)\\n            return 0;\\n\\n        vector<int> A = KMP(s);\\n        int power_index = -1;\\n\\n        for (int i = 0; i < A.size(); i++)\\n            if ((i + 1) == A[i] *2)\\n                power_index = i;\\n\\n        if (power_index != -1)\\n        {\\n            string temp = s.substr(A[power_index]);\\n            return 1 + Helper(temp);\\n        }\\n        return 1;\\n    }\\n    public:\\n        int deleteString(string s)\\n        {\\n            return Helper(s);\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    vector<int> KMP(string s)\\n    {\\n        vector<int> KMPvector(s.length(), 0);\\n        KMPvector[0] = 0;\\n\\n        int len = 0;\\n        int i = 1;\\n\\n        while (i < s.length())\\n        {\\n            if (s[i] == s[len])\\n            {\\n                len++;\\n                KMPvector[i] = len;\\n                i++;\\n            }\\n            else\\n            {\\n               \\t// the character does not match, you go to the previous one which matched, which points to the starting same prefix\\n                if (len != 0)\\n                    len = KMPvector[len - 1];\\n                else\\n                {\\n                    KMPvector[i] = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return KMPvector;\\n    }\\n\\n    int Helper(string s)\\n    {\\n        if (s.length() == 0)\\n            return 0;\\n\\n        vector<int> A = KMP(s);\\n        int power_index = -1;\\n\\n        for (int i = 0; i < A.size(); i++)\\n            if ((i + 1) == A[i] *2)\\n                power_index = i;\\n\\n        if (power_index != -1)\\n        {\\n            string temp = s.substr(A[power_index]);\\n            return 1 + Helper(temp);\\n        }\\n        return 1;\\n    }\\n    public:\\n        int deleteString(string s)\\n        {\\n            return Helper(s);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653482,
                "title": "expected-result-for-aaaaa-extending-the-logic-given-should-it-not-have-been-4",
                "content": "First two aa get deleted, aaa remain. Then the first a gets deleted and aa remains. Then the first a gets deleted and a remains and finally the last a gets deleted. Please clarify if my understanding is wrong.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2653307,
                "title": "python-memoization-with-a-tricky-optimisation",
                "content": "\\tclass Solution:\\n\\t\\tdef deleteString(self, s: str) -> int:\\n\\t\\t\\tlen_s=len(s)\\n\\t\\t\\tmemo=[-1]*len_s\\n\\t\\t\\tdef dfs(start):\\n\\t\\t\\t\\tif len(set(s[start:]))==1:\\n\\t\\t\\t\\t\\treturn len(s[start:])\\n\\t\\t\\t\\tif start==len_s:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif start==len_s-1:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tif memo[start]!=-1:\\n\\t\\t\\t\\t\\treturn memo[start]\\n\\t\\t\\t\\tn=(len(s)-start)//2\\n\\t\\t\\t\\tres=1\\n\\t\\t\\t\\tfor i in range(start+1,start+n+1):\\n\\t\\t\\t\\t\\tfwd_len=i-start\\n\\t\\t\\t\\t\\tif s[start:start+fwd_len]==s[i:i+fwd_len]:\\n\\t\\t\\t\\t\\t\\tres=max(res,1+dfs(i))\\n\\t\\t\\t\\tmemo[start]=res\\n\\t\\t\\t\\treturn res\\n\\t\\t\\treturn dfs(0)",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef deleteString(self, s: str) -> int:\\n\\t\\t\\tlen_s=len(s)\\n\\t\\t\\tmemo=[-1]*len_s\\n\\t\\t\\tdef dfs(start):\\n\\t\\t\\t\\tif len(set(s[start:]))==1:\\n\\t\\t\\t\\t\\treturn len(s[start:])\\n\\t\\t\\t\\tif start==len_s:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif start==len_s-1:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tif memo[start]!=-1:\\n\\t\\t\\t\\t\\treturn memo[start]\\n\\t\\t\\t\\tn=(len(s)-start)//2\\n\\t\\t\\t\\tres=1\\n\\t\\t\\t\\tfor i in range(start+1,start+n+1):\\n\\t\\t\\t\\t\\tfwd_len=i-start\\n\\t\\t\\t\\t\\tif s[start:start+fwd_len]==s[i:i+fwd_len]:\\n\\t\\t\\t\\t\\t\\tres=max(res,1+dfs(i))\\n\\t\\t\\t\\tmemo[start]=res\\n\\t\\t\\t\\treturn res\\n\\t\\t\\treturn dfs(0)",
                "codeTag": "Java"
            },
            {
                "id": 2652826,
                "title": "faster-than-100-python-top-down-memoized-recursion-should-be-medium-upvote",
                "content": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        global memMap\\n        memMap = {}\\n        if all([i == s[0] for i in s]):\\n            return len(s)\\n    \\n        def rec(string):\\n            global memMap\\n            \\n            if string in memMap:\\n                return memMap[string]\\n            l = len(string)\\n            if l == 0:\\n                return 0\\n            if l == 1:\\n                return 1\\n            \\n            if l == 2:\\n                return 1 + int(string[0] == string[1])\\n            \\n            if l == 3:\\n                return 1 + int(string[0] == string[1]) + int(string[0] == string[1] and string[1] == string[2])\\n            \\n            \\n            cnt = 1\\n            \\n            batch = []\\n            for i in range(1, 1+ len(string)//2):\\n                \\n                if string[:i] == string[i:2*i]:\\n                    batch.append(i)\\n            if len(batch) == 0:\\n                \\n                memMap[string] = 1\\n                return 1\\n            ans = max([1 + rec(string[i:]) for i in batch])\\n            \\n            memMap[string] = ans\\n            \\n            return memMap[string]\\n        return rec(s)\\n\\t\\t\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        global memMap\\n        memMap = {}\\n        if all([i == s[0] for i in s]):\\n            return len(s)\\n    \\n        def rec(string):\\n            global memMap\\n            \\n            if string in memMap:\\n                return memMap[string]\\n            l = len(string)\\n            if l == 0:\\n                return 0\\n            if l == 1:\\n                return 1\\n            \\n            if l == 2:\\n                return 1 + int(string[0] == string[1])\\n            \\n            if l == 3:\\n                return 1 + int(string[0] == string[1]) + int(string[0] == string[1] and string[1] == string[2])\\n            \\n            \\n            cnt = 1\\n            \\n            batch = []\\n            for i in range(1, 1+ len(string)//2):\\n                \\n                if string[:i] == string[i:2*i]:\\n                    batch.append(i)\\n            if len(batch) == 0:\\n                \\n                memMap[string] = 1\\n                return 1\\n            ans = max([1 + rec(string[i:]) for i in batch])\\n            \\n            memMap[string] = ans\\n            \\n            return memMap[string]\\n        return rec(s)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652768,
                "title": "python-keeps-getting-tle",
                "content": "I am trying with a high ranked contestant\\'s code, and keeps getting TLE. Why?\\n\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        @cache\\n        def dfs(s, i):\\n            if i == len(s):\\n                return 0\\n            ret = 1\\n            span = 1\\n            while i + span * 2 <= len(s):\\n                if s[i:i+span] == s[i+span:i+span*2]:\\n                    ret = max(ret, 1 + dfs(s, i + span))\\n                span += 1\\n            return ret\\n        ans = dfs(s, 0)\\n        dfs.cache_clear()\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        @cache\\n        def dfs(s, i):\\n            if i == len(s):\\n                return 0\\n            ret = 1\\n            span = 1\\n            while i + span * 2 <= len(s):\\n                if s[i:i+span] == s[i+span:i+span*2]:\\n                    ret = max(ret, 1 + dfs(s, i + span))\\n                span += 1\\n            return ret\\n        ans = dfs(s, 0)\\n        dfs.cache_clear()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652452,
                "title": "dp-python-solution",
                "content": "Very similar to target sum problem \\n\\t\\n\\tclass Solution(object):\\n\\t\\tdef deleteString(self, s):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type s: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif len(set(s)) == 1: return len(s) \\n        \\n\\t\\t\\tmemo = {}\\n\\t\\t\\tdef ways(i = 0):\\n\\t\\t\\t\\tif i == len(s):\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tif i in memo:\\n\\t\\t\\t\\t\\treturn memo[i]\\n\\n\\t\\t\\t\\tmemo[i] = 1\\n\\t\\t\\t\\tfor p in range(1, (len(s)-i)//2+1):\\n\\t\\t\\t\\t\\tif s[i:i+p] == s[i+p:i+p*2]:\\n\\t\\t\\t\\t\\t\\tmemo[i] = max(memo[i], ways(i + p)+1)\\n\\n\\t\\t\\t\\treturn memo[i]\\n\\n\\t\\t\\treturn ways()",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\t\\tdef deleteString(self, s):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type s: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif len(set(s)) == 1: return len(s) \\n        \\n\\t\\t\\tmemo = {}",
                "codeTag": "Java"
            },
            {
                "id": 2652195,
                "title": "java-from-memorization-tle-to-dp-ac",
                "content": "The below is the memorization TLE solution, any idea to improve it?\\n```\\nclass Solution {\\n    public int deleteString(String s) {\\n        Integer[][] mem = new Integer[s.length()][s.length()];\\n        int res = 1;\\n        for(int i=0;i<s.length()/2;i++){\\n            res = Math.max(res, helper(s, 0, i, mem));\\n        }\\n        return res;\\n    }\\n    \\n    public int helper(String str, int s, int e, Integer[][] mem){\\n        if(s>=str.length()||e>=str.length()){\\n            return 0;\\n        }\\n        if(mem[s][e]!=null){\\n            return mem[s][e];\\n        }\\n        mem[s][e] = 1;\\n        if(e+1+(e-s)+1 <= str.length()){\\n            int tmp = 1;\\n            String substr = str.substring(s, e+1);\\n            String candidstr = str.substring(e+1, e+1+substr.length());\\n            if(substr.equals(candidstr)){\\n                for(int i=e+1;i<str.length();i++){\\n                    tmp = Math.max(tmp, 1 + helper(str, e+1, i, mem));\\n                }\\n            }\\n            mem[s][e] = tmp;\\n        }\\n        return mem[s][e];\\n    }\\n}\\n```\\n\\nAnd this one is the AC solution:\\n```\\nclass Solution {\\n    public int deleteString(String s) {\\n        int[][] lcs = new int[s.length()+1][s.length()+1];\\n        int[] dp = new int[s.length()];\\n        for(int i=s.length()-1;i>=0;i--){\\n            dp[i] = 1;\\n            for(int j=i+1;j<s.length();j++){\\n                if(s.charAt(i)==s.charAt(j)){\\n                    lcs[i][j] = lcs[i+1][j+1]+1;\\n                }\\n                if(lcs[i][j] >= j-i){\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n\\nWhy the below?\\n```\\n if(lcs[i][j] >= j-i){\\n\\tdp[i] = Math.max(dp[i], 1 + dp[j]);\\n}\\n```\\n\\nsuppose the input string is \"aaabaab\", and when we deal with the dp[0], the optimization will be 1+dp[1], since lcs[0][1]=2, which is greater than (j-i), that\\'s why we need \\n```\\n>=, not ==\\n```\\ninside the above solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int deleteString(String s) {\\n        Integer[][] mem = new Integer[s.length()][s.length()];\\n        int res = 1;\\n        for(int i=0;i<s.length()/2;i++){\\n            res = Math.max(res, helper(s, 0, i, mem));\\n        }\\n        return res;\\n    }\\n    \\n    public int helper(String str, int s, int e, Integer[][] mem){\\n        if(s>=str.length()||e>=str.length()){\\n            return 0;\\n        }\\n        if(mem[s][e]!=null){\\n            return mem[s][e];\\n        }\\n        mem[s][e] = 1;\\n        if(e+1+(e-s)+1 <= str.length()){\\n            int tmp = 1;\\n            String substr = str.substring(s, e+1);\\n            String candidstr = str.substring(e+1, e+1+substr.length());\\n            if(substr.equals(candidstr)){\\n                for(int i=e+1;i<str.length();i++){\\n                    tmp = Math.max(tmp, 1 + helper(str, e+1, i, mem));\\n                }\\n            }\\n            mem[s][e] = tmp;\\n        }\\n        return mem[s][e];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int deleteString(String s) {\\n        int[][] lcs = new int[s.length()+1][s.length()+1];\\n        int[] dp = new int[s.length()];\\n        for(int i=s.length()-1;i>=0;i--){\\n            dp[i] = 1;\\n            for(int j=i+1;j<s.length();j++){\\n                if(s.charAt(i)==s.charAt(j)){\\n                    lcs[i][j] = lcs[i+1][j+1]+1;\\n                }\\n                if(lcs[i][j] >= j-i){\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\n```\\n if(lcs[i][j] >= j-i){\\n\\tdp[i] = Math.max(dp[i], 1 + dp[j]);\\n}\\n```\n```\\n>=, not ==\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651992,
                "title": "c-dp-solution-100-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string &s, int i, int j){\\n        for(int k=0; k<j; k++){\\n            if(s[i+k]!=s[i+j+k]) return false;\\n        }\\n        return true;\\n    }\\n    int deleteString(string s) {\\n        int n = s.size();\\n        if(n==1) return 1;\\n        \\n        set<char> st;\\n        for(char c:s) st.insert(c);\\n        if(st.size()==1) return n;\\n        \\n        int dp[4001];\\n        std::fill(begin(dp), end(dp), 1);\\n        dp[n]=0;\\n        \\n        for(int i=n-2; i>=0; i--){\\n            for(int j=1; j<=(n-i)/2; j++){\\n                if(check(s,i,j)){\\n                    dp[i] = max(dp[i], 1 + dp[i+j]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string &s, int i, int j){\\n        for(int k=0; k<j; k++){\\n            if(s[i+k]!=s[i+j+k]) return false;\\n        }\\n        return true;\\n    }\\n    int deleteString(string s) {\\n        int n = s.size();\\n        if(n==1) return 1;\\n        \\n        set<char> st;\\n        for(char c:s) st.insert(c);\\n        if(st.size()==1) return n;\\n        \\n        int dp[4001];\\n        std::fill(begin(dp), end(dp), 1);\\n        dp[n]=0;\\n        \\n        for(int i=n-2; i>=0; i--){\\n            for(int j=1; j<=(n-i)/2; j++){\\n                if(check(s,i,j)){\\n                    dp[i] = max(dp[i], 1 + dp[i+j]);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651981,
                "title": "real-quick-real-dp-no-dfs",
                "content": "\\nit is really quick as 247ms in Python\\n\\nfor quick tips:\\n1 after each remove, except remove whole string, the first letter will always keep same\\n   this helps me much to optimize the logic/\\n2 if the whole string contain only one letter, \\n   the answer will be the length of the string\\n3 repeat the first letter before any other letters \\n   it is obviously we have at least the option to remove them one by one, except the last one before the OTHER letter \\n\\nThe major idea is the most steps to remove all previor letters before the one at the index i, equals to one plus the maximum steps for any j.\\n\\nIt is O(n**3): a: go through all string, b: go through all previous possible position after legal removals, c: string compare.\\nAlso it is O(n**3), it is not slow. because \\n    for the a, only the letter is same as the first one, ( that mean worse case happen when repeat first letter)\\n\\tfor the b, only the position has legal removals to make it new head ( all position are not able to become a new head will never bother)\\n\\tfor the c, the comparation will stop at the first non matching letters\\nfor the \\'worse and worst case\\' the first letter will repeat so many times, in this case it is in face best. because O(N) effort will make the N smaller \\t\\n\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n\\t    # tip 3\\n        for i, c in enumerate(s[1:]):\\n            if c != s[0]:\\n                z = [(j, j) for j in range(i + 1)]\\n                break\\n        else:\\n\\t\\t    # tip 2\\n            return len(s)\\n        #print(z)\\n        for i in range(z[-1][1] + 1, len(s)):\\n\\t\\t    # tip 1\\n            if s[i] == s[0]:\\n                try:\\n\\t\\t\\t\\t    # remove every before i\\n                    z.append((max(p + 1  for p, j in z[::-1] if s[j + 1: i] == s[i + 1: i + i - j]), i))\\n                except:\\n                    pass\\n        #print(z)\\n\\t\\t# remove remain\\n        return 1 + max(z)[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n\\t    # tip 3\\n        for i, c in enumerate(s[1:]):\\n            if c != s[0]:\\n                z = [(j, j) for j in range(i + 1)]\\n                break\\n        else:\\n\\t\\t    # tip 2\\n            return len(s)\\n        #print(z)\\n        for i in range(z[-1][1] + 1, len(s)):\\n\\t\\t    # tip 1\\n            if s[i] == s[0]:\\n                try:\\n\\t\\t\\t\\t    # remove every before i\\n                    z.append((max(p + 1  for p, j in z[::-1] if s[j + 1: i] == s[i + 1: i + i - j]), i))\\n                except:\\n                    pass\\n        #print(z)\\n\\t\\t# remove remain\\n        return 1 + max(z)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651702,
                "title": "dp-two-pointers-o-n-2",
                "content": "C++\\n```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n = s.size();\\n        vector<vector<int>> next(n);\\n        for (int shift = 1; 2 * shift <= n; shift++) {\\n            int i = 0, j;\\n            while (i + shift < n) {\\n                j = i;\\n                while (j + shift < n && s[j + shift] == s[j]) j++;\\n                if (j - i >= shift) {\\n                    for (int k = i; k + shift <= j; k++) next[k].push_back(k + shift);\\n                }\\n                i = max(i + 1, j);\\n            }\\n        }\\n        vector<int> dp(n, 1);\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (const auto& j : next[i]) dp[i] = max(dp[i], 1 + dp[j]);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int deleteString(String str) {\\n        char[] s = str.toCharArray();\\n        int n = s.length;\\n        List<List<Integer>> next = new ArrayList<>();\\n        for (int i = 0; i < n; i++) next.add(new ArrayList<Integer>());\\n        for (int shift = 1; 2 * shift <= n; shift++) {\\n            int i = 0, j;\\n            while (i + shift < n) {\\n                j = i;\\n                while (j + shift < n && s[j + shift] == s[j]) j++;\\n                if (j - i >= shift) {\\n                    for (int k = i; k + shift <= j; k++) next.get(k).add(k + shift);\\n                }\\n                i = Math.max(i + 1, j);\\n            }\\n        }\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, 1);\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (var j : next.get(i)) dp[i] = Math.max(dp[i], 1 + dp[j]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteString(string s) {\\n        int n = s.size();\\n        vector<vector<int>> next(n);\\n        for (int shift = 1; 2 * shift <= n; shift++) {\\n            int i = 0, j;\\n            while (i + shift < n) {\\n                j = i;\\n                while (j + shift < n && s[j + shift] == s[j]) j++;\\n                if (j - i >= shift) {\\n                    for (int k = i; k + shift <= j; k++) next[k].push_back(k + shift);\\n                }\\n                i = max(i + 1, j);\\n            }\\n        }\\n        vector<int> dp(n, 1);\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (const auto& j : next[i]) dp[i] = max(dp[i], 1 + dp[j]);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int deleteString(String str) {\\n        char[] s = str.toCharArray();\\n        int n = s.length;\\n        List<List<Integer>> next = new ArrayList<>();\\n        for (int i = 0; i < n; i++) next.add(new ArrayList<Integer>());\\n        for (int shift = 1; 2 * shift <= n; shift++) {\\n            int i = 0, j;\\n            while (i + shift < n) {\\n                j = i;\\n                while (j + shift < n && s[j + shift] == s[j]) j++;\\n                if (j - i >= shift) {\\n                    for (int k = i; k + shift <= j; k++) next.get(k).add(k + shift);\\n                }\\n                i = Math.max(i + 1, j);\\n            }\\n        }\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, 1);\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (var j : next.get(i)) dp[i] = Math.max(dp[i], 1 + dp[j]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651285,
                "title": "simple-dp-c-solution",
                "content": "class Solution {\\npublic:\\n    \\n    int dp[4001];\\n    \\n    int fun(string s)\\n    {\\n        if(s.size()==1)\\n        {\\n            return 1;\\n        }\\n        \\n        int n=s.size();\\n        \\n        if(dp[n]!=-1)\\n        {\\n            return dp[n];\\n        }\\n        \\n        int ans=1;\\n        \\n        int c=0;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                c++;\\n            }\\n            else break;\\n    \\n        }\\n        c++;\\n        \\n        if(c==n)\\n        {\\n            return n;\\n        }\\n        \\n        \\n        for(int i=1;i<s.length();i++)\\n        {\\n            \\n            \\n             if(s[i]==s[0])\\n             {\\n                 if(s.substr(0,i)==s.substr(i,i))\\n                 {\\n                     ans=max(ans, 1+fun(s.substr(i)));\\n                 }\\n             }\\n              \\n            \\n            if(i>s.length()-i)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        return dp[n]=ans;\\n        \\n        \\n    }\\n    int deleteString(string s) {\\n        memset(dp,-1,sizeof(dp));\\n      return fun(s);\\n    \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int dp[4001];\\n    \\n    int fun(string s)\\n    {\\n        if(s.size()==1)\\n        {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2651281,
                "title": "clean-and-readable-java-codes-dp-kmp-lcs",
                "content": "```\\n// Solution-1 : KMP + DP \\n\\n// Find all lengths for a particular index such that \\n// first \"length\" characters from index \\n// are equal to following \"length\" characters\\n// using KMP, then use DP to iterate through \\n// all options for an index\\n\\n// TC : O(len^2)\\n// SC : O(len^2)\\n\\nclass Solution {\\n    public int deleteString(String s) {\\n        int len = s.length();\\n        Integer dp[] = new Integer[len];\\n        List<Integer> options[] = new ArrayList[len];\\n        \\n        for(int idx =0; idx<len; idx++){\\n            options[idx] = new ArrayList();\\n            String str = s.substring(idx);\\n            \\n            int lps[] = getLps(str);\\n            int lpsLen = lps.length;\\n            \\n            for(int currIdx = 0; currIdx<lpsLen; currIdx++){\\n                if(lps[currIdx]>0){\\n                    if(currIdx-2*lps[currIdx]+1 == 0) options[idx].add(lps[currIdx]);\\n                }\\n            }\\n        }\\n        \\n        return deleteString(s, 0, len, options, dp);\\n    }\\n    \\n    private int[] getLps(String str){\\n        int strLen = str.length();\\n        int lps[] = new int[strLen];\\n        int idx = 1;\\n        int len = 0;\\n        \\n        while(idx<strLen){\\n            if(str.charAt(idx) == str.charAt(len)){\\n                len++;\\n                lps[idx] = len;\\n                idx++;\\n            }else{\\n                if(len>0) len = lps[len-1];\\n                else{\\n                    lps[idx] = 0;\\n                    idx++;\\n                }\\n            }\\n        }\\n        \\n        return lps;\\n    }\\n    \\n    private int deleteString(String str, int idx, int len, List<Integer> options[], Integer dp[]){\\n        if(idx == len) return 0;\\n        if(dp[idx]!=null) return dp[idx];\\n        \\n        int maxOperations = 1;\\n        \\n        for(int length : options[idx]){\\n            int currOperations = deleteString(str, idx+length, len, options, dp);\\n            maxOperations = Math.max(maxOperations, currOperations+1);\\n        }\\n        \\n       return dp[idx] = maxOperations;\\n    }\\n}\\n```\\n\\n```\\n// Solution-2 : LCS + DP, \\n// derived from lee215s solution : https://leetcode.com/problems/maximum-deletions-on-a-string/discuss/2648900/JavaC%2B%2BPython-DP-Solution\\n\\n// Find longest common substring for all pairs of indices\\n// If the longest common substring for any pair\\n// overlap or touch each other\\n// then we can perform partitioning \\n\\n// TC : O(len^2)\\n// SC : O(len)\\n\\nclass Solution {\\n    public int deleteString(String s) {\\n        int len = s.length();\\n        int lcs[] = new int[len+1];\\n        int dp[] = new int[len];\\n        \\n        for(int idx1=len-1; idx1>=0; idx1--){\\n            dp[idx1] = 1;\\n            \\n            for(int idx2=idx1+1; idx2<len; idx2++){\\n                if(s.charAt(idx1) == s.charAt(idx2)){\\n                    lcs[idx2] = lcs[idx2+1]+1;\\n                }else lcs[idx2] = 0;\\n                \\n                if(lcs[idx2] >= idx2-idx1) dp[idx1] = Math.max(dp[idx1], dp[idx2]+1);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Solution-1 : KMP + DP \\n\\n// Find all lengths for a particular index such that \\n// first \"length\" characters from index \\n// are equal to following \"length\" characters\\n// using KMP, then use DP to iterate through \\n// all options for an index\\n\\n// TC : O(len^2)\\n// SC : O(len^2)\\n\\nclass Solution {\\n    public int deleteString(String s) {\\n        int len = s.length();\\n        Integer dp[] = new Integer[len];\\n        List<Integer> options[] = new ArrayList[len];\\n        \\n        for(int idx =0; idx<len; idx++){\\n            options[idx] = new ArrayList();\\n            String str = s.substring(idx);\\n            \\n            int lps[] = getLps(str);\\n            int lpsLen = lps.length;\\n            \\n            for(int currIdx = 0; currIdx<lpsLen; currIdx++){\\n                if(lps[currIdx]>0){\\n                    if(currIdx-2*lps[currIdx]+1 == 0) options[idx].add(lps[currIdx]);\\n                }\\n            }\\n        }\\n        \\n        return deleteString(s, 0, len, options, dp);\\n    }\\n    \\n    private int[] getLps(String str){\\n        int strLen = str.length();\\n        int lps[] = new int[strLen];\\n        int idx = 1;\\n        int len = 0;\\n        \\n        while(idx<strLen){\\n            if(str.charAt(idx) == str.charAt(len)){\\n                len++;\\n                lps[idx] = len;\\n                idx++;\\n            }else{\\n                if(len>0) len = lps[len-1];\\n                else{\\n                    lps[idx] = 0;\\n                    idx++;\\n                }\\n            }\\n        }\\n        \\n        return lps;\\n    }\\n    \\n    private int deleteString(String str, int idx, int len, List<Integer> options[], Integer dp[]){\\n        if(idx == len) return 0;\\n        if(dp[idx]!=null) return dp[idx];\\n        \\n        int maxOperations = 1;\\n        \\n        for(int length : options[idx]){\\n            int currOperations = deleteString(str, idx+length, len, options, dp);\\n            maxOperations = Math.max(maxOperations, currOperations+1);\\n        }\\n        \\n       return dp[idx] = maxOperations;\\n    }\\n}\\n```\n```\\n// Solution-2 : LCS + DP, \\n// derived from lee215s solution : https://leetcode.com/problems/maximum-deletions-on-a-string/discuss/2648900/JavaC%2B%2BPython-DP-Solution\\n\\n// Find longest common substring for all pairs of indices\\n// If the longest common substring for any pair\\n// overlap or touch each other\\n// then we can perform partitioning \\n\\n// TC : O(len^2)\\n// SC : O(len)\\n\\nclass Solution {\\n    public int deleteString(String s) {\\n        int len = s.length();\\n        int lcs[] = new int[len+1];\\n        int dp[] = new int[len];\\n        \\n        for(int idx1=len-1; idx1>=0; idx1--){\\n            dp[idx1] = 1;\\n            \\n            for(int idx2=idx1+1; idx2<len; idx2++){\\n                if(s.charAt(idx1) == s.charAt(idx2)){\\n                    lcs[idx2] = lcs[idx2+1]+1;\\n                }else lcs[idx2] = 0;\\n                \\n                if(lcs[idx2] >= idx2-idx1) dp[idx1] = Math.max(dp[idx1], dp[idx2]+1);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650986,
                "title": "c-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we can use bottom up dynamic programming\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) in typical case\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\npublic class Solution {\\n\\n    public int DeleteString(string s) {\\n      int[] dp = Enumerable.Repeat(1, s.Length).ToArray();\\n\\n      for (int start = s.Length - 2; start >= 0; --start) {\\n        int max = 1;\\n\\n        for (int length = 1; length <= (s.Length - start) / 2; ++length) \\n          if (dp[start + length] + 1 < max)\\n            continue;\\n          else if (s.Substring(start, length) == s.Substring(start + length, length)) \\n            max = Math.Max(max, dp[start + length] + 1);\\n\\n        dp[start] = max;\\n      }\\n\\n      return dp[0];\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public int DeleteString(string s) {\\n      int[] dp = Enumerable.Repeat(1, s.Length).ToArray();\\n\\n      for (int start = s.Length - 2; start >= 0; --start) {\\n        int max = 1;\\n\\n        for (int length = 1; length <= (s.Length - start) / 2; ++length) \\n          if (dp[start + length] + 1 < max)\\n            continue;\\n          else if (s.Substring(start, length) == s.Substring(start + length, length)) \\n            max = Math.Max(max, dp[start + length] + 1);\\n\\n        dp[start] = max;\\n      }\\n\\n      return dp[0];\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650714,
                "title": "c-rust-concise-dp-solution-runtime-100-space-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n~~~\\n//C++ -- First Submission in the Contest\\nclass Solution {\\n    void eval(string &s, vector<int> &dp, int i) {\\n        dp[i] = 1;\\n        \\n        for (int j = i - 1; i >= 0; --j) {\\n            if (i - j > j + 1) break;\\n            if (dp[j] + 1 <= dp[i]) continue;\\n            \\n            bool good = true;\\n            for (int k = 0; k < i - j; ++k) {\\n                if (s[i - k] == s[j - k]) continue;\\n                good = false;\\n                break;\\n            }\\n            if (not good) continue;\\n            dp[i] = dp[j] + 1;\\n        }\\n    }\\n    \\npublic:\\n    int deleteString(string s) {\\n        int n = s.size();\\n        reverse(s.begin(), s.end());\\n        vector<int> dp(n);\\n        \\n        for (int i = 0; i < n; ++i) eval(s, dp, i);\\n        \\n        return dp[n - 1];\\n    }\\n};\\n~~~\\n\\n```\\n//Rust -- Second Submission in the Contest\\nimpl Solution {\\n    pub fn delete_string(s: String) -> i32 {\\n        let n = s.len();\\n        let mut s = s.chars().collect::<Vec<char>>();\\n        let mut dp = vec![1; n];\\n        s.reverse();\\n        \\n        for i in 0..n {\\n            for j in (0..i).rev() {\\n                if j + 1 < i - j { break }\\n                if dp[j] + 1 <= dp[i] { continue; }\\n                \\n                let mut good = true;\\n                for k in 0..i - j {\\n                    if s[j - k] == s[i - k] { continue }\\n                    \\n                    good = false;\\n                    break\\n                }\\n                if good == false { continue }\\n                dp[i] = dp[j] + 1;\\n            }\\n        }\\n        \\n        dp[n - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n//Rust -- Second Submission in the Contest\\nimpl Solution {\\n    pub fn delete_string(s: String) -> i32 {\\n        let n = s.len();\\n        let mut s = s.chars().collect::<Vec<char>>();\\n        let mut dp = vec![1; n];\\n        s.reverse();\\n        \\n        for i in 0..n {\\n            for j in (0..i).rev() {\\n                if j + 1 < i - j { break }\\n                if dp[j] + 1 <= dp[i] { continue; }\\n                \\n                let mut good = true;\\n                for k in 0..i - j {\\n                    if s[j - k] == s[i - k] { continue }\\n                    \\n                    good = false;\\n                    break\\n                }\\n                if good == false { continue }\\n                dp[i] = dp[j] + 1;\\n            }\\n        }\\n        \\n        dp[n - 1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2650476,
                "title": "c-hashing-memoization",
                "content": "class Solution {\\npublic:\\n    long long h[100000];\\n    long long po[100000];\\n    int mod = 1000000007;\\n    void power31()\\n    {\\n        po[0]=1;\\n        for(int i=1;i<40000;i++)\\n            po[i] = (po[i-1]*31)%mod;\\n    }\\n    void hasher(string s)\\n    {\\n        h[0]=0;\\n        for(int i=1;i<=s.length();i++)\\n        {\\n            h[i] = (h[i-1] + ((s[i-1]-\\'a\\'+1)*po[i-1])%mod)%mod;\\n        }\\n    }\\n    unordered_map<int,int>mp;\\n    int solve(string &s,int st,int end) {\\n        if(mp.find(st)!=mp.end()) return mp[st];\\n        int ans=0;\\n        for(int i=1;i<=(end-st+1)/2;i++){\\n            if((((h[i+st]- h[st] + mod)%mod)*po[40000-(st+1)])%mod == (((h[st+2*i]-h[st+i]+mod)%mod)*po[40000-(st+i+1)])%mod)\\n                ans=max(ans,1+solve(s,st+i,end));\\n        }\\n        return mp[st]=max(ans,1);\\n    }\\n    int deleteString(string s) {\\n        power31();\\n        hasher(s);\\n        return solve(s,0,s.length()-1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long h[100000];\\n    long long po[100000];\\n    int mod = 1000000007;\\n    void power31()\\n    {\\n        po[0]=1;\\n        for(int i=1;i<40000;i++)\\n            po[i] = (po[i-1]*31)%mod;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2650225,
                "title": "python-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        \\n        def findPairStringIndexes(s,i) :\\n            idxList = []\\n            for j in range(len(s)//2) :\\n                # think s[i:]\\n                if s[i:i+j+1] == s[i+j+1:i+2*j+2] :\\n                    idxList.append(j)\\n            return idxList\\n        \\n        # special case : number of operation is obvious\\n        if len(set(list(s))) == 1 : return len(s)\\n\\n        # dynamic programming : because several truncate strategies are possible\\n        dp = [ 0 for _ in s ]\\n        i=0\\n        while i<len(s) :\\n            \\n            # list up possible pair case of s[i:] (index returns)\\n            idxList = findPairStringIndexes(s,i)\\n            # edge-case\\n            if i==0 and len(idxList)==0 : return 1\\n            \\n            # accumulate the number of operation\\n            for j in idxList :\\n                k = i+j\\n                dp[k+1] = max(dp[i],dp[k])+1   # number of operation\\n            \\n            # displace the pointer of s head\\n            while True :\\n                i+=1\\n                if i==len(s) : break\\n                if dp[i]!=0 : break\\n                \\n        return max(dp)+1\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        \\n        def findPairStringIndexes(s,i) :\\n            idxList = []\\n            for j in range(len(s)//2) :\\n                # think s[i:]\\n                if s[i:i+j+1] == s[i+j+1:i+2*j+2] :\\n                    idxList.append(j)\\n            return idxList\\n        \\n        # special case : number of operation is obvious\\n        if len(set(list(s))) == 1 : return len(s)\\n\\n        # dynamic programming : because several truncate strategies are possible\\n        dp = [ 0 for _ in s ]\\n        i=0\\n        while i<len(s) :\\n            \\n            # list up possible pair case of s[i:] (index returns)\\n            idxList = findPairStringIndexes(s,i)\\n            # edge-case\\n            if i==0 and len(idxList)==0 : return 1\\n            \\n            # accumulate the number of operation\\n            for j in idxList :\\n                k = i+j\\n                dp[k+1] = max(dp[i],dp[k])+1   # number of operation\\n            \\n            # displace the pointer of s head\\n            while True :\\n                i+=1\\n                if i==len(s) : break\\n                if dp[i]!=0 : break\\n                \\n        return max(dp)+1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650149,
                "title": "python-memoization-solution",
                "content": "```\\nfrom functools import cache\\n\\n\\nclass Solution:\\n    \\n    def deleteString(self, s: str) -> int:\\n        \\n        if len(set(s)) == 1: \\n            return len(s)\\n        \\n        @cache\\n        def count_deletions(start_idx: int = 0) -> int:\\n            \\n            if start_idx == len(s) - 1:\\n                return 1\\n            \\n            count = 0\\n            for k in range(1, (len(s) - start_idx) // 2 + 1):\\n                for idx in range(k):\\n                    if s[start_idx + idx] != s[start_idx + k + idx]:\\n                        break\\n                else:                        \\n                    count = max(count, count_deletions(start_idx + k))\\n                        \\n            return count + 1                \\n        \\n        return count_deletions()\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nfrom functools import cache\\n\\n\\nclass Solution:\\n    \\n    def deleteString(self, s: str) -> int:\\n        \\n        if len(set(s)) == 1: \\n            return len(s)\\n        \\n        @cache\\n        def count_deletions(start_idx: int = 0) -> int:\\n            \\n            if start_idx == len(s) - 1:\\n                return 1\\n            \\n            count = 0\\n            for k in range(1, (len(s) - start_idx) // 2 + 1):\\n                for idx in range(k):\\n                    if s[start_idx + idx] != s[start_idx + k + idx]:\\n                        break\\n                else:                        \\n                    count = max(count, count_deletions(start_idx + k))\\n                        \\n            return count + 1                \\n        \\n        return count_deletions()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650013,
                "title": "c-dp-simple-solution-100-faster",
                "content": "# C++ Dynamic Programming Solution\\n- \"isValid\" method check the whether the substring starting at some index \\'second\\' starts where the substring starting at index \\'first\\' ends.\\n- \"temp\" is a hash table for storing the index of the characters (Can use unordered_map<int, unordered_map< int, int >> to reduce the time complexity even more for large enough values, but for this solution vector< int > is enough).\\n- Worst case Time Complexity is O(n^3).\\n- Storing DP array from last index as it is easy to solve the last character. At each index of DP, the algorithm stores the maximum possible deletions for the substring starting at that index.\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int first, int second, string &s){\\n        int i = first;\\n        int j = second;\\n        int n = s.length();\\n        while(i < second){\\n            if(s[i] == s[j]){\\n                i++;\\n                j++;\\n            }else{\\n                return false;\\n            }\\n            if(j == n && i<second)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int deleteString(string s) {\\n        int n = s.length();\\n        int dp[n];\\n        dp[n-1] = 1;\\n        unordered_map<char, vector<int>> temp;\\n        temp[s[n-1]] = {n-1};\\n        for(int i=n-2; i>=0 ;i--){\\n            if(temp.find(s[i]) == temp.end()){\\n                dp[i] = 1;\\n                temp[s[i]] = {i};\\n            }\\n            else{\\n                vector<int> st = temp[s[i]];\\n                int maximum = 0;\\n                for(int j=st.size()-1; j >=0; j--){\\n                    if(dp[st[j]] > maximum && isValid(i, st[j], s))\\n                        maximum = dp[st[j]];\\n                }\\n                dp[i] = maximum +1;\\n                temp[s[i]].push_back(i);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int first, int second, string &s){\\n        int i = first;\\n        int j = second;\\n        int n = s.length();\\n        while(i < second){\\n            if(s[i] == s[j]){\\n                i++;\\n                j++;\\n            }else{\\n                return false;\\n            }\\n            if(j == n && i<second)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int deleteString(string s) {\\n        int n = s.length();\\n        int dp[n];\\n        dp[n-1] = 1;\\n        unordered_map<char, vector<int>> temp;\\n        temp[s[n-1]] = {n-1};\\n        for(int i=n-2; i>=0 ;i--){\\n            if(temp.find(s[i]) == temp.end()){\\n                dp[i] = 1;\\n                temp[s[i]] = {i};\\n            }\\n            else{\\n                vector<int> st = temp[s[i]];\\n                int maximum = 0;\\n                for(int j=st.size()-1; j >=0; j--){\\n                    if(dp[st[j]] > maximum && isValid(i, st[j], s))\\n                        maximum = dp[st[j]];\\n                }\\n                dp[i] = maximum +1;\\n                temp[s[i]].push_back(i);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649997,
                "title": "python-3-dp-rolling-hash-o-n-2-solution",
                "content": "Check [@xil899](https://leetcode.com/problems/maximum-deletions-on-a-string/discuss/2648661/Python3-Dynamic-Programming-Clean-and-Concise) about the DP idea. His first solution uses string slicing. Although Python does this efficiently, it\\'s still theoretically O(n) operation, so overall O(n^3). \\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        if len(set(s)) == 1:\\n            return n\\n        dp = [1] * n\\n        for i in range(n - 2, -1, -1):\\n            for l in range(1, (n - i) // 2 + 1):\\n                if s[i : i + l] == s[i + l : i + 2 * l]:\\n                    dp[i] = max(dp[i], 1 + dp[i + l])\\n        return dp[0]\\n```\\nThe inner two loops (index by j, and then the silent loop that compares s[i : i + l] == s[i + l : i + 2 * l]) can be optimized with rolling hash.\\n\\nWe can use two rolling hash implemented in the `RollingHash` class below, which almost like a `deque` that characters can be appended and popped left and right. \\n\\nFor example, \"aaabaab\", when `i = 4`, the tail we are looking at is \"aab\".\\nNow we want to check if there are \"a|aab -> aab\", \"aa|aab -> aab\", and \"aab|aab -> aab\". \\n\\n1. `l = 1`, `h_l.append_left(\"b\")`, `h_r.append(\"a\")`, `\"b\" != \"a\"`, there is no match, we cannot update `dp[i - l]`\\n2. `l = 2`, `h_l.append_left(\"a\")`, `h_r.append(\"a\")`, `\"ab\" != \"aa\"`, there is no match, we cannot update `dp[i - l]`.\\n3. `l = 3`, `h_l.append_left(\"a\")`, `h_r.append(\"b\")`, `\"aab\" == \"aab\"`, matched, we update `dp[i - l]`.\\n\\n\\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        if (len(set(s)) == 1):\\n            return n\\n   \\n        dp = [1] * n\\n        for i in reversed(range(1, n)):\\n            h_l = RollingHash()\\n            h_r = RollingHash()\\n            for l in range(1, n - i + 1):\\n                if i - l < 0:\\n                    break\\n                h_l.append_left(s[i - l])\\n                h_r.append(s[i + l - 1])\\n                if h_l.h == h_r.h:\\n                    dp[i - l] = max(dp[i - l], dp[i] + 1)\\n        return dp[0]\\n    \\n    \\nclass RollingHash:\\n    \\n    def __init__(self, p = 31, m = 10 ** 9 + 7):\\n        self.h = 0\\n        self.l = 0\\n        self.p = p\\n        self.m = m\\n        self.invmod = pow(self.p, -1, self.m)\\n    \\n    def append(self, char):\\n        self.h = (self.h * self.p + ord(char) - ord(\\'a\\')) % self.m\\n        self.l += 1 \\n        return\\n    \\n    def pop(self, char):\\n        self.h = ((self.h - (ord(char) - ord(\\'a\\'))) * self.invmod) % self.m\\n        self.l -= 1\\n        return\\n    \\n    def append_left(self, char):\\n        self.h = (self.h + (ord(char) - ord(\\'a\\')) * pow(self.p, self.l, self.m)) % self.m\\n        self.l += 1\\n        return\\n    \\n    def pop_left(self, char):\\n        self.h = (self.h - ((ord(char) - ord(\\'a\\')) * pow(self.p, self.l - 1, self.m))) % self.m\\n        self.l -= 1\\n        return\\n    \\n    def clear(self):\\n        self.h = 0\\n        self.l = 0\\n        return\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        if len(set(s)) == 1:\\n            return n\\n        dp = [1] * n\\n        for i in range(n - 2, -1, -1):\\n            for l in range(1, (n - i) // 2 + 1):\\n                if s[i : i + l] == s[i + l : i + 2 * l]:\\n                    dp[i] = max(dp[i], 1 + dp[i + l])\\n        return dp[0]\\n```\n```\\nclass Solution:\\n    def deleteString(self, s: str) -> int:\\n        n = len(s)\\n        if (len(set(s)) == 1):\\n            return n\\n   \\n        dp = [1] * n\\n        for i in reversed(range(1, n)):\\n            h_l = RollingHash()\\n            h_r = RollingHash()\\n            for l in range(1, n - i + 1):\\n                if i - l < 0:\\n                    break\\n                h_l.append_left(s[i - l])\\n                h_r.append(s[i + l - 1])\\n                if h_l.h == h_r.h:\\n                    dp[i - l] = max(dp[i - l], dp[i] + 1)\\n        return dp[0]\\n    \\n    \\nclass RollingHash:\\n    \\n    def __init__(self, p = 31, m = 10 ** 9 + 7):\\n        self.h = 0\\n        self.l = 0\\n        self.p = p\\n        self.m = m\\n        self.invmod = pow(self.p, -1, self.m)\\n    \\n    def append(self, char):\\n        self.h = (self.h * self.p + ord(char) - ord(\\'a\\')) % self.m\\n        self.l += 1 \\n        return\\n    \\n    def pop(self, char):\\n        self.h = ((self.h - (ord(char) - ord(\\'a\\'))) * self.invmod) % self.m\\n        self.l -= 1\\n        return\\n    \\n    def append_left(self, char):\\n        self.h = (self.h + (ord(char) - ord(\\'a\\')) * pow(self.p, self.l, self.m)) % self.m\\n        self.l += 1\\n        return\\n    \\n    def pop_left(self, char):\\n        self.h = (self.h - ((ord(char) - ord(\\'a\\')) * pow(self.p, self.l - 1, self.m))) % self.m\\n        self.l -= 1\\n        return\\n    \\n    def clear(self):\\n        self.h = 0\\n        self.l = 0\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649964,
                "title": "fastest-python-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    # DP with a valid check\\n    def deleteString(self, s: str) -> int:\\n        @lru_cache(None)\\n        def helper(s):\\n            if len(Counter(s)) == 1:\\n                return len(s)\\n            res = 1\\n            for i in range(0, (len(s) >> 1) + 1):\\n                if self.isValid(0, i, s): res = max(res, 1 + helper(s[i + 1:]))\\n            return res\\n        return helper(s)\\n      \\n    # EG- l = 0, r = 2 sub = abcabcdabc will check for \\'abc\\'{sub[0:3]} and \\'abc\\'{sub[3: 6]} and return True\\n    def isValid(self, l, r, sub):\\n        total = (r - l + 1) << 1\\n        if sub[l : r + 1] == sub[r + 1: total]: return True\\n        return False\\n```\\ncredits - Took help from https://leetcode.com/problems/maximum-deletions-on-a-string/discuss/2649062/Python-or-DFS-%2B-MEMO-or-Easy-to-Understand\\n\\nUpvote if this made you understand this question!",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    # DP with a valid check\\n    def deleteString(self, s: str) -> int:\\n        @lru_cache(None)\\n        def helper(s):\\n            if len(Counter(s)) == 1:\\n                return len(s)\\n            res = 1\\n            for i in range(0, (len(s) >> 1) + 1):\\n                if self.isValid(0, i, s): res = max(res, 1 + helper(s[i + 1:]))\\n            return res\\n        return helper(s)\\n      \\n    # EG- l = 0, r = 2 sub = abcabcdabc will check for \\'abc\\'{sub[0:3]} and \\'abc\\'{sub[3: 6]} and return True\\n    def isValid(self, l, r, sub):\\n        total = (r - l + 1) << 1\\n        if sub[l : r + 1] == sub[r + 1: total]: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649857,
                "title": "c-z-algorithm-dp-simple-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[4005];\\n    vector<int> getZScore(string &s){\\n        int n = s.length();\\n        \\n            vector<int>zScore(n,0);\\n            zScore[0] = n;\\n            \\n            int i=1,l=-1, r =-1;\\n        \\n            while(i<n){\\n                if(i>r){\\n                    l = i;\\n                    r= i;\\n                \\n                while(r<n && s[r-l] == s[r])  r++;\\n                \\n                zScore[i] = r-l;\\n                r--;\\n                }\\n                else{\\n                    if(i+ zScore[i-l]<=r)\\n                        zScore[i]= zScore[i-l];\\n                    else{\\n                        l = i;\\n                        while(r<n && s[r-l] == s[r])  r++;\\n                \\n                        zScore[i] = r-l;\\n                        r--;\\n                    }\\n                }\\n                i++;\\n            }\\n        \\n        return zScore;\\n    }\\n    \\n    int findMaxOpr(string &inputString, int inx){\\n        \\n        if(dp[inx]!=-1)\\n            return dp[inx];\\n        \\n        string s = inputString.substr(inx);\\n        vector<int> zScore = getZScore(s);\\n        \\n        int ans =  1;\\n        \\n        for(int i=1;i<s.size(); i++){\\n            if(i<=zScore[i]){\\n                ans = max(ans, 1 + findMaxOpr(inputString,  inx + i));\\n            }\\n        }\\n        \\n        return dp[inx] = ans;\\n    }\\n    \\n    \\npublic:\\n    int deleteString(string inputString) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return findMaxOpr(inputString, 0);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\nprivate:\\n    int dp[4005];\\n    vector<int> getZScore(string &s){\\n        int n = s.length();\\n        \\n            vector<int>zScore(n,0);\\n            zScore[0] = n;\\n            \\n            int i=1,l=-1, r =-1;\\n        \\n            while(i<n){\\n                if(i>r){\\n                    l = i;\\n                    r= i;\\n                \\n                while(r<n && s[r-l] == s[r])  r++;\\n                \\n                zScore[i] = r-l;\\n                r--;\\n                }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1626975,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1643872,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1870474,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1628330,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 2019129,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1901391,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1900105,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1875261,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1632417,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1627071,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1626975,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1643872,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1870474,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1628330,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 2019129,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1901391,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1900105,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1875261,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1632417,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            },
            {
                "id": 1627071,
                "content": [
                    {
                        "username": "violet_7",
                        "content": "Someone cheating if testcase is \"aaaaaaaaaaa...\". Leatcode please add some test case, and drop rank of cheating people.\n\nUp vote to leetcode can see!"
                    },
                    {
                        "username": "berlin8282",
                        "content": "yeah my sol was giving tle i hardcoded if the string consists of 1 unique character case then it passed"
                    },
                    {
                        "username": "holfeld",
                        "content": "Premium user and all of the python solutions are failing. Pretty annoying, not sure if test cases changed but getting TLE on 115/128 using the top voted python solutions."
                    },
                    {
                        "username": "Finesse",
                        "content": "A rolling hash Python solution gives TLE in my case, but a solution with a pre-calculated Longest Common Prefix table succeeds"
                    },
                    {
                        "username": "ellayu",
                        "content": "Same here... Got TLE on nearly all the Python solutions posted..."
                    },
                    {
                        "username": "DeltaPavonis",
                        "content": "??? Can\\'t you delete all of s in one operation always?"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, but you need to perform as many operations as possible"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Yepp"
                    },
                    {
                        "username": "bayartsogt",
                        "content": "I guess this is one of the problems that giving Python users a little bit of disadvantage :')) \nAt least, second place solution made it done even though the same code does not pass now :D"
                    },
                    {
                        "username": "user0846Bu",
                        "content": "why disadvantage ?"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "how can we say that hashing doesn\\'t undergo collision while checking for matching substrings?"
                    },
                    {
                        "username": "JasonGua",
                        "content": "can someone explain me why \"aaaaa\" needs 5 step? should that be: \\n` remove \"aa\" -> \"aaa\"`\\n` remove \"a\" -> \"aa\"`\\n `remove \"a\" -> \"a\"`\\n`remove \"a\"`\\n"
                    },
                    {
                        "username": "kesharivishal611",
                        "content": "remove \"a\" -> \"aaaa\"\\nremove \"a\" -> \"aaa\"\\nremove \"a\" -> \"aa\"\\nremove \"a\" -> \"a\"\\nremove \"a"
                    },
                    {
                        "username": "theodor1289",
                        "content": "What is up with test 129? It looks empty and I get a grey result on it"
                    },
                    {
                        "username": "user3838wC",
                        "content": "Why \"ititititvt\" expected 4????\\n1) remove \"itit\" -> ititvt\\n2) remove \"it\" -> itvt\\n3) remove \"itvt\""
                    },
                    {
                        "username": "chetan_saini21",
                        "content": "You don\\'t need to maximize the removing string. \\n1. Remove \"it\" -> itititvt\\n2. Remove \"it\" -> ititvt\\n3. Remove \"it\" -> itvt\\n4. Remove \"itvt\""
                    },
                    {
                        "username": "harshit_90",
                        "content": "Can anyone tell what's wrong with this code??\n\n\n****************************\nclass Solution {\npublic:\n    \n\nint recur(int st, string& s, vector<int>& dp,vector<vector<int>>& isSame) {\n    if (st >= s.length()) return 0;\n    if (dp[st] != -1) return dp[st];\n    int ans = 1;\n    string dummy = \"\";\n    for (int i = st; i < s.length(); i++) {\n        dummy += s[i];\n        if (st + 2 * dummy.length() - 1 < s.length() and isSame[st][dummy.length()]==1) {\n            ans = max(ans, 1 + recur(st + dummy.length(), s, dp,isSame));\n        }\n    }\n    return dp[st] = ans;\n}\n\nint deleteString(string s) {\n    vector<int>dp(4005, -1);\n    vector<vector<int>>isSame(4005,vector<int>(4005,-1));\n\n    unordered_map<string,int> msid;\n    int cal[4005][4005];\n    int id=0;\n    for (int i = 0; i < s.length(); i++){\n        string dummy=\"\";\n        for (int j = i; j < s.length(); j++){\n            dummy+=s[j];\n            if(msid.count(dummy)==0){\n                msid[dummy]=id++;\n            }\n            cal[i][j-i+1]=msid[dummy];\n        }\n    }\n\n    for (int i = 0; i < s.length(); i++){\n        for (int j = i; j < s.length(); j++){\n            if(j+1+j-i+1-1<s.length() && cal[i][j-i+1]==cal[j+1][j-i+1]){\n                isSame[i][j-i+1]=1;\n            }\n        }\n    }\n    return recur(0, s, dp,isSame);\n}\n};\n************\n\n[@lee](/lee215)"
                    },
                    {
                        "username": "dhiru_1612",
                        "content": "Passed 99/118\\nCan you please tell me why my Solution is giving tle even after I did in Time O(n^2) with dp+memorization.\\n\\nSOLUTION:\\n\\nclass Solution {\\npublic:\\nvector<vector>dp;\\nint deleteString(string s) {\\ndp.resize(s.size(),vector(s.size(),-1));\\nreturn del(s,0,0);\\n}\\n\\nint del(string &s, int l, int r){\\n    if(l>=s.size() && r>=s.size()) return 0;\\n    if(r>=s.size()) return 1;\\n    \\n    if(dp[l][r]!=-1) return dp[l][r];\\n    \\n    for(int j=r;j<=r+(s.size()-r)/2;j++){\\n        if(s.substr(l,j-l+1)==s.substr(j+1,j-l+1)){\\n            return dp[l][r]=max(1+del(s,l+(j-l+1),l+(j-l+1)), del(s,l,j+1));\\n        }\\n    }\\n     return dp[l][r]=1;\\n}\\n};"
                    },
                    {
                        "username": "rp202910",
                        "content": "substr has time complexity of o(n), hence your tc will be o(n^4)"
                    }
                ]
            }
        ]
    }
]