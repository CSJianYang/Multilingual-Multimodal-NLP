[
    {
        "title": "Unique Binary Search Trees II",
        "question_content": "Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.\n&nbsp;\nExample 1:\n\nInput: n = 3\nOutput: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n\nExample 2:\n\nInput: n = 1\nOutput: [[1]]\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 8",
        "solutions": [
            {
                "id": 31508,
                "title": "divide-and-conquer-f-i-g-i-1-g-n-i",
                "content": "This problem is a variant of the problem of [Unique Binary Search Trees][1]. \\n\\nI provided a solution along with explanation for the above problem, in the question [\"DP solution in 6 lines with explanation\"](https://leetcode.com/problems/unique-binary-search-trees/discuss/31666/DP-Solution-in-6-lines-with-explanation.-F(i-n)-G(i-1)-*-G(n-i))\\n\\nIt is intuitive to solve this problem by following the same algorithm. Here is the code in a divide-and-conquer style. \\n\\n    public List<TreeNode> generateTrees(int n) {\\n    \\treturn generateSubtrees(1, n);\\n    }\\n \\n\\tprivate List<TreeNode> generateSubtrees(int s, int e) {\\n\\t\\tList<TreeNode> res = new LinkedList<TreeNode>();\\n\\t\\tif (s > e) {\\n\\t\\t\\tres.add(null); // empty tree\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tfor (int i = s; i <= e; ++i) {\\n\\t\\t\\tList<TreeNode> leftSubtrees = generateSubtrees(s, i - 1);\\n\\t\\t\\tList<TreeNode> rightSubtrees = generateSubtrees(i + 1, e);\\n\\n\\t\\t\\tfor (TreeNode left : leftSubtrees) {\\n\\t\\t\\t\\tfor (TreeNode right : rightSubtrees) {\\n\\t\\t\\t\\t\\tTreeNode root = new TreeNode(i);\\n\\t\\t\\t\\t\\troot.left = left;\\n\\t\\t\\t\\t\\troot.right = right;\\n\\t\\t\\t\\t\\tres.add(root);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n  [1]: https://oj.leetcode.com/problems/unique-binary-search-trees/\\n  [2]: https://oj.leetcode.com/discuss/24282/dp-solution-in-6-lines-with-explanation-f-i-g-i-1-g-n-i",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "This problem is a variant of the problem of [Unique Binary Search Trees][1]. \\n\\nI provided a solution along with explanation for the above problem, in the question [\"DP solution in 6 lines with explanation\"](https://leetcode.com/problems/unique-binary-search-trees/discuss/31666/DP-Solution-in-6-lines-with-explanation.-F(i-n)-G(i-1)-*-G(n-i))\\n\\nIt is intuitive to solve this problem by following the same algorithm. Here is the code in a divide-and-conquer style. \\n\\n    public List<TreeNode> generateTrees(int n) {\\n    \\treturn generateSubtrees(1, n);\\n    }\\n \\n\\tprivate List<TreeNode> generateSubtrees(int s, int e) {\\n\\t\\tList<TreeNode> res = new LinkedList<TreeNode>();\\n\\t\\tif (s > e) {\\n\\t\\t\\tres.add(null); // empty tree\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tfor (int i = s; i <= e; ++i) {\\n\\t\\t\\tList<TreeNode> leftSubtrees = generateSubtrees(s, i - 1);\\n\\t\\t\\tList<TreeNode> rightSubtrees = generateSubtrees(i + 1, e);\\n\\n\\t\\t\\tfor (TreeNode left : leftSubtrees) {\\n\\t\\t\\t\\tfor (TreeNode right : rightSubtrees) {\\n\\t\\t\\t\\t\\tTreeNode root = new TreeNode(i);\\n\\t\\t\\t\\t\\troot.left = left;\\n\\t\\t\\t\\t\\troot.right = right;\\n\\t\\t\\t\\t\\tres.add(root);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n  [1]: https://oj.leetcode.com/problems/unique-binary-search-trees/\\n  [2]: https://oj.leetcode.com/discuss/24282/dp-solution-in-6-lines-with-explanation-f-i-g-i-1-g-n-i",
                "codeTag": "Unknown"
            },
            {
                "id": 31493,
                "title": "java-solution-with-dp",
                "content": "Here is my java solution with DP:\\n\\n\\n    public static List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[] result = new List[n + 1];\\n        result[0] = new ArrayList<TreeNode>();\\n        if (n == 0) {\\n            return result[0];\\n        }\\n\\n        result[0].add(null);\\n        for (int len = 1; len <= n; len++) {\\n            result[len] = new ArrayList<TreeNode>();\\n            for (int j = 0; j < len; j++) {\\n                for (TreeNode nodeL : result[j]) {\\n                    for (TreeNode nodeR : result[len - j - 1]) {\\n                        TreeNode node = new TreeNode(j + 1);\\n                        node.left = nodeL;\\n                        node.right = clone(nodeR, j + 1);\\n                        result[len].add(node);\\n                    }\\n                }\\n            }\\n        }\\n        return result[n];\\n    }\\n\\n    private static TreeNode clone(TreeNode n, int offset) {\\n        if (n == null) {\\n            return null;\\n        }\\n        TreeNode node = new TreeNode(n.val + offset);\\n        node.left = clone(n.left, offset);\\n        node.right = clone(n.right, offset);\\n        return node;\\n    }\\n\\n\\n\\n**result[i]** stores the result until length **i**. For the result for length i+1, select the root node j from 0 to i, combine the result from left side and right side. Note for the right side we have to clone the nodes as the value will be offsetted by **j**.",
                "solutionTags": [
                    "Java"
                ],
                "code": "Here is my java solution with DP:\\n\\n\\n    public static List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[] result = new List[n + 1];\\n        result[0] = new ArrayList<TreeNode>();\\n        if (n == 0) {\\n            return result[0];\\n        }\\n\\n        result[0].add(null);\\n        for (int len = 1; len <= n; len++) {\\n            result[len] = new ArrayList<TreeNode>();\\n            for (int j = 0; j < len; j++) {\\n                for (TreeNode nodeL : result[j]) {\\n                    for (TreeNode nodeR : result[len - j - 1]) {\\n                        TreeNode node = new TreeNode(j + 1);\\n                        node.left = nodeL;\\n                        node.right = clone(nodeR, j + 1);\\n                        result[len].add(node);\\n                    }\\n                }\\n            }\\n        }\\n        return result[n];\\n    }\\n\\n    private static TreeNode clone(TreeNode n, int offset) {\\n        if (n == null) {\\n            return null;\\n        }\\n        TreeNode node = new TreeNode(n.val + offset);\\n        node.left = clone(n.left, offset);\\n        node.right = clone(n.right, offset);\\n        return node;\\n    }\\n\\n\\n\\n**result[i]** stores the result until length **i**. For the result for length i+1, select the root node j from 0 to i, combine the result from left side and right side. Note for the right side we have to clone the nodes as the value will be offsetted by **j**.",
                "codeTag": "Unknown"
            },
            {
                "id": 1849266,
                "title": "c-detailed-explanation-recursive-tree-with-comments",
                "content": "**Problem**\\n> Given n, find all structurally unique BST\\'s (binary search trees) that has n nodes with unique values from 1 to n\\n\\n**Strategy:**\\nWe will use a **recursive helper function** `bst(start, end)` that receives a range (*start to end*, within n) and returns all BST\\'s rooted in that range.\\n\\nNow let\\'s look how our helper function will work!\\n* As there will be trees with root as 1, 2, 3...n.  Iterate through all values from start to end to construct tree rooted at i and construct its left and right subtree recursively.\\n* We know that in Binary Search Tree all nodes in left subtree are smaller than root and in right subtree are larger than root. So for start = 1 and end = n, if we have ith number as root, all numbers from 1 to i-1 will be in left subtree and i+1 to n will be in right subtree. \\n**Therefore, we will build the tree recursively for left and right subtrees rooted at i as `leftSubTree = bst(start, i-1)` and `rightSubtree = bst(i + 1, end)`**\\n* So, till what moment we will recursively find the left and right subtrees?? Answer is until **start < end**!! \\n`So when start > end, add NULL to the list and return`\\nThis will be our base case!\\n* Now, we have leftSubtree and rightSubtree for node with root i. The last thing we need to do is connect leftSubTree and rightSubTree with root and add this tree(rooted at i) to the ans list!\\n\\uD83D\\uDCCC Here, we can have multiple left and right subtrees. So we need to loop through all left and right subtrees and connect every left subTree to right subTree and to current root(i) one by one.\\n\\n**Recursive Tree**\\nSee below recursive tree for more details, expanded for n = 5 and 3 as root!\\n![image](https://assets.leetcode.com/users/images/0b63aeae-a4dd-4f27-80d6-90e94695619a_1647273543.8265834.jpeg)\\n\\n\\t\\n\\t\\t\\n**Code**\\n```cpp\\nvector<TreeNode*> buildTree(int start, int end) {\\n\\tvector<TreeNode*> ans;\\n        \\n    // If start > end, then subtree will be empty so add NULL in the ans and return it.\\n    if(start > end) {\\n\\t\\tans.push_back(NULL);\\n        return ans;\\n    }\\n\\n    // Iterate through all values from start to end to construct left and right subtree recursively\\n\\tfor(int i = start; i <= end; ++i) {\\n\\t\\tvector<TreeNode*> leftSubTree = buildTree(start, i - 1);    // Construct left subtree\\n        vector<TreeNode*> rightSubTree = buildTree(i + 1, end);     // Construct right subtree\\n            \\n\\t\\t// loop through all left and right subtrees and connect them to ith root  \\n\\t\\tfor(int j = 0; j < leftSubTree.size(); j++) {\\n\\t\\t\\tfor(int k = 0; k < rightSubTree.size(); k++) {\\n\\t\\t\\t\\tTreeNode* root = new TreeNode(i);   // Create root with value i\\n\\t\\t\\t\\troot->left = leftSubTree[j];   // Connect left subtree rooted at leftSubTree[j]\\n                root->right = rightSubTree[k];   // Connect right subtree rooted at rightSubTree[k]\\n\\t\\t\\t\\tans.push_back(root);    // Add this tree(rooted at i) to ans data-structure\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n        \\n\\treturn ans;\\n}\\n    \\nvector<TreeNode*> generateTrees(int n) {\\n\\treturn buildTree(1, n);\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nvector<TreeNode*> buildTree(int start, int end) {\\n\\tvector<TreeNode*> ans;\\n        \\n    // If start > end, then subtree will be empty so add NULL in the ans and return it.\\n    if(start > end) {\\n\\t\\tans.push_back(NULL);\\n        return ans;\\n    }\\n\\n    // Iterate through all values from start to end to construct left and right subtree recursively\\n\\tfor(int i = start; i <= end; ++i) {\\n\\t\\tvector<TreeNode*> leftSubTree = buildTree(start, i - 1);    // Construct left subtree\\n        vector<TreeNode*> rightSubTree = buildTree(i + 1, end);     // Construct right subtree\\n            \\n\\t\\t// loop through all left and right subtrees and connect them to ith root  \\n\\t\\tfor(int j = 0; j < leftSubTree.size(); j++) {\\n\\t\\t\\tfor(int k = 0; k < rightSubTree.size(); k++) {\\n\\t\\t\\t\\tTreeNode* root = new TreeNode(i);   // Create root with value i\\n\\t\\t\\t\\troot->left = leftSubTree[j];   // Connect left subtree rooted at leftSubTree[j]\\n                root->right = rightSubTree[k];   // Connect right subtree rooted at rightSubTree[k]\\n\\t\\t\\t\\tans.push_back(root);    // Add this tree(rooted at i) to ans data-structure\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n        \\n\\treturn ans;\\n}\\n    \\nvector<TreeNode*> generateTrees(int n) {\\n\\treturn buildTree(1, n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31495,
                "title": "should-be-6-liner",
                "content": "If only LeetCode had a `TreeNode(val, left, right)` constructor... sigh. Then I wouldn't need to provide my own and my solution would be six lines instead of eleven.\\n\\n    def generateTrees(self, n):\\n        def node(val, left, right):\\n            node = TreeNode(val)\\n            node.left = left\\n            node.right = right\\n            return node\\n        def trees(first, last):\\n            return [node(root, left, right)\\n                    for root in range(first, last+1)\\n                    for left in trees(first, root-1)\\n                    for right in trees(root+1, last)] or [None]\\n        return trees(1, n)\\n\\nOr even just **four** lines, if it's not forbidden to add an optional argument:\\n\\n    def node(val, left, right):\\n        node = TreeNode(val)\\n        node.left = left\\n        node.right = right\\n        return node\\n    \\n    class Solution:\\n        def generateTrees(self, last, first=1):\\n            return [node(root, left, right)\\n                    for root in range(first, last+1)\\n                    for left in self.generateTrees(root-1, first)\\n                    for right in self.generateTrees(last, root+1)] or [None]\\n\\nJust another version, using loops instead of list comprehension:\\n\\n    def generateTrees(self, n):\\n        def generate(first, last):\\n            trees = []\\n            for root in range(first, last+1):\\n                for left in generate(first, root-1):\\n                    for right in generate(root+1, last):\\n                        node = TreeNode(root)\\n                        node.left = left\\n                        node.right = right\\n                        trees += node,\\n            return trees or [None]\\n        return generate(1, n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "If only LeetCode had a `TreeNode(val, left, right)` constructor... sigh. Then I wouldn't need to provide my own and my solution would be six lines instead of eleven.\\n\\n    def generateTrees(self, n):\\n        def node(val, left, right):\\n            node = TreeNode(val)\\n            node.left = left\\n            node.right = right\\n            return node\\n        def trees(first, last):\\n            return [node(root, left, right)\\n                    for root in range(first, last+1)\\n                    for left in trees(first, root-1)\\n                    for right in trees(root+1, last)] or [None]\\n        return trees(1, n)\\n\\nOr even just **four** lines, if it's not forbidden to add an optional argument:\\n\\n    def node(val, left, right):\\n        node = TreeNode(val)\\n        node.left = left\\n        node.right = right\\n        return node\\n    \\n    class Solution:\\n        def generateTrees(self, last, first=1):\\n            return [node(root, left, right)\\n                    for root in range(first, last+1)\\n                    for left in self.generateTrees(root-1, first)\\n                    for right in self.generateTrees(last, root+1)] or [None]\\n\\nJust another version, using loops instead of list comprehension:\\n\\n    def generateTrees(self, n):\\n        def generate(first, last):\\n            trees = []\\n            for root in range(first, last+1):\\n                for left in generate(first, root-1):\\n                    for right in generate(root+1, last):\\n                        node = TreeNode(root)\\n                        node.left = left\\n                        node.right = right\\n                        trees += node,\\n            return trees or [None]\\n        return generate(1, n)",
                "codeTag": "Java"
            },
            {
                "id": 1440128,
                "title": "python-dfs-with-memoization-clean-concise",
                "content": "**Idea**\\n- Let `dfs(left, right)` return all valid BSTs where values in the BST in range `[left..right]`.\\n- Then `dfs(1, n)` is our result.\\n- To solve `dfs(left, right)`, we just\\n\\t- Generate `root` value in range `[left...right]`\\n\\t- Get left subtrees by `leftNodes = dfs(left, root-1)`\\n\\t- Get right subtrees by `rightNodes = dfs(root+1, right)`.\\n\\t- Add all combination between `leftNodes` and `rightNodes` to form `root` trees.\\n- Can we cache the result of `dfs(left, right)` to prevent it to re-compute multiple time.\\n- There is a simillar problem, which is **[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/)**, try to solve it yourself.\\n```python\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        @lru_cache(None)\\n        def dfs(left, right):\\n            if left > right: return [None]\\n            if left == right: return [TreeNode(left)]\\n            ans = []\\n            for root in range(left, right+1):\\n                leftNodes = dfs(left, root - 1)\\n                rightNodes = dfs(root+1, right)\\n                for leftNode in leftNodes:\\n                    for rightNode in rightNodes:\\n                        rootNode = TreeNode(root, leftNode, rightNode)\\n                        ans.append(rootNode)\\n            return ans\\n        \\n        return dfs(1, n)\\n```\\n**Complexity**\\n- Time: `O(C0+C1+...Cn)`, where `Cn` is the [Catalan number](https://en.wikipedia.org/wiki/Catalan_number), `n <= 8`. Can check this problem [96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/) to know why the number of nodes in the BST with `n` nodes is a Catalan number.\\n\\t- The Catalan numbers for `n = 0, 1, 2, 3, 4, 5, 6, 7, 8` are `1, 1, 2, 5, 14, 42, 132, 429, 1430`.\\n- Space: `O(n * Cn)`, there is total `Cn` BSTs, each BST has `n` nodes.\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        @lru_cache(None)\\n        def dfs(left, right):\\n            if left > right: return [None]\\n            if left == right: return [TreeNode(left)]\\n            ans = []\\n            for root in range(left, right+1):\\n                leftNodes = dfs(left, root - 1)\\n                rightNodes = dfs(root+1, right)\\n                for leftNode in leftNodes:\\n                    for rightNode in rightNodes:\\n                        rootNode = TreeNode(root, leftNode, rightNode)\\n                        ans.append(rootNode)\\n            return ans\\n        \\n        return dfs(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31516,
                "title": "share-a-c-dp-solution-with-o-1-space",
                "content": "The basic idea is that we can construct the result of n node tree just from the result of n-1 node tree.\\nHere's how we do it: only 2 conditions: 1)  The nth node is the new root, so `newroot->left = oldroot;`\\n2) the nth node is not root, we traverse the old tree, every time the node in the old tree has a right child, we can perform: `old node->right = nth node, nth node ->left = right child;` and when we reach the end of the tree, don't forget we can also add the nth node here.\\nOne thing to notice is that every time we push a TreeNode in our result, I push the clone version of the root, and I recover what I do to the old node immediately. This is because you may use the old tree for several times.\\n   \\n\\n     class Solution {\\n        public:\\n            TreeNode* clone(TreeNode* root){\\n                if(root == nullptr)\\n                    return nullptr;\\n                TreeNode* newroot = new TreeNode(root->val);\\n                newroot->left = clone(root->left);\\n                newroot->right = clone(root->right);\\n                return newroot;\\n            }\\n            vector<TreeNode *> generateTrees(int n) {\\n                vector<TreeNode *> res(1,nullptr);\\n                for(int i = 1; i <= n; i++){\\n                    vector<TreeNode *> tmp;\\n                    for(int j = 0; j<res.size();j++){\\n                        TreeNode* oldroot = res[j];\\n                        TreeNode* root = new TreeNode(i);\\n                        TreeNode* target = clone(oldroot);\\n                        root->left = target;\\n                        tmp.push_back(root);\\n                       \\n                        if(oldroot!=nullptr){\\n                            TreeNode* tmpold = oldroot;\\n                            while(tmpold->right!=nullptr){\\n                                TreeNode* nonroot = new TreeNode(i);\\n                                TreeNode *tright = tmpold->right;\\n                                tmpold->right = nonroot;\\n                                nonroot->left = tright;\\n                                TreeNode *target = clone(oldroot);\\n                                tmp.push_back(target);\\n                                tmpold->right = tright;\\n                                tmpold = tmpold->right;\\n                            }\\n                            tmpold->right = new TreeNode(i);\\n                            TreeNode *target = clone(oldroot);\\n                            tmp.push_back(target);\\n                            tmpold->right = nullptr;\\n                        }\\n                    }\\n                    res=tmp;\\n                }\\n                return res;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            TreeNode* clone(TreeNode* root){\\n                if(root == nullptr)\\n                    return nullptr;\\n                TreeNode* newroot = new TreeNode(root->val);\\n                newroot->left = clone(root->left);\\n                newroot->right = clone(root->right);\\n                return newroot;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31563,
                "title": "my-accepted-c-solution-recursive-less-than-30-lines",
                "content": "**explaination:**\\nGiven a tree which n nodes, it has the follwing form: \\n(0)root(n-1)\\n(1)root(n-2)\\n(2)root(n-3)\\nwhere (x) denotes the trees with x  nodes.\\n\\nNow take n=3 for example. Given n=3, we have [1 2 3] in which each of them can be used as the tree root.\\n\\nwhen root=1: [1 # 2 # 3]; [1 # 3 2];\\nwhen root=2: [2 1 3]; \\nwhen root=3: (similar with the situations when root=1.)\\n\\nThus, if we write a recursive function who generates a group of trees in which the numbers range from *f* to *t*, we have to generate the left trees and right trees of each tree in the vector. \\n\\nI give the following recursive code and expect to see non-recursive ones. please! \\n\\n**code:**\\n\\n    vector<TreeNode *> generateTree(int from, int to)\\n    {\\n        vector<TreeNode *> ret;\\n        if(to - from < 0) ret.push_back(0);\\n        if(to - from == 0) ret.push_back(new TreeNode(from));\\n        if(to - from > 0)\\n        {\\n            for(int i=from; i<=to; i++)\\n            {\\n                vector<TreeNode *> l = generateTree(from, i-1);\\n                vector<TreeNode *> r = generateTree(i+1, to);\\n\\n                for(int j=0; j<l.size(); j++)\\n                {\\n                    for(int k=0; k<r.size(); k++)\\n                    {\\n                        TreeNode * h = new TreeNode (i);\\n                        h->left = l[j];\\n                        h->right = r[k];\\n                        ret.push_back(h);\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    vector<TreeNode *> generateTrees(int n) {\\n        return generateTree(1, n);\\n    }",
                "solutionTags": [],
                "code": "**explaination:**\\nGiven a tree which n nodes, it has the follwing form: \\n(0)root(n-1)\\n(1)root(n-2)\\n(2)root(n-3)\\nwhere (x) denotes the trees with x  nodes.\\n\\nNow take n=3 for example. Given n=3, we have [1 2 3] in which each of them can be used as the tree root.\\n\\nwhen root=1: [1 # 2 # 3]; [1 # 3 2];\\nwhen root=2: [2 1 3]; \\nwhen root=3: (similar with the situations when root=1.)\\n\\nThus, if we write a recursive function who generates a group of trees in which the numbers range from *f* to *t*, we have to generate the left trees and right trees of each tree in the vector. \\n\\nI give the following recursive code and expect to see non-recursive ones. please! \\n\\n**code:**\\n\\n    vector<TreeNode *> generateTree(int from, int to)\\n    {\\n        vector<TreeNode *> ret;\\n        if(to - from < 0) ret.push_back(0);\\n        if(to - from == 0) ret.push_back(new TreeNode(from));\\n        if(to - from > 0)\\n        {\\n            for(int i=from; i<=to; i++)\\n            {\\n                vector<TreeNode *> l = generateTree(from, i-1);\\n                vector<TreeNode *> r = generateTree(i+1, to);\\n\\n                for(int j=0; j<l.size(); j++)\\n                {\\n                    for(int k=0; k<r.size(); k++)\\n                    {\\n                        TreeNode * h = new TreeNode (i);\\n                        h->left = l[j];\\n                        h->right = r[k];\\n                        ret.push_back(h);\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    vector<TreeNode *> generateTrees(int n) {\\n        return generateTree(1, n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3864900,
                "title": "recursion-dp-video-catalan-number-unique-bst",
                "content": "Given an integer \\\\( n \\\\), the task is to return all the structurally unique BST\\'s (binary search trees) that have exactly \\\\( n \\\\) nodes of unique values from \\\\( 1 \\\\) to \\\\( n \\\\).\\n\\n# Intuition Recursion & Dynamic Programming\\nThe problem can be solved by utilizing the properties of a BST, where the left subtree has all values less than the root and the right subtree has values greater than the root. We can explore both recursive and dynamic programming (DP) approaches to generate all possible combinations of unique BSTs.\\n\\n# Live Coding & Explenation Recursion\\nhttps://youtu.be/HeB6Oufsg_o\\n\\n# n-th Catalan number\\n\\nIn the context of this task, the \\\\(n\\\\)-th Catalan number gives the number of distinct binary search trees that can be formed with \\\\(n\\\\) unique values. The \\\\(n\\\\)-th Catalan number is given by the formula:\\n\\n$$\\nC_n = \\\\frac{1}{n+1} \\\\binom{2n}{n} = \\\\frac{(2n)!}{(n+1)!n!}\\n$$\\n\\nThe time and space complexity of generating these trees are both $$O(C_n)$$, which is equivalent to $$O\\\\left(\\\\frac{4^n}{n\\\\sqrt{n}}\\\\right)$$.\\n\\nHere\\'s how it relates to the task:\\n\\n1. **Choosing the Root**: For each root value, we\\'re essentially dividing the problem into two subproblems (left and right subtrees), and the number of combinations for each division aligns with the recursive definition of the Catalan numbers.\\n   \\n2. **Recursive and Dynamic Programming Solutions**: Both approaches inherently follow the recursive nature of the Catalan numbers. The recursive approach directly corresponds to the recursive formula for the Catalan numbers, while the dynamic programming approach leverages the computed results for smaller subproblems to build up to the solution.\\n\\n3. **Number of Unique BSTs**: The fact that there are \\\\(C_n\\\\) unique BSTs with \\\\(n\\\\) nodes is a direct application of the Catalan numbers. The complexity of generating all these trees is thus closely tied to the value of the \\\\(n\\\\)-th Catalan number.\\n\\nIn conclusion, the complexity of the problem is inherently linked to the Catalan numbers, as they precisely describe the number of unique structures that can be formed, which in turn dictates the computational resources required to enumerate them.\\n\\n# Approach Short\\n\\n1. **Recursion**: Recursively construct left and right subtrees and combine them with each root.\\n2. **Dynamic Programming**: Use dynamic programming to store the result of subproblems (subtrees) and utilize them for constructing unique BSTs.\\n\\n## Approach Differences\\nThe recursive approach constructs the trees from scratch every time, while the DP approach reuses previously computed subtrees to avoid redundant work.\\n\\n# Approach Recursion\\n\\nThe recursive approach involves the following steps:\\n\\n1. **Base Case**: If the start index is greater than the end index, return a list containing `None`. This represents an empty tree and serves as the base case for the recursion.\\n\\n2. **Choose Root**: For every number \\\\( i \\\\) in the range from `start` to `end`, consider \\\\( i \\\\) as the root of the tree.\\n\\n3. **Generate Left Subtrees**: Recursively call the function to generate all possible left subtrees using numbers from `start` to \\\\( i-1 \\\\). This forms the left child of the root.\\n\\n4. **Generate Right Subtrees**: Recursively call the function to generate all possible right subtrees using numbers from \\\\( i+1 \\\\) to `end`. This forms the right child of the root.\\n\\n5. **Combine Subtrees**: For each combination of left and right subtrees, create a new tree with \\\\( i \\\\) as the root and the corresponding left and right subtrees. Append this tree to the list of all possible trees.\\n\\n6. **Return Trees**: Finally, return the list of all trees generated.\\n\\n# Complexity Recursion\\n- Time complexity: $$O(\\\\frac{4^n}{n\\\\sqrt{n}})$$\\n- Space complexity: $$ O(\\\\frac{4^n}{n\\\\sqrt{n}}) $$\\n\\n# Performance Recursion\\n\\n| Language   | Runtime (ms) | Beats (%) | Memory (MB) | Beats (%) |\\n|------------|--------------|-----------|-------------|-----------|\\n| Rust       | 0            | 100       | 2.5         | 80        |\\n| Java       | 1            | 99.88     | 43.7        | 66.87     |\\n| Go         | 3            | 56.88     | 4.4         | 63.30     |\\n| C++        | 16           | 75.53     | 16.2        | 20.99     |\\n| Python3    | 53           | 97.4      | 18.1        | 27.83     |\\n| JavaScript | 74           | 89.61     | 48.4        | 55.19     |\\n| C#         | 91           | 88.76     | 39.8        | 19.10     |\\n\\n![performance_recursion_updated.png](https://assets.leetcode.com/users/images/bede177d-f334-42bd-85ec-517c600b7ef7_1691199606.5911264.png)\\n\\n\\n# Code Recursion\\n``` Python []\\nclass Solution:\\n    def generateTrees(self, n: int):\\n        def generate_trees(start, end):\\n            if start > end:\\n                return [None,]\\n            \\n            all_trees = []\\n            for i in range(start, end + 1):\\n                left_trees = generate_trees(start, i - 1)\\n                right_trees = generate_trees(i + 1, end)\\n                \\n                for l in left_trees:\\n                    for r in right_trees:\\n                        current_tree = TreeNode(i)\\n                        current_tree.left = l\\n                        current_tree.right = r\\n                        all_trees.append(current_tree)\\n            \\n            return all_trees\\n        \\n        return generate_trees(1, n) if n else []\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n ? generate_trees(1, n) : vector<TreeNode*>();\\n    }\\n\\nprivate:\\n    vector<TreeNode*> generate_trees(int start, int end) {\\n        if (start > end) return {nullptr};\\n\\n        vector<TreeNode*> all_trees;\\n        for (int i = start; i <= end; i++) {\\n            vector<TreeNode*> left_trees = generate_trees(start, i - 1);\\n            vector<TreeNode*> right_trees = generate_trees(i + 1, end);\\n\\n            for (TreeNode* l : left_trees) {\\n                for (TreeNode* r : right_trees) {\\n                    TreeNode* current_tree = new TreeNode(i);\\n                    current_tree->left = l;\\n                    current_tree->right = r;\\n                    all_trees.push_back(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return n > 0 ? generate_trees(1, n) : new ArrayList<>();\\n    }\\n\\n    private List<TreeNode> generate_trees(int start, int end) {\\n        List<TreeNode> all_trees = new ArrayList<>();\\n        if (start > end) {\\n            all_trees.add(null);\\n            return all_trees;\\n        }\\n\\n        for (int i = start; i <= end; i++) {\\n            List<TreeNode> left_trees = generate_trees(start, i - 1);\\n            List<TreeNode> right_trees = generate_trees(i + 1, end);\\n\\n            for (TreeNode l : left_trees) {\\n                for (TreeNode r : right_trees) {\\n                    TreeNode current_tree = new TreeNode(i);\\n                    current_tree.left = l;\\n                    current_tree.right = r;\\n                    all_trees.add(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n}\\n```\\n``` JavaScript []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    function generate_trees(start, end) {\\n        if (start > end) return [null];\\n\\n        const all_trees = [];\\n        for (let i = start; i <= end; i++) {\\n            const left_trees = generate_trees(start, i - 1);\\n            const right_trees = generate_trees(i + 1, end);\\n\\n            for (const l of left_trees) {\\n                for (const r of right_trees) {\\n                    const current_tree = new TreeNode(i);\\n                    current_tree.left = l;\\n                    current_tree.right = r;\\n                    all_trees.push(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n\\n    return generate_trees(1, n);\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        return n > 0 ? GenerateTrees(1, n) : new List<TreeNode>();\\n    }\\n\\n    private IList<TreeNode> GenerateTrees(int start, int end) {\\n        if (start > end) return new List<TreeNode> {null};\\n\\n        var all_trees = new List<TreeNode>();\\n        for (int i = start; i <= end; i++) {\\n            var left_trees = GenerateTrees(start, i - 1);\\n            var right_trees = GenerateTrees(i + 1, end);\\n\\n            foreach (var l in left_trees) {\\n                foreach (var r in right_trees) {\\n                    var current_tree = new TreeNode(i, l, r);\\n                    all_trees.Add(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n}\\n```\\n``` Rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if n == 0 {\\n            return Vec::new();\\n        }\\n        Self::generate(1, n)\\n    }\\n\\n    fn generate(start: i32, end: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if start > end {\\n            return vec![None];\\n        }\\n\\n        let mut all_trees = Vec::new();\\n        for i in start..=end {\\n            let left_trees = Self::generate(start, i - 1);\\n            let right_trees = Self::generate(i + 1, end);\\n\\n            for l in &left_trees {\\n                for r in &right_trees {\\n                    let current_tree = Some(Rc::new(RefCell::new(TreeNode::new(i))));\\n                    current_tree.as_ref().unwrap().borrow_mut().left = l.clone();\\n                    current_tree.as_ref().unwrap().borrow_mut().right = r.clone();\\n                    all_trees.push(current_tree);\\n                }\\n            }\\n        }\\n        all_trees\\n    }\\n}\\n```\\n``` Go []\\nfunc generateTrees(n int) []*TreeNode {\\n\\tif n == 0 {\\n\\t\\treturn []*TreeNode{}\\n\\t}\\n\\treturn generate(1, n)\\n}\\n\\nfunc generate(start, end int) []*TreeNode {\\n\\tif start > end {\\n\\t\\treturn []*TreeNode{nil}\\n\\t}\\n\\n\\tvar allTrees []*TreeNode\\n\\tfor i := start; i <= end; i++ {\\n\\t\\tleftTrees := generate(start, i-1)\\n\\t\\trightTrees := generate(i+1, end)\\n\\n\\t\\tfor _, l := range leftTrees {\\n\\t\\t\\tfor _, r := range rightTrees {\\n\\t\\t\\t\\tcurrentTree := &TreeNode{Val: i, Left: l, Right: r}\\n\\t\\t\\t\\tallTrees = append(allTrees, currentTree)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn allTrees\\n}\\n```\\n\\n# Approach Dynamic Programming\\n\\n1. **Initialization**: Create a DP table `dp` where `dp[i]` will store all the unique BSTs with `i` nodes. Initialize `dp[0]` with a single `None` value representing an empty tree.\\n\\n2. **Iterate Over Number of Nodes**: For every number `nodes` from 1 to `n`, iterate and construct all possible trees with `nodes` number of nodes.\\n\\n3. **Choose Root**: For every possible root value within the current `nodes`, iterate and use the root to build trees.\\n\\n4. **Use Previously Computed Subtrees**: For the chosen root, use the previously computed `dp[root - 1]` for left subtrees and `dp[nodes - root]` for right subtrees.\\n\\n5. **Clone Right Subtree**: Since the right subtree\\'s values will be affected by the choice of the root, clone the right subtree with an offset equal to the root value. The `clone` function handles this.\\n\\n6. **Combine Subtrees**: Create a new tree by combining the current root with the left and right subtrees. Append this tree to `dp[nodes]`.\\n\\n7. **Return Result**: Finally, return the trees stored in `dp[n]`.\\n\\n# Complexity Dynamic Programming\\n- Time complexity: $$O(\\\\frac{4^n}{n\\\\sqrt{n}})$$\\n- Space complexity: $$ O(\\\\frac{4^n}{n\\\\sqrt{n}}) $$\\n\\n# Performance Dynamic Programming\\n\\n| Language   | Runtime (ms) | Beats (%) | Memory (MB) | Beats (%) |\\n|------------|--------------|-----------|-------------|-----------|\\n| Rust       | 0            | 100       | 2.7         | 20        |\\n| Java       | 1            | 99.88     | 44.1        | 8.87      |\\n| Go         | 3            | 56.88     | 4.2         | 90.83     |\\n| C++        | 10           | 96.72     | 12.5        | 86.56     |\\n| JavaScript | 67           | 96.75     | 48.5        | 55.19     |\\n| Python3    | 49           | 98.84     | 18.1        | 21.91     |\\n| C#         | 91           | 88.76     | 38.5        | 80.90     |\\n\\n![performance_dynamic_programming.png](https://assets.leetcode.com/users/images/172a4ebb-facf-4b20-8c7b-1c59a891ea05_1691199566.481603.png)\\n\\n\\n# Code Dynamic Programming\\n``` Python []\\nclass Solution:\\n    def generateTrees(self, n: int):\\n        if n == 0:\\n            return []\\n\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0].append(None)\\n        for nodes in range(1, n + 1):\\n            for root in range(1, nodes + 1):\\n                for left_tree in dp[root - 1]:\\n                    for right_tree in dp[nodes - root]:\\n                        root_node = TreeNode(root)\\n                        root_node.left = left_tree\\n                        root_node.right = self.clone(right_tree, root)\\n                        dp[nodes].append(root_node)\\n        return dp[n]\\n    \\n    def clone(self, n: TreeNode, offset: int) -> TreeNode:\\n        if n:\\n            node = TreeNode(n.val + offset)\\n            node.left = self.clone(n.left, offset)\\n            node.right = self.clone(n.right, offset)\\n            return node\\n        return None\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n == 0) return {};\\n\\n        vector<vector<TreeNode*>> dp(n + 1);\\n        dp[0].push_back(nullptr);\\n        for (int nodes = 1; nodes <= n; nodes++) {\\n            for (int root = 1; root <= nodes; root++) {\\n                for (TreeNode* left_tree : dp[root - 1]) {\\n                    for (TreeNode* right_tree : dp[nodes - root]) {\\n                        TreeNode* root_node = new TreeNode(root);\\n                        root_node->left = left_tree;\\n                        root_node->right = clone(right_tree, root);\\n                        dp[nodes].push_back(root_node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\nprivate:\\n    TreeNode* clone(TreeNode* n, int offset) {\\n        if (n == nullptr) return nullptr;\\n        TreeNode* node = new TreeNode(n->val + offset);\\n        node->left = clone(n->left, offset);\\n        node->right = clone(n->right, offset);\\n        return node;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) return new ArrayList<>();\\n\\n        List<TreeNode>[] dp = new ArrayList[n + 1];\\n        dp[0] = new ArrayList<>();\\n        dp[0].add(null);\\n        for (int nodes = 1; nodes <= n; nodes++) {\\n            dp[nodes] = new ArrayList<>();\\n            for (int root = 1; root <= nodes; root++) {\\n                for (TreeNode left_tree : dp[root - 1]) {\\n                    for (TreeNode right_tree : dp[nodes - root]) {\\n                        TreeNode root_node = new TreeNode(root);\\n                        root_node.left = left_tree;\\n                        root_node.right = clone(right_tree, root);\\n                        dp[nodes].add(root_node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    private TreeNode clone(TreeNode n, int offset) {\\n        if (n == null) return null;\\n        TreeNode node = new TreeNode(n.val + offset);\\n        node.left = clone(n.left, offset);\\n        node.right = clone(n.right, offset);\\n        return node;\\n    }\\n}\\n```\\n``` JavaScript []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    const dp = Array.from({ length: n + 1 }, () => []);\\n    dp[0].push(null);\\n    for (let nodes = 1; nodes <= n; nodes++) {\\n        for (let root = 1; root <= nodes; root++) {\\n            for (const left_tree of dp[root - 1]) {\\n                for (const right_tree of dp[nodes - root]) {\\n                    const root_node = new TreeNode(root);\\n                    root_node.left = left_tree;\\n                    root_node.right = clone(right_tree, root);\\n                    dp[nodes].push(root_node);\\n                }\\n            }\\n        }\\n    }\\n    return dp[n];\\n};\\n\\nfunction clone(n, offset) {\\n    if (n === null) return null;\\n    const node = new TreeNode(n.val + offset);\\n    node.left = clone(n.left, offset);\\n    node.right = clone(n.right, offset);\\n    return node;\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        if (n == 0) return new List<TreeNode>();\\n\\n        var dp = new List<TreeNode>[n + 1];\\n        dp[0] = new List<TreeNode> { null };\\n        for (int nodes = 1; nodes <= n; nodes++) {\\n            dp[nodes] = new List<TreeNode>();\\n            for (int root = 1; root <= nodes; root++) {\\n                foreach (var left_tree in dp[root - 1]) {\\n                    foreach (var right_tree in dp[nodes - root]) {\\n                        TreeNode root_node = new TreeNode(root);\\n                        root_node.left = left_tree;\\n                        root_node.right = Clone(right_tree, root);\\n                        dp[nodes].Add(root_node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    private TreeNode Clone(TreeNode n, int offset) {\\n        if (n == null) return null;\\n        TreeNode node = new TreeNode(n.val + offset);\\n        node.left = Clone(n.left, offset);\\n        node.right = Clone(n.right, offset);\\n        return node;\\n    }\\n}\\n```\\n``` Rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if n == 0 {\\n            return Vec::new();\\n        }\\n\\n        let mut dp = vec![Vec::new(); (n + 1) as usize];\\n        dp[0].push(None);\\n        for nodes in 1..=n {\\n            let mut trees_per_node = Vec::new();\\n            for root in 1..=nodes {\\n                let left_trees = &dp[(root - 1) as usize];\\n                let right_trees = &dp[(nodes - root) as usize];\\n                for left_tree in left_trees {\\n                    for right_tree in right_trees {\\n                        let root_node = Some(Rc::new(RefCell::new(TreeNode::new(root))));\\n                        root_node.as_ref().unwrap().borrow_mut().left = left_tree.clone();\\n                        root_node.as_ref().unwrap().borrow_mut().right = Solution::clone(right_tree.clone(), root);\\n                        trees_per_node.push(root_node);\\n                    }\\n                }\\n            }\\n            dp[nodes as usize] = trees_per_node;\\n        }\\n        dp[n as usize].clone()\\n    }\\n\\n    fn clone(tree: Option<Rc<RefCell<TreeNode>>>, offset: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        tree.map(|node| {\\n            Rc::new(RefCell::new(TreeNode {\\n                val: node.borrow().val + offset,\\n                left: Solution::clone(node.borrow().left.clone(), offset),\\n                right: Solution::clone(node.borrow().right.clone(), offset),\\n            }))\\n        })\\n    }\\n}\\n```\\n``` Go []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    const dp = Array.from({ length: n + 1 }, () => []);\\n    dp[0].push(null);\\n    for (let nodes = 1; nodes <= n; nodes++) {\\n        for (let root = 1; root <= nodes; root++) {\\n            for (const left_tree of dp[root - 1]) {\\n                for (const right_tree of dp[nodes - root]) {\\n                    const root_node = new TreeNode(root);\\n                    root_node.left = left_tree;\\n                    root_node.right = clone(right_tree, root);\\n                    dp[nodes].push(root_node);\\n                }\\n            }\\n        }\\n    }\\n    return dp[n];\\n};\\n\\nfunction clone(n, offset) {\\n    if (n === null) return null;\\n    const node = new TreeNode(n.val + offset);\\n    node.left = clone(n.left, offset);\\n    node.right = clone(n.right, offset);\\n    return node;\\n}\\n```\\n\\nThe time and space complexity for both approaches are the same. The $$ O(\\\\frac{4^n}{n\\\\sqrt{n}}) $$ complexity arises from the Catalan number, which gives the number of BSTs for a given \\\\( n \\\\).\\n\\nI hope you find this solution helpful in understanding how to generate all structurally unique Binary Search Trees (BSTs) for a given number n. If you have any further questions or need additional clarifications, please don\\'t hesitate to ask. If you understood the solution and found it beneficial, please consider giving it an upvote. Happy coding, and may your coding journey be filled with success and satisfaction! \\uD83D\\uDE80\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def generateTrees(self, n: int):\\n        def generate_trees(start, end):\\n            if start > end:\\n                return [None,]\\n            \\n            all_trees = []\\n            for i in range(start, end + 1):\\n                left_trees = generate_trees(start, i - 1)\\n                right_trees = generate_trees(i + 1, end)\\n                \\n                for l in left_trees:\\n                    for r in right_trees:\\n                        current_tree = TreeNode(i)\\n                        current_tree.left = l\\n                        current_tree.right = r\\n                        all_trees.append(current_tree)\\n            \\n            return all_trees\\n        \\n        return generate_trees(1, n) if n else []\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n ? generate_trees(1, n) : vector<TreeNode*>();\\n    }\\n\\nprivate:\\n    vector<TreeNode*> generate_trees(int start, int end) {\\n        if (start > end) return {nullptr};\\n\\n        vector<TreeNode*> all_trees;\\n        for (int i = start; i <= end; i++) {\\n            vector<TreeNode*> left_trees = generate_trees(start, i - 1);\\n            vector<TreeNode*> right_trees = generate_trees(i + 1, end);\\n\\n            for (TreeNode* l : left_trees) {\\n                for (TreeNode* r : right_trees) {\\n                    TreeNode* current_tree = new TreeNode(i);\\n                    current_tree->left = l;\\n                    current_tree->right = r;\\n                    all_trees.push_back(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return n > 0 ? generate_trees(1, n) : new ArrayList<>();\\n    }\\n\\n    private List<TreeNode> generate_trees(int start, int end) {\\n        List<TreeNode> all_trees = new ArrayList<>();\\n        if (start > end) {\\n            all_trees.add(null);\\n            return all_trees;\\n        }\\n\\n        for (int i = start; i <= end; i++) {\\n            List<TreeNode> left_trees = generate_trees(start, i - 1);\\n            List<TreeNode> right_trees = generate_trees(i + 1, end);\\n\\n            for (TreeNode l : left_trees) {\\n                for (TreeNode r : right_trees) {\\n                    TreeNode current_tree = new TreeNode(i);\\n                    current_tree.left = l;\\n                    current_tree.right = r;\\n                    all_trees.add(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n}\\n```\n``` JavaScript []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    function generate_trees(start, end) {\\n        if (start > end) return [null];\\n\\n        const all_trees = [];\\n        for (let i = start; i <= end; i++) {\\n            const left_trees = generate_trees(start, i - 1);\\n            const right_trees = generate_trees(i + 1, end);\\n\\n            for (const l of left_trees) {\\n                for (const r of right_trees) {\\n                    const current_tree = new TreeNode(i);\\n                    current_tree.left = l;\\n                    current_tree.right = r;\\n                    all_trees.push(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n\\n    return generate_trees(1, n);\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        return n > 0 ? GenerateTrees(1, n) : new List<TreeNode>();\\n    }\\n\\n    private IList<TreeNode> GenerateTrees(int start, int end) {\\n        if (start > end) return new List<TreeNode> {null};\\n\\n        var all_trees = new List<TreeNode>();\\n        for (int i = start; i <= end; i++) {\\n            var left_trees = GenerateTrees(start, i - 1);\\n            var right_trees = GenerateTrees(i + 1, end);\\n\\n            foreach (var l in left_trees) {\\n                foreach (var r in right_trees) {\\n                    var current_tree = new TreeNode(i, l, r);\\n                    all_trees.Add(current_tree);\\n                }\\n            }\\n        }\\n        return all_trees;\\n    }\\n}\\n```\n``` Rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if n == 0 {\\n            return Vec::new();\\n        }\\n        Self::generate(1, n)\\n    }\\n\\n    fn generate(start: i32, end: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if start > end {\\n            return vec![None];\\n        }\\n\\n        let mut all_trees = Vec::new();\\n        for i in start..=end {\\n            let left_trees = Self::generate(start, i - 1);\\n            let right_trees = Self::generate(i + 1, end);\\n\\n            for l in &left_trees {\\n                for r in &right_trees {\\n                    let current_tree = Some(Rc::new(RefCell::new(TreeNode::new(i))));\\n                    current_tree.as_ref().unwrap().borrow_mut().left = l.clone();\\n                    current_tree.as_ref().unwrap().borrow_mut().right = r.clone();\\n                    all_trees.push(current_tree);\\n                }\\n            }\\n        }\\n        all_trees\\n    }\\n}\\n```\n``` Go []\\nfunc generateTrees(n int) []*TreeNode {\\n\\tif n == 0 {\\n\\t\\treturn []*TreeNode{}\\n\\t}\\n\\treturn generate(1, n)\\n}\\n\\nfunc generate(start, end int) []*TreeNode {\\n\\tif start > end {\\n\\t\\treturn []*TreeNode{nil}\\n\\t}\\n\\n\\tvar allTrees []*TreeNode\\n\\tfor i := start; i <= end; i++ {\\n\\t\\tleftTrees := generate(start, i-1)\\n\\t\\trightTrees := generate(i+1, end)\\n\\n\\t\\tfor _, l := range leftTrees {\\n\\t\\t\\tfor _, r := range rightTrees {\\n\\t\\t\\t\\tcurrentTree := &TreeNode{Val: i, Left: l, Right: r}\\n\\t\\t\\t\\tallTrees = append(allTrees, currentTree)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn allTrees\\n}\\n```\n``` Python []\\nclass Solution:\\n    def generateTrees(self, n: int):\\n        if n == 0:\\n            return []\\n\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0].append(None)\\n        for nodes in range(1, n + 1):\\n            for root in range(1, nodes + 1):\\n                for left_tree in dp[root - 1]:\\n                    for right_tree in dp[nodes - root]:\\n                        root_node = TreeNode(root)\\n                        root_node.left = left_tree\\n                        root_node.right = self.clone(right_tree, root)\\n                        dp[nodes].append(root_node)\\n        return dp[n]\\n    \\n    def clone(self, n: TreeNode, offset: int) -> TreeNode:\\n        if n:\\n            node = TreeNode(n.val + offset)\\n            node.left = self.clone(n.left, offset)\\n            node.right = self.clone(n.right, offset)\\n            return node\\n        return None\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n == 0) return {};\\n\\n        vector<vector<TreeNode*>> dp(n + 1);\\n        dp[0].push_back(nullptr);\\n        for (int nodes = 1; nodes <= n; nodes++) {\\n            for (int root = 1; root <= nodes; root++) {\\n                for (TreeNode* left_tree : dp[root - 1]) {\\n                    for (TreeNode* right_tree : dp[nodes - root]) {\\n                        TreeNode* root_node = new TreeNode(root);\\n                        root_node->left = left_tree;\\n                        root_node->right = clone(right_tree, root);\\n                        dp[nodes].push_back(root_node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\nprivate:\\n    TreeNode* clone(TreeNode* n, int offset) {\\n        if (n == nullptr) return nullptr;\\n        TreeNode* node = new TreeNode(n->val + offset);\\n        node->left = clone(n->left, offset);\\n        node->right = clone(n->right, offset);\\n        return node;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) return new ArrayList<>();\\n\\n        List<TreeNode>[] dp = new ArrayList[n + 1];\\n        dp[0] = new ArrayList<>();\\n        dp[0].add(null);\\n        for (int nodes = 1; nodes <= n; nodes++) {\\n            dp[nodes] = new ArrayList<>();\\n            for (int root = 1; root <= nodes; root++) {\\n                for (TreeNode left_tree : dp[root - 1]) {\\n                    for (TreeNode right_tree : dp[nodes - root]) {\\n                        TreeNode root_node = new TreeNode(root);\\n                        root_node.left = left_tree;\\n                        root_node.right = clone(right_tree, root);\\n                        dp[nodes].add(root_node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    private TreeNode clone(TreeNode n, int offset) {\\n        if (n == null) return null;\\n        TreeNode node = new TreeNode(n.val + offset);\\n        node.left = clone(n.left, offset);\\n        node.right = clone(n.right, offset);\\n        return node;\\n    }\\n}\\n```\n``` JavaScript []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    const dp = Array.from({ length: n + 1 }, () => []);\\n    dp[0].push(null);\\n    for (let nodes = 1; nodes <= n; nodes++) {\\n        for (let root = 1; root <= nodes; root++) {\\n            for (const left_tree of dp[root - 1]) {\\n                for (const right_tree of dp[nodes - root]) {\\n                    const root_node = new TreeNode(root);\\n                    root_node.left = left_tree;\\n                    root_node.right = clone(right_tree, root);\\n                    dp[nodes].push(root_node);\\n                }\\n            }\\n        }\\n    }\\n    return dp[n];\\n};\\n\\nfunction clone(n, offset) {\\n    if (n === null) return null;\\n    const node = new TreeNode(n.val + offset);\\n    node.left = clone(n.left, offset);\\n    node.right = clone(n.right, offset);\\n    return node;\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        if (n == 0) return new List<TreeNode>();\\n\\n        var dp = new List<TreeNode>[n + 1];\\n        dp[0] = new List<TreeNode> { null };\\n        for (int nodes = 1; nodes <= n; nodes++) {\\n            dp[nodes] = new List<TreeNode>();\\n            for (int root = 1; root <= nodes; root++) {\\n                foreach (var left_tree in dp[root - 1]) {\\n                    foreach (var right_tree in dp[nodes - root]) {\\n                        TreeNode root_node = new TreeNode(root);\\n                        root_node.left = left_tree;\\n                        root_node.right = Clone(right_tree, root);\\n                        dp[nodes].Add(root_node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    private TreeNode Clone(TreeNode n, int offset) {\\n        if (n == null) return null;\\n        TreeNode node = new TreeNode(n.val + offset);\\n        node.left = Clone(n.left, offset);\\n        node.right = Clone(n.right, offset);\\n        return node;\\n    }\\n}\\n```\n``` Rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if n == 0 {\\n            return Vec::new();\\n        }\\n\\n        let mut dp = vec![Vec::new(); (n + 1) as usize];\\n        dp[0].push(None);\\n        for nodes in 1..=n {\\n            let mut trees_per_node = Vec::new();\\n            for root in 1..=nodes {\\n                let left_trees = &dp[(root - 1) as usize];\\n                let right_trees = &dp[(nodes - root) as usize];\\n                for left_tree in left_trees {\\n                    for right_tree in right_trees {\\n                        let root_node = Some(Rc::new(RefCell::new(TreeNode::new(root))));\\n                        root_node.as_ref().unwrap().borrow_mut().left = left_tree.clone();\\n                        root_node.as_ref().unwrap().borrow_mut().right = Solution::clone(right_tree.clone(), root);\\n                        trees_per_node.push(root_node);\\n                    }\\n                }\\n            }\\n            dp[nodes as usize] = trees_per_node;\\n        }\\n        dp[n as usize].clone()\\n    }\\n\\n    fn clone(tree: Option<Rc<RefCell<TreeNode>>>, offset: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        tree.map(|node| {\\n            Rc::new(RefCell::new(TreeNode {\\n                val: node.borrow().val + offset,\\n                left: Solution::clone(node.borrow().left.clone(), offset),\\n                right: Solution::clone(node.borrow().right.clone(), offset),\\n            }))\\n        })\\n    }\\n}\\n```\n``` Go []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    const dp = Array.from({ length: n + 1 }, () => []);\\n    dp[0].push(null);\\n    for (let nodes = 1; nodes <= n; nodes++) {\\n        for (let root = 1; root <= nodes; root++) {\\n            for (const left_tree of dp[root - 1]) {\\n                for (const right_tree of dp[nodes - root]) {\\n                    const root_node = new TreeNode(root);\\n                    root_node.left = left_tree;\\n                    root_node.right = clone(right_tree, root);\\n                    dp[nodes].push(root_node);\\n                }\\n            }\\n        }\\n    }\\n    return dp[n];\\n};\\n\\nfunction clone(n, offset) {\\n    if (n === null) return null;\\n    const node = new TreeNode(n.val + offset);\\n    node.left = clone(n.left, offset);\\n    node.right = clone(n.right, offset);\\n    return node;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31592,
                "title": "recursive-python-solution",
                "content": "    class Solution(object):\\n        def generateTrees(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: List[TreeNode]\\n            \"\"\"\\n            if n == 0:\\n                return [[]]\\n            return self.dfs(1, n+1)\\n            \\n        def dfs(self, start, end):\\n            if start == end:\\n                return None\\n            result = []\\n            for i in xrange(start, end):\\n                for l in self.dfs(start, i) or [None]:\\n                    for r in self.dfs(i+1, end) or [None]:\\n                        node = TreeNode(i)\\n                        node.left, node.right  = l, r\\n                        result.append(node)\\n            return result\\n\\nUse start/end instead of actual nodes to bosst the program.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def generateTrees(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: List[TreeNode]\\n            \"\"\"\\n            if n == 0:\\n                return [[]]\\n            return self.dfs(1, n+1)\\n            \\n        def dfs(self, start, end):\\n            if start == end:\\n                return None\\n            result = []\\n            for i in xrange(start, end):\\n                for l in self.dfs(start, i) or [None]:\\n                    for r in self.dfs(i+1, end) or [None]:\\n                        node = TreeNode(i)\\n                        node.left, node.right  = l, r\\n                        result.append(node)\\n            return result\\n\\nUse start/end instead of actual nodes to bosst the program.",
                "codeTag": "Java"
            },
            {
                "id": 1440883,
                "title": "small-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\\n        vector<TreeNode*> ans;\\n        if(n < s)\\n            return {nullptr};\\n\\t\\t\\t\\n\\t\\t// Consider every number in range [s,n] as root \\n        for(int i=s; i<=n; i++) {\\n\\t\\t\\n\\t\\t\\t// generate all possible trees in range [s,i)\\n            for(auto left: generateTrees(i-1, s)) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// generate all possible trees in range (i,e]\\n                for(auto right: generateTrees(n, i+1))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// make new trees with i as the root\\n                    ans.push_back(new TreeNode(i, left, right));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\\n        vector<TreeNode*> ans;\\n        if(n < s)\\n            return {nullptr};\\n\\t\\t\\t\\n\\t\\t// Consider every number in range [s,n] as root \\n        for(int i=s; i<=n; i++) {\\n\\t\\t\\n\\t\\t\\t// generate all possible trees in range [s,i)\\n            for(auto left: generateTrees(i-1, s)) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// generate all possible trees in range (i,e]\\n                for(auto right: generateTrees(n, i+1))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// make new trees with i as the root\\n                    ans.push_back(new TreeNode(i, left, right));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31552,
                "title": "java-dp-solution-and-brute-force-recursive-solution",
                "content": "The first method that came to mind was the brute force solution as below. \\n\\n     public List<TreeNode> generateTrees(int n) {\\n         return generateTrees(1,n);\\n     }\\n    \\n    public List<TreeNode> generateTrees(int start,int end){             \\n        List<TreeNode> trees = new ArrayList<TreeNode>();\\n        if(start>end){  trees.add(null); return trees;}\\n    \\n        for(int rootValue=start;rootValue<=end;rootValue++){\\n            List<TreeNode> leftSubTrees=generateTrees(start,rootValue-1);\\n            List<TreeNode> rightSubTrees=generateTrees(rootValue+1,end);\\n    \\n            for(TreeNode leftSubTree:leftSubTrees){\\n                for(TreeNode rightSubTree:rightSubTrees){\\n                    TreeNode root=new TreeNode(rootValue);\\n                    root.left=leftSubTree;\\n                    root.right=rightSubTree;\\n                    trees.add(root);\\n                }\\n            }\\n        }\\n        return trees;\\n    }\\n\\n\\n\\nThen @6219221 reminded me it is unnecessary to create the BSTs with all brand new nodes. \\nAssume you have a list of all BSTs with values from 1 to n-1, every possible way to insert value n only involves changing the right tree (root inclusive) because n is always greater than root.val and the left subtree structure is fixed. So all we gotta do is to create a new copy of the right part of the tree and point the new root.left to the original left subtree. This way we reuse the left tree, which saves time and space.\\n\\nHow to insert Node n into the right subtree?\\nGiven any BST on the n - 1 level, it will be only valid to put n on the root.right, root.right.right or root.right.....right locations and then move the right subtree of n.right...right to become the left child of n, in order to keep n on the right-most position as the greatest value in the tree.\\n\\nHere is my implementation. Note that I do the dp from [n] back to [n to 1]. Therefore all the right subtree structures are fixed and new values are inserted into the left side, opposite to making BSTs from 1 to [1 to n].\\n\\n        public List<TreeNode> generateTrees(int n) {\\n            List<TreeNode> res = new ArrayList<>();\\n            res.add(null);\\n            for(; n > 0; n--) {\\n                List<TreeNode> next = new ArrayList<>();\\n                for(TreeNode node: res) {\\n                    //the special case when Node(n) is root of new tree\\n                    TreeNode root = new TreeNode(n); \\n                    root.right = node;\\n                    next.add(root);\\n                   //while loop inserts new value to every possible position into the left tree side\\n                    while(node != null) {\\n                        TreeNode cRoot = new TreeNode(root.right.val);\\n                        //clone left subtree\\n                        cRoot.left = copyTree(root.right.left);\\n                        //reusing - point new root.right to the original right subtree\\n                        cRoot.right = root.right.right;\\n                        //curr is the cutoff node whose right child will be replaced by the new n \\n                        TreeNode curr = getValNode(cRoot, node.val); \\n                        //place n as curr's right child, make curr's original right child as the left child of n.\\n                        TreeNode tmp = curr.left;\\n                        curr.left = new TreeNode(n);\\n                        curr.left.right = tmp;\\n\\n                        next.add(cRoot);\\n                        node = node.left;\\n                    }\\n                }\\n                res = next;\\n            }\\n            return res;\\n        }\\n        private TreeNode getValNode(TreeNode n, int val) { //find the cutoff node in the new tree\\n            while(n != null) {\\n                if(n.val == val) break;\\n                n = n.left;\\n            }\\n            return n;\\n        }\\n\\n        private TreeNode copyTree(TreeNode root) { //clone the right subtree\\n            if(root == null) return null;\\n            TreeNode cRoot = new TreeNode(root.val);\\n            cRoot.left = copyTree(root.left);\\n            cRoot.right = copyTree(root.right);\\n            return cRoot;\\n        }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "The first method that came to mind was the brute force solution as below. \\n\\n     public List<TreeNode> generateTrees(int n) {\\n         return generateTrees(1,n);\\n     }\\n    \\n    public List<TreeNode> generateTrees(int start,int end){             \\n        List<TreeNode> trees = new ArrayList<TreeNode>();\\n        if(start>end){  trees.add(null); return trees;}\\n    \\n        for(int rootValue=start;rootValue<=end;rootValue++){\\n            List<TreeNode> leftSubTrees=generateTrees(start,rootValue-1);\\n            List<TreeNode> rightSubTrees=generateTrees(rootValue+1,end);\\n    \\n            for(TreeNode leftSubTree:leftSubTrees){\\n                for(TreeNode rightSubTree:rightSubTrees){\\n                    TreeNode root=new TreeNode(rootValue);\\n                    root.left=leftSubTree;\\n                    root.right=rightSubTree;\\n                    trees.add(root);\\n                }\\n            }\\n        }\\n        return trees;\\n    }\\n\\n\\n\\nThen @6219221 reminded me it is unnecessary to create the BSTs with all brand new nodes. \\nAssume you have a list of all BSTs with values from 1 to n-1, every possible way to insert value n only involves changing the right tree (root inclusive) because n is always greater than root.val and the left subtree structure is fixed. So all we gotta do is to create a new copy of the right part of the tree and point the new root.left to the original left subtree. This way we reuse the left tree, which saves time and space.\\n\\nHow to insert Node n into the right subtree?\\nGiven any BST on the n - 1 level, it will be only valid to put n on the root.right, root.right.right or root.right.....right locations and then move the right subtree of n.right...right to become the left child of n, in order to keep n on the right-most position as the greatest value in the tree.\\n\\nHere is my implementation. Note that I do the dp from [n] back to [n to 1]. Therefore all the right subtree structures are fixed and new values are inserted into the left side, opposite to making BSTs from 1 to [1 to n].\\n\\n        public List<TreeNode> generateTrees(int n) {\\n            List<TreeNode> res = new ArrayList<>();\\n            res.add(null);\\n            for(; n > 0; n--) {\\n                List<TreeNode> next = new ArrayList<>();\\n                for(TreeNode node: res) {\\n                    //the special case when Node(n) is root of new tree\\n                    TreeNode root = new TreeNode(n); \\n                    root.right = node;\\n                    next.add(root);\\n                   //while loop inserts new value to every possible position into the left tree side\\n                    while(node != null) {\\n                        TreeNode cRoot = new TreeNode(root.right.val);\\n                        //clone left subtree\\n                        cRoot.left = copyTree(root.right.left);\\n                        //reusing - point new root.right to the original right subtree\\n                        cRoot.right = root.right.right;\\n                        //curr is the cutoff node whose right child will be replaced by the new n \\n                        TreeNode curr = getValNode(cRoot, node.val); \\n                        //place n as curr's right child, make curr's original right child as the left child of n.\\n                        TreeNode tmp = curr.left;\\n                        curr.left = new TreeNode(n);\\n                        curr.left.right = tmp;\\n\\n                        next.add(cRoot);\\n                        node = node.left;\\n                    }\\n                }\\n                res = next;\\n            }\\n            return res;\\n        }\\n        private TreeNode getValNode(TreeNode n, int val) { //find the cutoff node in the new tree\\n            while(n != null) {\\n                if(n.val == val) break;\\n                n = n.left;\\n            }\\n            return n;\\n        }\\n\\n        private TreeNode copyTree(TreeNode root) { //clone the right subtree\\n            if(root == null) return null;\\n            TreeNode cRoot = new TreeNode(root.val);\\n            cRoot.left = copyTree(root.left);\\n            cRoot.right = copyTree(root.right);\\n            return cRoot;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 703236,
                "title": "c-simple-and-short",
                "content": "***Plz upvote if you like it***\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> helper(int start,int end) {\\n        vector<TreeNode*> v;\\n        if(start > end) {\\n            v.push_back(NULL);\\n            return v;\\n        }\\n        for(int i = start; i <= end; i++){\\n            auto left = helper(start,i-1);\\n            auto right = helper(i+1,end);\\n            for(auto l : left) {\\n                for(auto r : right){\\n                    TreeNode* newNode = new TreeNode(i, l, r);\\n                    v.push_back(newNode);\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0) \\n            return vector<TreeNode*>();\\n        auto ans = helper(1,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> helper(int start,int end) {\\n        vector<TreeNode*> v;\\n        if(start > end) {\\n            v.push_back(NULL);\\n            return v;\\n        }\\n        for(int i = start; i <= end; i++){\\n            auto left = helper(start,i-1);\\n            auto right = helper(i+1,end);\\n            for(auto l : left) {\\n                for(auto r : right){\\n                    TreeNode* newNode = new TreeNode(i, l, r);\\n                    v.push_back(newNode);\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0) \\n            return vector<TreeNode*>();\\n        auto ans = helper(1,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023791,
                "title": "java-recursion-along-with-recursion-tree-figure-explanation",
                "content": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) {\\n            return new ArrayList<>();\\n        }\\n        return helper(1, n);\\n    }\\n    \\n    private List<TreeNode> helper(int lo, int hi) {\\n        List<TreeNode> result = new ArrayList<>();\\n        //base case\\n        if (lo > hi) {\\n            result.add(null);\\n            return result;\\n        }\\n        \\n        //subproblem to reach boootm\\n        for (int i = lo; i <= hi; i++) {\\n            List<TreeNode> left = helper(lo, i - 1);\\n            List<TreeNode> right = helper(i + 1, hi);\\n            //reconstruct tree from bottom to up\\n            for (TreeNode l : left) {\\n                for (TreeNode r : right) {\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = l;\\n                    root.right = r;\\n                    result.add(root);\\n                }\\n            }\\n        }\\n        //return list of root to last layer\\n        return result;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/12370c10-2924-4705-9b20-4c93fe83945d_1611015319.6731772.png)\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) {\\n            return new ArrayList<>();\\n        }\\n        return helper(1, n);\\n    }\\n    \\n    private List<TreeNode> helper(int lo, int hi) {\\n        List<TreeNode> result = new ArrayList<>();\\n        //base case\\n        if (lo > hi) {\\n            result.add(null);\\n            return result;\\n        }\\n        \\n        //subproblem to reach boootm\\n        for (int i = lo; i <= hi; i++) {\\n            List<TreeNode> left = helper(lo, i - 1);\\n            List<TreeNode> right = helper(i + 1, hi);\\n            //reconstruct tree from bottom to up\\n            for (TreeNode l : left) {\\n                for (TreeNode r : right) {\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = l;\\n                    root.right = r;\\n                    result.add(root);\\n                }\\n            }\\n        }\\n        //return list of root to last layer\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31575,
                "title": "24ms-c-easy-understanding-solution",
                "content": "    class Solution {\\n    private:\\n        vector<TreeNode*> helper(int start, int end){\\n            vector<TreeNode*> res;\\n            if(start > end) {\\n                res.push_back(NULL);\\n                return res;\\n            }\\n            for(int i = start; i <= end; i++){\\n                vector<TreeNode*> lefts = helper(start, i - 1);\\n                vector<TreeNode*> rights = helper(i + 1, end);\\n                for(int j = 0; j < (int)lefts.size(); j++){\\n                    for(int k = 0; k < (int)rights.size(); k++){\\n                        TreeNode* root = new TreeNode(i);\\n                        root->left = lefts[j];\\n                        root->right = rights[k];\\n                        res.push_back(root);\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    public:\\n        vector<TreeNode*> generateTrees(int n) {\\n            if(n == 0) return vector<TreeNode*>(0);\\n            return helper(1,n);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    private:\\n        vector<TreeNode*> helper(int start, int end){\\n            vector<TreeNode*> res;\\n            if(start > end) {\\n                res.push_back(NULL);\\n                return res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1440190,
                "title": "c-python-simple-and-short-recursive-solutions-with-explanation",
                "content": "**Idea:**\\nWe will use a recursive helper function that recieves a range (within n) and returns all subtrees in that range.\\nWe have a few cases:\\n1. if `start > end`, which is not supposed to happen, we return a list that contains only a null.\\n2. if `start == end` it means we reached a leaf and we will return a list containing a tree that has only that node.\\n3. Otherwise:\\nfor each option of root, we get all possible subtrees with that root for `left` and `right` children.\\nThen for each possible pair of `left` and `right` we add to the result a new tree.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> rec(int start, int end) {\\n        vector<TreeNode*> res;\\n        if (start > end) return {NULL};\\n        \\n        if (start == end) return {new TreeNode(start)};\\n        \\n        for (int i = start; i <= end; i++) {\\n            vector<TreeNode*> left = rec(start, i-1), right = rec(i+1, end);\\n            \\n            for (auto l : left)\\n                for (auto r : right)\\n                    res.push_back(new TreeNode(i, l, r));\\n        }\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> res = rec(1, n);\\n        return res;\\n    }\\n};\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def rec(start, end):\\n\\t\\t\\n            if start > end:\\n                return [None]\\n\\t\\t\\t\\t\\n            if start == end:\\n                return [TreeNode(start)]\\n            ret_list = []\\n\\t\\t\\t\\n            for i in range(start, end+1):\\n                left = rec(start, i-1)\\n                right = rec(i+1, end)\\n                for pair in product(left, right):\\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\\n        \\n            return ret_list\\n        \\n        res = rec(1,n)\\n        return res\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> rec(int start, int end) {\\n        vector<TreeNode*> res;\\n        if (start > end) return {NULL};\\n        \\n        if (start == end) return {new TreeNode(start)};\\n        \\n        for (int i = start; i <= end; i++) {\\n            vector<TreeNode*> left = rec(start, i-1), right = rec(i+1, end);\\n            \\n            for (auto l : left)\\n                for (auto r : right)\\n                    res.push_back(new TreeNode(i, l, r));\\n        }\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> res = rec(1, n);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def rec(start, end):\\n\\t\\t\\n            if start > end:\\n                return [None]\\n\\t\\t\\t\\t\\n            if start == end:\\n                return [TreeNode(start)]\\n            ret_list = []\\n\\t\\t\\t\\n            for i in range(start, end+1):\\n                left = rec(start, i-1)\\n                right = rec(i+1, end)\\n                for pair in product(left, right):\\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\\n        \\n            return ret_list\\n        \\n        res = rec(1,n)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31609,
                "title": "simple-python-solution",
                "content": "    class Solution(object):\\n    def generateTrees(self, n):\\n        return self.cal([i for i in xrange(1, n+1)])\\n        \\n    def cal(self, lst):\\n        if not lst: return [None]\\n        res=[]\\n        for i in xrange(len(lst)):\\n            for left in self.cal(lst[:i]):\\n                for right in self.cal(lst[i+1:]):\\n                    node, node.left, node.right=TreeNode(lst[i]), left, right\\n                    res+=[node]\\n        return res",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def generateTrees(self, n):\\n        return self.cal([i for i in xrange(1, n+1)])\\n        \\n    def cal(self, lst):\\n        if not lst: return [None]\\n        res=[]\\n        for i in xrange(len(lst)):\\n            for left in self.cal(lst[:i]):\\n                for right in self.cal(lst[i+1:]):\\n                    node, node.left, node.right=TreeNode(lst[i]), left, right\\n                    res+=[node]\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 167055,
                "title": "c-recursive-and-iterative-solutions-beats-100-and-doesn-t-create-frankenstein-trees",
                "content": "# TL;DR\\n### Recursive solution\\n```cpp\\n  /// Returns all insert orderings of [first, last) that will produce a unique tree when inserted into a tree\\n  std::vector<std::vector<int>> unique_orderings(int first, int last)\\n  {\\n    std::vector<std::vector<int>> ret;\\n    if (first == last) {\\n      ret.emplace_back();\\n    } else {\\n      // For each possible root digit\\n      for (int digit = first; digit != last; ++digit) {\\n        \\n        // Get all the orderings to build unique left branches\\n        auto left_orders = unique_orderings(first, digit);\\n        \\n        // Get all the orderings to build unique right branches\\n        auto right_orders = unique_orderings(digit + 1, last);\\n        \\n        // Combine all the possibilities together\\n        for (auto& left : left_orders) {\\n          for (auto& right : right_orders) {\\n            ret.emplace_back(1, digit);\\n            ret.reserve(left.size() + 1 + right.size());\\n            std::copy(left.begin(), left.end(), std::back_inserter(ret.back()));\\n            std::copy(right.begin(), right.end(), std::back_inserter(ret.back()));\\n          }\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n\\n  vector<TreeNode*> generateTrees(int n) {\\n    std::vector<TreeNode*> ret;\\n    \\n    // Get the orderings that will produce unique unique tress using the numbers from [1, n]\\n    // For example, when n is 3, will return [[1, 2, 3], [1, 3, 2], [2, 1, 3], [3, 1, 2], [3, 2, 1]].\\n    // Each ordering will produce a unique tree when inserted from left to right.\\n    auto orderings = unique_orderings(1, n + 1);\\n    if (!orderings.front().empty()) {\\n      std::fill_n(std::back_inserter(ret), orderings.size(), nullptr);\\n      \\n      // Make each unique tree by inserting the digits of each orderings into a tree.\\n      for (int i = 0; i < orderings.size(); ++i) {\\n        for (auto digit : orderings[i]) {\\n          TreeNode** curr = &ret[i];\\n          while (*curr) {\\n            curr = (digit <= (**curr).val) ? &((**curr).left): &((**curr).right);\\n          }\\n          *curr = new TreeNode(digit);\\n        }\\n      }\\n    }\\n    \\n    return ret;\\n  }\\n```\\n### Iterative solution. Using cache for maximum speed\\n```cpp\\n  vector<TreeNode*> generateTrees(int n) {\\n    std::vector<TreeNode*> ret;\\n    \\n    std::vector<std::vector<std::vector<int>>> patterns(1, std::vector<std::vector<int>>(1));\\n   \\n    // Create a template for each level from 0 to n - 1. This lists all the unique patterns for that level. If you take a pattern \\n    // and create a tree by inserting the digits in order, you will produce a unique tree that no other pattern creates\\n    for (int lvl = 1; lvl < n; ++lvl) {\\n      patterns.emplace_back();\\n      // For each possible root digit\\n      for (int digit = 1; digit <= lvl; ++digit) {\\n        // For each possible unique pattern that can be made using digits less than the root\\n        for (auto& left : patterns[digit - 1]) {\\n          // For each possible unique pattern that can be made using digits greater than the root\\n          for (auto& right : patterns[lvl - digit]) {\\n            patterns[lvl].emplace_back();\\n            patterns[lvl].reserve(left.size() + 1 + right.size());\\n            auto it = std::back_inserter(patterns.back().back());\\n            // Add root\\n            *it++ = digit;\\n            \\n            // Add left branch pattern\\n            it = std::copy(left.begin(), left.end(), it);\\n            \\n            // Add right branch pattern, but offsetting the numbers by the root value\\n            it = std::generate_n(it, right.size(), [digit, r_it = right.begin()] () mutable { return digit + *r_it++; });\\n          }\\n        }\\n      }\\n    }\\n\\n    // We now have a template for each level 0 to n - 1. Time to build level n, but this time we must create it as\\n    // actual trees\\n    \\n    // For each possible root digit\\n    for (int digit = 1; digit <= n; ++digit) {\\n      // For each possible unique pattern that can be made using digits less than the root\\n      for (auto& left : patterns[digit - 1]) {\\n        // For each possible unique pattern that can be made using digits greater than the root\\n        for (auto& right : patterns[n - digit]) {\\n          ret.emplace_back(new TreeNode(digit));\\n   \\n          // Create left branch\\n          for (int left_digit : left) {\\n            TreeNode** curr = &ret.back()->left;\\n            while (*curr) {\\n              curr = (left_digit <= (**curr).val) ? &((**curr).left): &((**curr).right);\\n            }\\n            *curr = new TreeNode(left_digit);\\n          }\\n          \\n          // Create right branch, remembering to add the offset\\n          for (int right_digit : right) {\\n            TreeNode** curr = &ret.back()->right;\\n            while (*curr) {\\n              curr = (right_digit + digit <= (**curr).val) ? &((**curr).left): &((**curr).right);\\n            }\\n            *curr = new TreeNode(right_digit + digit);\\n          }\\n        }\\n      }\\n    } \\n    \\n    return ret;\\n  }\\n```\\n# Details\\n### Background\\nMy solutions are an expansion of [unique binary search tree](https://leetcode.com/problems/unique-binary-search-trees/discuss/166725/c++-extremely-short-stl-solution.-4-lines.-With-detailed-explaination). The idea being that if you choose a root node _r_, then there are [1, _r_) numbers to use to build the left branch and [_r_ + 1, _n_) numbers to use to build the right branch. Focusing on the left branch for the moment, it is obviously just the same problem except instead of needing to use the numbers [1, _n_], we now use [1, _r_), where _r_ <= _n_. So we have a decreasing, recursive problem. The right branch is actually exactly the same, just with a different offset, starting position.\\n\\nSo lets get down to how to use this.\\n### Recursive solution\\nA convient way to represent a unique tree is by indicating the order of numbers to be inserted. For example [1, 2, 3] would be;\\n```\\n1\\n \\\\\\n  2\\n   \\\\\\n    3\\n```\\n[3, 1, 2, 4]\\n```\\n  3\\n / \\\\\\n1   4\\n \\\\\\n  2\\n```\\nThis is convient because from above, we will be dividing the numbers around a root. What we\\'re aiming for is a list of numbers like `[root, <left branch>, <right branch>]`. This is what the recursive function `unique_orderings` is producing. Given a range [first, last), return all the unique insert orderings for that range. All that is left to do after that is actually build all the trees to return.\\n\\n**Note: After I implemented my solution, I checked out other peoples solutions. I found a large number of them were returning trees directly from their recursive function. These would then be directly linked to. This results in trees _sharing_ branches. Not something I expect the question is looking for.**\\n```cpp\\nstd::vector<TreeNode*> branches(...)\\n{\\n  ...\\n  auto left = branches(...);\\n  auto right = branches(...);\\n  for (auto l : left) {\\n    for (auto r : right) {\\n      TreeNode* root = new TreeNode(root_val);\\n      root->left = l;    // Every tree points to the _same_ left branch\\n      root->right = r;   // Every tree points to the _same_ right branch\\n      ...\\n    }\\n  }\\n}\\n```\\nIt\\'s hard to visualise, in ascii, but the trees [3, 2, 1, 5, 4] and [3, 2, 1, 4, 5] will be linked very stranglely. Using the same node for node _2_.\\n```\\n   -------\\\\\\n  /\\t   \\\\\\n /   3      \\\\    3\\n \\\\ /   \\\\     ---/ \\\\\\n  2     5          4\\n /     /            \\\\\\n1      4             5\\n```\\t \\nThis is why I choose to build the trees outside of the recursive function. To avoid such an a quirk.\\n### Iterative\\nYou will notice that the recursive solution actually generates the same branches over and over again. To make it faster, we could instead cache our branches, so every time the branch options for [1, 4) was requested, the same values would be returned. We can go further than this though. Consider the case of a _n_ = 7 and using a root node of 4. The left branch with use the range [1, 4), while the right branch will need to use [5, 8). The number of options will be the same for both branches as they have the same, just the starting number will be different. My solution uses this to build all branches from a _pattern_, where each node value is offset to adjust for different start values.\\n\\nThe solution is very fast while still being relatively memory efficent. Once again it doesn\\'t create Frankenstein trees that are share branches.\\n\\n**Please give me a thumbs up if this helped explain this problem for you**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\n  /// Returns all insert orderings of [first, last) that will produce a unique tree when inserted into a tree\\n  std::vector<std::vector<int>> unique_orderings(int first, int last)\\n  {\\n    std::vector<std::vector<int>> ret;\\n    if (first == last) {\\n      ret.emplace_back();\\n    } else {\\n      // For each possible root digit\\n      for (int digit = first; digit != last; ++digit) {\\n        \\n        // Get all the orderings to build unique left branches\\n        auto left_orders = unique_orderings(first, digit);\\n        \\n        // Get all the orderings to build unique right branches\\n        auto right_orders = unique_orderings(digit + 1, last);\\n        \\n        // Combine all the possibilities together\\n        for (auto& left : left_orders) {\\n          for (auto& right : right_orders) {\\n            ret.emplace_back(1, digit);\\n            ret.reserve(left.size() + 1 + right.size());\\n            std::copy(left.begin(), left.end(), std::back_inserter(ret.back()));\\n            std::copy(right.begin(), right.end(), std::back_inserter(ret.back()));\\n          }\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n\\n  vector<TreeNode*> generateTrees(int n) {\\n    std::vector<TreeNode*> ret;\\n    \\n    // Get the orderings that will produce unique unique tress using the numbers from [1, n]\\n    // For example, when n is 3, will return [[1, 2, 3], [1, 3, 2], [2, 1, 3], [3, 1, 2], [3, 2, 1]].\\n    // Each ordering will produce a unique tree when inserted from left to right.\\n    auto orderings = unique_orderings(1, n + 1);\\n    if (!orderings.front().empty()) {\\n      std::fill_n(std::back_inserter(ret), orderings.size(), nullptr);\\n      \\n      // Make each unique tree by inserting the digits of each orderings into a tree.\\n      for (int i = 0; i < orderings.size(); ++i) {\\n        for (auto digit : orderings[i]) {\\n          TreeNode** curr = &ret[i];\\n          while (*curr) {\\n            curr = (digit <= (**curr).val) ? &((**curr).left): &((**curr).right);\\n          }\\n          *curr = new TreeNode(digit);\\n        }\\n      }\\n    }\\n    \\n    return ret;\\n  }\\n```\n```cpp\\n  vector<TreeNode*> generateTrees(int n) {\\n    std::vector<TreeNode*> ret;\\n    \\n    std::vector<std::vector<std::vector<int>>> patterns(1, std::vector<std::vector<int>>(1));\\n   \\n    // Create a template for each level from 0 to n - 1. This lists all the unique patterns for that level. If you take a pattern \\n    // and create a tree by inserting the digits in order, you will produce a unique tree that no other pattern creates\\n    for (int lvl = 1; lvl < n; ++lvl) {\\n      patterns.emplace_back();\\n      // For each possible root digit\\n      for (int digit = 1; digit <= lvl; ++digit) {\\n        // For each possible unique pattern that can be made using digits less than the root\\n        for (auto& left : patterns[digit - 1]) {\\n          // For each possible unique pattern that can be made using digits greater than the root\\n          for (auto& right : patterns[lvl - digit]) {\\n            patterns[lvl].emplace_back();\\n            patterns[lvl].reserve(left.size() + 1 + right.size());\\n            auto it = std::back_inserter(patterns.back().back());\\n            // Add root\\n            *it++ = digit;\\n            \\n            // Add left branch pattern\\n            it = std::copy(left.begin(), left.end(), it);\\n            \\n            // Add right branch pattern, but offsetting the numbers by the root value\\n            it = std::generate_n(it, right.size(), [digit, r_it = right.begin()] () mutable { return digit + *r_it++; });\\n          }\\n        }\\n      }\\n    }\\n\\n    // We now have a template for each level 0 to n - 1. Time to build level n, but this time we must create it as\\n    // actual trees\\n    \\n    // For each possible root digit\\n    for (int digit = 1; digit <= n; ++digit) {\\n      // For each possible unique pattern that can be made using digits less than the root\\n      for (auto& left : patterns[digit - 1]) {\\n        // For each possible unique pattern that can be made using digits greater than the root\\n        for (auto& right : patterns[n - digit]) {\\n          ret.emplace_back(new TreeNode(digit));\\n   \\n          // Create left branch\\n          for (int left_digit : left) {\\n            TreeNode** curr = &ret.back()->left;\\n            while (*curr) {\\n              curr = (left_digit <= (**curr).val) ? &((**curr).left): &((**curr).right);\\n            }\\n            *curr = new TreeNode(left_digit);\\n          }\\n          \\n          // Create right branch, remembering to add the offset\\n          for (int right_digit : right) {\\n            TreeNode** curr = &ret.back()->right;\\n            while (*curr) {\\n              curr = (right_digit + digit <= (**curr).val) ? &((**curr).left): &((**curr).right);\\n            }\\n            *curr = new TreeNode(right_digit + digit);\\n          }\\n        }\\n      }\\n    } \\n    \\n    return ret;\\n  }\\n```\n```\\n1\\n \\\\\\n  2\\n   \\\\\\n    3\\n```\n```\\n  3\\n / \\\\\\n1   4\\n \\\\\\n  2\\n```\n```cpp\\nstd::vector<TreeNode*> branches(...)\\n{\\n  ...\\n  auto left = branches(...);\\n  auto right = branches(...);\\n  for (auto l : left) {\\n    for (auto r : right) {\\n      TreeNode* root = new TreeNode(root_val);\\n      root->left = l;    // Every tree points to the _same_ left branch\\n      root->right = r;   // Every tree points to the _same_ right branch\\n      ...\\n    }\\n  }\\n}\\n```\n```\\n   -------\\\\\\n  /\\t   \\\\\\n /   3      \\\\    3\\n \\\\ /   \\\\     ---/ \\\\\\n  2     5          4\\n /     /            \\\\\\n1      4             5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3865536,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nThere 3 important things. \\n\\nOne is we try to create subtrees with some range between start(minimum) and end(maximum) value.\\n\\nSecond is calculation of the range. left range should be between start and current root - 1 as end value because all values of left side must be smaller than current root. right range should be between current root + 1 and end becuase all values on the right side should be greater than current root value.\\n\\nThrid is we call the same funtion recursively, so it\\'s good idea to keep results of current start and end, so that we can use the results later. It\\'s time saving.\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/5G-Kwx8Lm5Q\\n\\n# Subscribe to my channel from here. I have 240 videos as of August 5th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Define a class `Solution` containing a method `generateTrees` which takes an integer `n` as input and returns a list of optional `TreeNode` objects.\\n\\n2. Check if `n` is 0. If it is, return an empty list since there are no possible trees with 0 nodes.\\n\\n3. Initialize an empty dictionary called `memo`. This dictionary will be used to store previously computed results for specific ranges of values to avoid redundant calculations.\\n\\n4. Define an inner function called `generate_trees` that takes two parameters: `start` and `end`, which represent the range of values for which binary search trees need to be generated.\\n\\n5. Inside the `generate_trees` function:\\n   - Check if the tuple `(start, end)` exists as a key in the `memo` dictionary. If it does, return the corresponding value from the `memo` dictionary.\\n   - Initialize an empty list called `trees`. This list will store the generated trees for the current range.\\n   - If `start` is greater than `end`, append `None` to the `trees` list, indicating an empty subtree, and return the `trees` list.\\n   - Loop through each value `root_val` in the range `[start, end]` (inclusive):\\n     - Recursively call the `generate_trees` function for the left subtree with the range `[start, root_val - 1]` and store the result in `left_trees`.\\n     - Recursively call the `generate_trees` function for the right subtree with the range `[root_val + 1, end]` and store the result in `right_trees`.\\n     - Nested loop through each combination of `left_tree` in `left_trees` and `right_tree` in `right_trees`:\\n       - Create a new `TreeNode` instance with `root_val` as the value, `left_tree` as the left child, and `right_tree` as the right child.\\n       - Append the new `TreeNode` to the `trees` list.\\n   - Store the `trees` list in the `memo` dictionary with the key `(start, end)`.\\n   - Return the `trees` list.\\n\\n6. Outside the `generate_trees` function, call `generate_trees` initially with arguments `1` and `n` to generate all unique binary search trees with `n` nodes.\\n\\n7. Return the list of generated trees.\\n\\nThis algorithm generates all possible unique binary search trees with `n` nodes by considering different ranges of root values and recursively generating left and right subtrees for each possible root value. The `memo` dictionary is used to store previously computed results, reducing redundant calculations and improving the efficiency of the algorithm.\\n\\n# Complexity\\n- Time complexity: O(C(n))\\nC is Catalan number.\\n\\n- Space complexity: O(C(n))\\nC is Catalan number.\\n\\nCatalan number\\nhttps://en.wikipedia.org/wiki/Catalan_number\\n\\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        if n == 0:\\n            return []\\n        \\n        memo = {}\\n\\n        def generate_trees(start, end):\\n            if (start, end) in memo:\\n                return memo[(start, end)]\\n            \\n            trees = []\\n            if start > end:\\n                trees.append(None)\\n                return trees\\n            \\n            for root_val in range(start, end + 1):\\n                left_trees = generate_trees(start, root_val - 1)\\n                right_trees = generate_trees(root_val + 1, end)\\n            \\n                for left_tree in left_trees:\\n                    for right_tree in right_trees:\\n                        root = TreeNode(root_val, left_tree, right_tree)\\n                        trees.append(root)\\n            \\n            memo[(start, end)] = trees\\n            return trees\\n\\n        return generate_trees(1, n)\\n```\\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {number} n\\n * @return {TreeNode[]}\\n */\\nvar generateTrees = function(n) {\\n   if (n === 0) {\\n        return [];\\n    }\\n    \\n    const memo = new Map();\\n\\n    function generateTreesHelper(start, end) {\\n        if (memo.has(`${start}-${end}`)) {\\n            return memo.get(`${start}-${end}`);\\n        }\\n        \\n        const trees = [];\\n        if (start > end) {\\n            trees.push(null);\\n            return trees;\\n        }\\n        \\n        for (let rootVal = start; rootVal <= end; rootVal++) {\\n            const leftTrees = generateTreesHelper(start, rootVal - 1);\\n            const rightTrees = generateTreesHelper(rootVal + 1, end);\\n            \\n            for (const leftTree of leftTrees) {\\n                for (const rightTree of rightTrees) {\\n                    const root = new TreeNode(rootVal, leftTree, rightTree);\\n                    trees.push(root);\\n                }\\n            }\\n        }\\n        \\n        memo.set(`${start}-${end}`, trees);\\n        return trees;\\n    }\\n\\n    return generateTreesHelper(1, n);    \\n};\\n```\\n```java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        Map<String, List<TreeNode>> memo = new HashMap<>();\\n\\n        return generateTreesHelper(1, n, memo);        \\n    }\\n\\n    private List<TreeNode> generateTreesHelper(int start, int end, Map<String, List<TreeNode>> memo) {\\n        String key = start + \"-\" + end;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        \\n        List<TreeNode> trees = new ArrayList<>();\\n        if (start > end) {\\n            trees.add(null);\\n            return trees;\\n        }\\n        \\n        for (int rootVal = start; rootVal <= end; rootVal++) {\\n            List<TreeNode> leftTrees = generateTreesHelper(start, rootVal - 1, memo);\\n            List<TreeNode> rightTrees = generateTreesHelper(rootVal + 1, end, memo);\\n            \\n            for (TreeNode leftTree : leftTrees) {\\n                for (TreeNode rightTree : rightTrees) {\\n                    TreeNode root = new TreeNode(rootVal);\\n                    root.left = leftTree;\\n                    root.right = rightTree;\\n                    trees.add(root);\\n                }\\n            }\\n        }\\n        \\n        memo.put(key, trees);\\n        return trees;\\n    }\\n}\\n```\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n == 0) {\\n            return vector<TreeNode*>();\\n        }\\n        \\n        unordered_map<string, vector<TreeNode*>> memo;\\n\\n        return generateTreesHelper(1, n, memo);        \\n    }\\n\\nprivate:\\n    vector<TreeNode*> generateTreesHelper(int start, int end, unordered_map<string, vector<TreeNode*>>& memo) {\\n        string key = to_string(start) + \"-\" + to_string(end);\\n        if (memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n        \\n        vector<TreeNode*> trees;\\n        if (start > end) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n        \\n        for (int rootVal = start; rootVal <= end; rootVal++) {\\n            vector<TreeNode*> leftTrees = generateTreesHelper(start, rootVal - 1, memo);\\n            vector<TreeNode*> rightTrees = generateTreesHelper(rootVal + 1, end, memo);\\n            \\n            for (TreeNode* leftTree : leftTrees) {\\n                for (TreeNode* rightTree : rightTrees) {\\n                    TreeNode* root = new TreeNode(rootVal);\\n                    root->left = leftTree;\\n                    root->right = rightTree;\\n                    trees.push_back(root);\\n                }\\n            }\\n        }\\n        \\n        memo[key] = trees;\\n        return trees;\\n    }    \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        if n == 0:\\n            return []\\n        \\n        memo = {}\\n\\n        def generate_trees(start, end):\\n            if (start, end) in memo:\\n                return memo[(start, end)]\\n            \\n            trees = []\\n            if start > end:\\n                trees.append(None)\\n                return trees\\n            \\n            for root_val in range(start, end + 1):\\n                left_trees = generate_trees(start, root_val - 1)\\n                right_trees = generate_trees(root_val + 1, end)\\n            \\n                for left_tree in left_trees:\\n                    for right_tree in right_trees:\\n                        root = TreeNode(root_val, left_tree, right_tree)\\n                        trees.append(root)\\n            \\n            memo[(start, end)] = trees\\n            return trees\\n\\n        return generate_trees(1, n)\\n```\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {number} n\\n * @return {TreeNode[]}\\n */\\nvar generateTrees = function(n) {\\n   if (n === 0) {\\n        return [];\\n    }\\n    \\n    const memo = new Map();\\n\\n    function generateTreesHelper(start, end) {\\n        if (memo.has(`${start}-${end}`)) {\\n            return memo.get(`${start}-${end}`);\\n        }\\n        \\n        const trees = [];\\n        if (start > end) {\\n            trees.push(null);\\n            return trees;\\n        }\\n        \\n        for (let rootVal = start; rootVal <= end; rootVal++) {\\n            const leftTrees = generateTreesHelper(start, rootVal - 1);\\n            const rightTrees = generateTreesHelper(rootVal + 1, end);\\n            \\n            for (const leftTree of leftTrees) {\\n                for (const rightTree of rightTrees) {\\n                    const root = new TreeNode(rootVal, leftTree, rightTree);\\n                    trees.push(root);\\n                }\\n            }\\n        }\\n        \\n        memo.set(`${start}-${end}`, trees);\\n        return trees;\\n    }\\n\\n    return generateTreesHelper(1, n);    \\n};\\n```\n```java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        Map<String, List<TreeNode>> memo = new HashMap<>();\\n\\n        return generateTreesHelper(1, n, memo);        \\n    }\\n\\n    private List<TreeNode> generateTreesHelper(int start, int end, Map<String, List<TreeNode>> memo) {\\n        String key = start + \"-\" + end;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        \\n        List<TreeNode> trees = new ArrayList<>();\\n        if (start > end) {\\n            trees.add(null);\\n            return trees;\\n        }\\n        \\n        for (int rootVal = start; rootVal <= end; rootVal++) {\\n            List<TreeNode> leftTrees = generateTreesHelper(start, rootVal - 1, memo);\\n            List<TreeNode> rightTrees = generateTreesHelper(rootVal + 1, end, memo);\\n            \\n            for (TreeNode leftTree : leftTrees) {\\n                for (TreeNode rightTree : rightTrees) {\\n                    TreeNode root = new TreeNode(rootVal);\\n                    root.left = leftTree;\\n                    root.right = rightTree;\\n                    trees.add(root);\\n                }\\n            }\\n        }\\n        \\n        memo.put(key, trees);\\n        return trees;\\n    }\\n}\\n```\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n == 0) {\\n            return vector<TreeNode*>();\\n        }\\n        \\n        unordered_map<string, vector<TreeNode*>> memo;\\n\\n        return generateTreesHelper(1, n, memo);        \\n    }\\n\\nprivate:\\n    vector<TreeNode*> generateTreesHelper(int start, int end, unordered_map<string, vector<TreeNode*>>& memo) {\\n        string key = to_string(start) + \"-\" + to_string(end);\\n        if (memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n        \\n        vector<TreeNode*> trees;\\n        if (start > end) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n        \\n        for (int rootVal = start; rootVal <= end; rootVal++) {\\n            vector<TreeNode*> leftTrees = generateTreesHelper(start, rootVal - 1, memo);\\n            vector<TreeNode*> rightTrees = generateTreesHelper(rootVal + 1, end, memo);\\n            \\n            for (TreeNode* leftTree : leftTrees) {\\n                for (TreeNode* rightTree : rightTrees) {\\n                    TreeNode* root = new TreeNode(rootVal);\\n                    root->left = leftTree;\\n                    root->right = rightTree;\\n                    trees.push_back(root);\\n                }\\n            }\\n        }\\n        \\n        memo[key] = trees;\\n        return trees;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440118,
                "title": "python-divide-and-conquer-with-dp-explained",
                "content": "We can use `dp` technique here, where in `dp[i][j]` we keep all possible trees from numbers `i ... j`. We can also keep only one dimensional `dp`, but then we need to `clone` trees, adding the same values to all elements. However, number of trees is exponential, and I think it is not worth to make this optimization from `O(n^2)` to `O(n)` memory, because problem can be solved for only small `n <= 50`.\\n\\n#### Complexity\\nTime and space complexity is `O(C_{2n}^n)` approximately, because we have Catalan number of trees.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dp(i, j):\\n            if i > j: return [None]\\n            ans = []\\n            \\n            for k in range(i, j + 1):\\n                for lft, rgh in product(dp(i, k-1), dp(k+1, j)):\\n                    root = ListNode(k)\\n                    root.left = lft\\n                    root.right = rgh\\n                    ans.append(root)            \\n            return ans\\n        \\n        return dp(1, n)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dp(i, j):\\n            if i > j: return [None]\\n            ans = []\\n            \\n            for k in range(i, j + 1):\\n                for lft, rgh in product(dp(i, k-1), dp(k+1, j)):\\n                    root = ListNode(k)\\n                    root.left = lft\\n                    root.right = rgh\\n                    ans.append(root)            \\n            return ans\\n        \\n        return dp(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759719,
                "title": "c-very-easy-to-understand-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generateBST(int begin, int end)\\n    {\\n        vector<TreeNode*>V;\\n        \\n        if(begin>end)\\n        {\\n            V.push_back(NULL);\\n            return V;\\n        }\\n        \\n        for(int i=begin; i<=end; i++)\\n        {\\n            vector<TreeNode*>left =  generateBST(begin, i-1);\\n            vector<TreeNode*>right =  generateBST(i+1,end);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    TreeNode* root = new TreeNode();\\n                    root->val = i;\\n                    root->left = l;\\n                    root->right = r;\\n                    V.push_back(root);\\n                }\\n            }\\n            \\n        }\\n        return V;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        vector<TreeNode*>V;\\n        if(n==0) return V;\\n        \\n        return generateBST(1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generateBST(int begin, int end)\\n    {\\n        vector<TreeNode*>V;\\n        \\n        if(begin>end)\\n        {\\n            V.push_back(NULL);\\n            return V;\\n        }\\n        \\n        for(int i=begin; i<=end; i++)\\n        {\\n            vector<TreeNode*>left =  generateBST(begin, i-1);\\n            vector<TreeNode*>right =  generateBST(i+1,end);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    TreeNode* root = new TreeNode();\\n                    root->val = i;\\n                    root->left = l;\\n                    root->right = r;\\n                    V.push_back(root);\\n                }\\n            }\\n            \\n        }\\n        return V;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        vector<TreeNode*>V;\\n        if(n==0) return V;\\n        \\n        return generateBST(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31597,
                "title": "30-ms-c-solution",
                "content": "    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        vector<TreeNode *> generateTrees(int n) {\\n            return helper(1,n);\\n        }\\n        \\n        vector<TreeNode*> helper(int s, int e) {\\n            if (s > e) {\\n                 return vector<TreeNode*>(1,NULL);\\n            }\\n            \\n            vector<TreeNode*> result;\\n            for (int i=s; i <= e; ++i) {\\n                vector<TreeNode*> left, right;\\n                    left = helper(s,i-1);\\n                    right = helper(i+1,e);\\n                    for (int j = 0; j < left.size(); ++j) {\\n                        for (int k = 0; k < right.size(); ++k) {\\n                            TreeNode* root = new TreeNode(i);\\n                            root->left = left[j];\\n                            root->right = right[k];\\n                            result.push_back(root);\\n                        }\\n                    }\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<TreeNode *> generateTrees(int n) {\\n            return helper(1,n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31535,
                "title": "20ms-c-top-down-dp-solution",
                "content": "a bottom up solution looks much better, but I find it's also a little bit harder to understand. Top-down solution is straight forward,\\n\\n   \\n\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> ret;\\n        vector<vector<vector<TreeNode*>>> dp(n,vector<vector<TreeNode*>>(n));\\n        helper(1,n,ret,dp);\\n        return ret;\\n    }\\n    \\n    void helper(int start, int end, vector<TreeNode*> &ret,vector<vector<vector<TreeNode*>>> &dp) {\\n        if (start > end) {\\n            ret.push_back(NULL); return;\\n        }\\n        if (!dp[start-1][end-1].empty())  {\\n            ret = dp[start-1][end-1]; return;\\n        }\\n        for (int i = start; i <= end; ++i) {\\n            vector<TreeNode*> left, right;\\n            helper(start, i-1,left,dp);\\n            helper(i+1,end,right,dp);\\n            for(int j = 0; j < left.size(); ++j) {\\n                for (int k = 0; k < right.size(); ++k) {\\n                    TreeNode* node = new TreeNode(i);\\n                    node->left = left[j];\\n                    node->right = right[k];\\n                    ret.push_back(node);\\n                }\\n            }\\n        }\\n        dp[start-1][end-1] = ret;\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "a bottom up solution looks much better, but I find it's also a little bit harder to understand. Top-down solution is straight forward,\\n\\n   \\n\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> ret;\\n        vector<vector<vector<TreeNode*>>> dp(n,vector<vector<TreeNode*>>(n));\\n        helper(1,n,ret,dp);\\n        return ret;\\n    }\\n    \\n    void helper(int start, int end, vector<TreeNode*> &ret,vector<vector<vector<TreeNode*>>> &dp) {\\n        if (start > end) {\\n            ret.push_back(NULL); return;\\n        }\\n        if (!dp[start-1][end-1].empty())  {\\n            ret = dp[start-1][end-1]; return;\\n        }\\n        for (int i = start; i <= end; ++i) {\\n            vector<TreeNode*> left, right;\\n            helper(start, i-1,left,dp);\\n            helper(i+1,end,right,dp);\\n            for(int j = 0; j < left.size(); ++j) {\\n                for (int k = 0; k < right.size(); ++k) {\\n                    TreeNode* node = new TreeNode(i);\\n                    node->left = left[j];\\n                    node->right = right[k];\\n                    ret.push_back(node);\\n                }\\n            }\\n        }\\n        dp[start-1][end-1] = ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 536107,
                "title": "python-recursive-solution-explained-beats-99-56",
                "content": "The basic idea is to recursively split the conceptual array `[1, ..., n]` in half. During every split, make a new root node for every different combination of left/right subtree structures. For the time complexity of this algorithm, please check the comment below.\\n```python\\ndef generateTrees(self, n: int) -> List[TreeNode]:\\n    def generate(l, r):   # split between [l, r)\\n        if l == r:\\n            return [None]\\n        nodes = []\\n        for i in range(l, r):\\n            for lchild in generate(l, i):\\n                for rchild in generate(i+1, r):\\n                    node = TreeNode(i+1)   # +1 to convert the index to the actual value\\n                    node.left = lchild\\n                    node.right = rchild\\n                    nodes.append(node)\\n        return nodes\\n    return generate(0, n) if n else []\\n```\\nVote up if you find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\ndef generateTrees(self, n: int) -> List[TreeNode]:\\n    def generate(l, r):   # split between [l, r)\\n        if l == r:\\n            return [None]\\n        nodes = []\\n        for i in range(l, r):\\n            for lchild in generate(l, i):\\n                for rchild in generate(i+1, r):\\n                    node = TreeNode(i+1)   # +1 to convert the index to the actual value\\n                    node.left = lchild\\n                    node.right = rchild\\n                    nodes.append(node)\\n        return nodes\\n    return generate(0, n) if n else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2503720,
                "title": "6-liner-c-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\\n        vector<TreeNode*> ans;\\n        if(n < s) return {nullptr};                              \\n         for(int i=s; i<=n; i++) {                \\t                 // Consider every number in range [s,n] as root  \\n            for(auto left: generateTrees(i-1, s)) {                  // generate all possible trees in range [s,i)\\n                for(auto right: generateTrees(n, i+1))               // generate all possible trees in range (i,e]\\n                    ans.push_back(new TreeNode(i, left, right));     // make new trees with i as the root\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote \\nthank you**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\\n        vector<TreeNode*> ans;\\n        if(n < s) return {nullptr};                              \\n         for(int i=s; i<=n; i++) {                \\t                 // Consider every number in range [s,n] as root  \\n            for(auto left: generateTrees(i-1, s)) {                  // generate all possible trees in range [s,i)\\n                for(auto right: generateTrees(n, i+1))               // generate all possible trees in range (i,e]\\n                    ans.push_back(new TreeNode(i, left, right));     // make new trees with i as the root\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441066,
                "title": "unique-binary-search-trees-ii-recursion-w-approach-c-python",
                "content": "**Idea**:\\n* We will use a recursive helper function that recieves a range `(within n)` and returns all subtrees in that range.\\n* We have a few cases:\\n\\t* if `start > end`, which is not supposed to happen, we return a list that contains only a `null`.\\n\\t* if `start == end` it means we reached a `leaf` and we will return a `list containing a tree` that has only that node.\\n\\t* Otherwise:\\n\\t\\t* for each option of root, we get `all possible subtrees` with that root for left and right children. Then for each possible pair of left and right we add to the result a new tree.\\n\\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> rec(int start, int end) {\\n        vector<TreeNode*> res;\\n        if (start > end) return {NULL};\\n        if (start == end) return {new TreeNode(start)};\\n        for (int i = start; i <= end; i++) {\\n            vector<TreeNode*> left = rec(start, i-1), right = rec(i+1, end);\\n            for (auto l : left)\\n                for (auto r : right)\\n                    res.push_back(new TreeNode(i, l, r));\\n        }\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> res = rec(1, n);\\n        return res;\\n    }\\n};\\n```\\n`In Python`\\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def rec(start, end):\\n\\t\\t\\n            if start > end:\\n                return [None]\\n\\t\\t\\t\\t\\n            if start == end:\\n                return [TreeNode(start)]\\n            ret_list = []\\n\\t\\t\\t\\n            for i in range(start, end+1):\\n                left = rec(start, i-1)\\n                right = rec(i+1, end)\\n                for pair in product(left, right):\\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\\n        \\n            return ret_list\\n        \\n        res = rec(1,n)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> rec(int start, int end) {\\n        vector<TreeNode*> res;\\n        if (start > end) return {NULL};\\n        if (start == end) return {new TreeNode(start)};\\n        for (int i = start; i <= end; i++) {\\n            vector<TreeNode*> left = rec(start, i-1), right = rec(i+1, end);\\n            for (auto l : left)\\n                for (auto r : right)\\n                    res.push_back(new TreeNode(i, l, r));\\n        }\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> res = rec(1, n);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def rec(start, end):\\n\\t\\t\\n            if start > end:\\n                return [None]\\n\\t\\t\\t\\t\\n            if start == end:\\n                return [TreeNode(start)]\\n            ret_list = []\\n\\t\\t\\t\\n            for i in range(start, end+1):\\n                left = rec(start, i-1)\\n                right = rec(i+1, end)\\n                for pair in product(left, right):\\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\\n        \\n            return ret_list\\n        \\n        res = rec(1,n)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566092,
                "title": "c-easy-recursive-solution",
                "content": "Let us start by understanding how many unique BSTs are possible for keys 1-n.\\n\\nTo form a structurally unique BST of n nodes, we can take any of the 1-n keys as the root. Let us take key i (1<=i<=n) as the root. Now the left subtrees can contain nodes with keys 1 to i-1 (Since all the values in the left subtree must be smaller than that in the root) and the right subtrees can contain nodes with keys i+1 to n. \\nFor example if n=3, i can be 1 (or) 2 (or) 3\\n```\\n  1           1                2                3               3\\n\\t\\\\           \\\\              / \\\\              /               /\\n\\t 3            2           1   3            2               1\\n    /              \\\\                         /                  \\\\\\n   2                3                      1                     2\\n          i = 1               i = 2                    i = 3   \\n```\\nSo, to construct a BST with a given root, we need to know the number of possible left subtrees(LSTs) and number of possible right subtrees(RSTs).\\nLet the no. possible LSTs be *numTrees(i-1)* and no. of possible BSTs be *numTrees(n-i)* . So the total no. of BSTs possible when i is the root are : *numTrees(i-1) * numTrees(n-i)*\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> constructTrees(int start, int end){\\n        vector<TreeNode*> result;\\n\\t\\t\\n        if(start==end){\\n            TreeNode *root = new TreeNode(start);\\n            result.push_back(root);\\n            return result;\\n        }\\n        if(start>end){\\n            result.push_back(NULL);\\n            return result;\\n        }\\n        \\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*> leftTrees = constructTrees(start, i-1); /*Total no. of LSTs possible when  is the root*/\\n            vector<TreeNode*> rightTrees = constructTrees(i+1, end); \\n\\t\\t\\t/*Join each left and right subtree to the root to form different BSTs*/\\n            for(auto l: leftTrees){\\n                for(auto r: rightTrees){\\n                    TreeNode *root = new TreeNode(i); \\n                    root->left = l;\\n                    root->right = r;\\n                    result.push_back(root);  /*Add the root of the resulting BST each time to the vector result*/\\n                }\\n            }\\n        }\\n        return result;\\n        \\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return constructTrees(1, n);\\n    }\\n};\\n```\\n\\nPlease upvote if u like the solution\\uD83D\\uDE4F\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n  1           1                2                3               3\\n\\t\\\\           \\\\              / \\\\              /               /\\n\\t 3            2           1   3            2               1\\n    /              \\\\                         /                  \\\\\\n   2                3                      1                     2\\n          i = 1               i = 2                    i = 3   \\n```\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> constructTrees(int start, int end){\\n        vector<TreeNode*> result;\\n\\t\\t\\n        if(start==end){\\n            TreeNode *root = new TreeNode(start);\\n            result.push_back(root);\\n            return result;\\n        }\\n        if(start>end){\\n            result.push_back(NULL);\\n            return result;\\n        }\\n        \\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*> leftTrees = constructTrees(start, i-1); /*Total no. of LSTs possible when  is the root*/\\n            vector<TreeNode*> rightTrees = constructTrees(i+1, end); \\n\\t\\t\\t/*Join each left and right subtree to the root to form different BSTs*/\\n            for(auto l: leftTrees){\\n                for(auto r: rightTrees){\\n                    TreeNode *root = new TreeNode(i); \\n                    root->left = l;\\n                    root->right = r;\\n                    result.push_back(root);  /*Add the root of the resulting BST each time to the vector result*/\\n                }\\n            }\\n        }\\n        return result;\\n        \\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return constructTrees(1, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440312,
                "title": "an-intuitive-explanation-with-diagrams",
                "content": "***BASICS***\\nBST? A node `x` has node `z` to right with value `z>x` and node `y` to the left with `y<x`.\\n\\n![image](https://assets.leetcode.com/users/images/3c9045fe-eaed-456a-a20b-3bcb09a6b4a2_1630574055.9780717.png)\\n\\n***BUILDING THE INTUITION: OBSERVATIONS***\\n- n = 1 case is trivial\\n- n = 2 case suggests\\n\\t- either swapping is important\\n\\t- or, changing the root is\\n![image](https://assets.leetcode.com/users/images/3f9339f0-279e-42fa-80b9-66d0c40b0939_1630574123.1668983.png)\\n\\n- n = 3 shows us:\\n\\t- swapping idea is too complex for > 2 nodes\\n\\t- the root idea works out better, we can **recursively** find the subtrees\\n\\t- there are repeating structures **DP**\\n![image](https://assets.leetcode.com/users/images/1757d47f-d667-4c66-9d4d-cbc0c621b197_1630574306.0539086.png)\\n\\n***SAMPLE CASE***\\nConsider the case: curr is 4. We split into left and right parts - for which we will call a recursive function again. I have considered the right sub-tree case:\\n![image](https://assets.leetcode.com/users/images/0af12d87-261d-4af0-9b5e-1085b58882c7_1630574322.4836857.png)\\n\\nEach recursion returns the total number of BSTs formed.\\n\\n***CODE***\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        \\n        @lru_cache(None)\\n        def recurse(l, r):\\n            if l > r: return [None]\\n            trees = []\\n            for i in range(l, r+1):\\n                lefts = recurse(l, i-1)\\n                rights = recurse(i+1, r)\\n            \\n                for left in lefts:\\n                    for right in rights:\\n                        tree = TreeNode(i)\\n                        tree.left = left\\n                        tree.right = right\\n                        trees.append(tree)\\n            \\n            return trees\\n        \\n        return recurse(1, n)\\n```\\n\\n**Upvote if this helps! It gives me feedback :)**",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        \\n        @lru_cache(None)\\n        def recurse(l, r):\\n            if l > r: return [None]\\n            trees = []\\n            for i in range(l, r+1):\\n                lefts = recurse(l, i-1)\\n                rights = recurse(i+1, r)\\n            \\n                for left in lefts:\\n                    for right in rights:\\n                        tree = TreeNode(i)\\n                        tree.left = left\\n                        tree.right = right\\n                        trees.append(tree)\\n            \\n            return trees\\n        \\n        return recurse(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31581,
                "title": "sharing-top-down-dp-python-solution-beats-93-33",
                "content": "    def generateTrees(self, n):\\n        \\n        def gen_trees(s, e, memo):\\n            if e < s:\\n                return [None]\\n            ret_list = []\\n            if (s, e) in memo:\\n                return memo[s, e]\\n            for i in range(s, e + 1):\\n                list_left = gen_trees(s, i - 1, memo)\\n                list_right = gen_trees(i + 1, e, memo)\\n                for left in list_left:\\n                    for right in list_right:\\n                        root = TreeNode(i)\\n                        root.left = left\\n                        root.right = right\\n                        ret_list.append(root)\\n            memo[s, e] = ret_list\\n            return ret_list\\n        \\n        if n == 0:\\n            return []\\n        return gen_trees(1, n, {})",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "    def generateTrees(self, n):\\n        \\n        def gen_trees(s, e, memo):\\n            if e < s:\\n                return [None]\\n            ret_list = []\\n            if (s, e) in memo:\\n                return memo[s, e]\\n            for i in range(s, e + 1):\\n                list_left = gen_trees(s, i - 1, memo)\\n                list_right = gen_trees(i + 1, e, memo)\\n                for left in list_left:\\n                    for right in list_right:\\n                        root = TreeNode(i)\\n                        root.left = left\\n                        root.right = right\\n                        ret_list.append(root)\\n            memo[s, e] = ret_list\\n            return ret_list\\n        \\n        if n == 0:\\n            return []\\n        return gen_trees(1, n, {})",
                "codeTag": "Python3"
            },
            {
                "id": 3866363,
                "title": "c-recursion-day-5",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTree(int size,int s,int e) {\\n        if(size==0){\\n            return {NULL};\\n        }\\n        if(size==1){\\n            TreeNode* temp = new TreeNode(s);\\n            return {temp};\\n        }\\n       vector<TreeNode*>ans;\\n        for(int i=s;i<=e;i++){\\n            vector<TreeNode*>v1 = generateTree(i-s,s,i-1);\\n             vector<TreeNode*>v2 = generateTree(e-i,i+1,e);\\n             for(int j=0;j<v1.size();j++){\\n                 for(int k=0;k<v2.size();k++){\\n                     TreeNode* temp = new TreeNode(i);\\n                     temp->left = v1[j];\\n                     temp->right = v2[k];\\n                     ans.push_back(temp);\\n                 }\\n             }   \\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return generateTree(n,1,n);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/abcf0777-a48c-4c76-ab0a-0c126e6b8ca7_1691226748.0385122.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTree(int size,int s,int e) {\\n        if(size==0){\\n            return {NULL};\\n        }\\n        if(size==1){\\n            TreeNode* temp = new TreeNode(s);\\n            return {temp};\\n        }\\n       vector<TreeNode*>ans;\\n        for(int i=s;i<=e;i++){\\n            vector<TreeNode*>v1 = generateTree(i-s,s,i-1);\\n             vector<TreeNode*>v2 = generateTree(e-i,i+1,e);\\n             for(int j=0;j<v1.size();j++){\\n                 for(int k=0;k<v2.size();k++){\\n                     TreeNode* temp = new TreeNode(i);\\n                     temp->left = v1[j];\\n                     temp->right = v2[k];\\n                     ans.push_back(temp);\\n                 }\\n             }   \\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return generateTree(n,1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865068,
                "title": "beats-100-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/4Ca9t6LYRDI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    Map<Pair<Integer, Integer>, List<TreeNode>> dp; \\n    public List<TreeNode> generateTrees(int n) {\\n        dp = new HashMap<>();\\n        return helper(1, n);\\n    }\\n    \\n    public List<TreeNode> helper(int start, int end) {\\n        List<TreeNode> variations = new ArrayList<>();\\n        if (start > end) {\\n            variations.add(null);\\n            return variations;\\n        }\\n        if (dp.containsKey(new Pair<>(start, end))) {\\n            return dp.get(new Pair<>(start, end));\\n        }\\n        for (int i = start; i <= end; ++i) {\\n            List<TreeNode> leftSubTrees = helper(start, i - 1);\\n            List<TreeNode> rightSubTrees = helper(i + 1, end);\\n            for (TreeNode left: leftSubTrees) {\\n                for (TreeNode right: rightSubTrees) {\\n                    TreeNode root = new TreeNode(i, left, right);\\n                    variations.add(root);\\n                }\\n            }\\n        }\\n        dp.put(new Pair<>(start, end), variations);\\n        return variations;\\n    }   \\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    map<pair<int, int>, vector<TreeNode*>> dp; \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return helper(1, n);\\n    }\\n    \\n    vector<TreeNode*> helper(int start, int end) {\\n        vector<TreeNode*> variations;\\n        if (start > end) {\\n            variations.push_back(nullptr);\\n            return variations;\\n        }\\n        if (dp.find(make_pair(start, end)) != dp.end()) {\\n            return dp[make_pair(start, end)];\\n        }\\n        for (int i = start; i <= end; ++i) {\\n            vector<TreeNode*> leftSubTrees = helper(start, i - 1);\\n            vector<TreeNode*> rightSubTrees = helper(i + 1, end);\\n            for (TreeNode* left : leftSubTrees) {\\n                for (TreeNode* right : rightSubTrees) {\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = left;\\n                    root->right = right;\\n                    variations.push_back(root);\\n                }\\n            }\\n        }\\n        dp[make_pair(start, end)] = variations;\\n        return variations;\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def helper(start, end):\\n            variations = []\\n            if start > end:\\n                variations.append(None)\\n                return variations\\n            if (start, end) in dp:\\n                return dp[(start, end)]\\n            for i in range(start, end + 1):\\n                leftSubTrees = helper(start, i - 1)\\n                rightSubTrees = helper(i + 1, end)\\n                for left in leftSubTrees:\\n                    for right in rightSubTrees:\\n                        root = TreeNode(i)\\n                        root.left = left\\n                        root.right = right\\n                        variations.append(root)\\n            dp[(start, end)] = variations\\n            return variations\\n        \\n        dp = {}\\n        return helper(1, n)\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    Map<Pair<Integer, Integer>, List<TreeNode>> dp; \\n    public List<TreeNode> generateTrees(int n) {\\n        dp = new HashMap<>();\\n        return helper(1, n);\\n    }\\n    \\n    public List<TreeNode> helper(int start, int end) {\\n        List<TreeNode> variations = new ArrayList<>();\\n        if (start > end) {\\n            variations.add(null);\\n            return variations;\\n        }\\n        if (dp.containsKey(new Pair<>(start, end))) {\\n            return dp.get(new Pair<>(start, end));\\n        }\\n        for (int i = start; i <= end; ++i) {\\n            List<TreeNode> leftSubTrees = helper(start, i - 1);\\n            List<TreeNode> rightSubTrees = helper(i + 1, end);\\n            for (TreeNode left: leftSubTrees) {\\n                for (TreeNode right: rightSubTrees) {\\n                    TreeNode root = new TreeNode(i, left, right);\\n                    variations.add(root);\\n                }\\n            }\\n        }\\n        dp.put(new Pair<>(start, end), variations);\\n        return variations;\\n    }   \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    map<pair<int, int>, vector<TreeNode*>> dp; \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return helper(1, n);\\n    }\\n    \\n    vector<TreeNode*> helper(int start, int end) {\\n        vector<TreeNode*> variations;\\n        if (start > end) {\\n            variations.push_back(nullptr);\\n            return variations;\\n        }\\n        if (dp.find(make_pair(start, end)) != dp.end()) {\\n            return dp[make_pair(start, end)];\\n        }\\n        for (int i = start; i <= end; ++i) {\\n            vector<TreeNode*> leftSubTrees = helper(start, i - 1);\\n            vector<TreeNode*> rightSubTrees = helper(i + 1, end);\\n            for (TreeNode* left : leftSubTrees) {\\n                for (TreeNode* right : rightSubTrees) {\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = left;\\n                    root->right = right;\\n                    variations.push_back(root);\\n                }\\n            }\\n        }\\n        dp[make_pair(start, end)] = variations;\\n        return variations;\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def helper(start, end):\\n            variations = []\\n            if start > end:\\n                variations.append(None)\\n                return variations\\n            if (start, end) in dp:\\n                return dp[(start, end)]\\n            for i in range(start, end + 1):\\n                leftSubTrees = helper(start, i - 1)\\n                rightSubTrees = helper(i + 1, end)\\n                for left in leftSubTrees:\\n                    for right in rightSubTrees:\\n                        root = TreeNode(i)\\n                        root.left = left\\n                        root.right = right\\n                        variations.append(root)\\n            dp[(start, end)] = variations\\n            return variations\\n        \\n        dp = {}\\n        return helper(1, n)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926204,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    func generateTrees(_ n: Int) -> [TreeNode?] {\\n        var nums: [Int] = []\\n        \\n        func copyNodes(_ node: TreeNode?, _ left: TreeNode?, _ right: TreeNode?) -> TreeNode? {\\n            if node == nil { return nil } \\n            else {\\n                let newNode = TreeNode(node!.val)\\n                newNode.left = copyNodes(left, left?.left, left?.right)\\n                newNode.right = copyNodes(right, right?.left, right?.right)\\n                return newNode\\n            }\\n        }\\n\\n        func generateNodes(_ node: TreeNode?, _ left: [TreeNode?], _ right: [TreeNode?]) -> [TreeNode?] {\\n            let leftCount = left.count > 0 ? left.count : 1\\n            let rightCount = right.count > 0 ? right.count : 1\\n            var res: [TreeNode?] = []\\n            \\n            for i in 0..<leftCount {\\n                let leftNode = left.count > 0 ? left[i] : nil\\n                for j in 0..<rightCount {\\n                    let rightNode = right.count > 0 ? right[j] : nil\\n                    res.append(copyNodes(node, leftNode, rightNode))\\n                }\\n            }\\n            return res\\n        }\\n\\n        func nodes(_ nums: [Int]) -> [TreeNode?] {\\n            if nums.count == 0 { return [] }\\n            var res: [TreeNode?] = []\\n\\n            for (i, num) in nums.enumerated() {\\n                let node = TreeNode(num)\\n                let leftNodes = i > 0 ? nodes(Array(nums[0..<i])) : nodes([])\\n                let rightNodes = i < nums.count - 1 ? nodes(Array(nums[i + 1...nums.count - 1])) : nodes([])\\n                res += generateNodes(node, leftNodes, rightNodes)\\n            }\\n            return res\\n        }\\n        \\n        for num in 1...n { nums.append(num) }\\n        return nodes(nums)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    func generateTrees(_ n: Int) -> [TreeNode?] {\\n        var nums: [Int] = []\\n        \\n        func copyNodes(_ node: TreeNode?, _ left: TreeNode?, _ right: TreeNode?) -> TreeNode? {\\n            if node == nil { return nil } \\n            else {\\n                let newNode = TreeNode(node!.val)\\n                newNode.left = copyNodes(left, left?.left, left?.right)\\n                newNode.right = copyNodes(right, right?.left, right?.right)\\n                return newNode\\n            }\\n        }\\n\\n        func generateNodes(_ node: TreeNode?, _ left: [TreeNode?], _ right: [TreeNode?]) -> [TreeNode?] {\\n            let leftCount = left.count > 0 ? left.count : 1\\n            let rightCount = right.count > 0 ? right.count : 1\\n            var res: [TreeNode?] = []\\n            \\n            for i in 0..<leftCount {\\n                let leftNode = left.count > 0 ? left[i] : nil\\n                for j in 0..<rightCount {\\n                    let rightNode = right.count > 0 ? right[j] : nil\\n                    res.append(copyNodes(node, leftNode, rightNode))\\n                }\\n            }\\n            return res\\n        }\\n\\n        func nodes(_ nums: [Int]) -> [TreeNode?] {\\n            if nums.count == 0 { return [] }\\n            var res: [TreeNode?] = []\\n\\n            for (i, num) in nums.enumerated() {\\n                let node = TreeNode(num)\\n                let leftNodes = i > 0 ? nodes(Array(nums[0..<i])) : nodes([])\\n                let rightNodes = i < nums.count - 1 ? nodes(Array(nums[i + 1...nums.count - 1])) : nodes([])\\n                res += generateNodes(node, leftNodes, rightNodes)\\n            }\\n            return res\\n        }\\n        \\n        for num in 1...n { nums.append(num) }\\n        return nodes(nums)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410074,
                "title": "java-recursion-iteration-solutions-dp-clone-memoization",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/unique-binary-search-trees-ii/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> Given an integer `n`, generate all structurally unique BST\\'s (binary search trees) that store values `1 ... n`.\\n\\n**Example:**\\n\\n```java\\nInput: 3\\nOutput:\\n[\\n  [1,null,3,2],\\n  [3,2,null,1],\\n  [3,1,null,null,2],\\n  [2,1,3],\\n  [1,null,2,null,3]\\n]\\nExplanation:\\nThe above output corresponds to the 5 unique BST\\'s shown below:\\n\\n   1         3     3      2      1\\n    \\\\       /     /      / \\\\      \\\\\\n     3     2     1      1   3      2\\n    /     /       \\\\                 \\\\\\n   2     1         2                 3\\n```\\n\\n\\n## Analysis\\n\\n### Recursion\\n\\nIf we directly apply the solution in `96. Unique Binary Search Trees`, we have an incorrect result. Consider the following example.\\n\\n```java\\nn = 5, i = 3\\n2 left nodes:  [1, 2]\\n2 right nodes: [4, 5]\\n\\nn = 10, i = 8\\n7 left nodes:  [1, 2, 3, 4, 5, 6, 7]\\n2 right nodes: [9, 10]\\n```\\n\\nAs you can see, although there are still 2 nodes in the right subtrees, the values are not the same. In the previous approach, it did not handle this situation.\\n\\nSo rather than passing a parameter `n` (number of nodes), we now pass down two parameters `lo` and `hi` indicating the range of values of a tree.\\n\\nFor example, `generateTrees(1, 5)` generate trees whose values range from `1` to `5`, and each of them has a chance to be the root, which also includes the information of number of nodes `n`. Say when the root is `3`, we calculate `generateTrees(1, 2)` and `generateTrees(4, 5)`.\\n\\n**Note:** When `n == 0`, it returns `[]` instead of `[[null]]`.\\n\\n```java\\npublic List<TreeNode> generateTrees(int n) {\\n  if (n == 0) {\\n    return new ArrayList<>();\\n  }\\n  return generateTrees(1, n);\\n}\\n\\nprivate List<TreeNode> generateTrees(int lo, int hi) {\\n  int n = hi - lo + 1;\\n  if (n == 0) {\\n    List<TreeNode> L = new ArrayList<>();\\n    L.add(null);\\n    return L;\\n  }\\n  List<TreeNode> result = new ArrayList<>();\\n  for (int i = lo; i <= hi; ++i) {\\n    List<TreeNode> leftSubtrees = generateTrees(lo, i - 1);\\n    List<TreeNode> rightSubtrees = generateTrees(i + 1, hi);\\n    for (TreeNode leftSub : leftSubtrees) {\\n      for (TreeNode rightSub : rightSubtrees) {\\n        TreeNode newTree = new TreeNode(i);\\n        newTree.left = leftSub;\\n        newTree.right = rightSub;\\n        result.add(newTree);\\n      }\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** It is at most bounded by `O(N x N!)`. A tighter bound would be Catalan number times `N` since we\\'ve done `N` times, which is `N x G_N = O(Nx\\\\frac{4^N}{N^{3/2}}) = O(\\\\frac{4^N}{N^{1/2}})`.\\n**Space:** `O(N x G_N) = O(\\\\frac{4^N}{N^{1/2}})`\\n\\n\\n\\n### DP (Clone)\\n\\nReference: [link](https://leetcode.wang/leetCode-95-Unique-Binary-Search-TreesII.html)\\n\\nLet\\'s denote `tree[i]` as the list of trees of size `i`. Think of `tree[i]` as our building blocks for a larger tree.\\n\\n```java\\nExample: n = 3\\n\\ntree[0]:\\nnull\\n\\ntree[1]:\\n[1]\\n[2]\\n[3]\\n\\ntree[2]:\\n[1 2]\\n1\\n \\\\\\n  2      // 2 structures\\n  2\\n /\\n1\\n[2 3]\\n2\\n \\\\\\n  3\\n  3\\n /\\n2        // [1 3] is not possible\\n\\ntree[3]:  // (based on tree[1], tree[2])\\n   3\\n  /\\n[1 2]\\n   1\\n    \\\\\\n   [2 3]\\n   2\\n /  \\\\\\n[1] [3]\\n```\\n\\nSo we can compute all possible trees for `tree[1]`, `tree[2]`, ..., then we can construct `tree[n]` by previous results.\\n\\nFor a small `n = 3` , we notice that when we calculate `tree[2]` we want all possible combinations for `tree[2]` (`[1 2]`, `[2 3]`). **Furthermore**, if we have a large `n = 100`, we want all the combinations as follows `[1 2]`, `[2 3]`, `[3 4]`, ..., `[99 100]` (each of them has two structures).\\n\\nSince these trees have the same two types of structures:\\n\\n```java\\nx       y\\n \\\\     /\\n  y   x\\n```\\n\\nWe can actually construct all the trees by `[1 2]` plus some constant, say `offset`. For example, `[5 6]` can be constructed as follows:\\n\\n```java\\n1    +4    5\\n \\\\          \\\\\\n  2    +4    6\\n------------------\\n  2    +4    6\\n /          /\\n1    +4    5\\n```\\n\\nSay the problem is `n = 100`. During the execution of the algorithm when `i = 98`, we want to get all possible trees for `i = 98` as the root. The size of the left subtree is `97` and the subtree is picked from `tree[97]`; the size of the right subtree is `2` and the subtree is picked from `tree[2]`.\\n\\nFor the left subtree, we already have `tree[97]` computed as `[1 2 3 ... 97]`.\\n\\nFor the right subtree, we want `[99 100]`, which can be computed by `[1 2]` plus `offset = 98`.\\n\\n```java\\n1    +98    99\\n \\\\            \\\\\\n  2    +98    100\\n------------------\\n  2    +98    100\\n /            /\\n1    +98     99\\n```\\n\\nTherefore, given a tree `root`, we can generate a new tree by cloning with an `offset`.\\n\\n```java\\n// adding offset to each node of a tree root\\nprivate TreeNode clone(TreeNode root, int offset) {\\n  if (n == null) {\\n    return null;\\n  }\\n  TreeNode node = new TreeNode(root.val + offset);\\n  node.left = clone(root.left, offset);\\n  node.right = clone(root.right, offset);\\n  return node;\\n}\\n```\\n\\nFor input `n`, the result we want is `tree[n]` (`[1 2 3 ... n]`). Here is the code for `generateTrees(n)`:\\n\\n```java\\npublic List<TreeNode> generateTrees(int n) {\\n  List<TreeNode>[] tree = new ArrayList[n + 1];\\n  tree[0] = new ArrayList<>();\\n  if (n == 0) {\\n    return tree[0];\\n  }\\n  tree[0].add(null);\\n  // Calculate all lengths\\n  for (int len = 1; len <= n; ++len) {\\n    tree[len] = new ArrayList<>(); // contains all trees we construct\\n    // Consider each as the root\\n    for (int i = 1; i <= len; ++i) {\\n      int leftSize = i - 1;\\n      int rightSize = len - i;\\n      for (TreeNode leftTree : tree[leftSize]) [\\n        for (TreeNode rightTree : tree[rightSize]) {\\n          TreeNode tree = new TreeNode(i);\\n          tree.left = leftTree;  // left subtree requires no cloning\\n          tree.right = clone(rightTree, i); // add i as the offset\\n          tree[len].add(tree);\\n        }\\n      ]\\n    }\\n  }\\n  return tree[n];\\n}\\n```\\n\\n**Time:** <span class=\"purple\">N/A</span> (I don\\'t know T_T)\\n**Space:** <span class=\"purple\">N/A</span> (I don\\'t know T_T)\\n\\n\\n### DP (2D)\\n\\nJudge: `1ms`, faster than `99.95%`. I have nothing to say.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/sz3zr.jpg)\\n\\nHere is the code I wrote:\\n\\n```java\\npublic List<TreeNode> generateTrees(int n) {\\n  if (n == 0) {\\n    return new ArrayList<>();\\n  }\\n  List<TreeNode>[][] g = new ArrayList[n + 1][n + 1];\\n  // init\\n  List<TreeNode> nullList = new ArrayList<>(); nullList.add(null);\\n  g[0][0] = nullList;\\n  for (int k = 1; k <= n; ++k) { // g(0, k)\\n    g[0][k] = nullList;\\n  }\\n  for (int k = 1; k <= n; ++k) { // diagonal: one node (itself)\\n    List<TreeNode> oneList = new ArrayList<>(); oneList.add(new TreeNode(k));\\n    g[k][k] = oneList;\\n  }\\n  for (int k = 1; k <= n; ++k) { // one node above diagonal: nullList\\n    g[k][k - 1] = nullList;\\n  }\\n  // dp\\n  for (int i = n - 1; i >= 1; --i) {\\n    for (int j = i + 1; j <= n; ++j) {\\n      List<TreeNode> result = new ArrayList<>();\\n      for (int k = i ; k <= j; ++k) { // for each k as root [i, j]\\n        List<TreeNode> leftList = (k - 1 <= n) ? g[i][k - 1] : nullList;\\n        List<TreeNode> rightList = (k + 1 <= n) ? g[k + 1][j] : nullList;\\n        for (TreeNode left : leftList) {\\n          for (TreeNode right: rightList) {\\n            TreeNode newTree = new TreeNode(k);\\n            newTree.left = left;\\n            newTree.right = right;\\n            result.add(newTree);\\n          }\\n        }\\n      }\\n      g[i][j] = result;\\n    }\\n  }\\n  return g[1][n];\\n}\\n```\\n\\n**Time:** <span class=\"purple\">N/A</span> (I don\\'t know T_T)\\n**Space:** <span class=\"purple\">N/A</span> (I don\\'t know T_T)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```java\\nInput: 3\\nOutput:\\n[\\n  [1,null,3,2],\\n  [3,2,null,1],\\n  [3,1,null,null,2],\\n  [2,1,3],\\n  [1,null,2,null,3]\\n]\\nExplanation:\\nThe above output corresponds to the 5 unique BST\\'s shown below:\\n\\n   1         3     3      2      1\\n    \\\\       /     /      / \\\\      \\\\\\n     3     2     1      1   3      2\\n    /     /       \\\\                 \\\\\\n   2     1         2                 3\\n```\n```java\\nn = 5, i = 3\\n2 left nodes:  [1, 2]\\n2 right nodes: [4, 5]\\n\\nn = 10, i = 8\\n7 left nodes:  [1, 2, 3, 4, 5, 6, 7]\\n2 right nodes: [9, 10]\\n```\n```java\\npublic List<TreeNode> generateTrees(int n) {\\n  if (n == 0) {\\n    return new ArrayList<>();\\n  }\\n  return generateTrees(1, n);\\n}\\n\\nprivate List<TreeNode> generateTrees(int lo, int hi) {\\n  int n = hi - lo + 1;\\n  if (n == 0) {\\n    List<TreeNode> L = new ArrayList<>();\\n    L.add(null);\\n    return L;\\n  }\\n  List<TreeNode> result = new ArrayList<>();\\n  for (int i = lo; i <= hi; ++i) {\\n    List<TreeNode> leftSubtrees = generateTrees(lo, i - 1);\\n    List<TreeNode> rightSubtrees = generateTrees(i + 1, hi);\\n    for (TreeNode leftSub : leftSubtrees) {\\n      for (TreeNode rightSub : rightSubtrees) {\\n        TreeNode newTree = new TreeNode(i);\\n        newTree.left = leftSub;\\n        newTree.right = rightSub;\\n        result.add(newTree);\\n      }\\n    }\\n  }\\n  return result;\\n}\\n```\n```java\\nExample: n = 3\\n\\ntree[0]:\\nnull\\n\\ntree[1]:\\n[1]\\n[2]\\n[3]\\n\\ntree[2]:\\n[1 2]\\n1\\n \\\\\\n  2      // 2 structures\\n  2\\n /\\n1\\n[2 3]\\n2\\n \\\\\\n  3\\n  3\\n /\\n2        // [1 3] is not possible\\n\\ntree[3]:  // (based on tree[1], tree[2])\\n   3\\n  /\\n[1 2]\\n   1\\n    \\\\\\n   [2 3]\\n   2\\n /  \\\\\\n[1] [3]\\n```\n```java\\nx       y\\n \\\\     /\\n  y   x\\n```\n```java\\n1    +4    5\\n \\\\          \\\\\\n  2    +4    6\\n------------------\\n  2    +4    6\\n /          /\\n1    +4    5\\n```\n```java\\n1    +98    99\\n \\\\            \\\\\\n  2    +98    100\\n------------------\\n  2    +98    100\\n /            /\\n1    +98     99\\n```\n```java\\n// adding offset to each node of a tree root\\nprivate TreeNode clone(TreeNode root, int offset) {\\n  if (n == null) {\\n    return null;\\n  }\\n  TreeNode node = new TreeNode(root.val + offset);\\n  node.left = clone(root.left, offset);\\n  node.right = clone(root.right, offset);\\n  return node;\\n}\\n```\n```java\\npublic List<TreeNode> generateTrees(int n) {\\n  List<TreeNode>[] tree = new ArrayList[n + 1];\\n  tree[0] = new ArrayList<>();\\n  if (n == 0) {\\n    return tree[0];\\n  }\\n  tree[0].add(null);\\n  // Calculate all lengths\\n  for (int len = 1; len <= n; ++len) {\\n    tree[len] = new ArrayList<>(); // contains all trees we construct\\n    // Consider each as the root\\n    for (int i = 1; i <= len; ++i) {\\n      int leftSize = i - 1;\\n      int rightSize = len - i;\\n      for (TreeNode leftTree : tree[leftSize]) [\\n        for (TreeNode rightTree : tree[rightSize]) {\\n          TreeNode tree = new TreeNode(i);\\n          tree.left = leftTree;  // left subtree requires no cloning\\n          tree.right = clone(rightTree, i); // add i as the offset\\n          tree[len].add(tree);\\n        }\\n      ]\\n    }\\n  }\\n  return tree[n];\\n}\\n```\n```java\\npublic List<TreeNode> generateTrees(int n) {\\n  if (n == 0) {\\n    return new ArrayList<>();\\n  }\\n  List<TreeNode>[][] g = new ArrayList[n + 1][n + 1];\\n  // init\\n  List<TreeNode> nullList = new ArrayList<>(); nullList.add(null);\\n  g[0][0] = nullList;\\n  for (int k = 1; k <= n; ++k) { // g(0, k)\\n    g[0][k] = nullList;\\n  }\\n  for (int k = 1; k <= n; ++k) { // diagonal: one node (itself)\\n    List<TreeNode> oneList = new ArrayList<>(); oneList.add(new TreeNode(k));\\n    g[k][k] = oneList;\\n  }\\n  for (int k = 1; k <= n; ++k) { // one node above diagonal: nullList\\n    g[k][k - 1] = nullList;\\n  }\\n  // dp\\n  for (int i = n - 1; i >= 1; --i) {\\n    for (int j = i + 1; j <= n; ++j) {\\n      List<TreeNode> result = new ArrayList<>();\\n      for (int k = i ; k <= j; ++k) { // for each k as root [i, j]\\n        List<TreeNode> leftList = (k - 1 <= n) ? g[i][k - 1] : nullList;\\n        List<TreeNode> rightList = (k + 1 <= n) ? g[k + 1][j] : nullList;\\n        for (TreeNode left : leftList) {\\n          for (TreeNode right: rightList) {\\n            TreeNode newTree = new TreeNode(k);\\n            newTree.left = left;\\n            newTree.right = right;\\n            result.add(newTree);\\n          }\\n        }\\n      }\\n      g[i][j] = result;\\n    }\\n  }\\n  return g[1][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 332563,
                "title": "explanation-with-diagrams-dp-solution",
                "content": "Again I am going to explain a DP solution using diagrams.\\nFirst I define a two-dimension list res[0..n][0..n].(res[0][0] is of no use,just for readability,so we will ignore them later.)\\nres[i][j] stores the root TreeNode of all possible BST formed by integers from i to j.Then our goal is res[1][n].\\nTo calculate res[1][n],we can review last problem,to find out the recursion formula.\\nTake n=3 into consideration first,we want to know res[1][3].\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855139.png)\\n\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855122.png)\\nFrom the picture we can find that solving res[1][3] needs res[2][3],res[1][1],res[3][3] and res[1][2].\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855224.png)\\n\\nTo be specific,for instance,if we have known res[2][3],by simply set \\n```\\nfor oneNode of res[2][3] :\\n    t = TreeNode(1)\\n    t.left = null\\n    t.right = oneNode\\n    res[1][3].append(t)\\n```\\nwe can get some possible solution of res[1][3].By the same method we can solve out all solutions of res[1][3].\\nThen we turn to res[2][3].As is the same,res[2][3] rely on res[2][2] and res[3][3]\\n,and res[1][2] rely on res[1][1] and res[2][2].\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855195.png)\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855252.png)\\nIt is obvious that res[i][i] = [i].\\nSo we only need to fill the matrix along every diagonal line one by one,from middle diagonal line to the right-top corner.\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855271.png)\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855278.png)\\n![image](https://assets.leetcode.com/users/planegoose/image_1562855281.png)\\nThen we can use bottom-up DP to solve every diagonal line,and finally get res[1][n].\\n\\n**Supplement**\\n(res begins at 0,ends at n,just for readability.Of course it will occupy less space if we let it end at n-1.)\\n(There are many vacant grid occupied(colored in gray) at left-bottom.Maybe we can improve the algorithms in this term.)\\n(My code is somewhat too long,though excelling 98% in time and 97% in space,but I haven\\'t compacted it,so I feel shamed to put it up.)\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nfor oneNode of res[2][3] :\\n    t = TreeNode(1)\\n    t.left = null\\n    t.right = oneNode\\n    res[1][3].append(t)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151394,
                "title": "javascript-dfs-with-memo",
                "content": "```js\\nfunction generateTrees(n) {\\n  if (n < 1) return [];\\n  const dp = [...Array(n+1)].map(r => Array(n+1));\\n  return generate(1, n);\\n  \\n  function generate(s, e) {\\n    if (s > e) return [null];\\n    if (dp[s][e]) return dp[s][e];\\n    \\n    const res = [];\\n    for (let root = s; root <= e; root++) {\\n      for (let left of generate(s, root-1)) {\\n        for (let right of generate(root+1, e)) {\\n          const newTree = new TreeNode(root);\\n          newTree.left = left;\\n          newTree.right = right;\\n          res.push(newTree);\\n        }\\n      }\\n    }\\n    \\n    dp[s][e] = res;\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction generateTrees(n) {\\n  if (n < 1) return [];\\n  const dp = [...Array(n+1)].map(r => Array(n+1));\\n  return generate(1, n);\\n  \\n  function generate(s, e) {\\n    if (s > e) return [null];\\n    if (dp[s][e]) return dp[s][e];\\n    \\n    const res = [];\\n    for (let root = s; root <= e; root++) {\\n      for (let left of generate(s, root-1)) {\\n        for (let right of generate(root+1, e)) {\\n          const newTree = new TreeNode(root);\\n          newTree.left = left;\\n          newTree.right = right;\\n          res.push(newTree);\\n        }\\n      }\\n    }\\n    \\n    dp[s][e] = res;\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1670103,
                "title": "easy-to-understand-dp-solution-iterative-space-optimised-better-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* newTreeRight(TreeNode* root, int j){\\n        if(root==NULL){\\n            return root;\\n        }\\n        TreeNode* newRoot = new TreeNode(root->val + j);\\n        newRoot->left = newTreeRight(root->left, j);\\n        newRoot->right = newTreeRight(root->right, j);\\n        return newRoot;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n==1){\\n            return {new TreeNode(1)};\\n        }\\n        vector<vector<TreeNode*>> dp(n+1);\\n        TreeNode* root = new TreeNode(1);\\n        dp[1].push_back(root);\\n        for(int i = 2; i<=n; i++){\\n            for(int j = 1; j<=i; j++){\\n                int left = j-1;\\n                int right = i-j;\\n                if(left==0){\\n                    for(int k = 0; k<dp[right].size(); k++){\\n                        root = new TreeNode(j);\\n                        TreeNode *newRoot = newTreeRight(dp[right][k], j);\\n                        root->right = newRoot;\\n                        dp[i].push_back(root);\\n                    }\\n                }else if(right==0){\\n                    for(int k = 0; k<dp[left].size(); k++){\\n                        root = new TreeNode(j);\\n                        root->left = dp[left][k];\\n                        dp[i].push_back(root);\\n                    }\\n                }else{\\n                    for(int k = 0; k<dp[left].size(); k++){\\n                        for(int l = 0; l<dp[right].size(); l++){\\n                            root = new TreeNode(j);\\n                            root->left = dp[left][k];\\n                            TreeNode *newRoot = newTreeRight(dp[right][l], j);\\n                            root->right = newRoot;\\n                            dp[i].push_back(root);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* newTreeRight(TreeNode* root, int j){\\n        if(root==NULL){\\n            return root;\\n        }\\n        TreeNode* newRoot = new TreeNode(root->val + j);\\n        newRoot->left = newTreeRight(root->left, j);\\n        newRoot->right = newTreeRight(root->right, j);\\n        return newRoot;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n==1){\\n            return {new TreeNode(1)};\\n        }\\n        vector<vector<TreeNode*>> dp(n+1);\\n        TreeNode* root = new TreeNode(1);\\n        dp[1].push_back(root);\\n        for(int i = 2; i<=n; i++){\\n            for(int j = 1; j<=i; j++){\\n                int left = j-1;\\n                int right = i-j;\\n                if(left==0){\\n                    for(int k = 0; k<dp[right].size(); k++){\\n                        root = new TreeNode(j);\\n                        TreeNode *newRoot = newTreeRight(dp[right][k], j);\\n                        root->right = newRoot;\\n                        dp[i].push_back(root);\\n                    }\\n                }else if(right==0){\\n                    for(int k = 0; k<dp[left].size(); k++){\\n                        root = new TreeNode(j);\\n                        root->left = dp[left][k];\\n                        dp[i].push_back(root);\\n                    }\\n                }else{\\n                    for(int k = 0; k<dp[left].size(); k++){\\n                        for(int l = 0; l<dp[right].size(); l++){\\n                            root = new TreeNode(j);\\n                            root->left = dp[left][k];\\n                            TreeNode *newRoot = newTreeRight(dp[right][l], j);\\n                            root->right = newRoot;\\n                            dp[i].push_back(root);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31631,
                "title": "a-simple-bottom-up-dp-solution",
                "content": "The optimal substructure is that for any BST with nodes 1 to n, pick i-th node as root, then the left subtree will contain nodes from 1 to (i-1), and the right subtree will contain nodes from (i+1) to n. I use a 3-d vector to store all possible trees for subtrees with nodes from i to j (0 <= i <= j <=n+1 ), if i==j, there is only one-node tree; if j = i-1, then there is no actual node(storing NULL pointer).  Use a bottom up solution to generate all possible subtrees with nodes i to j. Finally the result will be the subtree set with nodes 1 to n, \\n    \\n    \\tvector<TreeNode *> generateTrees(int n) {\\n\\t\\tif(n == 0)\\treturn vector<TreeNode *>(1, NULL);\\n\\t\\tvector<vector<vector<TreeNode*>>> subtree(n+2, vector<vector<TreeNode*>>(n+2, vector<TreeNode*>()));\\n\\t\\tfor(int i=1; i<=n+1; ++i){\\n\\t\\t\\tsubtree[i][i].push_back(new TreeNode(i));\\n\\t\\t    subtree[i][i-1].push_back(NULL);\\t\\n\\t\\t}\\n\\t\\tfor(int l=2; l<=n; ++l){\\n\\t\\t\\tfor(int i=1; i<=n-l+1; ++i){\\n\\t\\t\\t\\tfor(int j=i; j<=i+l-1; ++j){\\n\\t\\t\\t\\t\\tfor(int k=0; k<subtree[j+1][i+l-1].size(); ++k){\\n\\t\\t\\t\\t\\t    for(int m=0; m<subtree[i][j-1].size(); ++m){\\n\\t\\t\\t\\t\\t        TreeNode *T = new TreeNode(j);\\n\\t\\t\\t\\t\\t        T->left = subtree[i][j-1][m];\\n\\t\\t\\t\\t\\t        T->right = subtree[j+1][i+l-1][k];\\n\\t\\t\\t\\t            subtree[i][i+l-1].push_back(T);    \\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn subtree[1][n];\\n\\t}",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree"
                ],
                "code": "The optimal substructure is that for any BST with nodes 1 to n, pick i-th node as root, then the left subtree will contain nodes from 1 to (i-1), and the right subtree will contain nodes from (i+1) to n. I use a 3-d vector to store all possible trees for subtrees with nodes from i to j (0 <= i <= j <=n+1 ), if i==j, there is only one-node tree; if j = i-1, then there is no actual node(storing NULL pointer).  Use a bottom up solution to generate all possible subtrees with nodes i to j. Finally the result will be the subtree set with nodes 1 to n, \\n    \\n    \\tvector<TreeNode *> generateTrees(int n) {\\n\\t\\tif(n == 0)\\treturn vector<TreeNode *>(1, NULL);\\n\\t\\tvector<vector<vector<TreeNode*>>> subtree(n+2, vector<vector<TreeNode*>>(n+2, vector<TreeNode*>()));\\n\\t\\tfor(int i=1; i<=n+1; ++i){\\n\\t\\t\\tsubtree[i][i].push_back(new TreeNode(i));\\n\\t\\t    subtree[i][i-1].push_back(NULL);\\t\\n\\t\\t}\\n\\t\\tfor(int l=2; l<=n; ++l){\\n\\t\\t\\tfor(int i=1; i<=n-l+1; ++i){\\n\\t\\t\\t\\tfor(int j=i; j<=i+l-1; ++j){\\n\\t\\t\\t\\t\\tfor(int k=0; k<subtree[j+1][i+l-1].size(); ++k){\\n\\t\\t\\t\\t\\t    for(int m=0; m<subtree[i][j-1].size(); ++m){\\n\\t\\t\\t\\t\\t        TreeNode *T = new TreeNode(j);\\n\\t\\t\\t\\t\\t        T->left = subtree[i][j-1][m];\\n\\t\\t\\t\\t\\t        T->right = subtree[j+1][i+l-1][k];\\n\\t\\t\\t\\t            subtree[i][i+l-1].push_back(T);    \\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn subtree[1][n];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1321506,
                "title": "java-easy-solution-recursion",
                "content": "```\\n\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return recursion(1,n);\\n    }\\n    List<TreeNode> recursion(int start ,int end)\\n    {\\n        List<TreeNode> list = new ArrayList<>();\\n        if(start > end)\\n        {\\n            list.add(null);\\n            return list;\\n        }\\n        if(start == end)\\n        {\\n            list.add(new TreeNode(start));\\n            return list;\\n        }\\n        List<TreeNode> left,right;\\n        for(int i = start;i<=end;i++)\\n        {\\n            left = recursion(start,i-1);\\n            right = recursion(i+1,end);\\n            for(TreeNode lst : left)\\n            {\\n                for(TreeNode rst : right)\\n                {\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = lst;\\n                    root.right = rst;\\n                    list.add(root);\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return recursion(1,n);\\n    }\\n    List<TreeNode> recursion(int start ,int end)\\n    {\\n        List<TreeNode> list = new ArrayList<>();\\n        if(start > end)\\n        {\\n            list.add(null);\\n            return list;\\n        }\\n        if(start == end)\\n        {\\n            list.add(new TreeNode(start));\\n            return list;\\n        }\\n        List<TreeNode> left,right;\\n        for(int i = start;i<=end;i++)\\n        {\\n            left = recursion(start,i-1);\\n            right = recursion(i+1,end);\\n            for(TreeNode lst : left)\\n            {\\n                for(TreeNode rst : right)\\n                {\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = lst;\\n                    root.right = rst;\\n                    list.add(root);\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865004,
                "title": "c-recursion",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n![image](https://assets.leetcode.com/users/images/5be019ea-898c-4178-b92a-afdd521465c9_1691201173.537878.jpeg)\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> build(int start, int end){\\n        if(start>end) return {NULL};\\n        if(start==end) return {new TreeNode(start)};\\n        \\n        vector<TreeNode*> ans;\\n        for(int i=start;i<=end;i++){\\n            // inorder of BST is sorted i.e left -> root-> right\\n            vector<TreeNode*> left=build(start,i-1);\\n            vector<TreeNode*> right=build(i+1,end);\\n            \\n            // building all possible combinations with left having smaller than root & right having bigger values than root\\n            for(TreeNode* l : left){\\n                for(TreeNode* r : right){\\n                    TreeNode* root=new TreeNode(i);\\n                    root->left=l;\\n                    root->right=r;\\n                    \\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return build(1,n);\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> build(int start, int end){\\n        if(start>end) return {NULL};\\n        if(start==end) return {new TreeNode(start)};\\n        \\n        vector<TreeNode*> ans;\\n        for(int i=start;i<=end;i++){\\n            // inorder of BST is sorted i.e left -> root-> right\\n            vector<TreeNode*> left=build(start,i-1);\\n            vector<TreeNode*> right=build(i+1,end);\\n            \\n            // building all possible combinations with left having smaller than root & right having bigger values than root\\n            for(TreeNode* l : left){\\n                for(TreeNode* r : right){\\n                    TreeNode* root=new TreeNode(i);\\n                    root->left=l;\\n                    root->right=r;\\n                    \\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return build(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280436,
                "title": "c-pure-recursion-to-dp-only-with-addition-of-2-lines",
                "content": "There is a significant amount of improvement in the 2nd solution compared to the effort made to code that one over the inital recursive un-memoized solution.\\n\\n# 1. Pure Recursion (43 ms)\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> buildTrees(int l, int r) {\\n        \\n        if(l > r) return {nullptr};\\n        \\n        vector<TreeNode*> ans;\\n        \\n        for(int i=l; i<=r; ++i)\\n        {\\n\\t\\t\\t// set of BST\\'s we can make using values [l, i-1] \\n\\t\\t\\t\\n            vector<TreeNode*> left = buildTrees(l, i-1);\\n            \\n\\t\\t\\t// set of BST\\'s we can make using values [i+1, r]\\n\\t\\t\\t\\n            vector<TreeNode*> right = buildTrees(i+1, r);\\n            \\n\\t\\t\\t// creating all the possible different combinations using left and right vectors\\n\\t\\t\\t\\n            for(int j=0; j<left.size(); ++j)\\n            {\\n                for(int k=0; k<right.size(); ++k)\\n                {\\n                    ans.push_back(new TreeNode(i, left[j], right[k]));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildTrees(1, n);\\n    }\\n};\\n```\\n\\n# 2. Top-Down DP (11 ms)\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>, vector<TreeNode*>> m; //Line #1\\n    \\n    vector<TreeNode*> buildTrees(int l, int r) {\\n        \\n        if(l > r) return {nullptr};\\n        \\n        if(m.find({l, r}) != m.end()) return m[{l, r}]; //Line #2\\n        \\n        vector<TreeNode*> ans;\\n        \\n        for(int i=l; i<=r; ++i)\\n        {\\n            vector<TreeNode*> left = buildTrees(l, i-1);\\n            \\n            vector<TreeNode*> right = buildTrees(i+1, r);\\n            \\n            for(int j=0; j<left.size(); ++j)\\n            {\\n                for(int k=0; k<right.size(); ++k)\\n                {\\n                    ans.push_back(new TreeNode(i, left[j], right[k]));\\n                }\\n            }\\n        }\\n        \\n        return m[{l, r}] = ans; //Line #3\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildTrees(1, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> buildTrees(int l, int r) {\\n        \\n        if(l > r) return {nullptr};\\n        \\n        vector<TreeNode*> ans;\\n        \\n        for(int i=l; i<=r; ++i)\\n        {\\n\\t\\t\\t// set of BST\\'s we can make using values [l, i-1] \\n\\t\\t\\t\\n            vector<TreeNode*> left = buildTrees(l, i-1);\\n            \\n\\t\\t\\t// set of BST\\'s we can make using values [i+1, r]\\n\\t\\t\\t\\n            vector<TreeNode*> right = buildTrees(i+1, r);\\n            \\n\\t\\t\\t// creating all the possible different combinations using left and right vectors\\n\\t\\t\\t\\n            for(int j=0; j<left.size(); ++j)\\n            {\\n                for(int k=0; k<right.size(); ++k)\\n                {\\n                    ans.push_back(new TreeNode(i, left[j], right[k]));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildTrees(1, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>, vector<TreeNode*>> m; //Line #1\\n    \\n    vector<TreeNode*> buildTrees(int l, int r) {\\n        \\n        if(l > r) return {nullptr};\\n        \\n        if(m.find({l, r}) != m.end()) return m[{l, r}]; //Line #2\\n        \\n        vector<TreeNode*> ans;\\n        \\n        for(int i=l; i<=r; ++i)\\n        {\\n            vector<TreeNode*> left = buildTrees(l, i-1);\\n            \\n            vector<TreeNode*> right = buildTrees(i+1, r);\\n            \\n            for(int j=0; j<left.size(); ++j)\\n            {\\n                for(int k=0; k<right.size(); ++k)\\n                {\\n                    ans.push_back(new TreeNode(i, left[j], right[k]));\\n                }\\n            }\\n        }\\n        \\n        return m[{l, r}] = ans; //Line #3\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildTrees(1, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337271,
                "title": "recursive-c-solution-faster-than-97-c-submissions",
                "content": "**INTUTION:**\\nFor every element in range 1 to n lets say (temp), we try to find its corresponding left and right subtrees by helper(start,i-1) && helper(i+1,end) iterate through all possibilities of them and set temp\\'s left and right sub trees and push back to some vector and return.\\n```\\nvector<TreeNode*> generateTrees(int n) \\n    {\\n        return helper(1,n);\\n    }\\n    \\n    vector<TreeNode*> helper(int start,int end)\\n    {\\n        vector<TreeNode*> ans;\\n        if(start>end)\\n        {\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        for(int i=start;i<=end;i++)\\n        {\\n            vector<TreeNode*> left = helper(start,i-1);\\n            vector<TreeNode*> right = helper(i+1,end);\\n            \\n            for(int j=0;j<left.size();j++)\\n            {\\n                for(int k=0;k<right.size();k++)\\n                {\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left=left[j];\\n                    root->right=right[k];\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "**INTUTION:**\\nFor every element in range 1 to n lets say (temp), we try to find its corresponding left and right subtrees by helper(start,i-1) && helper(i+1,end) iterate through all possibilities of them and set temp\\'s left and right sub trees and push back to some vector and return.\\n```\\nvector<TreeNode*> generateTrees(int n) \\n    {\\n        return helper(1,n);\\n    }\\n    \\n    vector<TreeNode*> helper(int start,int end)\\n    {\\n        vector<TreeNode*> ans;\\n        if(start>end)\\n        {\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        for(int i=start;i<=end;i++)\\n        {\\n            vector<TreeNode*> left = helper(start,i-1);\\n            vector<TreeNode*> right = helper(i+1,end);\\n            \\n            for(int j=0;j<left.size();j++)\\n            {\\n                for(int k=0;k<right.size();k++)\\n                {\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left=left[j];\\n                    root->right=right[k];\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1172462,
                "title": "approach-code",
                "content": "Honestly I was not able to solve the problem in one go. I was able to get the idea to solve the problem but wasn\\'t able to implement it. \\nFirstly try to solve the problem Unique Binary Search Tree\\nSo here is my approach:\\n1) We need to generate a ***BST*** which means that left child will contain the node value lesser than root and right child will contain the value greater than the value of root.\\n2) And also I have ***n*** number of choices for the root node. \\n3) So i will iterate from ***1 to n*** and will generate left and rightsubtree recursivly.\\n4) Then create a tree from all the possible left and right subtree an then finally add to the solution list.\\n5) Also do not forget to add the base condition.\\nBase condition will be when my ***start>end***\\nSo here is my code:\\n```\\n vector<TreeNode*> generate(int start,int end)\\n    { vector<TreeNode*>list;\\n        if(start>end)\\n        {\\n            list.push_back(nullptr);\\n            return list;\\n        }\\n        for(int i=start;i<=end;i++)\\n        {\\n           vector<TreeNode*>leftsubtree=generate(start,i-1);\\n           vector<TreeNode*>rightsubtree=generate(i+1,end);\\n            for(int j=0;j<leftsubtree.size();j++)\\n            {\\n                TreeNode* left=leftsubtree[j];\\n                for(int k=0;k<rightsubtree.size();k++)\\n                {\\n                    TreeNode* right=rightsubtree[k];\\n                    TreeNode* node=new TreeNode(i);\\n                    node->left=left;\\n                    node->right=right;\\n                  list.push_back(node);\\n                }\\n            }\\n           \\n            \\n        }\\n     return list;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n   // binary search tree left node contain ->(1,i-1)and right child contain (i+1,n)\\n     vector<TreeNode*>ans=generate(1,n);   \\n        return ans;\\n    }\\n\\t//HappyCoding\\n\\t//Stay Safe and healthy\\n\\t//Also if you like the post do upvote and comment",
                "solutionTags": [],
                "code": "Honestly I was not able to solve the problem in one go. I was able to get the idea to solve the problem but wasn\\'t able to implement it. \\nFirstly try to solve the problem Unique Binary Search Tree\\nSo here is my approach:\\n1) We need to generate a ***BST*** which means that left child will contain the node value lesser than root and right child will contain the value greater than the value of root.\\n2) And also I have ***n*** number of choices for the root node. \\n3) So i will iterate from ***1 to n*** and will generate left and rightsubtree recursivly.\\n4) Then create a tree from all the possible left and right subtree an then finally add to the solution list.\\n5) Also do not forget to add the base condition.\\nBase condition will be when my ***start>end***\\nSo here is my code:\\n```\\n vector<TreeNode*> generate(int start,int end)\\n    { vector<TreeNode*>list;\\n        if(start>end)\\n        {\\n            list.push_back(nullptr);\\n            return list;\\n        }\\n        for(int i=start;i<=end;i++)\\n        {\\n           vector<TreeNode*>leftsubtree=generate(start,i-1);\\n           vector<TreeNode*>rightsubtree=generate(i+1,end);\\n            for(int j=0;j<leftsubtree.size();j++)\\n            {\\n                TreeNode* left=leftsubtree[j];\\n                for(int k=0;k<rightsubtree.size();k++)\\n                {\\n                    TreeNode* right=rightsubtree[k];\\n                    TreeNode* node=new TreeNode(i);\\n                    node->left=left;\\n                    node->right=right;\\n                  list.push_back(node);\\n                }\\n            }\\n           \\n            \\n        }\\n     return list;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n   // binary search tree left node contain ->(1,i-1)and right child contain (i+1,n)\\n     vector<TreeNode*>ans=generate(1,n);   \\n        return ans;\\n    }\\n\\t//HappyCoding\\n\\t//Stay Safe and healthy\\n\\t//Also if you like the post do upvote and comment",
                "codeTag": "Unknown"
            },
            {
                "id": 164932,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def generateTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        def generate(i,j):\\n            if j-i < 0:\\n                return [None]\\n            elif j-i == 0:\\n                return [TreeNode(i)]\\n            else:\\n                res = []\\n                for k in range(i,j+1):\\n                    left = generate(i,k-1)\\n                    right = generate(k+1,j)\\n                    for l in left:\\n                        for r in right:\\n                            root = TreeNode(k)\\n                            root.left = l\\n                            root.right = r\\n                            res.append(root)\\n                return res\\n        if n == 0:\\n            return []\\n        else:\\n            return generate(1,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def generateTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        def generate(i,j):\\n            if j-i < 0:\\n                return [None]\\n            elif j-i == 0:\\n                return [TreeNode(i)]\\n            else:\\n                res = []\\n                for k in range(i,j+1):\\n                    left = generate(i,k-1)\\n                    right = generate(k+1,j)\\n                    for l in left:\\n                        for r in right:\\n                            root = TreeNode(k)\\n                            root.left = l\\n                            root.right = r\\n                            res.append(root)\\n                return res\\n        if n == 0:\\n            return []\\n        else:\\n            return generate(1,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31523,
                "title": "dp-solution-in-python",
                "content": "----------\\n\\nclass Solution:\\n    # @return a list of tree node\\n\\n    def generateTrees(self, n):\\n        if n == 0:\\n            return [None]\\n        tree_list = [[[None]] * (n + 2) for i in range(n + 2)]\\n        for i in range(1, n + 1):\\n            tree_list[i][i] = [TreeNode(i)]\\n            for j in reversed(range(1, i)):\\n                tree_list[j][i] = []\\n                for k in range(j, i + 1):\\n                    for left in tree_list[j][k - 1]:\\n                        for right in tree_list[k + 1][i]:\\n                            root = TreeNode(k)\\n                            (root.left, root.right) = (left, right)\\n                            tree_list[j][i].append(root)\\n        return tree_list[1][n]",
                "solutionTags": [],
                "code": "----------\\n\\nclass Solution:\\n    # @return a list of tree node\\n\\n    def generateTrees(self, n):\\n        if n == 0:\\n            return [None]\\n        tree_list = [[[None]] * (n + 2) for i in range(n + 2)]\\n        for i in range(1, n + 1):\\n            tree_list[i][i] = [TreeNode(i)]\\n            for j in reversed(range(1, i)):\\n                tree_list[j][i] = []\\n                for k in range(j, i + 1):\\n                    for left in tree_list[j][k - 1]:\\n                        for right in tree_list[k + 1][i]:\\n                            root = TreeNode(k)\\n                            (root.left, root.right) = (left, right)\\n                            tree_list[j][i].append(root)\\n        return tree_list[1][n]",
                "codeTag": "Java"
            },
            {
                "id": 31639,
                "title": "help-simplify-my-code-the-second-one",
                "content": "    class Solution {\\n    private:\\n    \\tvector<TreeNode*> generateTreesRec(int start, int end){\\n    \\t\\tvector<TreeNode*> v;\\n    \\t\\tif(start > end){\\n    \\t\\t\\tv.push_back(NULL);\\n    \\t\\t\\treturn v;\\n    \\t\\t}\\n    \\t\\tfor(int i = start; i <= end; ++i){\\n    \\t\\t\\tvector<TreeNode*> left = generateTreesRec(start, i - 1);\\n    \\t\\t\\tvector<TreeNode*> right = generateTreesRec(i + 1, end);\\n    \\t\\t\\tTreeNode *node;\\n    \\t\\t\\tfor(int j = 0; j < left.size(); ++j){\\n    \\t\\t\\t\\tfor(int k = 0; k < right.size(); ++k){\\n    \\t\\t\\t\\t\\tnode = new TreeNode(i);\\n    \\t\\t\\t\\t\\tnode->left = left[j];\\n    \\t\\t\\t\\t\\tnode->right = right[k];\\n    \\t\\t\\t\\t\\tv.push_back(node);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn v;\\n    \\t}\\n    public:\\n        vector<TreeNode *> generateTrees(int n) {\\n            return generateTreesRec(1, n);\\n        }\\n    };\\n\\nI think one defect of the above code is that it constructs trees interleaving with rather than being independent of each other. For example, if `n == 5` and `3` is selected as root, you'll get four trees as follow:\\n\\n<a href=\"http://www.freeimagehosting.net/xepj1\"><img src=\"http://www.freeimagehosting.net/t/xepj1.jpg\"></a>\\n\\nI prefer to construct independent trees so I write the following code...\\n\\n    class Solution {\\n    private:\\n    \\tTreeNode *constructBSTRec(const string &preorder, int ps, int pe, int is, int ie){\\n    \\t\\tif(ps > pe || is > ie || pe - ps != ie - is) return NULL;\\n    \\t\\tTreeNode *root = new TreeNode(preorder[ps] - '0');\\n    \\t\\tint i = preorder[ps] - '0' - 1;\\n    \\t\\tint leftLen = i - is;\\n    \\t\\troot->left = constructBSTRec(preorder, ps + 1, ps + leftLen, is, i - 1);\\n    \\t\\troot->right = constructBSTRec(preorder, ps + leftLen + 1, pe, i + 1, ie);\\n    \\t\\treturn root;\\n    \\t}\\n    \\tTreeNode *constructBST(const string &preorder){\\n    \\t\\treturn constructBSTRec(preorder, 0, preorder.size() - 1, 0, preorder.size() - 1);\\n    \\t}\\n    \\tvector<string> combine(vector<string> &s1, vector<string> &s2){\\n    \\t\\tif(s1.empty() || s2.empty()){\\n    \\t\\t\\treturn s1.empty() ? s2 : s1;\\n    \\t\\t}\\n    \\t\\tvector<string> v;\\n    \\t\\tfor(int i = 0; i < s1.size(); ++i){\\n    \\t\\t\\tfor(int j = 0; j < s2.size(); ++j){\\n    \\t\\t\\t\\tv.push_back(s1[i] + s2[j]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn v;\\n    \\t}\\n    \\tvector<string> preorderSequence(int start, int end){\\n    \\t\\tvector<string> v;\\n    \\t\\tfor(int i = start; i <= end; ++i){\\n    \\t\\t\\tvector<string> tmp;\\n    \\t\\t\\ttmp.push_back(string(1, i + '0'));\\n    \\t\\t\\tvector<string> left = preorderSequence(start, i - 1);\\n    \\t\\t\\tvector<string> right = preorderSequence(i + 1, end);\\n    \\t\\t\\ttmp = combine(tmp, left);\\n    \\t\\t\\ttmp = combine(tmp, right);\\n    \\t\\t\\tfor(int i = 0; i < tmp.size(); ++i){\\n    \\t\\t\\t\\tv.push_back(tmp[i]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn v;\\n    \\t}\\n    public:\\n        vector<TreeNode *> generateTrees(int n) {\\n        \\tvector<TreeNode*> trees;\\n        \\tif(n < 0) return trees;\\n        \\tif(n == 0){\\n        \\t\\ttrees.push_back(NULL);\\n        \\t\\treturn trees;\\n        \\t}\\n        \\tvector<string> v = preorderSequence(1, n);\\n        \\tfor(int i = 0; i < v.size(); ++i){\\n        \\t\\ttrees.push_back(constructBST(v[i]));\\n        \\t}\\n        \\treturn trees;\\n        }\\n    };\\n\\nThe main idea is to generate preorder sequences of unique BSTs and construct independent BSTs in the end. But I am afraid it's lack of readability. Can you help me simplify it? Any advice?\\n\\n\\n  [1]: http://www.freeimagehosting.net/xepj1",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n    \\tvector<TreeNode*> generateTreesRec(int start, int end){\\n    \\t\\tvector<TreeNode*> v;\\n    \\t\\tif(start > end){\\n    \\t\\t\\tv.push_back(NULL);\\n    \\t\\t\\treturn v;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2212994,
                "title": "dp-solution-in-c-and-java",
                "content": "**Code in C++**\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return subTrees(1, n);\\n    }\\nprivate:\\n    vector<TreeNode*> subTrees(int start, int end){\\n        vector<TreeNode*> res;\\n        if(start>end){\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        for(int i=start; i<=end; i++){\\n            vector<TreeNode*> left = subTrees(start, i-1);\\n            vector<TreeNode*> right = subTrees(i+1, end);\\n            for(TreeNode* l: left){\\n                for(TreeNode* r: right){\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = l;\\n                    root->right = r;\\n                    res.push_back(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Code in Java**\\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return subTrees(1, n);\\n    }\\n    private List<TreeNode> subTrees(int start, int end){\\n        List<TreeNode> res = new ArrayList();\\n        if(start>end) {\\n            res.add(null);\\n            return res;\\n        }\\n        for(int i=start; i<=end; i++){\\n            List<TreeNode> left = subTrees(start, i-1);\\n            List<TreeNode> right = subTrees(i+1, end);\\n            for(TreeNode l: left){\\n                for(TreeNode r: right){\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = l;\\n                    root.right = r;\\n                    res.add(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```\\n**Please upvote if you found the solution helpful**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return subTrees(1, n);\\n    }\\nprivate:\\n    vector<TreeNode*> subTrees(int start, int end){\\n        vector<TreeNode*> res;\\n        if(start>end){\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        for(int i=start; i<=end; i++){\\n            vector<TreeNode*> left = subTrees(start, i-1);\\n            vector<TreeNode*> right = subTrees(i+1, end);\\n            for(TreeNode* l: left){\\n                for(TreeNode* r: right){\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = l;\\n                    root->right = r;\\n                    res.push_back(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return subTrees(1, n);\\n    }\\n    private List<TreeNode> subTrees(int start, int end){\\n        List<TreeNode> res = new ArrayList();\\n        if(start>end) {\\n            res.add(null);\\n            return res;\\n        }\\n        for(int i=start; i<=end; i++){\\n            List<TreeNode> left = subTrees(start, i-1);\\n            List<TreeNode> right = subTrees(i+1, end);\\n            for(TreeNode l: left){\\n                for(TreeNode r: right){\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = l;\\n                    root.right = r;\\n                    res.add(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730933,
                "title": "easy-java-solution-faster-than-96",
                "content": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if(n < 1)return Collections.EMPTY_LIST;\\n        return helper(1,n);\\n    }\\n    \\n    private List<TreeNode> helper(int start , int end){\\n        List<TreeNode> ans = new ArrayList<>();\\n        if(start > end){\\n            ans.add(null);\\n            return ans;\\n        }\\n        \\n       for(int i = start ; i <= end ;i++ ){\\n           List<TreeNode> left = helper(start , i - 1);\\n           List<TreeNode> right = helper(i + 1 , end);\\n           \\n           for(TreeNode l : left){\\n               for(TreeNode r : right){\\n                 TreeNode root = new TreeNode(i);\\n                   root.left = l;\\n                   root.right = r;\\n                   ans.add(root);\\n               }\\n           }\\n           \\n       }\\n     return ans;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if(n < 1)return Collections.EMPTY_LIST;\\n        return helper(1,n);\\n    }\\n    \\n    private List<TreeNode> helper(int start , int end){\\n        List<TreeNode> ans = new ArrayList<>();\\n        if(start > end){\\n            ans.add(null);\\n            return ans;\\n        }\\n        \\n       for(int i = start ; i <= end ;i++ ){\\n           List<TreeNode> left = helper(start , i - 1);\\n           List<TreeNode> right = helper(i + 1 , end);\\n           \\n           for(TreeNode l : left){\\n               for(TreeNode r : right){\\n                 TreeNode root = new TreeNode(i);\\n                   root.left = l;\\n                   root.right = r;\\n                   ans.add(root);\\n               }\\n           }\\n           \\n       }\\n     return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720284,
                "title": "python-recursive-explanation",
                "content": "1. For every node with value `val`\\n\\t* **Left subtree\\'s root**\\'s value must be in `[1, val - 1]`\\n\\n\\t* **Right subtree\\'s root**\\'s value must be in `[val + 1, n]` \\n\\n2. Now, what **root value** do we get to try in each recursive call? We try root values in `[start, end]`\\n\\n3. This means for each root, there is a combination / list of `left` and `right` sub**trees** we get to try. (This explains the 2 `for-loops` in the recursive call)\\n\\n4. Therefore, this is what the `build` function does.\\n\\n\\t* Generates a **root** with `val` between `[start, end]`\\n\\n\\t* Generates **all** possible **left** subtree roots with value between `[start, val - 1]`\\n\\n\\t* Generates **all** possible **right** subtree roots with value between `[val + 1, end]`\\n\\n\\t* For **every of these combinations**, it creates a brand new tree and adds it to `trees` before returning it in each recursive call\\n \\n<br><br>\\n\\n```\\nclass Solution:\\n    \\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        # EDGE CASE\\n        if n == 0:\\n            return []\\n        \\n\\t\\t# CALL ON  BUILD() TO RETURN THE LIST OF ROOTS\\n        return self.build(1, n)\\n    \\n        \\n    def build(self, start, end):\\n        trees = []\\n        \\n        # CHOOSE A ROOT VALUE ANYWHERE BETWEEN [START, END]\\n        for val in range(start, end + 1):\\n            \\n            # ATTACH ROOT TO EVERY POSSIBLE LEFT SUBTREE\\n            for left in self.build(start, val - 1):\\n                \\n                # ATTACH ROOT TO EVERY POSSIBLE RIGHT SUBTREE\\n                for right in self.build(val + 1, end):\\n                    \\n                    # CREATE A TREE AND ADD IT\\n                    trees.append(TreeNode(val, left, right))\\n                    \\n        # [NONE] = THE EMPTY TREE\\n        return trees or [None]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        # EDGE CASE\\n        if n == 0:\\n            return []\\n        \\n\\t\\t# CALL ON  BUILD() TO RETURN THE LIST OF ROOTS\\n        return self.build(1, n)\\n    \\n        \\n    def build(self, start, end):\\n        trees = []\\n        \\n        # CHOOSE A ROOT VALUE ANYWHERE BETWEEN [START, END]\\n        for val in range(start, end + 1):\\n            \\n            # ATTACH ROOT TO EVERY POSSIBLE LEFT SUBTREE\\n            for left in self.build(start, val - 1):\\n                \\n                # ATTACH ROOT TO EVERY POSSIBLE RIGHT SUBTREE\\n                for right in self.build(val + 1, end):\\n                    \\n                    # CREATE A TREE AND ADD IT\\n                    trees.append(TreeNode(val, left, right))\\n                    \\n        # [NONE] = THE EMPTY TREE\\n        return trees or [None]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688947,
                "title": "javascript-solution-top-down-bottom-up-approach",
                "content": "**Top-Down Approach:**\\n\\n```\\nvar generateTrees = function(n) {\\n    if (n == 0) return [];\\n    \\n    return findAllUniqueTrees(1, n);\\n\\n    function findAllUniqueTrees(start, end) {\\n        const ans = [];\\n        \\n        // base case\\n        if (start > end) {\\n            ans.push(null);\\n            return ans;\\n        };\\n        \\n        if (start == end) {\\n            ans.push(new TreeNode(start));\\n            return ans;\\n        }\\n        \\n        for (let i = start; i <= end; i++) {\\n            const leftSubTrees = findAllUniqueTrees(start, i - 1);\\n            const rightSubTrees = findAllUniqueTrees(i + 1, end);\\n            \\n            for (const leftSubTree of leftSubTrees) {\\n                for (const rightSubTree of rightSubTrees) {\\n                    const root = new TreeNode(i);\\n                    root.left = leftSubTree;\\n                    root.right = rightSubTree;\\n                    ans.push(root);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n<br>\\n\\n---\\n\\n<br>\\n\\n**Bottom-Up Approach:**\\n\\nI did not implement a clone/copy function for the subtrees. Instead, I connected multiple roots to each subtrees. I know this might not be ideal, but it seem to be an acceptable approach from observing solutions to other similar questions.\\n\\nFew personal comments about this problem. There were parts of it that I found difficult which generally transfer over to dynamic programming problems. One was keeping track of the off-by-one issues involving the index of the dp grid vs. the actual number used for root. Also, prior to this problem, I did not quite grasp the relationship amongst the indexes of the 3 nested for-loops. Although not completely, but I felt that this problem gave me a better understanding of them and was definitely was a good practice. Second, thanks to [@zmj97](https://leetcode.com/problems/unique-binary-search-trees-ii/discuss/671388/javascript-dp-solution) providing the idea of what to do when there is no left or right subtree. Like many people, dynamic programming is a problem that I have found difficult to master. However, recently I have committed myself to improving that weakness and hopefully will get better in due time. If anybody has any questions or constructive criticism of ways of improving my solution or approaches to dynamic programming in general, please feel free to leave your comments below. Thank you.\\n\\n<br>\\n\\n```\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    var dp = [];\\n    \\n    for (var i = 0; i < n; i++) {\\n        dp[i] = [];\\n        for (var j = 0; j < n; j++) {\\n            dp[i][j] = [];\\n        }\\n    }\\n\\n    for (var len = 2; len <= n; len++) {\\n        for (var start = 1; start <= n - len + 1; start++) {\\n            const end = start + len - 1;\\n            for (let mid = start; mid <= end; mid++) {\\n                const leftSubTrees = mid - 1 - 1 < 0 ? [] : dp[start - 1][mid - 1 - 1];\\n                const rightSubTrees = mid + 1 - 1 >= n ? [] : dp[mid + 1 - 1][end - 1];\\n                \\n                if (leftSubTrees.length == 0) leftSubTrees.push(null);\\n                if (rightSubTrees.length == 0) rightSubTrees.push(null);\\n                \\n                for (const leftSubTree of leftSubTrees) {\\n                    for (const rightSubTree of rightSubTrees) {\\n                        const root = new TreeNode(mid);\\n                        root.left = leftSubTree;\\n                        root.right = rightSubTree;\\n                        dp[start - 1][end - 1].push(root);\\n                    }\\n                }\\n            }\\n        }\\n    \\n    }\\n\\n    return dp[0][n - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar generateTrees = function(n) {\\n    if (n == 0) return [];\\n    \\n    return findAllUniqueTrees(1, n);\\n\\n    function findAllUniqueTrees(start, end) {\\n        const ans = [];\\n        \\n        // base case\\n        if (start > end) {\\n            ans.push(null);\\n            return ans;\\n        };\\n        \\n        if (start == end) {\\n            ans.push(new TreeNode(start));\\n            return ans;\\n        }\\n        \\n        for (let i = start; i <= end; i++) {\\n            const leftSubTrees = findAllUniqueTrees(start, i - 1);\\n            const rightSubTrees = findAllUniqueTrees(i + 1, end);\\n            \\n            for (const leftSubTree of leftSubTrees) {\\n                for (const rightSubTree of rightSubTrees) {\\n                    const root = new TreeNode(i);\\n                    root.left = leftSubTree;\\n                    root.right = rightSubTree;\\n                    ans.push(root);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    var dp = [];\\n    \\n    for (var i = 0; i < n; i++) {\\n        dp[i] = [];\\n        for (var j = 0; j < n; j++) {\\n            dp[i][j] = [];\\n        }\\n    }\\n\\n    for (var len = 2; len <= n; len++) {\\n        for (var start = 1; start <= n - len + 1; start++) {\\n            const end = start + len - 1;\\n            for (let mid = start; mid <= end; mid++) {\\n                const leftSubTrees = mid - 1 - 1 < 0 ? [] : dp[start - 1][mid - 1 - 1];\\n                const rightSubTrees = mid + 1 - 1 >= n ? [] : dp[mid + 1 - 1][end - 1];\\n                \\n                if (leftSubTrees.length == 0) leftSubTrees.push(null);\\n                if (rightSubTrees.length == 0) rightSubTrees.push(null);\\n                \\n                for (const leftSubTree of leftSubTrees) {\\n                    for (const rightSubTree of rightSubTrees) {\\n                        const root = new TreeNode(mid);\\n                        root.left = leftSubTree;\\n                        root.right = rightSubTree;\\n                        dp[start - 1][end - 1].push(root);\\n                    }\\n                }\\n            }\\n        }\\n    \\n    }\\n\\n    return dp[0][n - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31600,
                "title": "quite-clean-java-solution-with-explanation",
                "content": "For all possible root of the trees (i.e. 1, 2, ..., n), get the list of left subtrees and list of right subtrees, recursively. Now, for every left and right subtree combination, create a new tree and add to resultant list.\\n\\nHere, \"start > end\" becomes the base case for recursion, for which I add \"null\" as the only element of list, which will form the only possible left or right subtree. (To understand why this works, check with n = 1).\\n\\nn = 0 is handled separately, since leetcode expects an empty list, rather than a list with a null value.\\n\\n    public class Solution {\\n        public List<TreeNode> generateTrees(int n) {\\n            if(n == 0)\\n                return new ArrayList<TreeNode>();\\n            return generateTrees(1, n);\\n        }\\n        \\n        List<TreeNode> generateTrees(int start, int end) {\\n            List<TreeNode> result = new ArrayList<TreeNode>();\\n            if(start > end) {\\n                result.add(null);\\n                return result;\\n            }\\n            for(int i = start; i <= end; i++) {\\n                List<TreeNode> leftSubTrees = generateTrees(start, i - 1);\\n                List<TreeNode> rightSubTrees = generateTrees(i + 1, end);\\n                for(TreeNode left : leftSubTrees) {\\n                    for(TreeNode right : rightSubTrees) {\\n                        TreeNode root = new TreeNode(i);\\n                        root.left = left;\\n                        root.right = right;\\n                        result.add(root);\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<TreeNode> generateTrees(int n) {\\n            if(n == 0)\\n                return new ArrayList<TreeNode>();\\n            return generateTrees(1, n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3187679,
                "title": "94-15-unique-binary-search-trees-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo generate all structurally unique BST\\'s with n nodes, we can use a recursive approach. The idea is to fix each number i (1 <= i <= n) as the root of the tree and then recursively generate all the left and right subtrees that can be formed using the remaining numbers (1, 2, ..., i-1) and (i+1, i+2, ..., n) respectively.\\n\\nFor example, to generate all the BST\\'s with 3 nodes, we can fix 1 as the root and recursively generate all the BST\\'s with 0 and 2 nodes respectively. Then we can fix 2 as the root and recursively generate all the BST\\'s with 1 node on the left and 1 node on the right. Finally, we can fix 3 as the root and recursively generate all the BST\\'s with 2 and 0 nodes respectively.\\n\\nTo avoid generating duplicate trees, we can use memoization to store the trees generated for each combination of left and right subtree sizes.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n89.57%\\n\\n- Space complexity:\\nBeats\\n94.15%\\n\\n# Code\\n```\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\nclass Solution:\\n   def generateTrees(self, n: \\'int\\') -> \\'List[TreeNode]\\':\\n    memo = {}\\n    \\n    def generate_trees_helper(start: int, end: int) -> List[TreeNode]:\\n        if start > end:\\n            return [None]\\n        \\n        if (start, end) in memo:\\n            return memo[(start, end)]\\n        \\n        result = []\\n        \\n        for i in range(start, end+1):\\n            left_subtrees = generate_trees_helper(start, i-1)\\n            right_subtrees = generate_trees_helper(i+1, end)\\n            \\n            for left in left_subtrees:\\n                for right in right_subtrees:\\n                    root = TreeNode(i)\\n                    root.left = left\\n                    root.right = right\\n                    result.append(root)\\n        \\n        memo[(start, end)] = result\\n        \\n        return result\\n    \\n    return generate_trees_helper(1, n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\nclass Solution:\\n   def generateTrees(self, n: \\'int\\') -> \\'List[TreeNode]\\':\\n    memo = {}\\n    \\n    def generate_trees_helper(start: int, end: int) -> List[TreeNode]:\\n        if start > end:\\n            return [None]\\n        \\n        if (start, end) in memo:\\n            return memo[(start, end)]\\n        \\n        result = []\\n        \\n        for i in range(start, end+1):\\n            left_subtrees = generate_trees_helper(start, i-1)\\n            right_subtrees = generate_trees_helper(i+1, end)\\n            \\n            for left in left_subtrees:\\n                for right in right_subtrees:\\n                    root = TreeNode(i)\\n                    root.left = left\\n                    root.right = right\\n                    result.append(root)\\n        \\n        memo[(start, end)] = result\\n        \\n        return result\\n    \\n    return generate_trees_helper(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299072,
                "title": "c-16ms-beats-98-1-of-cpp-submissions",
                "content": "```\\nvector<TreeNode*> genTreesUtil(int beg, int end) {\\n\\tif (end < beg) return { nullptr };\\n\\tif (end == beg) return { new TreeNode(beg) };\\n\\n\\tvector<TreeNode*> trees;\\n\\tfor (int i = beg; i <= end; ++i) {\\n\\n\\t\\tauto leftTrees = genTreesUtil(beg, i - 1);\\n\\t\\tauto rightTrees = genTreesUtil(i + 1, end);\\n\\n\\t\\tfor (auto& l : leftTrees)\\n\\t\\t\\tfor (auto& r : rightTrees) {\\n\\t\\t\\t\\tauto t = new TreeNode(i);\\n\\t\\t\\t\\tt->left = l;\\n\\t\\t\\t\\tt->right = r;\\n\\n\\t\\t\\t\\ttrees.push_back(t);\\n\\t\\t\\t}\\n\\t}\\n\\n\\treturn trees;\\n}\\n\\nvector<TreeNode*> generateTrees(int n) {\\n\\tif (n == 0) return {};\\n\\treturn genTreesUtil(1, n);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nvector<TreeNode*> genTreesUtil(int beg, int end) {\\n\\tif (end < beg) return { nullptr };\\n\\tif (end == beg) return { new TreeNode(beg) };\\n\\n\\tvector<TreeNode*> trees;\\n\\tfor (int i = beg; i <= end; ++i) {\\n\\n\\t\\tauto leftTrees = genTreesUtil(beg, i - 1);\\n\\t\\tauto rightTrees = genTreesUtil(i + 1, end);\\n\\n\\t\\tfor (auto& l : leftTrees)\\n\\t\\t\\tfor (auto& r : rightTrees) {\\n\\t\\t\\t\\tauto t = new TreeNode(i);\\n\\t\\t\\t\\tt->left = l;\\n\\t\\t\\t\\tt->right = r;\\n\\n\\t\\t\\t\\ttrees.push_back(t);\\n\\t\\t\\t}\\n\\t}\\n\\n\\treturn trees;\\n}\\n\\nvector<TreeNode*> generateTrees(int n) {\\n\\tif (n == 0) return {};\\n\\treturn genTreesUtil(1, n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31627,
                "title": "a-straightforward-python-solution",
                "content": "    from itertools import product\\n    \\n    class Solution:\\n        # @param {integer} n\\n        # @return {TreeNode[]}\\n        def generateTrees(self, n):\\n            return self.BST([i+1 for i in range(n)])\\n            \\n        def BST(self, nodes):\\n            trees = []\\n            for i in range(len(nodes)):\\n                for leftSubTree, rightSubTree in product(self.BST(nodes[:i]), self.BST(nodes[i+1:])):\\n                    root = TreeNode(nodes[i])\\n                    root.left, root.right = leftSubTree, rightSubTree\\n                    trees.append(root)\\n                \\n            return trees or [None]",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 31638,
                "title": "python-accepted-python-code",
                "content": "    class Solution:\\n        # @return a list of tree node\\n        def generate(self,s,t):\\n            '''recursion with left and right branches'''\\n            if s>t:return [None];\\n            if s==t:return [TreeNode(s)];\\n            re=[];\\n            for i in range(s,t+1):\\n                left=self.generate(s,i-1);\\n                right=self.generate(i+1,t);\\n                for l in left:\\n                    for r in right:\\n                        tmp=TreeNode(i);\\n                        tmp.left=l;\\n                        tmp.right=r;\\n                        re.append(tmp);\\n            return re;\\n        def generateTrees(self, n):\\n            return self.generate(1,n);\\n\\nthe code is straight forward,first generate the left tree, then generate the right tree. for each left and right tree, generate the tree with root.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @return a list of tree node\\n        def generate(self,s,t):\\n            '''recursion with left and right branches'''\\n            if s>t:return [None];\\n            if s==t:return [TreeNode(s)];\\n            re=[];\\n            for i in range(s,t+1):\\n                left=self.generate(s,i-1);\\n                right=self.generate(i+1,t);\\n                for l in left:\\n                    for r in right:\\n                        tmp=TreeNode(i);\\n                        tmp.left=l;\\n                        tmp.right=r;\\n                        re.append(tmp);\\n            return re;\\n        def generateTrees(self, n):\\n            return self.generate(1,n);\\n\\nthe code is straight forward,first generate the left tree, then generate the right tree. for each left and right tree, generate the tree with root.",
                "codeTag": "Java"
            },
            {
                "id": 3837403,
                "title": "c-recursive-catalan-number-like-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse 3D array for TreeNode* as memoization. Solve it recursely with memo. Again a DP solution is done. \\n\\nThis code generates all possible unique binary search trees  for a given range [1, n] using dynamic programming. It uses a 3D vector \\'dp\\' to store computed values and avoids redundant calculations. The function \\'BSTree\\' recursively forms BSTs for each range [s, e], combining left and right subtrees. The \\'generateTrees\\' function initializes \\'dp\\', then calls \\'BSTree\\' with range [1, n] to compute all unique BSTs. The approach is efficient and relates to Catalan numbers, representing the number of BSTs that can be formed using \\'n\\' nodes.\\n\\n# Catalan numbers\\nCatalan numbers can be given by a recursive way as follows\\n$$ \\nG(0)=1, G(n)=\\\\sum_{i=1}^nG(i-1)G(n-i)\\n$$\\nThe solution is related to this recursive recurrence.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimilar idea as in solving the hard question 894. All Possible Full Binary Trees.\\n[Please Turn on English subtitles if neccessary]\\n[https://youtu.be/AVbHDf6H_gE](https://youtu.be/AVbHDf6H_gE)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n * G(n))$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n^2 * G(n))$\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<vector<TreeNode*>>> dp;\\n    \\n    vector<TreeNode*> BSTree(int s, int e){\\n        if (s > e) return {NULL};\\n        if (s == e) return {new TreeNode(s)};\\n        \\n        if (dp[s][e].size()>0) return dp[s][e];\\n        \\n        vector<TreeNode*> ans;\\n        for (int j = s; j <= e; j++) {\\n            vector<TreeNode*> Left = BSTree(s, j - 1);\\n            vector<TreeNode*> Right = BSTree(j + 1, e);\\n            \\n            for (TreeNode* l : Left) {\\n                for (TreeNode* r : Right) {\\n                    TreeNode* root = new TreeNode(j, l, r);\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return dp[s][e] = ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        dp.assign(n+1, vector(n+1, vector<TreeNode*>()));\\n        return BSTree(1, n);\\n    }\\n};\\n```\\n# Code with Explanation in comments\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<TreeNode*>>> dp; // 3D vector to store computed values for dynamic programming\\n    \\n    // Function to generate all possible unique binary search trees given a range [s, e]\\n    vector<TreeNode*> BSTree(int s, int e) {\\n        // Base cases: If the range is invalid or contains a single element, return appropriate values.\\n        if (s > e) return {NULL}; // A single element in the range [s, e] cannot form a tree, so return NULL.\\n        if (s == e) return {new TreeNode(s)}; // A single element in the range is a valid tree by itself.\\n\\n        if (dp[s][e].size() > 0) return dp[s][e]; // If the value has already been computed, return it from the dp array.\\n\\n        vector<TreeNode*> ans; // Vector to store all possible BSTs in the range [s, e].\\n\\n        // Loop through each possible root node value (j) in the range [s, e]\\n        for (int j = s; j <= e; j++) {\\n            // Recursively generate all possible left subtrees (Left) from range [s, j-1]\\n            vector<TreeNode*> Left = BSTree(s, j - 1);\\n\\n            // Recursively generate all possible right subtrees (Right) from range [j+1, e]\\n            vector<TreeNode*> Right = BSTree(j + 1, e);\\n\\n            // Combine all possible combinations of left and right subtrees with the current root value (j)\\n            for (TreeNode* l : Left) {\\n                for (TreeNode* r : Right) {\\n                    TreeNode* root = new TreeNode(j, l, r); // Create a new tree with root value (j), left subtree (l), and right subtree (r).\\n                    ans.push_back(root); // Add the current tree to the result vector.\\n                }\\n            }\\n        }\\n\\n        return dp[s][e] = ans; // Store the computed value in the dp array and return the result.\\n    }\\n\\n    vector<TreeNode*> generateTrees(int n) {\\n        dp.assign(n + 1, vector(n + 1, vector<TreeNode*>())); // Initialize the dp array with dimensions (n+1) x (n+1) x unknown.\\n        return BSTree(1, n); // Call the helper function with the range [1, n] to generate all possible BSTs from 1 to n.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<vector<TreeNode*>>> dp;\\n    \\n    vector<TreeNode*> BSTree(int s, int e){\\n        if (s > e) return {NULL};\\n        if (s == e) return {new TreeNode(s)};\\n        \\n        if (dp[s][e].size()>0) return dp[s][e];\\n        \\n        vector<TreeNode*> ans;\\n        for (int j = s; j <= e; j++) {\\n            vector<TreeNode*> Left = BSTree(s, j - 1);\\n            vector<TreeNode*> Right = BSTree(j + 1, e);\\n            \\n            for (TreeNode* l : Left) {\\n                for (TreeNode* r : Right) {\\n                    TreeNode* root = new TreeNode(j, l, r);\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return dp[s][e] = ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        dp.assign(n+1, vector(n+1, vector<TreeNode*>()));\\n        return BSTree(1, n);\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<TreeNode*>>> dp; // 3D vector to store computed values for dynamic programming\\n    \\n    // Function to generate all possible unique binary search trees given a range [s, e]\\n    vector<TreeNode*> BSTree(int s, int e) {\\n        // Base cases: If the range is invalid or contains a single element, return appropriate values.\\n        if (s > e) return {NULL}; // A single element in the range [s, e] cannot form a tree, so return NULL.\\n        if (s == e) return {new TreeNode(s)}; // A single element in the range is a valid tree by itself.\\n\\n        if (dp[s][e].size() > 0) return dp[s][e]; // If the value has already been computed, return it from the dp array.\\n\\n        vector<TreeNode*> ans; // Vector to store all possible BSTs in the range [s, e].\\n\\n        // Loop through each possible root node value (j) in the range [s, e]\\n        for (int j = s; j <= e; j++) {\\n            // Recursively generate all possible left subtrees (Left) from range [s, j-1]\\n            vector<TreeNode*> Left = BSTree(s, j - 1);\\n\\n            // Recursively generate all possible right subtrees (Right) from range [j+1, e]\\n            vector<TreeNode*> Right = BSTree(j + 1, e);\\n\\n            // Combine all possible combinations of left and right subtrees with the current root value (j)\\n            for (TreeNode* l : Left) {\\n                for (TreeNode* r : Right) {\\n                    TreeNode* root = new TreeNode(j, l, r); // Create a new tree with root value (j), left subtree (l), and right subtree (r).\\n                    ans.push_back(root); // Add the current tree to the result vector.\\n                }\\n            }\\n        }\\n\\n        return dp[s][e] = ans; // Store the computed value in the dp array and return the result.\\n    }\\n\\n    vector<TreeNode*> generateTrees(int n) {\\n        dp.assign(n + 1, vector(n + 1, vector<TreeNode*>())); // Initialize the dp array with dimensions (n+1) x (n+1) x unknown.\\n        return BSTree(1, n); // Call the helper function with the range [1, n] to generate all possible BSTs from 1 to n.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491113,
                "title": "python-elegant-short-three-lines-top-down-dp-lru-cache",
                "content": "# Complexity\\n- Time complexity: $$O(n!)$$\\n- Space complexity: $$O(n^{3})$$\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        return self.__generate(lo=1, hi=n)\\n\\n    @classmethod\\n    @cache\\n    def __generate(cls, lo: int, hi: int) -> list:\\n        if lo > hi:\\n            return [None]\\n        return [\\n            TreeNode(root, left, right)\\n            for root in range(lo, hi + 1)              # All possible roots for the current subarray\\n            for left in cls.__generate(lo, root - 1)   # All possible trees to the left of the root element\\n            for right in cls.__generate(root + 1, hi)  # All possible trees to the right of the root element\\n        ]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        return self.__generate(lo=1, hi=n)\\n\\n    @classmethod\\n    @cache\\n    def __generate(cls, lo: int, hi: int) -> list:\\n        if lo > hi:\\n            return [None]\\n        return [\\n            TreeNode(root, left, right)\\n            for root in range(lo, hi + 1)              # All possible roots for the current subarray\\n            for left in cls.__generate(lo, root - 1)   # All possible trees to the left of the root element\\n            for right in cls.__generate(root + 1, hi)  # All possible trees to the right of the root element\\n        ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495639,
                "title": "12-ms-97-faster-cpp-solution-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> helper(int start, int end){\\n        vector<TreeNode*> ans;\\n        if(start > end){\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        for(int i = start; i <= end; i++){\\n            auto left = helper(start, i - 1);\\n            auto right = helper(i + 1, end);\\n            \\n            for(auto l : left){\\n                for(auto r : right){\\n                    TreeNode* root = new TreeNode(i);\\n                    \\n                    root->left = l;\\n                    root->right = r;\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        auto h = helper(1, n);\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> helper(int start, int end){\\n        vector<TreeNode*> ans;\\n        if(start > end){\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        for(int i = start; i <= end; i++){\\n            auto left = helper(start, i - 1);\\n            auto right = helper(i + 1, end);\\n            \\n            for(auto l : left){\\n                for(auto r : right){\\n                    TreeNode* root = new TreeNode(i);\\n                    \\n                    root->left = l;\\n                    root->right = r;\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        auto h = helper(1, n);\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865956,
                "title": "simple-java-solution-with-comments-1-ms-recursive",
                "content": "Algorithm:\\n\\n- Imagine the input as a continuous array of integers.\\n- move in a sliding window fashion considering every element as possible root.\\n- For every element chosen as root\\n\\t- everything in the array on the left will form the possible left subtrees\\n\\t- everything in the array on the right will form the possible right subtrees\\n- Use this list of generated subtrees to form the complete forest\\n\\n```\\nclass Solution {\\n    \\n    public List<TreeNode> generateTrees(int n) {\\n        return treeBuilder(1, n);\\n    }\\n    \\n    private List<TreeNode> treeBuilder(int start, int end) {\\n        if(start > end) return Collections.emptyList();\\n        List<TreeNode> res = new ArrayList<>();\\n        // n == 1\\n        if(start == end) {\\n            res.add(new TreeNode(start));\\n            return res;\\n        }\\n        \\n        // n == 2\\n        if( start+1 == end) {\\n            res.add(new TreeNode(start, null, new TreeNode(start+1)));\\n            res.add(new TreeNode(start+1, new TreeNode(start), null));\\n            return res;\\n        }\\n        \\n        for(int i=start; i<=end; i++) {\\n            TreeNode newRoot = new TreeNode(i);\\n            List<TreeNode> left = treeBuilder(start, i-1); // build trees only using left elements\\n            List<TreeNode> right = treeBuilder(i+1, end); // build trees only using right elements\\n            \\n            if(left.size() == 0) { // No left subtrees possible\\n                for(TreeNode node : right) {\\n                    newRoot.right = node;\\n                    res.add(copyTree(newRoot));\\n                    newRoot.right = null;\\n                }\\n            } else if(right.size() == 0) { // No right subtrees possible\\n                for(TreeNode node : left) {\\n                    newRoot.left = node;\\n                    res.add(copyTree(newRoot));\\n                    newRoot.left = null;\\n                }\\n            } else {\\n\\t\\t\\t\\t// For every left subtree; process every possibility of right subtree\\n\\t\\t\\t\\t// This is analogous to taking a cartesian product of possibilities\\n                for (TreeNode node : left) {\\n                    newRoot.left = node;\\n                    for(TreeNode node1 : right) {\\n                        newRoot.right = node1;\\n                        res.add(copyTree(newRoot));\\n                        newRoot.right = null;\\n                    }\\n                    newRoot.left = null;\\n                }\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n    // Helper Function to deep copy a given tree\\n    private TreeNode copyTree (TreeNode head) {\\n        if(head == null) return head;\\n        TreeNode temp = new TreeNode(head.val);\\n        temp.left = copyTree(head.left);\\n        temp.right = copyTree(head.right);\\n        return temp;\\n    }\\n}\\n```\\n\\n**Please Vote up, if this helped you!!**\\n\\nHappy Coding! :)",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<TreeNode> generateTrees(int n) {\\n        return treeBuilder(1, n);\\n    }\\n    \\n    private List<TreeNode> treeBuilder(int start, int end) {\\n        if(start > end) return Collections.emptyList();\\n        List<TreeNode> res = new ArrayList<>();\\n        // n == 1\\n        if(start == end) {\\n            res.add(new TreeNode(start));\\n            return res;\\n        }\\n        \\n        // n == 2\\n        if( start+1 == end) {\\n            res.add(new TreeNode(start, null, new TreeNode(start+1)));\\n            res.add(new TreeNode(start+1, new TreeNode(start), null));\\n            return res;\\n        }\\n        \\n        for(int i=start; i<=end; i++) {\\n            TreeNode newRoot = new TreeNode(i);\\n            List<TreeNode> left = treeBuilder(start, i-1); // build trees only using left elements\\n            List<TreeNode> right = treeBuilder(i+1, end); // build trees only using right elements\\n            \\n            if(left.size() == 0) { // No left subtrees possible\\n                for(TreeNode node : right) {\\n                    newRoot.right = node;\\n                    res.add(copyTree(newRoot));\\n                    newRoot.right = null;\\n                }\\n            } else if(right.size() == 0) { // No right subtrees possible\\n                for(TreeNode node : left) {\\n                    newRoot.left = node;\\n                    res.add(copyTree(newRoot));\\n                    newRoot.left = null;\\n                }\\n            } else {\\n\\t\\t\\t\\t// For every left subtree; process every possibility of right subtree\\n\\t\\t\\t\\t// This is analogous to taking a cartesian product of possibilities\\n                for (TreeNode node : left) {\\n                    newRoot.left = node;\\n                    for(TreeNode node1 : right) {\\n                        newRoot.right = node1;\\n                        res.add(copyTree(newRoot));\\n                        newRoot.right = null;\\n                    }\\n                    newRoot.left = null;\\n                }\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n    // Helper Function to deep copy a given tree\\n    private TreeNode copyTree (TreeNode head) {\\n        if(head == null) return head;\\n        TreeNode temp = new TreeNode(head.val);\\n        temp.left = copyTree(head.left);\\n        temp.right = copyTree(head.right);\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526542,
                "title": "c-simple-recursive-solution-detailed-explanation",
                "content": "```\\n/*\\n    95. Unique Binary Search Trees II\\n    https://leetcode.com/problems/unique-binary-search-trees-ii/\\n*/\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> createTree(int start, int end) {\\n        // base case: return nullptr\\n        if(end < start)\\n            return vector<TreeNode*>{nullptr};\\n\\n        vector<TreeNode*> ans;\\n        // for current interval each number is taken as root once\\n        for(int i = start; i <= end; i++) {\\n            vector<TreeNode*> left_subtree, right_subtree;\\n            // recurse for left and right subtrees\\n            left_subtree = createTree(start, i-1);\\n            right_subtree = createTree(i+1, end);\\n            \\n            // fixing the current root, traverse through the ]\\n            // different root nodes of left and right subtrees and\\n            // make them the child nodes one by one\\n            for(int j = 0; j < left_subtree.size(); j++) {\\n                for(int k = 0; k < right_subtree.size(); k++) {\\n                    // create the root \\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = left_subtree[j];\\n                    root->right = right_subtree[k];\\n                    ans.emplace_back(root);\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n <= 0)\\n            return vector<TreeNode*>{};\\n        return createTree(1, n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    95. Unique Binary Search Trees II\\n    https://leetcode.com/problems/unique-binary-search-trees-ii/\\n*/\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> createTree(int start, int end) {\\n        // base case: return nullptr\\n        if(end < start)\\n            return vector<TreeNode*>{nullptr};\\n\\n        vector<TreeNode*> ans;\\n        // for current interval each number is taken as root once\\n        for(int i = start; i <= end; i++) {\\n            vector<TreeNode*> left_subtree, right_subtree;\\n            // recurse for left and right subtrees\\n            left_subtree = createTree(start, i-1);\\n            right_subtree = createTree(i+1, end);\\n            \\n            // fixing the current root, traverse through the ]\\n            // different root nodes of left and right subtrees and\\n            // make them the child nodes one by one\\n            for(int j = 0; j < left_subtree.size(); j++) {\\n                for(int k = 0; k < right_subtree.size(); k++) {\\n                    // create the root \\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = left_subtree[j];\\n                    root->right = right_subtree[k];\\n                    ans.emplace_back(root);\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n <= 0)\\n            return vector<TreeNode*>{};\\n        return createTree(1, n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480196,
                "title": "two-python-sol-based-on-dp-and-recursion-with-memorization-with-explanation",
                "content": "Two Python sol. based on DP and recursion with memorization\\n\\n------------------------------------------\\n\\nMethod_#1: bottom-up dynamic programming\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    \\n    \\n    def clone_with_offset(self, node: TreeNode, offset):\\n        \\n        if not node:\\n            return None\\n        \\n        else:\\n            \\n            # Clone whole tree with constant value offset\\n            root_node = TreeNode( node.val + offset )\\n            root_node.left = self.clone_with_offset( node.left, offset )\\n            root_node.right = self.clone_with_offset( node.right, offset )\\n            \\n            return root_node\\n    \\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        \\n        if n == 0:\\n            # Quick response for empty tree\\n            return []\\n        \\n        # dynamic programming table\\n        bst_dp_table = [ None for i in range(n+1) ]\\n        \\n        # base case: \\n        bst_dp_table[0] = [None]\\n        \\n        \\n        # bottom-up. build bst with k nodes, k from 1 to n\\n        for number_of_nodes in range(1, n+1):\\n            \\n            bst_dp_table[number_of_nodes] = []\\n            \\n            # for root node of bst:     1 node                            \\n            # for left-subtree of bst : (number_of_nodes_on_left) nodes     \\n            # for right-subtrr of bst : (k-1-number_of_nodes_on_left) nodes \\n            for number_of_nodes_on_left in range(0, number_of_nodes):\\n                \\n                for left_subtree in bst_dp_table[number_of_nodes_on_left]:\\n                    \\n                    number_of_nodes_on_right = number_of_nodes-1-number_of_nodes_on_left\\n                    \\n                    for right_subtree in bst_dp_table[number_of_nodes_on_right]:\\n                        \\n                        # construct one unique bst\\n                        root_of_bst = TreeNode( number_of_nodes_on_left+1 )\\n                        root_of_bst.left = left_subtree\\n                        root_of_bst.right = self.clone_with_offset(right_subtree, number_of_nodes_on_left+1)\\n                        \\n                        # update dynamic programming table\\n                        bst_dp_table[number_of_nodes].append( root_of_bst )\\n            \\n        return bst_dp_table[n]\\n```\\n\\n---------------------------------------------------------------------------------\\n\\nMethod_#2: top-down recursion with memorization\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n\\n    def __init__(self):\\n        \\n        # memorization table\\n        # key   : (lower bound of bst, upper bound of bst)\\n        # value : a list of bst, all nodes\\' value in range lower bound to upper bound.\\n        self.bst_dict = dict()\\n    \\n    def tree_factory(self, min_val, max_val):\\n        \\n        tree_list = []\\n        \\n        if min_val > max_val:\\n            # Invalid case\\n            tree_list.append( None )\\n            return tree_list\\n        \\n        if (min_val, max_val) in self.bst_dict:\\n            # speed-up by looking memorization table\\n            return self.bst_dict[(min_val, max_val)]\\n        \\n        \\n        # generate binary search trees from all possible root node value\\n        for root_node_value in range( min_val, max_val+1):\\n            \\n            left_sub_trees = self.tree_factory( min_val, root_node_value-1 )\\n            right_sub_trees = self.tree_factory( root_node_value+1, max_val )\\n            \\n            for left_subtree in left_sub_trees:\\n                for right_subtree in right_sub_trees:\\n                    \\n\\t\\t\\t\\t\\t# construct one unique bst\\n                    root_node = TreeNode( root_node_value )\\n                    root_node.left = left_subtree\\n                    root_node.right = right_subtree\\n                    \\n                    tree_list.append( root_node )\\n        \\n        # update memorization table\\n        self.bst_dict[(min_val, max_val)] = tree_list            \\n        return tree_list\\n        \\n        \\n        \\n    \\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        if n == 0:\\n            # Quick response for empty tree\\n            return []\\n        else:\\n            return self.tree_factory( min_val = 1, max_val = n )\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    \\n    \\n    def clone_with_offset(self, node: TreeNode, offset):\\n        \\n        if not node:\\n            return None\\n        \\n        else:\\n            \\n            # Clone whole tree with constant value offset\\n            root_node = TreeNode( node.val + offset )\\n            root_node.left = self.clone_with_offset( node.left, offset )\\n            root_node.right = self.clone_with_offset( node.right, offset )\\n            \\n            return root_node\\n    \\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        \\n        if n == 0:\\n            # Quick response for empty tree\\n            return []\\n        \\n        # dynamic programming table\\n        bst_dp_table = [ None for i in range(n+1) ]\\n        \\n        # base case: \\n        bst_dp_table[0] = [None]\\n        \\n        \\n        # bottom-up. build bst with k nodes, k from 1 to n\\n        for number_of_nodes in range(1, n+1):\\n            \\n            bst_dp_table[number_of_nodes] = []\\n            \\n            # for root node of bst:     1 node                            \\n            # for left-subtree of bst : (number_of_nodes_on_left) nodes     \\n            # for right-subtrr of bst : (k-1-number_of_nodes_on_left) nodes \\n            for number_of_nodes_on_left in range(0, number_of_nodes):\\n                \\n                for left_subtree in bst_dp_table[number_of_nodes_on_left]:\\n                    \\n                    number_of_nodes_on_right = number_of_nodes-1-number_of_nodes_on_left\\n                    \\n                    for right_subtree in bst_dp_table[number_of_nodes_on_right]:\\n                        \\n                        # construct one unique bst\\n                        root_of_bst = TreeNode( number_of_nodes_on_left+1 )\\n                        root_of_bst.left = left_subtree\\n                        root_of_bst.right = self.clone_with_offset(right_subtree, number_of_nodes_on_left+1)\\n                        \\n                        # update dynamic programming table\\n                        bst_dp_table[number_of_nodes].append( root_of_bst )\\n            \\n        return bst_dp_table[n]\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n\\n    def __init__(self):\\n        \\n        # memorization table\\n        # key   : (lower bound of bst, upper bound of bst)\\n        # value : a list of bst, all nodes\\' value in range lower bound to upper bound.\\n        self.bst_dict = dict()\\n    \\n    def tree_factory(self, min_val, max_val):\\n        \\n        tree_list = []\\n        \\n        if min_val > max_val:\\n            # Invalid case\\n            tree_list.append( None )\\n            return tree_list\\n        \\n        if (min_val, max_val) in self.bst_dict:\\n            # speed-up by looking memorization table\\n            return self.bst_dict[(min_val, max_val)]\\n        \\n        \\n        # generate binary search trees from all possible root node value\\n        for root_node_value in range( min_val, max_val+1):\\n            \\n            left_sub_trees = self.tree_factory( min_val, root_node_value-1 )\\n            right_sub_trees = self.tree_factory( root_node_value+1, max_val )\\n            \\n            for left_subtree in left_sub_trees:\\n                for right_subtree in right_sub_trees:\\n                    \\n\\t\\t\\t\\t\\t# construct one unique bst\\n                    root_node = TreeNode( root_node_value )\\n                    root_node.left = left_subtree\\n                    root_node.right = right_subtree\\n                    \\n                    tree_list.append( root_node )\\n        \\n        # update memorization table\\n        self.bst_dict[(min_val, max_val)] = tree_list            \\n        return tree_list\\n        \\n        \\n        \\n    \\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        if n == 0:\\n            # Quick response for empty tree\\n            return []\\n        else:\\n            return self.tree_factory( min_val = 1, max_val = n )\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 163620,
                "title": "divide-and-conquer-in-java-scala",
                "content": "> **Divide into subproblems**\\nThe root candidate can be selected from `[1, N]`.\\n\\n> **Recursively solve subproblems**\\nAfter we decide a root `x`, two subtrees (i.e. subproblems) generated. One contains nodes with values with the range `[1, x - 1]`, while the other contains nodes with values within the range `[x + 1, N]`. \\nWe can solve subproblems separately following the pattern described above.\\nUntil there is no nodes left to set as root (detected by `start > end`), we terminate the recursion after we add `null` to the current placement.\\n\\n>**Conquer results of subproblems**\\nCombine the results of subproblems, i.e. try all possible combinations of a node\\'s left child and right child to construct subtrees from bottom to top. \\n\\n\\n**More on Recursion**\\nThe return type of `generateTreesFrom()` is `List<TreeNode>`, which indicates all roots of generated trees until now. We receive the results(`i.e. leftSub, rightSub`), construct trees by all combinations of them, and add roots to the newly created result list of the current stack frame. The pseudo-code is as below:\\n```\\n            init curret result;\\n            for  leftNode in leftSub {\\n                for rightNode in rightSub {\\n                    create root node with value x;\\n                    attach leftNode, rightNode to root \\n                    add root to curret result; \\n                }\\n            }\\n\\t\\t\\treturn curret result;\\n```\\n****\\n> Java\\n```\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) return new ArrayList<>();\\n        if (n == 1) return new ArrayList<>(Arrays.asList(new TreeNode(n)));\\n        \\n        // Map start + \" \" + end to list of placement.\\n        Map<String, List<TreeNode>> memo = new HashMap<>(); \\n        \\n        return place(1, n, memo);\\n    }\\n    \\n    private List<TreeNode> place(int start, int end, Map<String, List<TreeNode>> memo) {\\n        List<TreeNode> placement = new ArrayList<>(); // List of root of each placement.\\n        // Base cases.\\n        if (start > end) {\\n            placement.add(null);\\n            return placement;\\n        }\\n        if (start == end) {\\n            placement.add(new TreeNode(start));\\n            return placement;\\n        }\\n        \\n        String memoKey = start + \" \" + end;\\n        if (memo.containsKey(memoKey)) return memo.get(memoKey);\\n        \\n        for (int x = start; x <= end; x++) {\\n            List<TreeNode> leftPlacement = place(start, x - 1, memo);\\n            List<TreeNode> rightPlacement = place(x + 1, end, memo);\\n            TreeNode root;\\n            for (TreeNode leftNode: leftPlacement) {\\n                for (TreeNode rightNode: rightPlacement) {\\n                    root = new TreeNode(x);\\n                    root.left = leftNode;\\n                    root.right = rightNode;\\n                    placement.add(root);\\n                }\\n            }\\n        }\\n        \\n        memo.put(memoKey, placement);\\n        return placement;\\n    }\\n```\\n> Scala\\n```\\nimport scala.collection.mutable.{ListBuffer, HashMap}\\n\\nobject Solution {\\n  def generateTrees(n: Int): List[TreeNode] = {\\n    if (n < 1) List()\\n    else generate(1, n, new HashMap[String, List[TreeNode]]())\\n  }\\n  \\n  def generate(start: Int, end: Int, memo: HashMap[String, List[TreeNode]]): List[TreeNode] = {\\n    val memoKey = start + \" \" + end\\n    \\n    if (!(memo contains memoKey)) {\\n      val rootList = new ListBuffer[TreeNode]()\\n      \\n      if (start > end) rootList += null\\n      else if (start == end) rootList += new TreeNode(start)\\n      else {\\n        for (x <- start to end) {\\n          val leftList = generate(start, x - 1, memo)\\n          val rightList = generate(x + 1, end, memo)\\n          for (leftNode <- leftList) {\\n            for (rightNode <- rightList) {\\n              val root = new TreeNode(x)\\n              root.left = leftNode\\n              root.right = rightNode\\n              rootList += root\\n            }\\n          }\\n        }\\n      }\\n      \\n      memo += memoKey -> rootList.toList\\n    }\\n    \\n    memo.get(memoKey).get\\n  }\\n}\\n```\\n\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n            init curret result;\\n            for  leftNode in leftSub {\\n                for rightNode in rightSub {\\n                    create root node with value x;\\n                    attach leftNode, rightNode to root \\n                    add root to curret result; \\n                }\\n            }\\n\\t\\t\\treturn curret result;\\n```\n```\\n    public List<TreeNode> generateTrees(int n) {\\n        if (n == 0) return new ArrayList<>();\\n        if (n == 1) return new ArrayList<>(Arrays.asList(new TreeNode(n)));\\n        \\n        // Map start + \" \" + end to list of placement.\\n        Map<String, List<TreeNode>> memo = new HashMap<>(); \\n        \\n        return place(1, n, memo);\\n    }\\n    \\n    private List<TreeNode> place(int start, int end, Map<String, List<TreeNode>> memo) {\\n        List<TreeNode> placement = new ArrayList<>(); // List of root of each placement.\\n        // Base cases.\\n        if (start > end) {\\n            placement.add(null);\\n            return placement;\\n        }\\n        if (start == end) {\\n            placement.add(new TreeNode(start));\\n            return placement;\\n        }\\n        \\n        String memoKey = start + \" \" + end;\\n        if (memo.containsKey(memoKey)) return memo.get(memoKey);\\n        \\n        for (int x = start; x <= end; x++) {\\n            List<TreeNode> leftPlacement = place(start, x - 1, memo);\\n            List<TreeNode> rightPlacement = place(x + 1, end, memo);\\n            TreeNode root;\\n            for (TreeNode leftNode: leftPlacement) {\\n                for (TreeNode rightNode: rightPlacement) {\\n                    root = new TreeNode(x);\\n                    root.left = leftNode;\\n                    root.right = rightNode;\\n                    placement.add(root);\\n                }\\n            }\\n        }\\n        \\n        memo.put(memoKey, placement);\\n        return placement;\\n    }\\n```\n```\\nimport scala.collection.mutable.{ListBuffer, HashMap}\\n\\nobject Solution {\\n  def generateTrees(n: Int): List[TreeNode] = {\\n    if (n < 1) List()\\n    else generate(1, n, new HashMap[String, List[TreeNode]]())\\n  }\\n  \\n  def generate(start: Int, end: Int, memo: HashMap[String, List[TreeNode]]): List[TreeNode] = {\\n    val memoKey = start + \" \" + end\\n    \\n    if (!(memo contains memoKey)) {\\n      val rootList = new ListBuffer[TreeNode]()\\n      \\n      if (start > end) rootList += null\\n      else if (start == end) rootList += new TreeNode(start)\\n      else {\\n        for (x <- start to end) {\\n          val leftList = generate(start, x - 1, memo)\\n          val rightList = generate(x + 1, end, memo)\\n          for (leftNode <- leftList) {\\n            for (rightNode <- rightList) {\\n              val root = new TreeNode(x)\\n              root.left = leftNode\\n              root.right = rightNode\\n              rootList += root\\n            }\\n          }\\n        }\\n      }\\n      \\n      memo += memoKey -> rootList.toList\\n    }\\n    \\n    memo.get(memoKey).get\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31582,
                "title": "java-concise-recursive-solution-3ms",
                "content": "public class Solution {\\n\\n    public List<TreeNode> generateTrees(int n) {\\n        return n > 0 ? helper(1, n) : new ArrayList<TreeNode>();\\n    }\\n    \\n    private List<TreeNode> helper(int from, int n) {\\n\\t\\tList<TreeNode> trees = new ArrayList<TreeNode>();\\n\\t\\tfor (int i = 0; i <= n - 1; ++i) {\\n\\t\\t\\t//left i, right n-1-i\\n\\t\\t\\tList<TreeNode> leftList = helper(from, i);\\n\\t\\t\\tList<TreeNode> rightList = helper(from + i + 1, n - 1 - i);\\n\\t\\t\\tfor (TreeNode left : leftList)\\n\\t\\t\\t\\tfor (TreeNode right : rightList) {\\n\\t\\t\\t\\t\\tTreeNode root = new TreeNode(from + i);\\n\\t\\t\\t\\t\\troot.left = left;\\n\\t\\t\\t\\t\\troot.right = right;\\n\\t\\t\\t\\t\\ttrees.add(root);\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (trees.size() == 0)\\n\\t\\t\\ttrees.add(null);\\n\\t\\treturn trees;\\n\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n    public List<TreeNode> generateTrees(int n) {\\n        return n > 0 ? helper(1, n) : new ArrayList<TreeNode>();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 31604,
                "title": "why-is-the-expected-result-when-the-return-type-is-just-a-list-and-not-list-of-list",
                "content": "Hi,\\n\\n8/9 test cases are passed except the following edge case:-\\n\\nInput : 0\\nOutput : [ ]\\nExpected : [ [ ] ]\\n\\nIt seems expected output is like a List of list. Can someone clarify what is going wrong.\\n\\nBelow is my java code :-\\n\\n    public class Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if(n == 0) {\\n            List<TreeNode> result = new ArrayList<TreeNode>();\\n            return result;\\n        }\\n            \\n        int[] arr = new int[n];\\n        for(int i = 0; i < n; i++)\\n            arr[i] = i + 1;\\n        return generate(arr, 0, n - 1);\\n    }\\n    \\n    List<TreeNode> generate(int[] arr, int begin, int end) {\\n        if(begin > end)\\n            return null;\\n        List<TreeNode> result = new ArrayList<TreeNode>();\\n        if(begin == end) {\\n            result.add(new TreeNode(arr[begin]));\\n            return result;\\n        }\\n        \\n        for(int i = begin; i <= end; i++) {\\n            \\n            List<TreeNode> leftTrees = generate(arr, begin, i - 1);\\n            List<TreeNode> rightTrees = generate(arr, i + 1, end);\\n            if(leftTrees == null) {\\n                for(TreeNode node : rightTrees) {\\n                    TreeNode root = new TreeNode(arr[i]);\\n                    root.right = node;\\n                    result.add(root);\\n                }\\n            } else if(rightTrees == null) {\\n                for(TreeNode node : leftTrees) {\\n                    TreeNode root = new TreeNode(arr[i]);\\n                    root.left = node;\\n                    result.add(root);\\n                }\\n            } else {\\n                for(TreeNode left : leftTrees) {\\n                    for(TreeNode right : rightTrees) {\\n                        TreeNode root = new TreeNode(arr[i]);\\n                        root.left = left;\\n                        root.right = right;\\n                        result.add(root);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if(n == 0) {\\n            List<TreeNode> result = new ArrayList<TreeNode>();\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3865866,
                "title": "very-easy-recursion-memoization-dp-java-99-faster",
                "content": "# Approach\\n- Try out all ways, i.e, Recursion\\n- Memoize the recursion for repeating subproblem\\n\\n# Code\\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[][] dp = new List[n + 1][n + 1];\\n        return f(1, n, dp);\\n    }\\n    private List<TreeNode> f(int low, int high, List<TreeNode>[][] dp){\\n        List<TreeNode> bst = new ArrayList<>();\\n        if (low > high){\\n            bst.add(null);\\n            return bst;\\n        }\\n        if (dp[low][high] != null)\\n            return dp[low][high];\\n\\n        for (int i = low; i <= high; i++){\\n            List<TreeNode> leftSubTree = f(low, i - 1, dp);\\n            List<TreeNode> rightSubTree = f(i + 1, high, dp);\\n            for (TreeNode left : leftSubTree){\\n                for (TreeNode right : rightSubTree){\\n                    bst.add(new TreeNode(i, left, right));\\n                }\\n            }\\n        }\\n        return dp[low][high] = bst;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[][] dp = new List[n + 1][n + 1];\\n        return f(1, n, dp);\\n    }\\n    private List<TreeNode> f(int low, int high, List<TreeNode>[][] dp){\\n        List<TreeNode> bst = new ArrayList<>();\\n        if (low > high){\\n            bst.add(null);\\n            return bst;\\n        }\\n        if (dp[low][high] != null)\\n            return dp[low][high];\\n\\n        for (int i = low; i <= high; i++){\\n            List<TreeNode> leftSubTree = f(low, i - 1, dp);\\n            List<TreeNode> rightSubTree = f(i + 1, high, dp);\\n            for (TreeNode left : leftSubTree){\\n                for (TreeNode right : rightSubTree){\\n                    bst.add(new TreeNode(i, left, right));\\n                }\\n            }\\n        }\\n        return dp[low][high] = bst;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440987,
                "title": "java-solution-explained-tc-92-better-variable-naming",
                "content": "# Basic Approach\\nwe create another function called generateBSTs which takes two parameters, the strart node value and the end node value\\n1. If the start node value is greater than the end node then add the null to the currentBST list and return it\\n2. for every node from start to end, make it as our root node value do\\n3. call generateBSTs to generate leftSubtree with start as current start and end as value before until current root value ,which returns the list of roots of unique left subtrees formed with values from start to currentroot value - 1 \\n4. call generateBSTs to generate rightSubtree with start as current currentrootvalue + 1 and end as current end ,which returns the list of roots of unique right subtrees formed with values from currentroot value + 1 to end\\n5. now to get all combinations of left subtrees and right subtrees for the current root, traverse using two for loops and create a root with value as current root value and add the leftchild and rightchild with the help of for loops\\n6. add the root node to the currentBST list\\n7. return the currentBST list \\n# Code\\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return generateBSTs(1, n);\\n    }\\n    List<TreeNode> generateBSTs(int start, int end) {\\n        List<TreeNode> currentBSTs = new ArrayList<>();\\n        if(start > end) currentBSTs.add(null);        \\n        else {\\n            for(int rootVal = start; rootVal <= end; rootVal ++) {                \\n                List<TreeNode> leftSubtreeRoots = generateBSTs(start, rootVal - 1);\\n                List<TreeNode> rightSubtreeRoots = generateBSTs(rootVal + 1, end);\\n                for(TreeNode leftChild : leftSubtreeRoots) {                    \\n                    for(TreeNode rightChild : rightSubtreeRoots) {\\n                        TreeNode root = new TreeNode(rootVal);\\n                        root.left = leftChild;\\n                        root.right = rightChild;\\n                        currentBSTs.add(root);\\n                    }\\n                }\\n            }\\n        }\\n        return currentBSTs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return generateBSTs(1, n);\\n    }\\n    List<TreeNode> generateBSTs(int start, int end) {\\n        List<TreeNode> currentBSTs = new ArrayList<>();\\n        if(start > end) currentBSTs.add(null);        \\n        else {\\n            for(int rootVal = start; rootVal <= end; rootVal ++) {                \\n                List<TreeNode> leftSubtreeRoots = generateBSTs(start, rootVal - 1);\\n                List<TreeNode> rightSubtreeRoots = generateBSTs(rootVal + 1, end);\\n                for(TreeNode leftChild : leftSubtreeRoots) {                    \\n                    for(TreeNode rightChild : rightSubtreeRoots) {\\n                        TreeNode root = new TreeNode(rootVal);\\n                        root.left = leftChild;\\n                        root.right = rightChild;\\n                        currentBSTs.add(root);\\n                    }\\n                }\\n            }\\n        }\\n        return currentBSTs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806941,
                "title": "c-simple-and-elegant",
                "content": "**Runtime: 8 ms, faster than 99.46% of C++ online submissions for Unique Binary Search Trees II.\\nMemory Usage: 14 MB, less than 63.64% of C++ online submissions for Unique Binary Search Trees II.**\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector<TreeNode *> helper(int start, int end)\\n    {\\n        if(start > end)\\n            return vector<TreeNode*>(1, NULL);\\n        if(start == end)\\n            return vector<TreeNode*>(1, new TreeNode(start));\\n        \\n        vector<TreeNode *> result, left, right;\\n        \\n        for(int i = start; i <= end; i++)\\n        {\\n            left = helper(start, i - 1);\\n            right = helper(i + 1, end);\\n            \\n            for(TreeNode *lNode: left)\\n            {\\n                for(TreeNode *rNode: right)\\n                    result.push_back(new TreeNode(i, lNode, rNode));\\n            }\\n        }\\n        return result;\\n    }\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0)\\n            return vector<TreeNode*>();\\n        return helper(1, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector<TreeNode *> helper(int start, int end)\\n    {\\n        if(start > end)\\n            return vector<TreeNode*>(1, NULL);\\n        if(start == end)\\n            return vector<TreeNode*>(1, new TreeNode(start));\\n        \\n        vector<TreeNode *> result, left, right;\\n        \\n        for(int i = start; i <= end; i++)\\n        {\\n            left = helper(start, i - 1);\\n            right = helper(i + 1, end);\\n            \\n            for(TreeNode *lNode: left)\\n            {\\n                for(TreeNode *rNode: right)\\n                    result.push_back(new TreeNode(i, lNode, rNode));\\n            }\\n        }\\n        return result;\\n    }\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0)\\n            return vector<TreeNode*>();\\n        return helper(1, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551479,
                "title": "c-miminalizm",
                "content": "```cpp\\nvector<TreeNode*> generateTrees(int end, int start = 0) {\\n    if (start > end)\\n        return { nullptr };\\n    vector<TreeNode*> res;\\n    for (auto i = max(1, start); i <= end; ++i) {\\n        for (auto l : generateTrees(i - 1, max(1, start)))\\n            for (auto r : generateTrees(end, i + 1)) {\\n                res.push_back(new TreeNode(i));\\n                res.back()->left = l;\\n                res.back()->right = r;\\n            }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<TreeNode*> generateTrees(int end, int start = 0) {\\n    if (start > end)\\n        return { nullptr };\\n    vector<TreeNode*> res;\\n    for (auto i = max(1, start); i <= end; ++i) {\\n        for (auto l : generateTrees(i - 1, max(1, start)))\\n            for (auto r : generateTrees(end, i + 1)) {\\n                res.push_back(new TreeNode(i));\\n                res.back()->left = l;\\n                res.back()->right = r;\\n            }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 457492,
                "title": "javascript-8-line-solution",
                "content": "```js\\nvar generateTrees = function(n, l = 1, r = n, res = []) {\\n    for(let i = l; i <= r; i++){\\n        for(const left of generateTrees(n, l, i - 1)){\\n            for(const right of generateTrees(n, i + 1, r)){\\n                res.push({val: i, left, right});\\n            }\\n        }\\n    }\\n    return n ? res.length ? res : [null] : [];\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar generateTrees = function(n, l = 1, r = n, res = []) {\\n    for(let i = l; i <= r; i++){\\n        for(const left of generateTrees(n, l, i - 1)){\\n            for(const right of generateTrees(n, i + 1, r)){\\n                res.push({val: i, left, right});\\n            }\\n        }\\n    }\\n    return n ? res.length ? res : [null] : [];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 350718,
                "title": "cpp-easy-to-understand-recursive-solution-with-explanation",
                "content": "Explanation :\\nEvery element in the array[1,n] can be a root sometime, because of the BST property, \\nif ith element is chosen as the root, then the elements from [1,i-1] will form the left subtree & [i+1,n] will form the right subtree.\\nWhat we ask recursion to do is , for each ith element , return all possible combinations of left subtree & right subtree, then we will attach the root(ith element) in all possible combinations.\\nThat\\'s it.\\nkEEP it simple, keep coding :)\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n    if (n==0) return {};\\n    return helper(1,n);\\n    }\\n    \\n    \\n    vector <TreeNode*> helper(int start, int end){\\n        if (start>end) return {nullptr};\\n      vector <TreeNode* > ans;\\n        for (int i=start; i <= end; ++i)\\n        {\\n        auto leftSubTree = helper(start, i-1);\\n        auto rightSubTree = helper(i+1,end);\\n            for (auto a:leftSubTree){\\n                  for (auto b:rightSubTree){\\n                      TreeNode *Node = new TreeNode(i); \\n                      Node->left= a;\\n                      Node->right= b;\\n                      ans.push_back(Node);\\n                  }   \\n            }\\n        }\\n        return ans;   \\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n    if (n==0) return {};\\n    return helper(1,n);\\n    }\\n    \\n    \\n    vector <TreeNode*> helper(int start, int end){\\n        if (start>end) return {nullptr};\\n      vector <TreeNode* > ans;\\n        for (int i=start; i <= end; ++i)\\n        {\\n        auto leftSubTree = helper(start, i-1);\\n        auto rightSubTree = helper(i+1,end);\\n            for (auto a:leftSubTree){\\n                  for (auto b:rightSubTree){\\n                      TreeNode *Node = new TreeNode(i); \\n                      Node->left= a;\\n                      Node->right= b;\\n                      ans.push_back(Node);\\n                  }   \\n            }\\n        }\\n        return ans;   \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262915,
                "title": "c-iterative-dp-solution-reuse-tree-nodes-both-100",
                "content": "Runtime: 16 ms, faster than 100.00% of C++ online submissions for Unique Binary Search Trees II.\\nMemory Usage: 11.6 MB, less than 100.00% of C++ online submissions for Unique Binary Search Trees II.\\n\\nBTW, I think {NULL} should be returned in the case n = 0, but I have to return {} to pass the test case; I think this is LC\\'s mistake.\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n == 0) return {};\\n        vector<TreeNode*> nul = {NULL};\\n        vector<vector<vector<TreeNode*>>> trees(n);\\n        // all trees in trees[i][j] contain exactly the numbers from j+1 to j+i+1\\n        for (int i = 0; i < n; ++i) {\\n            trees[i].resize(n-i);\\n            for (int j = 0; j < n-i; ++j) {\\n                for (int k = 0; k <= i; ++k) {\\n                    auto jk1 = j+k+1;\\n                    auto& left = k == 0 ? nul : trees[k-1][j];\\n                    auto& right = k == i ? nul : trees[i-k-1][jk1];\\n                    for (auto l : left) for (auto r : right) {\\n                        trees[i][j].emplace_back(new TreeNode(jk1));\\n                        trees[i][j].back()->left = l;\\n                        trees[i][j].back()->right = r;\\n                    }\\n                }                    \\n            }\\n        }\\n        return trees.back()[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n == 0) return {};\\n        vector<TreeNode*> nul = {NULL};\\n        vector<vector<vector<TreeNode*>>> trees(n);\\n        // all trees in trees[i][j] contain exactly the numbers from j+1 to j+i+1\\n        for (int i = 0; i < n; ++i) {\\n            trees[i].resize(n-i);\\n            for (int j = 0; j < n-i; ++j) {\\n                for (int k = 0; k <= i; ++k) {\\n                    auto jk1 = j+k+1;\\n                    auto& left = k == 0 ? nul : trees[k-1][j];\\n                    auto& right = k == i ? nul : trees[i-k-1][jk1];\\n                    for (auto l : left) for (auto r : right) {\\n                        trees[i][j].emplace_back(new TreeNode(jk1));\\n                        trees[i][j].back()->left = l;\\n                        trees[i][j].back()->right = r;\\n                    }\\n                }                    \\n            }\\n        }\\n        return trees.back()[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31529,
                "title": "unique-binary-search-trees-ii-c-shallow-copy-deep-copy",
                "content": "**Shallow Copy** - TreeNodes are shared between trees:\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n == 0 ? vector<TreeNode*>() : generate(1, n);\\n    }\\n\\n    vector<TreeNode*> generate(int lo, int hi) {\\n        vector<TreeNode*> trees;\\n        if (lo > hi) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n\\n        for (int i = lo; i <= hi; i++) {\\n            vector<TreeNode*> lefts = generate(lo, i - 1);\\n            vector<TreeNode*> rights = generate(i + 1, hi);\\n            for (TreeNode* left : lefts) {\\n                for (TreeNode* right : rights) {\\n                    TreeNode* node = new TreeNode(i);\\n                    node->left = left;\\n                    node->right = right;\\n                    trees.push_back(node);\\n                }\\n            }\\n        }\\n        \\n        return trees;\\n    }\\n};\\n````\\n\\n**Deep Copy** - All trees use its own nodes;\\n***Matrix***\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n == 0 ? vector<TreeNode*>() : generate(1, n);\\n    }\\n\\nprivate:\\n    vector<TreeNode*> generate(int lo, int hi) {\\n        vector<TreeNode*> trees;\\n        if (lo > hi) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n\\n        for (int k = lo; k <= hi; k++) {\\n            vector<vector<TreeNode*>> lefts(1, generate(lo, k - 1));\\n            vector<vector<TreeNode*>> rights(1, generate(k + 1, hi));\\n            int l = lefts[0].size(), r = rights[0].size();\\n            for (int i = 0; i < l; i++) {\\n                for (int j = 0; j < r; j++) {\\n                    if (j >= lefts.size()) lefts.push_back(generate(lo, k - 1));\\n                    if (i >= rights.size()) rights.push_back(generate(k + 1, hi));\\n                    TreeNode* node = new TreeNode(k);\\n                    node->left = lefts[j][i];\\n                    node->right = rights[i][j];\\n                    trees.push_back(node);\\n                }\\n            }\\n        }\\n\\n        return trees;\\n    }\\n};\\n```\\n\\n***Clone***\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n == 0 ? vector<TreeNode*>() : generate(1, n);\\n    }\\n\\n    vector<TreeNode*> generate(int lo, int hi) {\\n        vector<TreeNode*> trees;\\n        if (lo > hi) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n\\n        for (int i = lo; i <= hi; i++) {\\n            // TreeNode in this vector should only be used while combining with the first TreeNode in rights, for the rest use clone;\\n            vector<TreeNode*> lefts = generate(lo, i - 1);\\n            for (TreeNode* left : lefts) {\\n                vector<TreeNode*> rights = generate(i + 1, hi);\\n                bool first = true;\\n                for (TreeNode* right : rights) {\\n                    TreeNode* node = new TreeNode(i);\\n                    node->left = first ? left : clone(left);    // the first node in rights use left, other use cloned left;\\n                    node->right = right;\\n                    trees.push_back(node);\\n                    first = false;\\n                }\\n            }\\n        }\\n        \\n        return trees;\\n    }\\n\\nprivate:\\n    /* Check null both at node and left,right */\\n    TreeNode* clone(TreeNode* node) {\\n        if (!node) {\\n            return nullptr;\\n        }\\n        TreeNode* copy = new TreeNode(node->val);\\n        if (node->left) {\\n            copy->left = clone(node->left);\\n        }\\n        if (node->right) {\\n            copy->right = clone(node->right);\\n        }\\n        return copy;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n == 0 ? vector<TreeNode*>() : generate(1, n);\\n    }\\n\\n    vector<TreeNode*> generate(int lo, int hi) {\\n        vector<TreeNode*> trees;\\n        if (lo > hi) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n\\n        for (int i = lo; i <= hi; i++) {\\n            vector<TreeNode*> lefts = generate(lo, i - 1);\\n            vector<TreeNode*> rights = generate(i + 1, hi);\\n            for (TreeNode* left : lefts) {\\n                for (TreeNode* right : rights) {\\n                    TreeNode* node = new TreeNode(i);\\n                    node->left = left;\\n                    node->right = right;\\n                    trees.push_back(node);\\n                }\\n            }\\n        }\\n        \\n        return trees;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n == 0 ? vector<TreeNode*>() : generate(1, n);\\n    }\\n\\nprivate:\\n    vector<TreeNode*> generate(int lo, int hi) {\\n        vector<TreeNode*> trees;\\n        if (lo > hi) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n\\n        for (int k = lo; k <= hi; k++) {\\n            vector<vector<TreeNode*>> lefts(1, generate(lo, k - 1));\\n            vector<vector<TreeNode*>> rights(1, generate(k + 1, hi));\\n            int l = lefts[0].size(), r = rights[0].size();\\n            for (int i = 0; i < l; i++) {\\n                for (int j = 0; j < r; j++) {\\n                    if (j >= lefts.size()) lefts.push_back(generate(lo, k - 1));\\n                    if (i >= rights.size()) rights.push_back(generate(k + 1, hi));\\n                    TreeNode* node = new TreeNode(k);\\n                    node->left = lefts[j][i];\\n                    node->right = rights[i][j];\\n                    trees.push_back(node);\\n                }\\n            }\\n        }\\n\\n        return trees;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return n == 0 ? vector<TreeNode*>() : generate(1, n);\\n    }\\n\\n    vector<TreeNode*> generate(int lo, int hi) {\\n        vector<TreeNode*> trees;\\n        if (lo > hi) {\\n            trees.push_back(nullptr);\\n            return trees;\\n        }\\n\\n        for (int i = lo; i <= hi; i++) {\\n            // TreeNode in this vector should only be used while combining with the first TreeNode in rights, for the rest use clone;\\n            vector<TreeNode*> lefts = generate(lo, i - 1);\\n            for (TreeNode* left : lefts) {\\n                vector<TreeNode*> rights = generate(i + 1, hi);\\n                bool first = true;\\n                for (TreeNode* right : rights) {\\n                    TreeNode* node = new TreeNode(i);\\n                    node->left = first ? left : clone(left);    // the first node in rights use left, other use cloned left;\\n                    node->right = right;\\n                    trees.push_back(node);\\n                    first = false;\\n                }\\n            }\\n        }\\n        \\n        return trees;\\n    }\\n\\nprivate:\\n    /* Check null both at node and left,right */\\n    TreeNode* clone(TreeNode* node) {\\n        if (!node) {\\n            return nullptr;\\n        }\\n        TreeNode* copy = new TreeNode(node->val);\\n        if (node->left) {\\n            copy->left = clone(node->left);\\n        }\\n        if (node->right) {\\n            copy->right = clone(node->right);\\n        }\\n        return copy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31634,
                "title": "my-non-recursive-c-solution",
                "content": "    vector<TreeNode *> generateTrees(int n) {\\n        vector<TreeNode *> tmp;\\n        vector<TreeNode *> ret;\\n        tmp.push_back(NULL);        \\n        ret.push_back(new TreeNode(1));\\n        if (!n) return tmp;\\n\\n\\t\\t/* insert the largeset number into previously contructed trees */\\n        for (int i = 2; i <= n; i++) {\\n            tmp.clear();\\n            for (int j = 0; j < ret.size(); j++) {\\n\\t\\t\\t\\t/* firstly, put the largest number on the top of tree */\\n                TreeNode *orgTree = ret[j];                \\n                TreeNode *newNode = new TreeNode(i);\\n                newNode->left = copy(orgTree);\\n                tmp.push_back(newNode);\\n                \\n\\t\\t\\t\\t/* traverse thru the right-most branch, \\n\\t\\t\\t\\t * insert the largest number one position after another */\\n                TreeNode *orgRunner = orgTree;\\n                while (orgRunner) {\\n                    newNode = new TreeNode(i);\\n                    newNode->left = orgRunner->right;\\n                    orgRunner->right = newNode;\\n                    tmp.push_back(copy(orgTree));\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t/* recover the original tree */\\n                    orgRunner->right = orgRunner->right->left;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t/* for the next loop */\\n                    orgRunner = orgRunner->right;\\n                }\\n            }\\n            ret =  tmp;\\n        }\\n        return ret;\\n    }\\n    \\n    TreeNode *copy (TreeNode *root) {\\n        TreeNode *ret = NULL;\\n        if (root) {\\n            ret = new TreeNode(root->val);\\n            ret->left = copy(root->left);\\n            ret->right = copy(root->right);\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "    vector<TreeNode *> generateTrees(int n) {\\n        vector<TreeNode *> tmp;\\n        vector<TreeNode *> ret;\\n        tmp.push_back(NULL);        \\n        ret.push_back(new TreeNode(1));\\n        if (!n) return tmp;\\n\\n\\t\\t/* insert the largeset number into previously contructed trees */\\n        for (int i = 2; i <= n; i++) {\\n            tmp.clear();\\n            for (int j = 0; j < ret.size(); j++) {\\n\\t\\t\\t\\t/* firstly, put the largest number on the top of tree */\\n                TreeNode *orgTree = ret[j];                \\n                TreeNode *newNode = new TreeNode(i);\\n                newNode->left = copy(orgTree);\\n                tmp.push_back(newNode);\\n                \\n\\t\\t\\t\\t/* traverse thru the right-most branch, \\n\\t\\t\\t\\t * insert the largest number one position after another */\\n                TreeNode *orgRunner = orgTree;\\n                while (orgRunner) {\\n                    newNode = new TreeNode(i);\\n                    newNode->left = orgRunner->right;\\n                    orgRunner->right = newNode;\\n                    tmp.push_back(copy(orgTree));\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t/* recover the original tree */\\n                    orgRunner->right = orgRunner->right->left;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t/* for the next loop */\\n                    orgRunner = orgRunner->right;\\n                }\\n            }\\n            ret =  tmp;\\n        }\\n        return ret;\\n    }\\n    \\n    TreeNode *copy (TreeNode *root) {\\n        TreeNode *ret = NULL;\\n        if (root) {\\n            ret = new TreeNode(root->val);\\n            ret->left = copy(root->left);\\n            ret->right = copy(root->right);\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31626,
                "title": "python-generator-solution",
                "content": "credit goes to https://leetcode.com/discuss/3440/help-simplify-my-code-the-second-one?show=4884#a4884\\n\\n    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @return a list of tree node\\n        # 2:30\\n        def generateTrees(self, n):\\n            nodes = map(TreeNode, range(1, n+1))\\n            return map(copy.deepcopy, self.buildTree(nodes))\\n    \\n        def buildTree(self, nodes):\\n            n = len(nodes)\\n            if n == 0:\\n                yield None\\n                return\\n    \\n            for i in range(n):\\n                root = nodes[i]\\n                for left in self.buildTree(nodes[:i]):\\n                    for right in self.buildTree(nodes[i+1:]):\\n                        root.left, root.right = left, right\\n                        yield root",
                "solutionTags": [
                    "Python"
                ],
                "code": "credit goes to https://leetcode.com/discuss/3440/help-simplify-my-code-the-second-one?show=4884#a4884\\n\\n    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @return a list of tree node\\n        # 2:30\\n        def generateTrees(self, n):\\n            nodes = map(TreeNode, range(1, n+1))\\n            return map(copy.deepcopy, self.buildTree(nodes))\\n    \\n        def buildTree(self, nodes):\\n            n = len(nodes)\\n            if n == 0:\\n                yield None\\n                return\\n    \\n            for i in range(n):\\n                root = nodes[i]\\n                for left in self.buildTree(nodes[:i]):\\n                    for right in self.buildTree(nodes[i+1:]):\\n                        root.left, root.right = left, right\\n                        yield root",
                "codeTag": "Java"
            },
            {
                "id": 3865479,
                "title": "c-detailed-explanation-of-the-recursive-approach",
                "content": "# Intuition\\n- The Trees can have root nodes from 1 to n\\n- Left Subtree will have elements less than the root node\\n- Right Subtree will have elements greater than the root node\\n- Each left and right subtree can be treated as an individual tree which can have previousRoot-1 (starting from prevousRoot-1 till the left bound) number of root nodes and n-prevRoot (starting from previousRoot+1 till right end) number of root nodes respectively \\n\\n# Approach\\n- Base Case 1: For invalid boundary an empty tree can be created which is returned\\n- Base Case 2: When there is only a single node left the left and right value will be equal the value is pushed in the result as a node an returned\\n- For Every Tree/Subtree fix 1 node as the root node (i) and find all possible left and right Subtrees for that node.\\n- Every left Subtree can be combined with each of the right Subtrees to give a unique tree and vice versa\\n- Generate all possible combinations for the root node and push the root node in the result vector.\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<TreeNode*> f(int left,int right){\\n\\n        vector<TreeNode*> res;\\n\\n        //Base case 1:\\n        if(left>right){\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        //Base case 2:\\n        if(left==right){\\n            TreeNode* node= new TreeNode(left);\\n            res.push_back(node);\\n            return res;\\n        }\\n\\n        //Fix the root node in i\\n        for(int i=left; i<=right; i++){\\n        //The left subtree will have elements from the left bound till i-1\\n            vector<TreeNode*> leftSubtree=f(left,i-1);\\n        //The right subtree will have elements from i+1 till the right bound\\n            vector<TreeNode*> rightSubtree=f(i+1,right);\\n        //Add all possibilities of the combinations of the left subtrees and the right subtrees for the root node i\\n            for(int j=0; j<leftSubtree.size(); j++){\\n                for(int k=0; k<rightSubtree.size(); k++){\\n                    TreeNode* node=new TreeNode(i);\\n                    node->left=leftSubtree[j];\\n                    node->right=rightSubtree[k];\\n                    res.push_back(node);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return f(1,n);\\n    }\\n};\\n```\\n\\nPlease **UPVOTE** if you understood!",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<TreeNode*> f(int left,int right){\\n\\n        vector<TreeNode*> res;\\n\\n        //Base case 1:\\n        if(left>right){\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        //Base case 2:\\n        if(left==right){\\n            TreeNode* node= new TreeNode(left);\\n            res.push_back(node);\\n            return res;\\n        }\\n\\n        //Fix the root node in i\\n        for(int i=left; i<=right; i++){\\n        //The left subtree will have elements from the left bound till i-1\\n            vector<TreeNode*> leftSubtree=f(left,i-1);\\n        //The right subtree will have elements from i+1 till the right bound\\n            vector<TreeNode*> rightSubtree=f(i+1,right);\\n        //Add all possibilities of the combinations of the left subtrees and the right subtrees for the root node i\\n            for(int j=0; j<leftSubtree.size(); j++){\\n                for(int k=0; k<rightSubtree.size(); k++){\\n                    TreeNode* node=new TreeNode(i);\\n                    node->left=leftSubtree[j];\\n                    node->right=rightSubtree[k];\\n                    res.push_back(node);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return f(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865297,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n\\n        return upvote(1,n);\\n    }\\n\\n    private List<TreeNode> upvote(int s, int e){\\n        List<TreeNode> ans = new ArrayList<>();\\n\\n        if(s>e){\\n            ans.add(null);\\n            return ans;\\n        }\\n\\n        for(int i = s;i <= e;i++){\\n            List<TreeNode> left = upvote(s, i-1);\\n            List<TreeNode> right = upvote(i+1, e);\\n\\n            for(TreeNode l : left){\\n                for(TreeNode r : right){\\n                    TreeNode res = new TreeNode(i,l,r);\\n                    ans.add(res);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n\\n        return upvote(1,n);\\n    }\\n\\n    private List<TreeNode> upvote(int s, int e){\\n        List<TreeNode> ans = new ArrayList<>();\\n\\n        if(s>e){\\n            ans.add(null);\\n            return ans;\\n        }\\n\\n        for(int i = s;i <= e;i++){\\n            List<TreeNode> left = upvote(s, i-1);\\n            List<TreeNode> right = upvote(i+1, e);\\n\\n            for(TreeNode l : left){\\n                for(TreeNode r : right){\\n                    TreeNode res = new TreeNode(i,l,r);\\n                    ans.add(res);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864986,
                "title": "unique-binary-search-trees-ii-a-rusty-approach",
                "content": "Have you ever tried to generate all unique binary search trees (BSTs) with a given number of nodes? It\\'s a crab-tastic challenge, but don\\'t worry; Rust is here to help you out!\\n\\n## Intuition\\nImagine you have \\\\( n \\\\) distinct numbers. You can pick any number as the root of the BST. Once you pick a root, the remaining numbers are divided into two groups, forming the left and right subtrees. You can recursively build the subtrees and combine them to form all possible BSTs.\\n\\n## Approach\\nWe use dynamic programming to efficiently construct all possible trees. We start by building trees with 1 node, then 2 nodes, up to \\\\( n \\\\) nodes. We use previously computed solutions to build trees with more nodes, making the process fast and memory-efficient.\\n\\n### Example Explanation\\nFor \\\\( n = 3 \\\\), the output is:\\n```\\n[\\n    [1,null,2,null,3],\\n    [1,null,3,2],\\n    [2,1,3],\\n    [3,1,null,null,2],\\n    [3,2,null,1]\\n]\\n```\\nIt means there are 5 different ways to form a BST using numbers from 1 to 3.\\n\\n## Complexity\\n- Time complexity: $$ O\\\\left(\\\\frac{{4^n}}{{n\\\\sqrt{n}}}\\\\right) $$\\n- Space complexity: $$ O\\\\left(\\\\frac{{4^n}}{{n\\\\sqrt{n}}}\\\\right) $$\\n\\n## Code\\nThe Rust code below generates all unique BSTs for a given number of nodes, using dynamic programming.\\n\\n``` Rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if n == 0 {\\n            return Vec::new();\\n        }\\n\\n        let mut dp = vec![Vec::new(); (n + 1) as usize];\\n        dp[0].push(None);\\n        for nodes in 1..=n {\\n            let mut trees_per_node = Vec::new();\\n            for root in 1..=nodes {\\n                let left_trees = &dp[(root - 1) as usize];\\n                let right_trees = &dp[(nodes - root) as usize];\\n                for left_tree in left_trees {\\n                    for right_tree in right_trees {\\n                        let root_node = Some(Rc::new(RefCell::new(TreeNode::new(root))));\\n                        root_node.as_ref().unwrap().borrow_mut().left = left_tree.clone();\\n                        root_node.as_ref().unwrap().borrow_mut().right = Solution::clone(right_tree.clone(), root);\\n                        trees_per_node.push(root_node);\\n                    }\\n                }\\n            }\\n            dp[nodes as usize] = trees_per_node;\\n        }\\n        dp[n as usize].clone()\\n    }\\n\\n    fn clone(tree: Option<Rc<RefCell<TreeNode>>>, offset: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        tree.map(|node| {\\n            Rc::new(RefCell::new(TreeNode {\\n                val: node.borrow().val + offset,\\n                left: Solution::clone(node.borrow().left.clone(), offset),\\n                right: Solution::clone(node.borrow().right.clone(), offset),\\n            }))\\n        })\\n    }\\n}\\n```\\n``` Go []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    const dp = Array.from({ length: n + 1 }, () => []);\\n    dp[0].push(null);\\n    for (let nodes = 1; nodes <= n; nodes++) {\\n        for (let root = 1; root <= nodes; root++) {\\n            for (const left_tree of dp[root - 1]) {\\n                for (const right_tree of dp[nodes - root]) {\\n                    const root_node = new TreeNode(root);\\n                    root_node.left = left_tree;\\n                    root_node.right = clone(right_tree, root);\\n                    dp[nodes].push(root_node);\\n                }\\n            }\\n        }\\n    }\\n    return dp[n];\\n};\\n\\nfunction clone(n, offset) {\\n    if (n === null) return null;\\n    const node = new TreeNode(n.val + offset);\\n    node.left = clone(n.left, offset);\\n    node.right = clone(n.right, offset);\\n    return node;\\n}\\n```\\n``` Python []\\nclass Solution:\\n    def generateTrees(self, n: int):\\n        if n == 0:\\n            return []\\n\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0].append(None)\\n        for nodes in range(1, n + 1):\\n            for root in range(1, nodes + 1):\\n                for left_tree in dp[root - 1]:\\n                    for right_tree in dp[nodes - root]:\\n                        root_node = TreeNode(root)\\n                        root_node.left = left_tree\\n                        root_node.right = self.clone(right_tree, root)\\n                        dp[nodes].append(root_node)\\n        return dp[n]\\n    \\n    def clone(self, n: TreeNode, offset: int) -> TreeNode:\\n        if n:\\n            node = TreeNode(n.val + offset)\\n            node.left = self.clone(n.left, offset)\\n            node.right = self.clone(n.right, offset)\\n            return node\\n        return None\\n```\\nExplore the beauty of constructing binary trees and have fun with Rust! If you find this solution helpful, don\\'t forget to upvote and share it with fellow Rustaceans. Happy coding! \\uD83E\\uDD80",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\n[\\n    [1,null,2,null,3],\\n    [1,null,3,2],\\n    [2,1,3],\\n    [3,1,null,null,2],\\n    [3,2,null,1]\\n]\\n```\n``` Rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {\\n        if n == 0 {\\n            return Vec::new();\\n        }\\n\\n        let mut dp = vec![Vec::new(); (n + 1) as usize];\\n        dp[0].push(None);\\n        for nodes in 1..=n {\\n            let mut trees_per_node = Vec::new();\\n            for root in 1..=nodes {\\n                let left_trees = &dp[(root - 1) as usize];\\n                let right_trees = &dp[(nodes - root) as usize];\\n                for left_tree in left_trees {\\n                    for right_tree in right_trees {\\n                        let root_node = Some(Rc::new(RefCell::new(TreeNode::new(root))));\\n                        root_node.as_ref().unwrap().borrow_mut().left = left_tree.clone();\\n                        root_node.as_ref().unwrap().borrow_mut().right = Solution::clone(right_tree.clone(), root);\\n                        trees_per_node.push(root_node);\\n                    }\\n                }\\n            }\\n            dp[nodes as usize] = trees_per_node;\\n        }\\n        dp[n as usize].clone()\\n    }\\n\\n    fn clone(tree: Option<Rc<RefCell<TreeNode>>>, offset: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        tree.map(|node| {\\n            Rc::new(RefCell::new(TreeNode {\\n                val: node.borrow().val + offset,\\n                left: Solution::clone(node.borrow().left.clone(), offset),\\n                right: Solution::clone(node.borrow().right.clone(), offset),\\n            }))\\n        })\\n    }\\n}\\n```\n``` Go []\\nvar generateTrees = function(n) {\\n    if (n === 0) return [];\\n\\n    const dp = Array.from({ length: n + 1 }, () => []);\\n    dp[0].push(null);\\n    for (let nodes = 1; nodes <= n; nodes++) {\\n        for (let root = 1; root <= nodes; root++) {\\n            for (const left_tree of dp[root - 1]) {\\n                for (const right_tree of dp[nodes - root]) {\\n                    const root_node = new TreeNode(root);\\n                    root_node.left = left_tree;\\n                    root_node.right = clone(right_tree, root);\\n                    dp[nodes].push(root_node);\\n                }\\n            }\\n        }\\n    }\\n    return dp[n];\\n};\\n\\nfunction clone(n, offset) {\\n    if (n === null) return null;\\n    const node = new TreeNode(n.val + offset);\\n    node.left = clone(n.left, offset);\\n    node.right = clone(n.right, offset);\\n    return node;\\n}\\n```\n``` Python []\\nclass Solution:\\n    def generateTrees(self, n: int):\\n        if n == 0:\\n            return []\\n\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0].append(None)\\n        for nodes in range(1, n + 1):\\n            for root in range(1, nodes + 1):\\n                for left_tree in dp[root - 1]:\\n                    for right_tree in dp[nodes - root]:\\n                        root_node = TreeNode(root)\\n                        root_node.left = left_tree\\n                        root_node.right = self.clone(right_tree, root)\\n                        dp[nodes].append(root_node)\\n        return dp[n]\\n    \\n    def clone(self, n: TreeNode, offset: int) -> TreeNode:\\n        if n:\\n            node = TreeNode(n.val + offset)\\n            node.left = self.clone(n.left, offset)\\n            node.right = self.clone(n.right, offset)\\n            return node\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399086,
                "title": "java-memoization-beats-99-on-space-and-time-15-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  Map<Pair<Integer, Integer>, List<TreeNode>> memo = new HashMap<>();\\n\\n  private List<TreeNode> generateTrees(int l, int r) {\\n    if (l > r)\\n      return new ArrayList<>() {{add(null);}};\\n\\n    var list = new ArrayList<TreeNode>();\\n    var pair = new Pair(l, r);\\n\\n    if (memo.containsKey(pair))\\n      return memo.get(pair);\\n  \\n    for (var i=l; i<=r; i++)\\n      for (var left : generateTrees(l, i-1))\\n        for (var right : generateTrees(i+1, r))\\n          list.add(new TreeNode(i, left, right));\\n    \\n    memo.put(pair, list);\\n    return list;\\n  }\\n\\n  public List<TreeNode> generateTrees(int n) {\\n    return generateTrees(1, n);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  Map<Pair<Integer, Integer>, List<TreeNode>> memo = new HashMap<>();\\n\\n  private List<TreeNode> generateTrees(int l, int r) {\\n    if (l > r)\\n      return new ArrayList<>() {{add(null);}};\\n\\n    var list = new ArrayList<TreeNode>();\\n    var pair = new Pair(l, r);\\n\\n    if (memo.containsKey(pair))\\n      return memo.get(pair);\\n  \\n    for (var i=l; i<=r; i++)\\n      for (var left : generateTrees(l, i-1))\\n        for (var right : generateTrees(i+1, r))\\n          list.add(new TreeNode(i, left, right));\\n    \\n    memo.put(pair, list);\\n    return list;\\n  }\\n\\n  public List<TreeNode> generateTrees(int n) {\\n    return generateTrees(1, n);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246485,
                "title": "c-divide-and-conquer-easy-to-understand",
                "content": "# Algorithm\\n1. Pick a number `i` from `1 .. n`\\n2. Use it as the root of the current tree\\n3. Solve 2 subproblems `1 .. i - 1` and `i + 1 .. n`\\n4. Repeat for every `i` from `1 .. n`\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        return GenerateTrees(1, n);\\n    }\\n\\n    public IList<TreeNode> GenerateTrees(int left, int right)\\n    {\\n        var res = new List<TreeNode>();\\n\\n        if(left > right)\\n        {\\n            res.Add(null);\\n            return res;\\n        }\\n\\n        for(var i = left; i <= right; i++)\\n        {\\n            var leftNodes = GenerateTrees(left, i - 1);\\n            var rightNodes = GenerateTrees(i + 1, right);\\n            \\n            foreach(var leftNode in leftNodes)\\n            {\\n                foreach(var rightNode in rightNodes)\\n                {\\n                    var node = new TreeNode(i, leftNode, rightNode);\\n                    res.Add(node);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Divide and Conquer"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        return GenerateTrees(1, n);\\n    }\\n\\n    public IList<TreeNode> GenerateTrees(int left, int right)\\n    {\\n        var res = new List<TreeNode>();\\n\\n        if(left > right)\\n        {\\n            res.Add(null);\\n            return res;\\n        }\\n\\n        for(var i = left; i <= right; i++)\\n        {\\n            var leftNodes = GenerateTrees(left, i - 1);\\n            var rightNodes = GenerateTrees(i + 1, right);\\n            \\n            foreach(var leftNode in leftNodes)\\n            {\\n                foreach(var rightNode in rightNodes)\\n                {\\n                    var node = new TreeNode(i, leftNode, rightNode);\\n                    res.Add(node);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104988,
                "title": "c-short-solution-recursion",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generate(int n,int start){\\n        if(start>n)return {NULL};\\n        vector<TreeNode*>res;\\n        for(int i=start;i<=n;i++){\\n            for(auto left:generate(i-1,start)){\\n                for(auto right:generate(n,i+1)){\\n                    res.push_back(new TreeNode(i,left,right));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return generate(n,1);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generate(int n,int start){\\n        if(start>n)return {NULL};\\n        vector<TreeNode*>res;\\n        for(int i=start;i<=n;i++){\\n            for(auto left:generate(i-1,start)){\\n                for(auto right:generate(n,i+1)){\\n                    res.push_back(new TreeNode(i,left,right));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return generate(n,1);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986322,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<TreeNode*> solve(int start, int end) {\\n        vector<TreeNode*> ans;\\n        if(start > end) return {NULL};\\n        if(start == end) return {new TreeNode(start)};\\n        for(int i=start; i<=end; i++) {\\n            vector<TreeNode*> left = solve(start, i-1);\\n            vector<TreeNode*> right = solve(i+1, end);\\n            for(auto l: left)\\n                for(auto r: right)\\n                    ans.push_back(new TreeNode(i, l, r));\\n        }\\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> ans = solve(1, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<TreeNode*> solve(int start, int end) {\\n        vector<TreeNode*> ans;\\n        if(start > end) return {NULL};\\n        if(start == end) return {new TreeNode(start)};\\n        for(int i=start; i<=end; i++) {\\n            vector<TreeNode*> left = solve(start, i-1);\\n            vector<TreeNode*> right = solve(i+1, end);\\n            for(auto l: left)\\n                for(auto r: right)\\n                    ans.push_back(new TreeNode(i, l, r));\\n        }\\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> ans = solve(1, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611185,
                "title": "c-recursion-very-fast-minimum-line",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<TreeNode*> generateTrees(int n, int s = 1) {\\n\\t\\t\\t\\tvector<TreeNode*> ans;\\n\\t\\t\\t\\tif(n < s) return {nullptr};                              \\n\\t\\t\\t\\t for(int i=s; i<=n; i++) {                \\t                 // Consider every number in range [s,n] as root  \\n\\t\\t\\t\\t\\tfor(auto left: generateTrees(i-1, s)) {                  // generate all possible trees in range [s,i)\\n\\t\\t\\t\\t\\t\\tfor(auto right: generateTrees(n, i+1))               // generate all possible trees in range (i,e]\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(new TreeNode(i, left, right));     // make new trees with i as the root \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<TreeNode*> generateTrees(int n, int s = 1) {\\n\\t\\t\\t\\tvector<TreeNode*> ans;\\n\\t\\t\\t\\tif(n < s) return {nullptr}",
                "codeTag": "Java"
            },
            {
                "id": 2435086,
                "title": "trust-me-boys-and-girls-by-recursion",
                "content": "**Solution -->**\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generateBST(int begin, int end)\\n    {\\n        vector<TreeNode*> arr;\\n        \\n        if(begin>end)\\n        {\\n            arr.push_back(NULL);\\n            return arr;\\n        }\\n        \\n        for(int i=begin; i<=end; i++)\\n        {\\n            vector<TreeNode*>left =  generateBST(begin, i-1);\\n            vector<TreeNode*>right =  generateBST(i+1,end);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    TreeNode* root = new TreeNode();\\n                    root->val = i;\\n                    root->left = l;\\n                    root->right = r;\\n                    arr.push_back(root);\\n                }\\n            }\\n            \\n        }\\n        return arr;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        vector<TreeNode*>arr;\\n        if(n==0) return arr;\\n        \\n        return generateBST(1,n);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generateBST(int begin, int end)\\n    {\\n        vector<TreeNode*> arr;\\n        \\n        if(begin>end)\\n        {\\n            arr.push_back(NULL);\\n            return arr;\\n        }\\n        \\n        for(int i=begin; i<=end; i++)\\n        {\\n            vector<TreeNode*>left =  generateBST(begin, i-1);\\n            vector<TreeNode*>right =  generateBST(i+1,end);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    TreeNode* root = new TreeNode();\\n                    root->val = i;\\n                    root->left = l;\\n                    root->right = r;\\n                    arr.push_back(root);\\n                }\\n            }\\n            \\n        }\\n        return arr;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        vector<TreeNode*>arr;\\n        if(n==0) return arr;\\n        \\n        return generateBST(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276413,
                "title": "java-recursion-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return solve(1,n) ;\\n    }\\n    \\n    public List<TreeNode> solve(int left,int right){\\n        List<TreeNode> ans = new ArrayList<>() ;\\n        if(left > right){\\n            ans.add(null) ;\\n            return ans ;\\n        }\\n        for(int i = left ; i <= right ; i++){\\n            List<TreeNode> lft = solve(left,i-1) ;\\n            List<TreeNode> ryt = solve(i+1,right) ;\\n            for(TreeNode l : lft){\\n                for(TreeNode r : ryt){\\n                    ans.add(new TreeNode(i,l,r)) ;\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        return solve(1,n) ;\\n    }\\n    \\n    public List<TreeNode> solve(int left,int right){\\n        List<TreeNode> ans = new ArrayList<>() ;\\n        if(left > right){\\n            ans.add(null) ;\\n            return ans ;\\n        }\\n        for(int i = left ; i <= right ; i++){\\n            List<TreeNode> lft = solve(left,i-1) ;\\n            List<TreeNode> ryt = solve(i+1,right) ;\\n            for(TreeNode l : lft){\\n                for(TreeNode r : ryt){\\n                    ans.add(new TreeNode(i,l,r)) ;\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074851,
                "title": "easy-understandable-recursion-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generate(int start,int end){\\n        vector<TreeNode*> ans;  // to store subtree for current node.\\n        if(start>end){  // means null\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*> left_nodes=generate(start,i-1); // store all left child node here.\\n            vector<TreeNode*> right_nodes=generate(i+1,end);  // store all right child node here.\\n            \\n            // with every left child and right child , form a tree and push it in ans array.\\n            for(auto left: left_nodes){\\n                for(auto right: right_nodes){\\n                    TreeNode* root=new TreeNode(i,left,right);\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return generate(1,n);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generate(int start,int end){\\n        vector<TreeNode*> ans;  // to store subtree for current node.\\n        if(start>end){  // means null\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*> left_nodes=generate(start,i-1); // store all left child node here.\\n            vector<TreeNode*> right_nodes=generate(i+1,end);  // store all right child node here.\\n            \\n            // with every left child and right child , form a tree and push it in ans array.\\n            for(auto left: left_nodes){\\n                for(auto right: right_nodes){\\n                    TreeNode* root=new TreeNode(i,left,right);\\n                    ans.push_back(root);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return generate(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949237,
                "title": "this-was-tough-to-come-up-with-explained-c-beats-97",
                "content": "This one\\'s a bit tricky to come up with,\\n\\n1. We will start building unique BSTs for each number(1-n) by keeping it as a root of current BST \\n2. for this will need all unique BSTs to the left of current root and all unique BSTs to the right of current root,\\n3. for example we have numbers 1-2-3-4-5, keeping \\'3\\' as root we need :\\n* all unique BSTs to the left of 3, which will be generated recursively for (1-2) ->[2,1,null] & [1,null,2]\\n* all unique BSTs to the right of 3, which will be generated recursively for (4-5)->[5,4,null] & [4,null,5]\\nfor each of the unique left BST (keeping 3 as root) e.g.[2,1,null] join all unique right BSTs(root) to the right of 3\\nwhich is [5,4,null] & [4,null,5]\\n\\nThis will generate all unique BSTs recursively, also note while adding a BST to the left or right of current BST we add only root of that BST(since the remaining BST will be made recursively) \\n\\nfor recursion BASE CASE -> when start>end(this means no node can exist to the left or right of current root)\\nreturn {NULL}\\nwhen start==end , which means there is only 1 unique BST that can be made with current node which is the node itself return {new Node(start)}\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> fn(int start,int end){\\n        vector<TreeNode*> res;\\n        //case when left or right subtree for a given node cant be generated \\n        if(start>end) return {NULL};\\n        //case when there is only one node \\n        if(start==end) return {new TreeNode(start)};\\n        \\n        for(int i=start;i<=end;i++){\\n            //generate all left subtrees when i is the root \\n            vector<TreeNode*> left=fn(start,i-1);\\n            // all right subtrees when i is the root \\n            vector<TreeNode*> right=fn(i+1,end);\\n            \\n            for(auto lnode:left){\\n                //for every left subtree with root=i, add all rightsubtrees to it\\n                for(auto rnode:right){\\n                    TreeNode *root=new TreeNode(i,lnode,rnode);\\n                    res.push_back(root); //store one unique BST as result \\n                }\\n                    \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> res=fn(1,n);\\n        return res;\\n    }\\n};\\n```\\n\\nPlease upvote if you found it helpful :)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> fn(int start,int end){\\n        vector<TreeNode*> res;\\n        //case when left or right subtree for a given node cant be generated \\n        if(start>end) return {NULL};\\n        //case when there is only one node \\n        if(start==end) return {new TreeNode(start)};\\n        \\n        for(int i=start;i<=end;i++){\\n            //generate all left subtrees when i is the root \\n            vector<TreeNode*> left=fn(start,i-1);\\n            // all right subtrees when i is the root \\n            vector<TreeNode*> right=fn(i+1,end);\\n            \\n            for(auto lnode:left){\\n                //for every left subtree with root=i, add all rightsubtrees to it\\n                for(auto rnode:right){\\n                    TreeNode *root=new TreeNode(i,lnode,rnode);\\n                    res.push_back(root); //store one unique BST as result \\n                }\\n                    \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*> res=fn(1,n);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934099,
                "title": "java-fast-clean-concise-memoized-recursion-explained-0ms-100",
                "content": "**Intuition** We can break the problem into a subproblem by asking what are all of structures for a given root value.  If we do this, then by virtue of the definition of a binary search tree, all the values less than our root value will be within a left subtree, and al the values greater than our root value will be within a right subtree.  But then, we can repeat this process for both the left and right children, suggesting that recursion will be of help.\\n\\n**Optimization** The input limit n=8 is not very high, but if we want to squeeze every millisecond out of our solution, we should consider one more thing.  We are going to run into a lot of the same small subtrees over and over.  We can remember these for quick lookup instead of rebuilding them each time.  This will also save some space.  This combined with an array-based cache (see **Java Syntax Cleanup**) will put our solution in the fastest class of Java solutions.\\n\\n**Jave Syntax Cleanup** It\\'s nice to use arrays for memoization because they are faster and read more cleanly.  For example, `memo[1][2]` looks nicer (and is faster) than `memo.get(1).get(2)`.  But when you want to create an array out of `List<TreeNode>` elements, Java makes it disgustingly hard to do this without casting, etc.  But there\\'s a trick - you can create a subclass such as `TreeNodeList` which extends a list of a given type (such as `ArrayList<TreeNode>`, but doesn\\'t add any methods.  It\\'s purely an extension to specify a type parameter.  Then we can create `TreeNodeList` arrays for memoization, where each `TreeNodeList` element is a `List<TreeNode>`.  By having an array-based instead of list-based cache, we\\'ll also jump into the top tier in terms of performance of java solutions, with runtimes of 0-1ms for the test suite.\\n\\n**Java Code** O(n^2) space, O(n^2) time.  Space is n^2 due to memoization.  Time would be 2^n except using memoization, we short curcuit frequently.  If we assume that only tree-building is an operation, and a cache hit is not, then due to the size of our cache, we can do at most (n+2)(n+2) operations to fill it, which is O(n^2).\\n\\n```\\nclass Solution {\\n\\n    public List<TreeNode> generateTrees(int n) {\\n        final int limit = n + 1; // upper bound, exclusive\\n        TreeNodeList[][] memo = new TreeNodeList[limit + 1][limit + 1];\\n        return generateTrees(1, limit, memo);\\n    }\\n\\n    private TreeNodeList generateTrees(int low, int limit, TreeNodeList[][] memo) {\\n        TreeNodeList cached = memo[low][limit];\\n        if (cached != null) {\\n            return cached;\\n        }\\n        TreeNodeList out = new TreeNodeList();\\n        for (int r = low; r < limit; ++r) {\\n            TreeNodeList leftNodes = generateTrees(low, r, memo);\\n            TreeNodeList rightNodes = generateTrees(r + 1, limit, memo);\\n            for (TreeNode left : leftNodes) {\\n                for (TreeNode right : rightNodes) {\\n                    TreeNode root = new TreeNode(r);\\n                    root.left = left;\\n                    root.right = right;\\n                    out.add(root);\\n                }\\n            }\\n        }\\n        // Small correction: the list of all trees we can make without any values is [null],\\n\\t\\t// not [].  That is, if we have no node values, there is one possible tree: null.\\n\\t\\t// So we correct empty lists by making them lists of a single null element, instead.\\n        // This makes looping and generating left and right children more straight-forward.\\n        if (out.isEmpty()) {\\n            out.add(null);\\n        }\\n        memo[low][limit] = out;\\n        return out;\\n    }\\n\\n    static class TreeNodeList extends ArrayList<TreeNode> {\\n        // This class exists simply for the convenience of creating arrays without a type parameter.\\n    }\\n\\n}\\n```\\n\\nIf you found this explanation and thought process helpful, please consider an upvote so someone else is more likely to find it, too. And if not, I would sincerely appreciate your constructive criticism so I can learn to write better solutions. Thanks for your time, and happy problem-solving!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<TreeNode> generateTrees(int n) {\\n        final int limit = n + 1; // upper bound, exclusive\\n        TreeNodeList[][] memo = new TreeNodeList[limit + 1][limit + 1];\\n        return generateTrees(1, limit, memo);\\n    }\\n\\n    private TreeNodeList generateTrees(int low, int limit, TreeNodeList[][] memo) {\\n        TreeNodeList cached = memo[low][limit];\\n        if (cached != null) {\\n            return cached;\\n        }\\n        TreeNodeList out = new TreeNodeList();\\n        for (int r = low; r < limit; ++r) {\\n            TreeNodeList leftNodes = generateTrees(low, r, memo);\\n            TreeNodeList rightNodes = generateTrees(r + 1, limit, memo);\\n            for (TreeNode left : leftNodes) {\\n                for (TreeNode right : rightNodes) {\\n                    TreeNode root = new TreeNode(r);\\n                    root.left = left;\\n                    root.right = right;\\n                    out.add(root);\\n                }\\n            }\\n        }\\n        // Small correction: the list of all trees we can make without any values is [null],\\n\\t\\t// not [].  That is, if we have no node values, there is one possible tree: null.\\n\\t\\t// So we correct empty lists by making them lists of a single null element, instead.\\n        // This makes looping and generating left and right children more straight-forward.\\n        if (out.isEmpty()) {\\n            out.add(null);\\n        }\\n        memo[low][limit] = out;\\n        return out;\\n    }\\n\\n    static class TreeNodeList extends ArrayList<TreeNode> {\\n        // This class exists simply for the convenience of creating arrays without a type parameter.\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713746,
                "title": "simple-c-code-with-full-explanation-recursive-approach-runtime-16ms",
                "content": "**if you like my approach please don\\'t forget to hit upvote button ! : )**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // total no. of binary search tree (countBST) =  2nCn/(n+1)\\n    // node values goes from 1 to n. [SORTED HONA JAROORI HAI - inorder traversal type generate honge]\\n    // if instead of n, we have given vector of different random values to construct BSTs from all those values, then\\n    // you should sort the vector , and then use. approach is same as below...\\n    \\n    // Time Complexity : O(C*n)\\n    // Space Complexity : O(C*n), where C is catalan number \\n    // TC for Outermost loops is simply O(n)\\n    // TC for inner nested loops is O(C)\\n    vector<TreeNode*> rec(int l, int r) \\n    {\\n        if (l > r) return {NULL};\\n        if (l == r) return {new TreeNode(l)};\\n        \\n        vector<TreeNode*> ans;\\n        for (int root = l; root <= r; root++) // fixed at every root\\n        {\\n            vector<TreeNode*> left = rec(l, root-1); //  Have roots of all BSTs which are present in left of \"root\"\\n            vector<TreeNode*> right = rec(root+1, r); // Have roots of all BSTs which are present in right of \"root\"\\n            \\n            // suppose left 4 root, and right has 3 roots, then total BSTs formed for current root is 4 X 3 = 12.\\n            // For each of the 4 left roots, there is 3 roots....means we have to use nested loops for connection with\\n            // current root.\\n            for (auto node_l : left){\\n                for (auto node_r : right){\\n                    \\n                    TreeNode *rootNode = new TreeNode(root);\\n                    rootNode->left = node_l;\\n                    rootNode->right = node_r;\\n                    ans.push_back(rootNode);\\n                }\\n            }\\n                \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*>ans = rec(1, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // total no. of binary search tree (countBST) =  2nCn/(n+1)\\n    // node values goes from 1 to n. [SORTED HONA JAROORI HAI - inorder traversal type generate honge]\\n    // if instead of n, we have given vector of different random values to construct BSTs from all those values, then\\n    // you should sort the vector , and then use. approach is same as below...\\n    \\n    // Time Complexity : O(C*n)\\n    // Space Complexity : O(C*n), where C is catalan number \\n    // TC for Outermost loops is simply O(n)\\n    // TC for inner nested loops is O(C)\\n    vector<TreeNode*> rec(int l, int r) \\n    {\\n        if (l > r) return {NULL};\\n        if (l == r) return {new TreeNode(l)};\\n        \\n        vector<TreeNode*> ans;\\n        for (int root = l; root <= r; root++) // fixed at every root\\n        {\\n            vector<TreeNode*> left = rec(l, root-1); //  Have roots of all BSTs which are present in left of \"root\"\\n            vector<TreeNode*> right = rec(root+1, r); // Have roots of all BSTs which are present in right of \"root\"\\n            \\n            // suppose left 4 root, and right has 3 roots, then total BSTs formed for current root is 4 X 3 = 12.\\n            // For each of the 4 left roots, there is 3 roots....means we have to use nested loops for connection with\\n            // current root.\\n            for (auto node_l : left){\\n                for (auto node_r : right){\\n                    \\n                    TreeNode *rootNode = new TreeNode(root);\\n                    rootNode->left = node_l;\\n                    rootNode->right = node_r;\\n                    ans.push_back(rootNode);\\n                }\\n            }\\n                \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<TreeNode*>ans = rec(1, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620543,
                "title": "clean-c-recursive-solution-with-explanation",
                "content": "Basic idea here is to make every node a root and the nodes less than its value will go to its left side and nodes greater than it will go to right side and repeat the same process on those nodes also.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> solve(int l,int r)\\n    {\\n       vector<TreeNode*>ans;\\n        \\n        if(l>r)\\n       {\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        if(l==r)\\n        {\\n            ans.push_back(new TreeNode(l));\\n            return ans;\\n        }\\n        \\n        \\n         for(int i=l;i<=r;i++)\\n        {\\n             int mid=(l+r)/2;\\n             vector<TreeNode*>left=solve(l,i-1);\\n             vector<TreeNode*>right=solve(i+1,r);\\n             \\n             for(auto l:left)\\n             {\\n                 for(auto r:right)\\n                 {\\n                   TreeNode* root=new TreeNode(i);\\n                     root->left=l;\\n                     root->right=r;\\n                     ans.push_back(root);\\n                 }\\n             }\\n        }\\n        \\n       return ans;\\n    }\\n    \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return solve(1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> solve(int l,int r)\\n    {\\n       vector<TreeNode*>ans;\\n        \\n        if(l>r)\\n       {\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n        \\n        if(l==r)\\n        {\\n            ans.push_back(new TreeNode(l));\\n            return ans;\\n        }\\n        \\n        \\n         for(int i=l;i<=r;i++)\\n        {\\n             int mid=(l+r)/2;\\n             vector<TreeNode*>left=solve(l,i-1);\\n             vector<TreeNode*>right=solve(i+1,r);\\n             \\n             for(auto l:left)\\n             {\\n                 for(auto r:right)\\n                 {\\n                   TreeNode* root=new TreeNode(i);\\n                     root->left=l;\\n                     root->right=r;\\n                     ans.push_back(root);\\n                 }\\n             }\\n        }\\n        \\n       return ans;\\n    }\\n    \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        return solve(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441985,
                "title": "swift-readable-solution-recursion",
                "content": "```\\nclass Solution {\\n    func generateTrees(_ n: Int) -> [TreeNode?] {\\n        return generateTrees(start: 1, end: n)\\n    }\\n\\n    private func generateTrees(start: Int, end: Int) -> [TreeNode?] {\\n        var answer: [TreeNode?] = []\\n        if start > end {\\n            answer.append(nil)\\n            return answer\\n        }\\n\\n        for root in start...end {\\n            let leftTrees = generateTrees(start: start, end: root-1)\\n            let rightTrees = generateTrees(start: root+1, end: end)\\n            for leftRoot in leftTrees {\\n                for rightRoot in rightTrees {\\n                    let rootNode = TreeNode(root)\\n                    rootNode.left = leftRoot\\n                    rootNode.right = rightRoot\\n                    answer.append(rootNode)\\n                }\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    func generateTrees(_ n: Int) -> [TreeNode?] {\\n        return generateTrees(start: 1, end: n)\\n    }\\n\\n    private func generateTrees(start: Int, end: Int) -> [TreeNode?] {\\n        var answer: [TreeNode?] = []\\n        if start > end {\\n            answer.append(nil)\\n            return answer\\n        }\\n\\n        for root in start...end {\\n            let leftTrees = generateTrees(start: start, end: root-1)\\n            let rightTrees = generateTrees(start: root+1, end: end)\\n            for leftRoot in leftTrees {\\n                for rightRoot in rightTrees {\\n                    let rootNode = TreeNode(root)\\n                    rootNode.left = leftRoot\\n                    rootNode.right = rightRoot\\n                    answer.append(rootNode)\\n                }\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441709,
                "title": "c-solution",
                "content": "```\\nstruct TreeNode** creatTrees(int low, int high, int *size)\\n{ \\n    if(low > high)\\n    {\\n        struct TreeNode ** out = (struct TreeNode **)malloc(sizeof(struct TreeNode*));\\n        *size = 1;\\n        out[0] = NULL;\\n        return out;\\n    }\\n    struct TreeNode ** out = (struct TreeNode **)malloc(2000*sizeof(struct TreeNode*));\\n    *size = 0;\\n    for(int i=low; i<=high; i++)\\n    {\\n        int leftSize = 0, rightSize = 0;\\n        struct TreeNode ** leftNodes = creatTrees(low, i-1, &leftSize);\\n        struct TreeNode ** rightNodes = creatTrees(i+1, high, &rightSize);\\n        for(int k=0; k<leftSize; k++)\\n            for(int j=0; j<rightSize; j++)\\n            {\\n                out[*size] = (struct TreeNode *)malloc(sizeof(struct TreeNode));\\n                out[*size]->val = i;\\n                out[*size]->left = leftNodes[k];\\n                out[*size]->right = rightNodes[j];\\n                *size += 1;\\n            }\\n    }\\n    return out;\\n}\\nstruct TreeNode** generateTrees(int n, int* returnSize){\\n    return creatTrees(1, n, returnSize);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nstruct TreeNode** creatTrees(int low, int high, int *size)\\n{ \\n    if(low > high)\\n    {\\n        struct TreeNode ** out = (struct TreeNode **)malloc(sizeof(struct TreeNode*));\\n        *size = 1;\\n        out[0] = NULL;\\n        return out;\\n    }\\n    struct TreeNode ** out = (struct TreeNode **)malloc(2000*sizeof(struct TreeNode*));\\n    *size = 0;\\n    for(int i=low; i<=high; i++)\\n    {\\n        int leftSize = 0, rightSize = 0;\\n        struct TreeNode ** leftNodes = creatTrees(low, i-1, &leftSize);\\n        struct TreeNode ** rightNodes = creatTrees(i+1, high, &rightSize);\\n        for(int k=0; k<leftSize; k++)\\n            for(int j=0; j<rightSize; j++)\\n            {\\n                out[*size] = (struct TreeNode *)malloc(sizeof(struct TreeNode));\\n                out[*size]->val = i;\\n                out[*size]->left = leftNodes[k];\\n                out[*size]->right = rightNodes[j];\\n                *size += 1;\\n            }\\n    }\\n    return out;\\n}\\nstruct TreeNode** generateTrees(int n, int* returnSize){\\n    return creatTrees(1, n, returnSize);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1440845,
                "title": "simple-solution-with-detailed-explanation-and-comments",
                "content": "**Intuition:**\\nThe idea is to generate trees in inorder fashion , making each number in the range[1.n] as the root one by one and recursively obtaining its left and right subtrees ensuring that BST properties doesnt gets violated.\\nIf the Root Value is i\\n* Left subtree will contain values in range[start,i-1]\\n* right subrees will contain valyes in range[i+1,end]\\n\\nfor a particular root value \\'i\\' there are many left and right subtrees possible , so generate all of them and combine all of them and appending to our final result vector of all BSTs.\\n\\n**Base Case:**\\nThere are two base cases:\\n*  If start exceeds end; start>end, there is no tree possible, so instead of returning empty list (which will cause unexpected loop termination in the parent recursive call) , we will append null to the result list and return result.\\n*  if start=end, there is only one number in range i.e. start, so only one Tree possible rooted at start and left and right subtree as null, so, make this tree and add to result list and return.\\n\\nHere is my code:\\n```\\n\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return helper(1,n);//To generate all the BST possible in range(1,n) \\n    }\\n    vector<TreeNode*> helper(int start, int end){\\n        vector<TreeNode*> allTrees;//vector to store all bsts\\n        if(start>end)//base case\\n        {\\n            allTrees.push_back(NULL); //No Tree is possible if start>end so push none and return\\n            return allTrees;\\n        }\\n        if(start==end) // Base case 2 \\n        {\\n            TreeNode* root=new TreeNode(start); // if there is only 1 number in range i.e. start=end then make th\\n                                                // only number as root node and return\\n            allTrees.push_back(root);\\n            return allTrees;\\n            \\n        }\\n        // making all numbers from start to end as root one by one and generating their left and right subtrees according to BST rules\\n        for(int CurRootVal=start;CurRootVal<=end;CurRootVal++)\\n        {\\n        vector<TreeNode*>allLeftSubtrees=helper(start,CurRootVal-1); // generated Leftsubtrees contains values in range[start,currootvalue-1]\\n            vector<TreeNode*>allRightSubtrees=helper(CurRootVal+1,end); //generated rightsubtrees contains values in range[currootvalue+1,end]\\n            for(auto leftsubtree : allLeftSubtrees) // traversing each of the left subtrees generated\\n            {\\n                for(auto rightsubtree : allRightSubtrees) // for each left subtree, all the right subtrees generated are traversed and combined as below \\n                {\\n                    TreeNode* curRoot=new TreeNode(CurRootVal); // making root node of value curRootVal\\n                    curRoot->left=leftsubtree; // adding leftsubtree to the left child of current root\\n                    curRoot->right=rightsubtree;// adding right subtree to the right child of current root\\n                    allTrees.push_back(curRoot);// appending the tree generated to the result alltrees\\n                }\\n            }\\n            \\n        }\\n        return allTrees;\\n        \\n    }\\n};\\n```\\n\\nComment down in case of any queries.\\n\\n**Please upvote if it helps you :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return helper(1,n);//To generate all the BST possible in range(1,n) \\n    }\\n    vector<TreeNode*> helper(int start, int end){\\n        vector<TreeNode*> allTrees;//vector to store all bsts\\n        if(start>end)//base case\\n        {\\n            allTrees.push_back(NULL); //No Tree is possible if start>end so push none and return\\n            return allTrees;\\n        }\\n        if(start==end) // Base case 2 \\n        {\\n            TreeNode* root=new TreeNode(start); // if there is only 1 number in range i.e. start=end then make th\\n                                                // only number as root node and return\\n            allTrees.push_back(root);\\n            return allTrees;\\n            \\n        }\\n        // making all numbers from start to end as root one by one and generating their left and right subtrees according to BST rules\\n        for(int CurRootVal=start;CurRootVal<=end;CurRootVal++)\\n        {\\n        vector<TreeNode*>allLeftSubtrees=helper(start,CurRootVal-1); // generated Leftsubtrees contains values in range[start,currootvalue-1]\\n            vector<TreeNode*>allRightSubtrees=helper(CurRootVal+1,end); //generated rightsubtrees contains values in range[currootvalue+1,end]\\n            for(auto leftsubtree : allLeftSubtrees) // traversing each of the left subtrees generated\\n            {\\n                for(auto rightsubtree : allRightSubtrees) // for each left subtree, all the right subtrees generated are traversed and combined as below \\n                {\\n                    TreeNode* curRoot=new TreeNode(CurRootVal); // making root node of value curRootVal\\n                    curRoot->left=leftsubtree; // adding leftsubtree to the left child of current root\\n                    curRoot->right=rightsubtree;// adding right subtree to the right child of current root\\n                    allTrees.push_back(curRoot);// appending the tree generated to the result alltrees\\n                }\\n            }\\n            \\n        }\\n        return allTrees;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325098,
                "title": "c-easy-to-understand-recursive-approach-with-comments",
                "content": "Hi,\\n\\n**If this helps please do UPVOTE or if you have any query or doubt COMMENT it down.**\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// function that takes sub parameters left and right value\\n    vector<TreeNode*> solve(int l,int r){\\n        vector<TreeNode*> ans;\\n        \\n\\t\\t// if l>r just return null\\n        if(l>r){\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n\\t\\t// if l==r  then we have only 1 node with value l or r\\n        if(l==r){\\n            TreeNode* temp=new TreeNode(l);\\n            ans.push_back(temp);\\n            return ans;\\n        }\\n        \\n\\t\\t// else for every k between l to r append subtree of values left to it to left child and subtrees of values right to it to right child of k\\n        vector<TreeNode*> ansl; // stores pointer to left subtree\\n        vector<TreeNode*> ansr; // stores pointer to right subtree\\n\\n        for(int k=l;k<=r;k++){\\n            ansl = solve(l,k-1);\\n            ansr = solve(k+1,r);\\n            if(ansl.size()==0) ansl.push_back(NULL);\\n            if(ansr.size()==0) ansr.push_back(NULL);\\n\\t\\t\\t\\n\\t\\t\\t// make all combinations with left current and right\\n            for(int i=0;i<ansl.size();i++){\\n                for(int j=0;j<ansr.size();j++){\\n                    TreeNode* temp = new TreeNode(k,ansl[i],ansr[j]);\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        return solve(1,n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// function that takes sub parameters left and right value\\n    vector<TreeNode*> solve(int l,int r){\\n        vector<TreeNode*> ans;\\n        \\n\\t\\t// if l>r just return null\\n        if(l>r){\\n            ans.push_back(NULL);\\n            return ans;\\n        }\\n\\t\\t// if l==r  then we have only 1 node with value l or r\\n        if(l==r){\\n            TreeNode* temp=new TreeNode(l);\\n            ans.push_back(temp);\\n            return ans;\\n        }\\n        \\n\\t\\t// else for every k between l to r append subtree of values left to it to left child and subtrees of values right to it to right child of k\\n        vector<TreeNode*> ansl; // stores pointer to left subtree\\n        vector<TreeNode*> ansr; // stores pointer to right subtree\\n\\n        for(int k=l;k<=r;k++){\\n            ansl = solve(l,k-1);\\n            ansr = solve(k+1,r);\\n            if(ansl.size()==0) ansl.push_back(NULL);\\n            if(ansr.size()==0) ansr.push_back(NULL);\\n\\t\\t\\t\\n\\t\\t\\t// make all combinations with left current and right\\n            for(int i=0;i<ansl.size();i++){\\n                for(int j=0;j<ansr.size();j++){\\n                    TreeNode* temp = new TreeNode(k,ansl[i],ansr[j]);\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        return solve(1,n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214387,
                "title": "python-array-recursion",
                "content": "```\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        def f(arr):\\n\\t\\t    #Base conditions\\n            if len(arr) < 1:\\n                return [None]\\n            if len(arr) == 1:\\n                return [TreeNode(arr[0])]\\n            \\n            ret = []\\n            for i,item in enumerate(arr):\\n                leftTrees = f(arr[0:i])\\n                rightTrees = f(arr[i+1:])\\n                \\n                for lt in leftTrees:\\n                    for rt in rightTrees:\\n                        r = TreeNode(arr[i])\\n                        r.left = lt\\n                        r.right = rt\\n                        ret.append(r)\\n            return ret\\n        \\n        return f(list(range(1,n+1)))\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        def f(arr):\\n\\t\\t    #Base conditions\\n            if len(arr) < 1:\\n                return [None]\\n            if len(arr) == 1:\\n                return [TreeNode(arr[0])]\\n            \\n            ret = []\\n            for i,item in enumerate(arr):\\n                leftTrees = f(arr[0:i])\\n                rightTrees = f(arr[i+1:])\\n                \\n                for lt in leftTrees:\\n                    for rt in rightTrees:\\n                        r = TreeNode(arr[i])\\n                        r.left = lt\\n                        r.right = rt\\n                        ret.append(r)\\n            return ret\\n        \\n        return f(list(range(1,n+1)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1168576,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        \\n        \\n        List<TreeNode> ans = constructTrees(1, n);\\n        return ans;\\n        \\n    }\\n    public List<TreeNode> constructTrees(int start, int end){\\n        List<TreeNode> list = new ArrayList<>();\\n        //  if start > end   then subtree will be empty so returning NULL in the list\\n        if (start > end) \\n        { \\n            list.add(null); \\n            return list; \\n        } \\n    \\n        // iterate all values from start to end for constructing left and right subtree using recursion\\n        for (int i = start; i <= end; i++) \\n        { \\n            // constructing left subtree \\n            List<TreeNode> leftSubtree  = constructTrees(start, i - 1); \\n    \\n            // constructing right subtree\\n            List<TreeNode> rightSubtree = constructTrees(i + 1, end); \\n    \\n            // now loop through all left and right subtrees and connecting them to ith root\\n            for (int j = 0; j < leftSubtree.size(); j++) \\n            { \\n                TreeNode left = leftSubtree.get(j); \\n                for (int k = 0; k < rightSubtree.size(); k++) \\n                { \\n                    TreeNode right = rightSubtree.get(k); \\n                    TreeNode node = new TreeNode(i);        // making value i as root \\n                    node.left = left;                       // connect left subtree \\n                    node.right = right;                     // connect right subtree \\n                    list.add(node);                         // add this tree to list \\n                } \\n            } \\n        } \\n        return list; \\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        \\n        \\n        List<TreeNode> ans = constructTrees(1, n);\\n        return ans;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 864407,
                "title": "bottom-up-dp-solution-20ms-c",
                "content": "```\\n   TreeNode* cloneAndAddX(TreeNode* root,int x) {\\n        if(root) {\\n            TreeNode* node = new TreeNode(root->val+x);\\n            node->left = cloneAndAddX(root->left,x);\\n            node->right = cloneAndAddX(root->right,x);\\n            return node;\\n        }\\n        return nullptr;\\n    }\\n\\t\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0) return {};\\n        vector<vector<TreeNode*>> dp(n+1);\\n        dp[0].push_back(nullptr);\\n        dp[1].push_back(new TreeNode(1));\\n        for(int i=2;i<=n;i++) {\\n            for(int j=1;j<=i;j++) {\\n                int leftSize = j-1;\\n                int rightSize = i-j;\\n                for(TreeNode* l: dp[leftSize]) {\\n                    for(TreeNode* r: dp[rightSize]) {\\n                        TreeNode* node = new TreeNode(j);\\n                        node->left = cloneAndAddX(l,0);\\n                        node->right = cloneAndAddX(r,j);\\n                        dp[i].push_back(node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   TreeNode* cloneAndAddX(TreeNode* root,int x) {\\n        if(root) {\\n            TreeNode* node = new TreeNode(root->val+x);\\n            node->left = cloneAndAddX(root->left,x);\\n            node->right = cloneAndAddX(root->right,x);\\n            return node;\\n        }\\n        return nullptr;\\n    }\\n\\t\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0) return {};\\n        vector<vector<TreeNode*>> dp(n+1);\\n        dp[0].push_back(nullptr);\\n        dp[1].push_back(new TreeNode(1));\\n        for(int i=2;i<=n;i++) {\\n            for(int j=1;j<=i;j++) {\\n                int leftSize = j-1;\\n                int rightSize = i-j;\\n                for(TreeNode* l: dp[leftSize]) {\\n                    for(TreeNode* r: dp[rightSize]) {\\n                        TreeNode* node = new TreeNode(j);\\n                        node->left = cloneAndAddX(l,0);\\n                        node->right = cloneAndAddX(r,j);\\n                        dp[i].push_back(node);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780397,
                "title": "c-recursion-and-easy-to-understand",
                "content": "Idea : You have to calculate all the binary search trees from 1 to n. Therefore, for a number in the middle say i, the left subtree would be 1 to i-1 and right subtree would be i+1 to n. So it divides into two sub problems. Solve it for left and right subtree and then iterate through all the combinations of the left and right subtree assigning the left pick from left subtree as the left child and right pick from right subtree as the right child. Return the resulting vecotr of combinations. \\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> genTrees(int start, int end){\\n        vector<TreeNode*>res;\\n        if(start>end){\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*>leftTree = genTrees(start, i-1);\\n            vector<TreeNode*>rightTree = genTrees(i+1, end);\\n            for(auto leftNode:leftTree){\\n                for(auto rightNode:rightTree){\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = leftNode;\\n                    root->right = rightNode;\\n                    res.push_back(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n==0)return {};\\n        return genTrees(1,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> genTrees(int start, int end){\\n        vector<TreeNode*>res;\\n        if(start>end){\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*>leftTree = genTrees(start, i-1);\\n            vector<TreeNode*>rightTree = genTrees(i+1, end);\\n            for(auto leftNode:leftTree){\\n                for(auto rightNode:rightTree){\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = leftNode;\\n                    root->right = rightNode;\\n                    res.push_back(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n==0)return {};\\n        return genTrees(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474776,
                "title": "go-simple-solution",
                "content": "```go\\nfunc generateTrees(n int) []*TreeNode {\\n\\tif n <= 0 {\\n\\t\\treturn []*TreeNode{}\\n\\t}\\n\\treturn helper(1, n)\\n}\\n\\nfunc helper(min, max int) []*TreeNode {\\n\\tretSlice := []*TreeNode{}\\n\\tfor i := min; i <= max; i++ {\\n\\t\\tleft := helper(min, i-1)\\n\\t\\tright := helper(i+1, max)\\n\\t\\tfor _, l := range left {\\n\\t\\t\\tfor _, r := range right {\\n\\t\\t\\t\\tretSlice = append(retSlice, &TreeNode{\\n\\t\\t\\t\\t\\tVal:   i,\\n\\t\\t\\t\\t\\tLeft:  l,\\n\\t\\t\\t\\t\\tRight: r,\\n\\t\\t\\t\\t})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// if empty, we need a nil node\\n\\tif len(retSlice) == 0 {\\n\\t\\tretSlice = append(retSlice, nil)\\n\\t}\\n\\treturn retSlice\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc generateTrees(n int) []*TreeNode {\\n\\tif n <= 0 {\\n\\t\\treturn []*TreeNode{}\\n\\t}\\n\\treturn helper(1, n)\\n}\\n\\nfunc helper(min, max int) []*TreeNode {\\n\\tretSlice := []*TreeNode{}\\n\\tfor i := min; i <= max; i++ {\\n\\t\\tleft := helper(min, i-1)\\n\\t\\tright := helper(i+1, max)\\n\\t\\tfor _, l := range left {\\n\\t\\t\\tfor _, r := range right {\\n\\t\\t\\t\\tretSlice = append(retSlice, &TreeNode{\\n\\t\\t\\t\\t\\tVal:   i,\\n\\t\\t\\t\\t\\tLeft:  l,\\n\\t\\t\\t\\t\\tRight: r,\\n\\t\\t\\t\\t})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// if empty, we need a nil node\\n\\tif len(retSlice) == 0 {\\n\\t\\tretSlice = append(retSlice, nil)\\n\\t}\\n\\treturn retSlice\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285636,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        if (n == 0) return new List<TreeNode>();\\n        return DFS(1, n);\\n    }\\n\\n    private IList<TreeNode> DFS(int start, int end) {\\n        if (start > end) {\\n            return new List<TreeNode>() { null };\\n        }\\n        var result = new List<TreeNode>();\\n        for (int i = start; i <= end; i++) {\\n            var leftList = DFS(start, i - 1);\\n            var rightList = DFS(i + 1, end);\\n\\n            foreach (var left in leftList) {\\n                foreach (var right in rightList) {\\n                    var root = new TreeNode(i);\\n                    root.left = left;\\n                    root.right = right;\\n                    result.Add(root);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        if (n == 0) return new List<TreeNode>();\\n        return DFS(1, n);\\n    }\\n\\n    private IList<TreeNode> DFS(int start, int end) {\\n        if (start > end) {\\n            return new List<TreeNode>() { null };\\n        }\\n        var result = new List<TreeNode>();\\n        for (int i = start; i <= end; i++) {\\n            var leftList = DFS(start, i - 1);\\n            var rightList = DFS(i + 1, end);\\n\\n            foreach (var left in leftList) {\\n                foreach (var right in rightList) {\\n                    var root = new TreeNode(i);\\n                    root.left = left;\\n                    root.right = right;\\n                    result.Add(root);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243362,
                "title": "java-dp-runtime-1-ms-faster-than-100-00",
                "content": "The origin DP.Not use backup,nout use iteration\\uFF0Cso can be optimize more quickly.\\n```\\nF(1...n) =f(2,n)+f(1,1)*f(3,n)+...+f(1,i-1)*f(i+1,n)+...+f(1,n-1).\\n```\\nExplanation: n node,\\ncan be represent root 1,the left is null,the right can be represent (2,n) child problem,\\nplus  root 2,the left is (1,1) child problem ,the right can be represent (3,n) child problem,\\nplus root 3,the left is (1,2) child problem ,the right can be represent (4,n) child problem,...\\nplus root i,the left is (1,i-1) child problem ,the right can be represent (i+1,n) child problem, and so on.\\n```\\n     public List<TreeNode> generateTrees(int n) {\\n       if (n == 0) {\\n            return new ArrayList<>();\\n        }\\n        List<TreeNode> results = generateTrees(1, n);\\n        return results;\\n    }\\n\\n    private List<TreeNode> generateTrees(int begin, int end) {\\n        List<TreeNode> results = new ArrayList<>();\\n        if (begin > end) {\\n            results.add(null);\\n            return results;\\n        }\\n        if (begin == end) {\\n            results.add(new TreeNode(begin));\\n            return results;\\n        }\\n\\n        for (int i = begin; i <= end; i++) {\\n            List<TreeNode> lstLeft = generateTrees(begin, i - 1);\\n            List<TreeNode> lstRight = generateTrees(i + 1, end);\\n\\n            for (int j = 0; j < lstLeft.size(); j++) {\\n                TreeNode lNode = lstLeft.get(j);\\n                for (int k = 0; k < lstRight.size(); k++) {\\n                    TreeNode rNode = lstRight.get(k);\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = lNode;\\n                    root.right = rNode;\\n                    results.add(root);\\n                }\\n            }\\n        }\\n        return results;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nF(1...n) =f(2,n)+f(1,1)*f(3,n)+...+f(1,i-1)*f(i+1,n)+...+f(1,n-1).\\n```\n```\\n     public List<TreeNode> generateTrees(int n) {\\n       if (n == 0) {\\n            return new ArrayList<>();\\n        }\\n        List<TreeNode> results = generateTrees(1, n);\\n        return results;\\n    }\\n\\n    private List<TreeNode> generateTrees(int begin, int end) {\\n        List<TreeNode> results = new ArrayList<>();\\n        if (begin > end) {\\n            results.add(null);\\n            return results;\\n        }\\n        if (begin == end) {\\n            results.add(new TreeNode(begin));\\n            return results;\\n        }\\n\\n        for (int i = begin; i <= end; i++) {\\n            List<TreeNode> lstLeft = generateTrees(begin, i - 1);\\n            List<TreeNode> lstRight = generateTrees(i + 1, end);\\n\\n            for (int j = 0; j < lstLeft.size(); j++) {\\n                TreeNode lNode = lstLeft.get(j);\\n                for (int k = 0; k < lstRight.size(); k++) {\\n                    TreeNode rNode = lstRight.get(k);\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = lNode;\\n                    root.right = rNode;\\n                    results.add(root);\\n                }\\n            }\\n        }\\n        return results;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 141443,
                "title": "a-simple-python-dp-solution",
                "content": "```python\\nclass Solution(object):\\n    def generateTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        if n == 0:\\n            return []\\n        return self.gen_helper({}, 1, n)\\n        \\n    def gen_helper(self, memo, start, end):\\n        if start > end:\\n            return [None]\\n        if (start, end) in memo:\\n            return memo[(start, end)]\\n        memo[(start, end)] = []\\n        for root_val in xrange(start, end+1):\\n            for left_child in self.gen_helper(memo, start, root_val-1):\\n                for right_child in self.gen_helper(memo, root_val+1, end):\\n                    root = TreeNode(root_val)\\n                    root.left, root.right = left_child, right_child\\n                    memo[(start, end)].append(root)\\n        return memo[(start, end)]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def generateTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[TreeNode]\\n        \"\"\"\\n        if n == 0:\\n            return []\\n        return self.gen_helper({}, 1, n)\\n        \\n    def gen_helper(self, memo, start, end):\\n        if start > end:\\n            return [None]\\n        if (start, end) in memo:\\n            return memo[(start, end)]\\n        memo[(start, end)] = []\\n        for root_val in xrange(start, end+1):\\n            for left_child in self.gen_helper(memo, start, root_val-1):\\n                for right_child in self.gen_helper(memo, root_val+1, end):\\n                    root = TreeNode(root_val)\\n                    root.left, root.right = left_child, right_child\\n                    memo[(start, end)].append(root)\\n        return memo[(start, end)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31498,
                "title": "short-c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0) return {};\\n        return DFS(1, n);\\n    }\\n    \\n    vector<TreeNode*> DFS(int l, int r){\\n        vector<TreeNode*>res;\\n        if(l > r) return {NULL};\\n        for(int i = l; i <= r; i++){\\n            auto left = DFS(l, i - 1);\\n            auto right = DFS(i + 1, r);\\n            for(auto x: left)\\n                for(auto y: right){\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = x;\\n                    root->right = y;\\n                    res.push_back(root);\\n                }    \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0) return {};\\n        return DFS(1, n);\\n    }\\n    \\n    vector<TreeNode*> DFS(int l, int r){\\n        vector<TreeNode*>res;\\n        if(l > r) return {NULL};\\n        for(int i = l; i <= r; i++){\\n            auto left = DFS(l, i - 1);\\n            auto right = DFS(i + 1, r);\\n            for(auto x: left)\\n                for(auto y: right){\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = x;\\n                    root->right = y;\\n                    res.push_back(root);\\n                }    \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31553,
                "title": "very-simple-python-recursive-solution",
                "content": "```\\nclass Solution(object):\\n    def generate(self, i, j):\\n        l = []\\n        if i > j: l.append(None)\\n        for k in xrange(i, j+1):\\n            left = self.generate(i, k-1)\\n            right = self.generate(k+1, j)\\n            for nodeleft in left:\\n                for noderight in right:\\n                    root = TreeNode(k)\\n                    root.left = nodeleft\\n                    root.right = noderight\\n                    l.append(root)\\n        return l\\n    \\n    def generateTrees(self, n):\\n        if n == 0: return []\\n        return self.generate(1, n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def generate(self, i, j):\\n        l = []\\n        if i > j: l.append(None)\\n        for k in xrange(i, j+1):\\n            left = self.generate(i, k-1)\\n            right = self.generate(k+1, j)\\n            for nodeleft in left:\\n                for noderight in right:\\n                    root = TreeNode(k)\\n                    root.left = nodeleft\\n                    root.right = noderight\\n                    l.append(root)\\n        return l\\n    \\n    def generateTrees(self, n):\\n        if n == 0: return []\\n        return self.generate(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31555,
                "title": "recursive-c-15-lines",
                "content": "``` \\nclass Solution {\\npublic:\\n   std::vector<TreeNode*> generateTrees(int n2, int n1=1) {\\n      std::vector<TreeNode*> TreeHeads;\\n      for(int i=n1; i<=n2; ++i) {\\n         auto LeftTrees = i==n1 ? std::vector<TreeNode*>{nullptr} : generateTrees(i-1, n1);\\n         auto RightTrees = i==n2 ? std::vector<TreeNode*>{nullptr} : generateTrees(n2, i+1);\\n         for( auto pleft : LeftTrees )\\n            for( auto pright : RightTrees ) {\\n               auto head = new TreeNode(i);\\n               head->left = pleft; head->right = pright;\\n               TreeHeads.push_back(head);\\n            }\\n      }\\n      return TreeHeads;\\n   }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n   std::vector<TreeNode*> generateTrees(int n2, int n1=1) {\\n      std::vector<TreeNode*> TreeHeads;\\n      for(int i=n1; i<=n2; ++i) {\\n         auto LeftTrees = i==n1 ? std::vector<TreeNode*>{nullptr} : generateTrees(i-1, n1);\\n         auto RightTrees = i==n2 ? std::vector<TreeNode*>{nullptr} : generateTrees(n2, i+1);\\n         for( auto pleft : LeftTrees )\\n            for( auto pright : RightTrees ) {\\n               auto head = new TreeNode(i);\\n               head->left = pleft; head->right = pright;\\n               TreeHeads.push_back(head);\\n            }\\n      }\\n      return TreeHeads;\\n   }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31568,
                "title": "share-my-dp-c-solution-uff0cbeats-91-82-uff0ceasy-understand",
                "content": "    void genTree(TreeNode* root, TreeNode* left, TreeNode* right,int &num){\\n        if(left){\\n            root->left = new TreeNode(left->val);\\n            genTree(root->left,left->left,left->right,num);\\n        }\\n        root->val = ++ num;\\n        if(right){\\n            root->right = new TreeNode(right->val);\\n            genTree(root->right,right->left,right->right,num);\\n        }\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<vector<TreeNode*> > res(n + 1);\\n        if(!n) return res[0];\\n        res[0] = {NULL};\\n        res[1] = {new TreeNode(1)};\\n        for(int i = 2;i <= n; ++ i){\\n            for(int j = 1;j <= i; ++ j){\\n                for(int x = 0; x < res[j - 1].size(); ++ x)\\n                    for(int y = 0; y < res[i - j].size(); ++ y)\\n                    {\\n                        int num = 0;\\n                        TreeNode *tmp = new TreeNode(j);\\n                        genTree(tmp,res[j - 1][x],res[i - j][y],num);\\n                        res[i].push_back(tmp);\\n                    }\\n            }\\n        }\\n        return res[n];\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "    void genTree(TreeNode* root, TreeNode* left, TreeNode* right,int &num){\\n        if(left){\\n            root->left = new TreeNode(left->val);\\n            genTree(root->left,left->left,left->right,num);\\n        }\\n        root->val = ++ num;\\n        if(right){\\n            root->right = new TreeNode(right->val);\\n            genTree(root->right,right->left,right->right,num);\\n        }\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<vector<TreeNode*> > res(n + 1);\\n        if(!n) return res[0];\\n        res[0] = {NULL};\\n        res[1] = {new TreeNode(1)};\\n        for(int i = 2;i <= n; ++ i){\\n            for(int j = 1;j <= i; ++ j){\\n                for(int x = 0; x < res[j - 1].size(); ++ x)\\n                    for(int y = 0; y < res[i - j].size(); ++ y)\\n                    {\\n                        int num = 0;\\n                        TreeNode *tmp = new TreeNode(j);\\n                        genTree(tmp,res[j - 1][x],res[i - j][y],num);\\n                        res[i].push_back(tmp);\\n                    }\\n            }\\n        }\\n        return res[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31544,
                "title": "the-trap-i-meet-with-c",
                "content": "dURING my implementation.\\n\\nI make one mistake as follows:\\n\\n        if(s>e)  return NULL;\\n\\n        should be\\n\\n        if(s>e)  return { NULL };\\n\\n\\nAs we will loop left and right result to combine with the root node.\\n\\nHere is the AC implementation\\n\\n    class Solution {\\n    public:\\n        vector<TreeNode*> generateTrees(int n) {\\n            if(n==0)  return vector<TreeNode*>{};\\n            return help(1, n);\\n        }\\n        \\n        vector<TreeNode*> help(int s, int e){\\n            vector<TreeNode*> result;\\n            if(s>e)  return {NULL};\\n            for(int i=s; i<=e; i++){\\n                vector<TreeNode*> left=help(s, i-1);\\n                vector<TreeNode*> right=help(i+1, e);\\n                for(auto l:left){\\n                    for(auto r:right){\\n                        TreeNode* root=new TreeNode(i);\\n                        root->left=l;\\n                        root->right=r;\\n                        result.push_back(root);\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<TreeNode*> generateTrees(int n) {\\n            if(n==0)  return vector<TreeNode*>{}",
                "codeTag": "Java"
            },
            {
                "id": 31578,
                "title": "java-2ms-solution-beats-92",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public List<TreeNode> generateTrees(int n) {\\n            if(n==0) return new ArrayList<TreeNode>();\\n            return generateTress(1, n);\\n        }\\n        \\n        private List<TreeNode> generateTress(int start, int end){\\n            if(start>end) {\\n                List<TreeNode> list = new ArrayList<TreeNode>();\\n                list.add(null);\\n                return list;\\n            }\\n            if(start==end) {\\n                List<TreeNode> list = new ArrayList<TreeNode>();\\n                list.add(new TreeNode(start)); return list;\\n            }\\n            List<TreeNode> roots = new ArrayList<TreeNode>();\\n            for(int i=start;i<=end;i++){\\n                List<TreeNode> leftTrees = generateTress(start, i-1);\\n                List<TreeNode> rightTrees = generateTress(i+1, end);\\n                for(int j=0;j<leftTrees.size();j++){\\n                    for(int k=0;k<rightTrees.size();k++){\\n                        TreeNode root = new TreeNode(i);\\n                        root.left = leftTrees.get(j);\\n                        root.right = rightTrees.get(k);\\n                        roots.add(root);\\n                    }\\n                }\\n                \\n            }\\n            return roots;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<TreeNode> generateTrees(int n) {\\n            if(n==0) return new ArrayList<TreeNode>();\\n            return generateTress(1, n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31640,
                "title": "accepted-iterative-java-solution",
                "content": "The idea is to generate binary trees for every number from 1 and store them in map. And for every next N get roots from 1 to N and just link left and right subtrees generated previously. All values in right subtree should be encreased by the root value.\\n\\n    public List<TreeNode> generateTrees(int n) {\\n        Map<Integer, List<TreeNode>> lists = new HashMap<Integer, List<TreeNode>>();\\n        \\n        List<TreeNode> list = new LinkedList<TreeNode>();\\n        list.add(null);\\n        if (n==0) return list;\\n        lists.put(0, list);\\n        \\n        list = new LinkedList<TreeNode>();\\n        TreeNode root = new TreeNode(1);\\n        list.add(root);\\n        lists.put(1, list);\\n        \\n        for (int i=2; i<=n; i++) {\\n        \\tlist = new LinkedList<TreeNode>();\\n        \\tfor (int j=1; j<=i; j++) {\\n        \\t\\tfor (TreeNode left:lists.get(j-1)) {\\n        \\t\\t\\tfor (TreeNode right:lists.get(i-j)) {\\n        \\t\\t\\t\\troot = new TreeNode(j);\\n            \\t\\t\\troot.left = left;\\n        \\t\\t\\t\\troot.right = greaterCopy(right, j);\\n        \\t\\t\\t\\tlist.add(root);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tlists.put(i, list);\\n        }\\n        return list;\\n    }\\n\\t\\n\\tprivate TreeNode greaterCopy(TreeNode node, int add) {\\n\\t\\tif (node == null) return null;\\n\\t\\tTreeNode copy = new TreeNode(node.val + add);\\n\\t\\tcopy.left = greaterCopy(node.left, add);\\n\\t\\tcopy.right = greaterCopy(node.right, add);\\n\\t\\treturn copy;\\n\\t}",
                "solutionTags": [],
                "code": "The idea is to generate binary trees for every number from 1 and store them in map. And for every next N get roots from 1 to N and just link left and right subtrees generated previously. All values in right subtree should be encreased by the root value.\\n\\n    public List<TreeNode> generateTrees(int n) {\\n        Map<Integer, List<TreeNode>> lists = new HashMap<Integer, List<TreeNode>>();\\n        \\n        List<TreeNode> list = new LinkedList<TreeNode>();\\n        list.add(null);\\n        if (n==0) return list;\\n        lists.put(0, list);\\n        \\n        list = new LinkedList<TreeNode>();\\n        TreeNode root = new TreeNode(1);\\n        list.add(root);\\n        lists.put(1, list);\\n        \\n        for (int i=2; i<=n; i++) {\\n        \\tlist = new LinkedList<TreeNode>();\\n        \\tfor (int j=1; j<=i; j++) {\\n        \\t\\tfor (TreeNode left:lists.get(j-1)) {\\n        \\t\\t\\tfor (TreeNode right:lists.get(i-j)) {\\n        \\t\\t\\t\\troot = new TreeNode(j);\\n            \\t\\t\\troot.left = left;\\n        \\t\\t\\t\\troot.right = greaterCopy(right, j);\\n        \\t\\t\\t\\tlist.add(root);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tlists.put(i, list);\\n        }\\n        return list;\\n    }\\n\\t\\n\\tprivate TreeNode greaterCopy(TreeNode node, int add) {\\n\\t\\tif (node == null) return null;\\n\\t\\tTreeNode copy = new TreeNode(node.val + add);\\n\\t\\tcopy.left = greaterCopy(node.left, add);\\n\\t\\tcopy.right = greaterCopy(node.right, add);\\n\\t\\treturn copy;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3867714,
                "title": "java-tabulation-solution-beats-99-6-explained-efficiently-upvote-if-it-helps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code aims to generate all unique Binary Search Trees (BSTs) that can be formed using the values from 1 to `n`. It uses a recursive approach along with memoization (dynamic programming) to avoid redundant calculations and optimize the solution.\\n\\n**Logic:**\\n1. The `generateTrees` function is the entry point of the algorithm, which takes an integer `n` as input representing the number of nodes in the desired BSTs.\\n\\n2. It initializes a 2D array `dp` of `List<TreeNode>` to store the results of subproblems related to generating BSTs from different ranges of values.\\n\\n3. It calls the `addBst` function with `low = 1` and `high = n` to generate all BSTs that can be formed using the values from 1 to `n`.\\n\\n4. The `addBst` function is the main recursive function used to generate all unique BSTs for a given range of values between `low` and `high`.\\n\\n5. It checks the base case: if `low > high`, it means there are no valid values to form a BST in this range. So, it returns a list containing a single `null` element, representing an empty tree.\\n\\n6. If the result for the current range (`low` to `high`) is already computed and cached in the `dp` array, it directly returns that result, avoiding redundant calculations.\\n\\n7. If the result is not cached, it proceeds to generate all possible unique BSTs for the range of values between `low` and `high`.\\n\\n8. It iterates from `low` to `high`, choosing each value `i` as the root node.\\n\\n9. For each value `i`, it recursively calls the `addBst` function to generate all possible left subtrees and right subtrees.\\n\\n10. It then combines each left subtree with each right subtree and creates a new BST with the current root value `i`.\\n\\n11. The generated BSTs are added to a list, representing all the unique BSTs that can be formed using the range of values between `low` and `high`.\\n\\n12. Finally, the list of BSTs is stored in the `dp` array at index `[low][high]` to cache the result for future use.\\n\\n**Memoization:**\\nThe dynamic programming (DP) aspect comes into play with memoization. The `dp` array is used to store the results of subproblems (i.e., unique BSTs) for different ranges of values. By storing and reusing the results of subproblems, the algorithm avoids redundant calculations and significantly improves the overall efficiency.\\n\\n**Storing in the `dp` array (`dp[i][j]`):**\\nThe `dp` array stores the list of all possible unique BSTs that can be formed from the range of values between `i` and `j`. The idea is to compute the BSTs for smaller ranges first and store the results in the `dp` array. Then, when larger ranges require the same subproblems, the algorithm can directly fetch the precomputed results from the `dp` array, reducing the number of recursive calls and redundant computations.\\n\\nIn summary, the code employs a recursive approach with memoization to generate all unique Binary Search Trees from the given range of values (1 to `n`). It stores the results of subproblems in the `dp` array, allowing it to efficiently build up the solutions for larger ranges of values by reusing the previously computed results. This approach significantly improves the efficiency of generating all possible unique BSTs for the given range of values.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given algorithm is approximately exponential, specifically O((4^n) / \\u221An). As \\'n\\' increases, the number of recursive calls and the time spent inside each call grow rapidly, making the algorithm inefficient for larger \\'n\\' values.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[][] dp = new List[n + 1][n + 1];\\n        return addBst(1, n, dp);\\n    }\\n\\n    public List<TreeNode> addBst(int low, int high, List<TreeNode>[][] dp) {\\n        if (low > high) {\\n            List<TreeNode> list = new ArrayList<>();\\n            list.add(null);\\n            return list;\\n        }\\n        if (dp[low][high] != null) {\\n            return dp[low][high];\\n        }\\n\\n        List<TreeNode> list = new ArrayList<>();\\n        for (int i = low; i <= high; i++) {\\n            List<TreeNode> leftSubtree = addBst(low, i - 1, dp);\\n            List<TreeNode> rightSubtree = addBst(i + 1, high, dp);\\n\\n            for (TreeNode left : leftSubtree) {\\n                for (TreeNode right : rightSubtree) {\\n                    list.add(new TreeNode(i, left, right));\\n                }\\n            }\\n        }\\n        return dp[low][high] = list;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        List<TreeNode>[][] dp = new List[n + 1][n + 1];\\n        return addBst(1, n, dp);\\n    }\\n\\n    public List<TreeNode> addBst(int low, int high, List<TreeNode>[][] dp) {\\n        if (low > high) {\\n            List<TreeNode> list = new ArrayList<>();\\n            list.add(null);\\n            return list;\\n        }\\n        if (dp[low][high] != null) {\\n            return dp[low][high];\\n        }\\n\\n        List<TreeNode> list = new ArrayList<>();\\n        for (int i = low; i <= high; i++) {\\n            List<TreeNode> leftSubtree = addBst(low, i - 1, dp);\\n            List<TreeNode> rightSubtree = addBst(i + 1, high, dp);\\n\\n            for (TreeNode left : leftSubtree) {\\n                for (TreeNode right : rightSubtree) {\\n                    list.add(new TreeNode(i, left, right));\\n                }\\n            }\\n        }\\n        return dp[low][high] = list;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865312,
                "title": "c-solution-recursion-supereasy-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The function `generateTrees` takes two parameters: `n`, which represents the number of nodes to be used for constructing BSTs, and `start`, which represents the starting value of the node range.\\n\\n2. The function uses recursion to generate all possible BSTs. The base case for the recursion is when n is less than start. In this case, the function returns a vector containing a single element with a value of `nullptr`. This is because there are no nodes available to construct a BST.\\n\\n3. If the base case is not triggered, the function proceeds with the generation of BSTs.\\n\\n4. The function initializes an empty vector `res` that will store the root nodes of all generated BSTs.\\n\\n5. It then iterates through a loop from `i = start` to `i = n`.\\n Inside the loop, the function performs a nested loop for `leftSubTree` and `rightSubTree` using recursive calls to generateTrees.\\n\\n6. The recursive call `generateTrees(i - 1, start)` generates all possible `left subtrees` of the current root node with values ranging from `start to i - 1`.\\n\\n7. The recursive call `generateTrees(n, i + 1)` generates all possible `right subtrees` of the current root node with values ranging from `i + 1 to n`.\\n\\n8. For each combination of left and right subtrees, the function creates a new BST by creating a new TreeNode with the value `i` as the root and setting the left and right subtrees accordingly.The newly created BST\\'s root node is added to the `res` vector.\\n\\n9. The process repeats for each i in the loop, generating different combinations of BSTs.\\n\\n10. After the loop is complete, the function returns the `res` vector, which contains pointers to the root nodes of all the generated BSTs.\\n\\n# Complexity\\n***Here  C(n) represents the nth Catalan number.***\\n- Time complexity: $$O(C(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n * C(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n,int start=1) {\\n        \\n        //base case\\n        if(n<start){\\n            return {nullptr};\\n        }\\n\\n        vector<TreeNode*> res;\\n\\n        for(int i=start;i<=n;i++){\\n            for(auto leftSubTree:generateTrees(i-1,start)){\\n                for(auto rightSubTree:generateTrees(n,i+1)){\\n                    res.push_back(new TreeNode(i,leftSubTree,rightSubTree));\\n                }\\n\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```\\n\\n![upvote lc.jpeg](https://assets.leetcode.com/users/images/4adc0ee4-e71a-45fd-bb4d-4fa397ebe276_1691227351.1175337.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n,int start=1) {\\n        \\n        //base case\\n        if(n<start){\\n            return {nullptr};\\n        }\\n\\n        vector<TreeNode*> res;\\n\\n        for(int i=start;i<=n;i++){\\n            for(auto leftSubTree:generateTrees(i-1,start)){\\n                for(auto rightSubTree:generateTrees(n,i+1)){\\n                    res.push_back(new TreeNode(i,leftSubTree,rightSubTree));\\n                }\\n\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192975,
                "title": "best-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\\n        vector<TreeNode*> ans;\\n        if(n < s) return {nullptr};                              \\n         for(int i=s; i<=n; i++) {                \\t                 \\n            for(auto left: generateTrees(i-1, s)) {                \\n                for(auto right: generateTrees(n, i+1))               \\n                    ans.push_back(new TreeNode(i, left, right));   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\\n        vector<TreeNode*> ans;\\n        if(n < s) return {nullptr};                              \\n         for(int i=s; i<=n; i++) {                \\t                 \\n            for(auto left: generateTrees(i-1, s)) {                \\n                for(auto right: generateTrees(n, i+1))               \\n                    ans.push_back(new TreeNode(i, left, right));   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318945,
                "title": "c-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> solve(int start,int end)\\n    {\\n        vector<TreeNode*> ans;\\n        if(start>end)\\n            return {NULL};\\n        if(start==end)\\n            return {new TreeNode(start)};\\n        for(int i=start;i<=end;i++)\\n        {\\n            vector<TreeNode*> left=solve(start,i-1);\\n            vector<TreeNode*> right=solve(i+1,end);\\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    ans.push_back(new TreeNode(i,l,r));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) \\n    {\\n        vector<TreeNode*> res=solve(1,n);\\n        return res;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<TreeNode*> solve(int start,int end)\\n    {\\n        vector<TreeNode*> ans;\\n        if(start>end)\\n            return {NULL}",
                "codeTag": "Java"
            },
            {
                "id": 2195106,
                "title": "short-recursive-solution-c-recursion",
                "content": "```\\nclass Solution {\\npublic:    \\n    vector<TreeNode*> generateTrees(int end, int start = 1) {\\n        vector<TreeNode*> res;\\n        if(start > end) return { NULL };\\n        for(int i = start;i<=end;i++)\\n        {\\n            vector<TreeNode*> left = generateTrees(i-1,start);\\n            vector<TreeNode*> right = generateTrees(end,i+1);\\n            for(auto &l: left)\\n            {\\n                for(auto &r: right)\\n                {\\n                    TreeNode *q = new TreeNode(i,l,r);\\n                    res.push_back(q);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    vector<TreeNode*> generateTrees(int end, int start = 1) {\\n        vector<TreeNode*> res;\\n        if(start > end) return { NULL };\\n        for(int i = start;i<=end;i++)\\n        {\\n            vector<TreeNode*> left = generateTrees(i-1,start);\\n            vector<TreeNode*> right = generateTrees(end,i+1);\\n            for(auto &l: left)\\n            {\\n                for(auto &r: right)\\n                {\\n                    TreeNode *q = new TreeNode(i,l,r);\\n                    res.push_back(q);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061160,
                "title": "python-very-short-and-fast",
                "content": "Actually my code was 100 lines!\\nI gradually removed unneccesary parts\\nFrankly speaking I don\\'t even understand the code below myself :)\\n\\nPS: because **leetcode** checks iterable solutions by *for loop* (not strict equality) we can return a **generator object** instead of a list.\\n```\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dp(vals):\\n            if not vals: yield None\\n            for i, n in enumerate(vals):\\n                for left in dp(vals[:i]):\\n                    for right in dp(vals[i + 1:]):\\n                        yield TreeNode(n, left, right)\\n\\n        return dp(list(range(1, n + 1))) \\n```\\nYou can also use 2 pointers to avoid O(n) list slices.\\n```\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dp(l, r):\\n            if l > r: yield None\\n            for n in range(l, r+1):\\n                for left in dp(l, n-1):\\n                    for right in dp(n+1, r):\\n                        yield TreeNode(n, left, right)\\n\\n        return dp(1, n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dp(vals):\\n            if not vals: yield None\\n            for i, n in enumerate(vals):\\n                for left in dp(vals[:i]):\\n                    for right in dp(vals[i + 1:]):\\n                        yield TreeNode(n, left, right)\\n\\n        return dp(list(range(1, n + 1))) \\n```\n```\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dp(l, r):\\n            if l > r: yield None\\n            for n in range(l, r+1):\\n                for left in dp(l, n-1):\\n                    for right in dp(n+1, r):\\n                        yield TreeNode(n, left, right)\\n\\n        return dp(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002795,
                "title": "beat-simplicity-speed-and-space-python",
                "content": "```\\ndef generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        \\n\\t@functools.lru_cache(None)\\n\\tdef helper(left, right):\\n\\t\\tif left > right:\\n\\t\\t\\treturn [None]\\n\\t\\tres = []\\n\\t\\tfor val in range(left, right + 1):\\n\\t\\t\\tfor left_subtree in helper(left, val - 1):\\n\\t\\t\\t\\tfor right_subtree in helper(val + 1, right):\\n\\t\\t\\t\\t\\tres.append(TreeNode(val, left_subtree, right_subtree))\\n\\t\\treturn res\\n\\n\\treturn helper(1, n)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        \\n\\t@functools.lru_cache(None)\\n\\tdef helper(left, right):\\n\\t\\tif left > right:\\n\\t\\t\\treturn [None]\\n\\t\\tres = []\\n\\t\\tfor val in range(left, right + 1):\\n\\t\\t\\tfor left_subtree in helper(left, val - 1):\\n\\t\\t\\t\\tfor right_subtree in helper(val + 1, right):\\n\\t\\t\\t\\t\\tres.append(TreeNode(val, left_subtree, right_subtree))\\n\\t\\treturn res\\n\\n\\treturn helper(1, n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1974739,
                "title": "easy-clean-from-bf-to-dp-w-memorization",
                "content": "**Method 1: Brute Force recursive solution**\\nThe concept is similar to #96, using divide and conquer to solve the problem.\\n\\n```cpp\\nclass Solution {\\n  vector<TreeNode*> generateSubTree(int l, int r) {\\n    vector<TreeNode*> res;\\n    if (l > r){\\n      res.push_back(nullptr);\\n      return res;\\n    }\\n\\n    for (int i = l; i <= r; i++) {\\n      vector<TreeNode*> leftTrees = generateSubTree(l, i-1);\\n      vector<TreeNode*> rightTrees = generateSubTree(i+1, r);\\n      \\n      for (TreeNode *left : leftTrees) {\\n        for (TreeNode *right : rightTrees) {\\n          TreeNode *node = new TreeNode(i);\\n          node->left = left;\\n          node->right = right;\\n          res.push_back(node);\\n        }\\n      }\\n    }\\n    return res;\\n  }\\npublic:\\n  vector<TreeNode*> generateTrees(int n) {\\n    return generateSubTree(1, n);\\n  }\\n};\\n```\\n\\n**Method 2 DP w/ Memorization**\\nFrom above, there are a lot of overlapping subproblems. Therefore, we do not need to recompute every time, using a map to store the previous result which already computed.\\n\\nThis method is very simple, just using left and right as our key, if we find the key existed in memo, just return the value.\\n\\n```cpp\\nclass Solution {\\n  unordered_map<string, vector<TreeNode*>> memo;\\n  vector<TreeNode*> generateSubTree(int l, int r) {\\n    vector<TreeNode*> res;\\n    if (l > r){\\n      res.push_back(nullptr);\\n      return res;\\n    }\\n    string key = to_string(l) + \"_\" + to_string(r);\\n    if (memo.find(key) != memo.end())\\n      return memo.find(key)->second;\\n\\n    for (int i = l; i <= r; i++) {\\n      vector<TreeNode*> leftTrees = generateSubTree(l, i-1);\\n      vector<TreeNode*> rightTrees = generateSubTree(i+1, r);\\n      \\n      for (TreeNode *left : leftTrees) {\\n        for (TreeNode *right : rightTrees) {\\n          TreeNode *node = new TreeNode(i);\\n          node->left = left;\\n          node->right = right;\\n          res.push_back(node);\\n        }\\n      }\\n    }\\n    memo[key] = res;\\n    return res;\\n  }\\npublic:\\n  vector<TreeNode*> generateTrees(int n) {\\n    return generateSubTree(1, n);\\n  }\\n};\\n```\\n\\nRuntime: 12 ms, faster than 96.51% of C++ online submissions for Unique Binary Search Trees II.\\nMemory Usage: 12.3 MB, less than 96.39% of C++ online submissions for Unique Binary Search Trees II.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n  vector<TreeNode*> generateSubTree(int l, int r) {\\n    vector<TreeNode*> res;\\n    if (l > r){\\n      res.push_back(nullptr);\\n      return res;\\n    }\\n\\n    for (int i = l; i <= r; i++) {\\n      vector<TreeNode*> leftTrees = generateSubTree(l, i-1);\\n      vector<TreeNode*> rightTrees = generateSubTree(i+1, r);\\n      \\n      for (TreeNode *left : leftTrees) {\\n        for (TreeNode *right : rightTrees) {\\n          TreeNode *node = new TreeNode(i);\\n          node->left = left;\\n          node->right = right;\\n          res.push_back(node);\\n        }\\n      }\\n    }\\n    return res;\\n  }\\npublic:\\n  vector<TreeNode*> generateTrees(int n) {\\n    return generateSubTree(1, n);\\n  }\\n};\\n```\n```cpp\\nclass Solution {\\n  unordered_map<string, vector<TreeNode*>> memo;\\n  vector<TreeNode*> generateSubTree(int l, int r) {\\n    vector<TreeNode*> res;\\n    if (l > r){\\n      res.push_back(nullptr);\\n      return res;\\n    }\\n    string key = to_string(l) + \"_\" + to_string(r);\\n    if (memo.find(key) != memo.end())\\n      return memo.find(key)->second;\\n\\n    for (int i = l; i <= r; i++) {\\n      vector<TreeNode*> leftTrees = generateSubTree(l, i-1);\\n      vector<TreeNode*> rightTrees = generateSubTree(i+1, r);\\n      \\n      for (TreeNode *left : leftTrees) {\\n        for (TreeNode *right : rightTrees) {\\n          TreeNode *node = new TreeNode(i);\\n          node->left = left;\\n          node->right = right;\\n          res.push_back(node);\\n        }\\n      }\\n    }\\n    memo[key] = res;\\n    return res;\\n  }\\npublic:\\n  vector<TreeNode*> generateTrees(int n) {\\n    return generateSubTree(1, n);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772451,
                "title": "simple-recursive-c-solution-with-explaintion",
                "content": "\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        return helper( 1, n);\\n    }\\n    vector<TreeNode* > helper(  int start, int end){\\n\\t\\n        vector<TreeNode* > res; // to store list of unique bsts\\n        \\n        // eg: n=3, and current root=1;\\n        //left subtree ={1,....,0}                 right subtree= {2,......,3}\\n        //eg:      1\\n        //       /      \\\\\\n        // (1,...,0)     (2,...,3)\\n        \\n        // you can see (1>0) in the left subtree(i.e., no nodes ) (thats why we need to push \"NULL\" and return)\\n        if( start > end){\\n            res.push_back(nullptr);\\n            return res;\\n        }\\n        \\n        // we will make every no. the current rooot and recursively call the left & right subtree\\n        for( int i=start; i<=end; i++){\\n            \\n            vector<TreeNode*> left_sub, right_sub;\\n            left_sub = helper(start, i-1);  // recursively make left subtree\\n            right_sub = helper(i+1, end); // recursively make right subtree\\n            \\n            \\n            // iterate through the alll possible left(values < i) & right(values>i) nodes and do the linkings\\n            // with the current node\\n            for( auto l: left_sub){\\n                for(auto r: right_sub){\\n                    \\n                    //current root\\n                    TreeNode* curr_root= new TreeNode(i);\\n                    \\n                    // link current root with left and right nodes(with every possible combinations)\\n                    curr_root->left = l;\\n                    curr_root->right = r;\\n                    \\n                    res.push_back(curr_root); // push the rooot into the result list\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        return helper( 1, n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1686393,
                "title": "c-clean-and-concise",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> recur(int l,int r)\\n    {\\n        if(l>r)\\n            return {NULL};\\n        \\n        vector<TreeNode *>ans;\\n        for(int root=l;root<=r;root++)\\n        {\\n            auto left=recur(l,root-1);\\n            auto right=recur(root+1,r);\\n            \\n            for(auto i:left)\\n            {\\n                for(auto j:right)\\n                {\\n                    TreeNode *newNode=new TreeNode(root,i,j);\\n                    ans.push_back(newNode);\\n                }\\n                    \\n            }\\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        return recur(1,n);\\n    }\\n};\\n```\\n\\n**Pls upvote if you found helpful.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> recur(int l,int r)\\n    {\\n        if(l>r)\\n            return {NULL};\\n        \\n        vector<TreeNode *>ans;\\n        for(int root=l;root<=r;root++)\\n        {\\n            auto left=recur(l,root-1);\\n            auto right=recur(root+1,r);\\n            \\n            for(auto i:left)\\n            {\\n                for(auto j:right)\\n                {\\n                    TreeNode *newNode=new TreeNode(root,i,j);\\n                    ans.push_back(newNode);\\n                }\\n                    \\n            }\\n        }\\n        return ans;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        return recur(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504095,
                "title": "recursive-java-solution",
                "content": "For this question suppose the input is 4; That means that from 1 to 4 each of the values can act as the root and can have its own unique BST. SO lets take a start value equal to 1 and an end value equal to the given input n and then use a helper function.\\n \\n In the helper function, lets use a for loop where int i represents the TreeNode present in the list which at first will iterate from 1 to n as each node can be a root. now lets use recursion to find the leftList by defining the start as 1 and the end as (i - 1) and the right list by start as (i + 1) and end as n . By the principle of mathematical induction lets assume that we have recieved the required list of treeNode for the left of i and the right of i.\\n \\n now lets traverse though each of the TreeNode of the left as well as the Right by using a enhanced For Loop. then create a new TreeNode root that will have the data i. and we will have to connect root.left to each node of the leftTree as well as the right tree. Then add the root to the list and return it.\\n ...\\n \\n class Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        \\n        if(n == 0){\\n            return new ArrayList<TreeNode>(null);\\n        }\\n        return generateHelper(1, n);\\n    }\\n\\t// helper function\\n    private List<TreeNode> generateHelper(int start, int end){\\n        List<TreeNode> trees = new ArrayList<>();\\n        if(start > end){\\n            trees.add(null);\\n            return trees;\\n        }\\n        for(int i = start; i <= end; i++){\\n            List<TreeNode> leftTree = generateHelper(start, i - 1);\\n            List<TreeNode> rightTree = generateHelper(i + 1, end);\\n            \\n\\t\\t\\t// traverse to each TreeNode of both the lists\\n            for(TreeNode left : leftTree){\\n                for(TreeNode right : rightTree){\\n                    TreeNode root = new TreeNode(i);\\n                    \\n                    root.left = left;\\n                    root.right = right;\\n                    \\n                    trees.add(root);\\n                }\\n            }\\n        }\\n        return trees;\\n    }\\n}\\n\\n...\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        \\n        if(n == 0){\\n            return new ArrayList<TreeNode>(null);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1446833,
                "title": "java-clean-concise-optimal-code-postorder-traversal-depth-first-search-algorithm",
                "content": "```\\nclass Solution {\\n    \\n    private List<TreeNode> generateTrees (int start, int end) {\\n        \\n        List<TreeNode> allTrees = new ArrayList<> ();\\n        \\n        if (start > end) {\\n            allTrees.add (null);\\n            return allTrees;\\n        }\\n        \\n        for (int i = start; i <= end; i++) {\\n            List<TreeNode> leftTrees = generateTrees (start, i - 1);\\n            List<TreeNode> rightTrees = generateTrees (i + 1, end);\\n            \\n            for (TreeNode l : leftTrees) {\\n                for (TreeNode r : rightTrees) {\\n                    TreeNode node = new TreeNode (i);\\n                    node.left = l;\\n                    node.right = r;\\n                    allTrees.add (node);\\n                }\\n            }\\n        }\\n        \\n        return allTrees;\\n    }\\n    \\n    public List<TreeNode> generateTrees(int n) {\\n        \\n        return generateTrees (1, n);\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private List<TreeNode> generateTrees (int start, int end) {\\n        \\n        List<TreeNode> allTrees = new ArrayList<> ();\\n        \\n        if (start > end) {\\n            allTrees.add (null);\\n            return allTrees;\\n        }\\n        \\n        for (int i = start; i <= end; i++) {\\n            List<TreeNode> leftTrees = generateTrees (start, i - 1);\\n            List<TreeNode> rightTrees = generateTrees (i + 1, end);\\n            \\n            for (TreeNode l : leftTrees) {\\n                for (TreeNode r : rightTrees) {\\n                    TreeNode node = new TreeNode (i);\\n                    node.left = l;\\n                    node.right = r;\\n                    allTrees.add (node);\\n                }\\n            }\\n        }\\n        \\n        return allTrees;\\n    }\\n    \\n    public List<TreeNode> generateTrees(int n) {\\n        \\n        return generateTrees (1, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441817,
                "title": "simple-recursive-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*>helper(int start,int end){\\n        if(start>end){\\n            return {NULL};\\n        }\\n        vector<TreeNode*>ans;\\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*>leftOf =helper(start,i-1);\\n            vector<TreeNode*>rightOf =helper(i+1,end);\\n            for(auto l: leftOf){\\n                for(auto r: rightOf){\\n                    TreeNode* root= new TreeNode(i);\\n                    root->left=l;\\n                    root->right=r;\\n                    ans.push_back(root);                   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n==0)return vector<TreeNode*>();\\n        return helper(1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*>helper(int start,int end){\\n        if(start>end){\\n            return {NULL};\\n        }\\n        vector<TreeNode*>ans;\\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*>leftOf =helper(start,i-1);\\n            vector<TreeNode*>rightOf =helper(i+1,end);\\n            for(auto l: leftOf){\\n                for(auto r: rightOf){\\n                    TreeNode* root= new TreeNode(i);\\n                    root->left=l;\\n                    root->right=r;\\n                    ans.push_back(root);                   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n==0)return vector<TreeNode*>();\\n        return helper(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441035,
                "title": "python3-using-dfs",
                "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        return self.dfs(1, n)\\n    \\n    def dfs(self, start, end):\\n        if start > end:\\n            return [None]\\n        if start == end:\\n            return [TreeNode(start)]\\n        result = []\\n        for i in range(start, end+1):\\n            left = self.dfs(start, i-1)\\n            right = self.dfs(i+1, end)\\n            for l in left:\\n                for r in right:\\n                    temp = TreeNode(i)\\n                    temp.left = l\\n                    temp.right = r\\n                    result.append(temp)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        return self.dfs(1, n)\\n    \\n    def dfs(self, start, end):\\n        if start > end:\\n            return [None]\\n        if start == end:\\n            return [TreeNode(start)]\\n        result = []\\n        for i in range(start, end+1):\\n            left = self.dfs(start, i-1)\\n            right = self.dfs(i+1, end)\\n            for l in left:\\n                for r in right:\\n                    temp = TreeNode(i)\\n                    temp.left = l\\n                    temp.right = r\\n                    result.append(temp)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440911,
                "title": "day-2-unique-bst-2-recursion-with-pointers-c-with-explanation",
                "content": "Idea is to build a tree with each subtree by considering an element as a root.\\nTake `i` as root and build trees with `1 to i-1` and `i+1 to n`\\n\\nFor example:\\nTake `n = 3`\\n1. Start with `1` -> build tree from `1 to 0` which is NULL, then build with `2 to 3` for which you can have two types `2->null->3` and `3->2`. Now **attach** these two trees to the main tree i.e. `1` \\nSo, Total combinations you have are: `[1, null, 2, null, 3], [1, null, 3, 2]`\\n\\n\\n2. Start with `2` -> build tree from `1 to 1` which is `1` then build a tree with `3 to 3` which is `3`. Now, attach these two trees to `2`.\\nSo, you only have 1 total combination: `[2, 1, 3]`\\n\\n3. Start with `3` -> build tree from `1 to 2` which are `1->null->null->2` and `2->null->1`. Now attach these two trees to `3`.\\nSo, the combinations are `[3, 1, null, null, 2], [3, 2, null, 1]`\\n\\nLike this we can build for all starting nodes:\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> buildTree(int current, int n) {\\n        vector<TreeNode*> nodeList; // Creating a blank tree list\\n        if (current > n) {\\n            nodeList.push_back(NULL); // for case where current node is greater than n\\n            return nodeList;\\n        }\\n        if (current == n) {\\n            nodeList.push_back(new TreeNode(current)); // for case n just add the element as parent\\n            return nodeList;\\n        }\\n\\t\\t// Loop through all vertices building the tree nodes\\n        for (int i = current; i <= n; i++) {\\n            vector<TreeNode*> leftSubTree = buildTree(current, i-1); // first recursion to loop through all left nodes\\n            vector<TreeNode*> rightSubTree = buildTree(i+1, n); // second recursion to loop through all right nodes\\n\\t\\t\\t// Now we have all lsubtree and rsubtree, we can loop through them and create a tree\\n            for (auto leftTree: leftSubTree) {\\n                for (auto rightTree: rightSubTree) {\\n                    TreeNode *newTree = new TreeNode(i); // create a new tree with the current i as parent\\n                    newTree->left = leftTree; // assign left tree\\n                    newTree->right = rightTree; // assign right tree\\n                    nodeList.push_back(newTree); // push to vector\\n                }\\n            }\\n        }\\n        return nodeList;\\n    }\\n\\t\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildTree(1, n); // call function from 1 to n\\n    }\\n};\\n```\\n\\nPlease upvote if found helpful!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> buildTree(int current, int n) {\\n        vector<TreeNode*> nodeList; // Creating a blank tree list\\n        if (current > n) {\\n            nodeList.push_back(NULL); // for case where current node is greater than n\\n            return nodeList;\\n        }\\n        if (current == n) {\\n            nodeList.push_back(new TreeNode(current)); // for case n just add the element as parent\\n            return nodeList;\\n        }\\n\\t\\t// Loop through all vertices building the tree nodes\\n        for (int i = current; i <= n; i++) {\\n            vector<TreeNode*> leftSubTree = buildTree(current, i-1); // first recursion to loop through all left nodes\\n            vector<TreeNode*> rightSubTree = buildTree(i+1, n); // second recursion to loop through all right nodes\\n\\t\\t\\t// Now we have all lsubtree and rsubtree, we can loop through them and create a tree\\n            for (auto leftTree: leftSubTree) {\\n                for (auto rightTree: rightSubTree) {\\n                    TreeNode *newTree = new TreeNode(i); // create a new tree with the current i as parent\\n                    newTree->left = leftTree; // assign left tree\\n                    newTree->right = rightTree; // assign right tree\\n                    nodeList.push_back(newTree); // push to vector\\n                }\\n            }\\n        }\\n        return nodeList;\\n    }\\n\\t\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildTree(1, n); // call function from 1 to n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237072,
                "title": "c-recursion-easy-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n    \\n    // for a list of nodes, I can choose the root node for the tree\\n    // construct the left and right subtrees and return root node of all possible left and right subtrees (low, root-1) and (root+1, high)\\n    // iterate over the left and right subtree root nodes, add it to left and right child of root being considered\\n    \\n    \\n    vector<TreeNode*> constructTree(int low, int high){\\n        if(low>high)\\n            return vector<TreeNode*>{NULL};\\n        // choose the root node\\n        vector<TreeNode*> tree;\\n        vector<TreeNode*> leftSubtrees;\\n        vector<TreeNode*> rightSubtrees;\\n        for(int node = low; node<=high; node++ ){\\n            \\n            leftSubtrees = constructTree(low, node-1);\\n            rightSubtrees = constructTree(node+1, high);\\n            \\n            for(TreeNode* n1 : leftSubtrees){\\n                for(TreeNode* n2: rightSubtrees){\\n                    TreeNode* n = new TreeNode(node);\\n                    n->left = n1;\\n                    n->right = n2;\\n                    tree.push_back(n);\\n                }\\n            }\\n            \\n        } \\n        return tree;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n       if(n==0)\\n           return vector<TreeNode*>();\\n        \\n        return constructTree(1,n);\\n       \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    // for a list of nodes, I can choose the root node for the tree\\n    // construct the left and right subtrees and return root node of all possible left and right subtrees (low, root-1) and (root+1, high)\\n    // iterate over the left and right subtree root nodes, add it to left and right child of root being considered\\n    \\n    \\n    vector<TreeNode*> constructTree(int low, int high){\\n        if(low>high)\\n            return vector<TreeNode*>{NULL}",
                "codeTag": "Java"
            },
            {
                "id": 1199333,
                "title": "c-solution-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generateBST(int begin, int end)\\n    {\\n        vector<TreeNode*>V;\\n        \\n        if(begin>end)\\n        {\\n            V.push_back(NULL);\\n            return V;\\n        }\\n        \\n        for(int i=begin; i<=end; i++)\\n        {\\n            vector<TreeNode*>left =  generateBST(begin, i-1);\\n            vector<TreeNode*>right =  generateBST(i+1,end);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = l;\\n                    root->right = r;\\n                    V.push_back(root);\\n                }\\n            }\\n            \\n        }\\n        \\n        return V;\\n        \\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        vector<TreeNode*>V;\\n        if(n==0) return V;\\n        \\n        return generateBST(1,n);\\n        \\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<TreeNode*> generateBST(int begin, int end)\\n    {\\n        vector<TreeNode*>V;\\n        \\n        if(begin>end)\\n        {\\n            V.push_back(NULL);\\n            return V;\\n        }\\n        \\n        for(int i=begin; i<=end; i++)\\n        {\\n            vector<TreeNode*>left =  generateBST(begin, i-1);\\n            vector<TreeNode*>right =  generateBST(i+1,end);\\n            \\n            for(auto l:left)\\n            {\\n                for(auto r:right)\\n                {\\n                    TreeNode* root = new TreeNode(i);\\n                    root->left = l;\\n                    root->right = r;\\n                    V.push_back(root);\\n                }\\n            }\\n            \\n        }\\n        \\n        return V;\\n        \\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        vector<TreeNode*>V;\\n        if(n==0) return V;\\n        \\n        return generateBST(1,n);\\n        \\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137417,
                "title": "c-recursion-12ms-simple-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0){\\n            return {NULL};\\n        }\\n        return recur(1, n);\\n    }\\n    \\n    vector<TreeNode*> recur(int start, int end){\\n        vector<TreeNode*> V;\\n        if(start > end){\\n            V.push_back(NULL);\\n            return V;\\n        }\\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*> left = recur(start, i-1);\\n            vector<TreeNode*> right = recur(i+1, end);\\n            \\n            for(auto l: left){\\n                for(auto r: right){\\n                    TreeNode* tree = new TreeNode(i);\\n                    tree->left = l;\\n                    tree->right = r;\\n                    V.push_back(tree);\\n                }\\n            }\\n        }\\n        return V;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if(n == 0){\\n            return {NULL};\\n        }\\n        return recur(1, n);\\n    }\\n    \\n    vector<TreeNode*> recur(int start, int end){\\n        vector<TreeNode*> V;\\n        if(start > end){\\n            V.push_back(NULL);\\n            return V;\\n        }\\n        for(int i=start;i<=end;i++){\\n            vector<TreeNode*> left = recur(start, i-1);\\n            vector<TreeNode*> right = recur(i+1, end);\\n            \\n            for(auto l: left){\\n                for(auto r: right){\\n                    TreeNode* tree = new TreeNode(i);\\n                    tree->left = l;\\n                    tree->right = r;\\n                    V.push_back(tree);\\n                }\\n            }\\n        }\\n        return V;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121143,
                "title": "python-super-simple-with-documentation",
                "content": "This is actually an Easy difficulty problem. The only thing to remember is the discipline of keeping smaller values to left sub-tree and bigger values to right sub-tree, to ensure we have BSTs, which itself is trivially obvious since we are dealing with BST.\\n```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def bstGen(arr:List[int])->List[TreeNode]:\\n            if len(arr)<=0: return [None]                       # terminal condition\\n            result = []                                         \\n            for i in range(len(arr)):                           # for each number in the input list\\n                left, right = bstGen(arr[:i]), bstGen(arr[i+1:])# recursive calls to the lesser and greater numbers\\n                for l in left:                                  # genereate all combinations of left and right subtrees\\n                    for r in right:\\n                        result.append(TreeNode(arr[i], l, r))   # append each combination to the list of trees\\n            return result\\n        return bstGen(list(range(1,n+1)))\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        def bstGen(arr:List[int])->List[TreeNode]:\\n            if len(arr)<=0: return [None]                       # terminal condition\\n            result = []                                         \\n            for i in range(len(arr)):                           # for each number in the input list\\n                left, right = bstGen(arr[:i]), bstGen(arr[i+1:])# recursive calls to the lesser and greater numbers\\n                for l in left:                                  # genereate all combinations of left and right subtrees\\n                    for r in right:\\n                        result.append(TreeNode(arr[i], l, r))   # append each combination to the list of trees\\n            return result\\n        return bstGen(list(range(1,n+1)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075772,
                "title": "c-faster-than-97-5-recursive-with-memoization",
                "content": "1.  We know that all nodes in left subtree are smaller than root and all nodes in right subtree are greater than node in BST.\\n2.  So, if we make ith number as root, 1 to i-1 will be in our left subtree and i+1 to n will be in our right subtree.\\n3.  Now, If 1 to i-1 can form different trees in p ways and i+1 to n can form different trees in q ways. Then our answer will be p * q.\\n4.  Also, we can have n choices to select our root, so we will be iterating over 1 to n for root and another loops for left and right subtree.\\n5.  At last, we can memoize this recursive solution.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> dp[13][13];\\n    vector<TreeNode*> constructBST(int start,int end){\\n        vector<TreeNode*> res;\\n        if(start > end){\\n            res.push_back(NULL); // start > end => subtree will be empty\\n            return res;\\n        }\\n        if(dp[start][end].size() != 0){  // Memoizing recursion calls\\n            return dp[start][end];\\n        }\\n        for(int i = start;i<=end;i++){\\n            vector<TreeNode*> left = constructBST(start,i-1); // constructing left subtree\\n            vector<TreeNode*> right = constructBST(i+1,end); //constructing right subtree\\n            \\n            // now looping through all left and right subtrees and connecting \\n            // them to ith root  below\\n            for(TreeNode* l:left){\\n                for(TreeNode* r:right){\\n                    TreeNode* root = new TreeNode(i);  //making value i as root \\n                    root->left = l;                    //connecting left subtree\\n                    root->right = r;                   //connecting right subtree\\n                    \\n                    res.push_back(root);               // adding tree to list\\n                }\\n            }\\n        }\\n        return dp[start][end] = res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                dp[i][j].clear();\\n            }\\n        }\\n        return constructBST(1,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> dp[13][13];\\n    vector<TreeNode*> constructBST(int start,int end){\\n        vector<TreeNode*> res;\\n        if(start > end){\\n            res.push_back(NULL); // start > end => subtree will be empty\\n            return res;\\n        }\\n        if(dp[start][end].size() != 0){  // Memoizing recursion calls\\n            return dp[start][end];\\n        }\\n        for(int i = start;i<=end;i++){\\n            vector<TreeNode*> left = constructBST(start,i-1); // constructing left subtree\\n            vector<TreeNode*> right = constructBST(i+1,end); //constructing right subtree\\n            \\n            // now looping through all left and right subtrees and connecting \\n            // them to ith root  below\\n            for(TreeNode* l:left){\\n                for(TreeNode* r:right){\\n                    TreeNode* root = new TreeNode(i);  //making value i as root \\n                    root->left = l;                    //connecting left subtree\\n                    root->right = r;                   //connecting right subtree\\n                    \\n                    res.push_back(root);               // adding tree to list\\n                }\\n            }\\n        }\\n        return dp[start][end] = res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                dp[i][j].clear();\\n            }\\n        }\\n        return constructBST(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074455,
                "title": "javascript-recursive-solution",
                "content": "```\\nvar generateTrees = function(n) {\\n   \\n    \\n    const constructArray = (start, end) => {\\n        const result = [];\\n        \\n        if(start > end){\\n            return [null];\\n        }\\n        \\n        if(start===end){\\n            return [new TreeNode(start)];\\n        }\\n        \\n        if(end-start===1){\\n            const first = new TreeNode(start, null, new TreeNode(end));\\n            const second = new TreeNode(end, new TreeNode(start), null);\\n            return [first, second];\\n        }\\n        \\n        for(let i=start; i<=end; i++){\\n            const leftSide = constructArray(start, i-1);\\n            const rightSide = constructArray(i+1, end);\\n            \\n            leftSide.forEach(ls => {\\n                rightSide.forEach(rs => {\\n                    const tree = new TreeNode(i, ls, rs);\\n                    \\n                    result.push(tree);\\n                })\\n            })\\n        }\\n        \\n        return result;\\n    }\\n    \\n    return constructArray(1,n);\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar generateTrees = function(n) {\\n   \\n    \\n    const constructArray = (start, end) => {\\n        const result = [];\\n        \\n        if(start > end){\\n            return [null];\\n        }\\n        \\n        if(start===end){\\n            return [new TreeNode(start)];\\n        }\\n        \\n        if(end-start===1){\\n            const first = new TreeNode(start, null, new TreeNode(end));\\n            const second = new TreeNode(end, new TreeNode(start), null);\\n            return [first, second];\\n        }\\n        \\n        for(let i=start; i<=end; i++){\\n            const leftSide = constructArray(start, i-1);\\n            const rightSide = constructArray(i+1, end);\\n            \\n            leftSide.forEach(ls => {\\n                rightSide.forEach(rs => {\\n                    const tree = new TreeNode(i, ls, rs);\\n                    \\n                    result.push(tree);\\n                })\\n            })\\n        }\\n        \\n        return result;\\n    }\\n    \\n    return constructArray(1,n);\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1037235,
                "title": "scala-one-liner",
                "content": "Using separate recursive function\\n```scala\\ndef generateTrees(n: Int): List[TreeNode] = gen(0, n + 1).toList\\ndef gen(l: Int, r: Int): Seq[TreeNode]    =\\n  if (l == r) Seq(null) else for (m <- l until r; tl <- gen(l, m); tr <- gen(m + 1, r)) yield new TreeNode(m, tl, tr)\\n```\\nCan be done as one-liner using cumbersome default argument\\n```scala\\ndef generateTrees(r: Int, l : Int = 1): List[TreeNode] =\\n  if (l > r) List(null) else for (m <- (l to r).toList; tl <- generateTrees(m - 1, l); tr <- generateTrees(r, m + 1)) yield new TreeNode(m, tl, tr)\\n``` \\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```scala\\ndef generateTrees(n: Int): List[TreeNode] = gen(0, n + 1).toList\\ndef gen(l: Int, r: Int): Seq[TreeNode]    =\\n  if (l == r) Seq(null) else for (m <- l until r; tl <- gen(l, m); tr <- gen(m + 1, r)) yield new TreeNode(m, tl, tr)\\n```\n```scala\\ndef generateTrees(r: Int, l : Int = 1): List[TreeNode] =\\n  if (l > r) List(null) else for (m <- (l to r).toList; tl <- generateTrees(m - 1, l); tr <- generateTrees(r, m + 1)) yield new TreeNode(m, tl, tr)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1027430,
                "title": "javascript-simple-dp-memoization",
                "content": "```javascript\\nvar generateTrees = function(n) {\\n    const memo = new Map();\\n    \\n    function buildTree(arr) {\\n        if(!arr.length) return [null];\\n        if(memo.has(arr.join())) return memo.get(arr.join());\\n        const result = [];\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            const left = buildTree(arr.slice(0, i));\\n            const right = buildTree(arr.slice(i+1));\\n            \\n            for(let curLeft of left) {\\n                for(let curRight of right) {\\n                    const tree = new TreeNode(arr[i]);\\n                    tree.left = curLeft;\\n                    tree.right = curRight;\\n                    result.push(tree);\\n                }\\n            }\\n        }\\n        memo.set(arr.join(), result);\\n        return result;\\n    }\\n    return buildTree([...Array(n)].map((_, i) => i+1));\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```javascript\\nvar generateTrees = function(n) {\\n    const memo = new Map();\\n    \\n    function buildTree(arr) {\\n        if(!arr.length) return [null];\\n        if(memo.has(arr.join())) return memo.get(arr.join());\\n        const result = [];\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            const left = buildTree(arr.slice(0, i));\\n            const right = buildTree(arr.slice(i+1));\\n            \\n            for(let curLeft of left) {\\n                for(let curRight of right) {\\n                    const tree = new TreeNode(arr[i]);\\n                    tree.left = curLeft;\\n                    tree.right = curRight;\\n                    result.push(tree);\\n                }\\n            }\\n        }\\n        memo.set(arr.join(), result);\\n        return result;\\n    }\\n    return buildTree([...Array(n)].map((_, i) => i+1));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 945834,
                "title": "python-recursive",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        if n < 1: return []\\n        \\n        nums = list(range(1,n+1))\\n        return self.helper(nums)\\n            \\n            \\n    def helper(self, nums):\\n        if not nums:\\n            return [None]\\n        res = []\\n        for i in range(len(nums)):\\n            l = self.helper(nums[:i])\\n            r = self.helper(nums[i+1:])\\n            for ltree in l:\\n                for rtree in r:\\n                    root = TreeNode(nums[i])\\n                    root.left = ltree\\n                    root.right = rtree\\n                    res.append(root)\\n        return res \\n                \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        if n < 1: return []\\n        \\n        nums = list(range(1,n+1))\\n        return self.helper(nums)\\n            \\n            \\n    def helper(self, nums):\\n        if not nums:\\n            return [None]\\n        res = []\\n        for i in range(len(nums)):\\n            l = self.helper(nums[:i])\\n            r = self.helper(nums[i+1:])\\n            for ltree in l:\\n                for rtree in r:\\n                    root = TreeNode(nums[i])\\n                    root.left = ltree\\n                    root.right = rtree\\n                    res.append(root)\\n        return res \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810002,
                "title": "for-my-reference-have-a-look",
                "content": "Guys this is for my reference.\\nIf there is any mistake in the comments please do tell. It will me beneficial for everybody \\nThanks and be safe !\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        if n == 0:\\n            return []\\n        \\n        def helper(start,end):  # my helper function \\n            \\n            if start > end:  # when we reach at the leaf node\\n                return [None]\\n            \\n            res = []                    # for each tree \\n            \\n            for i in range(start,end+1):\\n                \\n                left = helper(start,i-1)  # creating list for left side of the root node\\n                right = helper(i+1,end)   # creating list for right side of the root node\\n                \\n                for l in left:            # iterating over left nodes of the root node\\n                    for r in right:        # iterating over right nodes of the root node            \\n                        node = TreeNode(i)  # creating a node \\n                        node.left = l       # constructing left side\\n                        node.right = r      # constructing right side\\n                        res.append(node)  \\n            print(res)\\n            return res\\n        \\n        return helper(1,n)\\n                        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        \\n        if n == 0:\\n            return []\\n        \\n        def helper(start,end):  # my helper function \\n            \\n            if start > end:  # when we reach at the leaf node\\n                return [None]\\n            \\n            res = []                    # for each tree \\n            \\n            for i in range(start,end+1):\\n                \\n                left = helper(start,i-1)  # creating list for left side of the root node\\n                right = helper(i+1,end)   # creating list for right side of the root node\\n                \\n                for l in left:            # iterating over left nodes of the root node\\n                    for r in right:        # iterating over right nodes of the root node            \\n                        node = TreeNode(i)  # creating a node \\n                        node.left = l       # constructing left side\\n                        node.right = r      # constructing right side\\n                        res.append(node)  \\n            print(res)\\n            return res\\n        \\n        return helper(1,n)\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 789874,
                "title": "python-recursive-solution-with-explanations",
                "content": "```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        # Edge case:\\n        if n == 0:\\n            return []\\n\\t\\t\\t\\n        # helping recursive function which recieves a range (within n) and returns all subtrees in that range:\\n        def rec(start, end):\\n\\t\\t\\n            # not supposed to happen:\\n            if start > end:\\n                return [None]\\n\\t\\t\\t\\t\\n            # got to a leaf:\\n            if start == end:\\n                return [TreeNode(start)]\\n            ret_list = []\\n\\t\\t\\t\\n            # for each option of root, get all possible subtrees and add to result each pair possible of left and right:\\n            for i in range(start, end+1):\\n                left = rec(start, i-1)\\n                right = rec(i+1, end)\\n                for pair in product(left, right):\\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\\n        \\n            return ret_list\\n        res = rec(1,n)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[TreeNode]:\\n        # Edge case:\\n        if n == 0:\\n            return []\\n\\t\\t\\t\\n        # helping recursive function which recieves a range (within n) and returns all subtrees in that range:\\n        def rec(start, end):\\n\\t\\t\\n            # not supposed to happen:\\n            if start > end:\\n                return [None]\\n\\t\\t\\t\\t\\n            # got to a leaf:\\n            if start == end:\\n                return [TreeNode(start)]\\n            ret_list = []\\n\\t\\t\\t\\n            # for each option of root, get all possible subtrees and add to result each pair possible of left and right:\\n            for i in range(start, end+1):\\n                left = rec(start, i-1)\\n                right = rec(i+1, end)\\n                for pair in product(left, right):\\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\\n        \\n            return ret_list\\n        res = rec(1,n)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460045,
                "title": "c-nice-recursion",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<TreeNode*> gen(int l, int r) {\\n        if (l > r) return {nullptr};\\n        if (l == r) return {new TreeNode(l)};\\n        vector<TreeNode*> ans;\\n        for (int i = l; i <= r; ++i) {\\n            vector<TreeNode*> leftL = gen(l, i-1);\\n            vector<TreeNode*> rightL = gen(i+1, r);\\n            for (auto &left: leftL) {\\n                for (auto &right: rightL) {\\n                    TreeNode *head = new TreeNode(i);\\n                    head->left = left;\\n                    head->right = right;\\n                    ans.push_back(head);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n < 1) return {};\\n        return gen(1,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<TreeNode*> gen(int l, int r) {\\n        if (l > r) return {nullptr};\\n        if (l == r) return {new TreeNode(l)};\\n        vector<TreeNode*> ans;\\n        for (int i = l; i <= r; ++i) {\\n            vector<TreeNode*> leftL = gen(l, i-1);\\n            vector<TreeNode*> rightL = gen(i+1, r);\\n            for (auto &left: leftL) {\\n                for (auto &right: rightL) {\\n                    TreeNode *head = new TreeNode(i);\\n                    head->left = left;\\n                    head->right = right;\\n                    ans.push_back(head);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n < 1) return {};\\n        return gen(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166620,
                "title": "java-dp-store-both-left-and-right-part",
                "content": "For example: n = 5, so dp[3] is all unique BST with {{1,2,3}, {2,3,4}, {3,4,5}} \\nThe reason to store {2,3,4}, {3,4,5} is we need to use it as right subtree in generate dp[4], dp[5]\\nSo, in generating dp[4], we can let 1/2/3/4 be the root, and the left subtree and right subtree could be retrieved from dp.\\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if(n == 0) return new ArrayList<TreeNode>();\\n        List<List<TreeNode>>[] dp = new List[n + 1];\\n        dp[0] = new ArrayList<List<TreeNode>>();\\n        for(int j = 1; j <= n + 1; j++){\\n            List<TreeNode> temp = new ArrayList<>();\\n            temp.add(null);\\n            dp[0].add(temp);\\n        }        \\n        dp[1] = new ArrayList<List<TreeNode>>();\\n        for(int j = 1; j <= n; j++){\\n            List<TreeNode> temp = new ArrayList<>();\\n            TreeNode tempNode = new TreeNode(j);\\n            temp.add(tempNode);\\n            dp[1].add(temp);\\n        }        \\n        for(int i = 2; i < dp.length; i++){\\n            dp[i] = new ArrayList<List<TreeNode>>();\\n            generateTreesHelper(dp, i, n);\\n        }\\n        return dp[n].get(0);\\n    }\\n    \\n    public void generateTreesHelper(List<List<TreeNode>>[] dp, int n, int total){\\n        for(int i = 1; i <= total - n + 1; i++){ // for example, n = 4. we need to generate 1234, 2345, 3456\\n            List<TreeNode> l = new ArrayList<>();\\n            for(int j = i; j < n + i; j++){\\n                List<TreeNode> left = dp[j - i].get(i - 1);\\n                List<TreeNode> right = dp[n + i - j - 1].get(j);\\n                for(TreeNode leftNode : left){\\n                    for(TreeNode rightNode : right){\\n                        TreeNode root = new TreeNode(j);\\n                        root.left = leftNode;\\n                        root.right = rightNode;\\n                        l.add(root);\\n                    }\\n                }   \\n            }\\n            dp[n].add(l);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n        if(n == 0) return new ArrayList<TreeNode>();\\n        List<List<TreeNode>>[] dp = new List[n + 1];\\n        dp[0] = new ArrayList<List<TreeNode>>();\\n        for(int j = 1; j <= n + 1; j++){\\n            List<TreeNode> temp = new ArrayList<>();\\n            temp.add(null);\\n            dp[0].add(temp);\\n        }        \\n        dp[1] = new ArrayList<List<TreeNode>>();\\n        for(int j = 1; j <= n; j++){\\n            List<TreeNode> temp = new ArrayList<>();\\n            TreeNode tempNode = new TreeNode(j);\\n            temp.add(tempNode);\\n            dp[1].add(temp);\\n        }        \\n        for(int i = 2; i < dp.length; i++){\\n            dp[i] = new ArrayList<List<TreeNode>>();\\n            generateTreesHelper(dp, i, n);\\n        }\\n        return dp[n].get(0);\\n    }\\n    \\n    public void generateTreesHelper(List<List<TreeNode>>[] dp, int n, int total){\\n        for(int i = 1; i <= total - n + 1; i++){ // for example, n = 4. we need to generate 1234, 2345, 3456\\n            List<TreeNode> l = new ArrayList<>();\\n            for(int j = i; j < n + i; j++){\\n                List<TreeNode> left = dp[j - i].get(i - 1);\\n                List<TreeNode> right = dp[n + i - j - 1].get(j);\\n                for(TreeNode leftNode : left){\\n                    for(TreeNode rightNode : right){\\n                        TreeNode root = new TreeNode(j);\\n                        root.left = leftNode;\\n                        root.right = rightNode;\\n                        l.add(root);\\n                    }\\n                }   \\n            }\\n            dp[n].add(l);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161471,
                "title": "a-java-dp-solution-explained",
                "content": "This is a classic DP problem. To get a sense of the thought process that would help you arrive at that conclusion, read on:\\nThe key to this problem is the fundamental structural property of BSTs that all the nodes to the left of the root are smaller than it, and all on the right are greater, the property being true recursively.\\nTherefore, if the root if the integer *i*, then the keys on the left must include all the natural numbers upto *i-1*, and those on the right must contain the integers from *i* to the integer *n*. \\nBut if you look closely, the keys on the right are only a version of the set {0,1,\\u2026.,k}, for some k, wherein each value is incremented by a certain constant. So, getting the BSTs for the right and the left part of the root will have pretty much the same approach. And if you have the BSTs for the left and the right part, then it takes only some *assembling* to get the BST with the key *i* as the root. Well, you have just solved the problem by breaking it down into it\\u2019s **optimal sub-structures**. \\nSo now you make a new function which takes two integers as input, i.e., the beginning and the end, to give all the possible BSTs with the keys in the desired range, and then change the key in the root, to start the process over again. At this point, it becomes nigh-on impossible to miss the fact that you will be repeating some computations that you have done in earlier iterations, for eg:![image](https://s3-lc-upload.s3.amazonaws.com/users/vaibhav98iitd/image_1532463279.png)\\n\\n\\nTherefore, you do see the **overlapping sub-problems**. So to optimize the process, all you need is some sort of a dump where you store the values as you compute them.\\n\\nSo once you have a vague idea of how the problem is structured, it is easy to solve it. You iterate over the numbers {0,1,..........,n} and in each iteration the integer *i* is put into the root, so create a node ***newroot*** and set the value as *i*. Naturally, the numbers *0* to *i-1* would go into the left sub-tree and *i+1* to *n* go to the right. Now, get all the possible BSTs for these two subtrees recursively and put then in All_left_BST and All_right_BST respectively. Then, for every pair  (**left**, **right**), where **left** belongs to All_left_BST and **right** belongs to All_right_BST, set the left child of ***newroot*** as **left** and the right child as **right**, and put them into the result  collection. Now, go over to the next iteration. Note that since for want to do this for all pairs of (**left**,**right**), the loop would run **|All_left_BST|x|All_right_BST|** times. Of course, you can run it in a nested *for* loop where the first one runs over all the trees in All_left_BST and the nested one over all in All_right_BST.\\nYou can find the code attached below.\\nHope it helped.\\n```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    List[][] dump;\\n    public List<TreeNode> generateTrees(int n) {\\n        List[][] temp=new List[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                temp[i][j]=null;\\n            }\\n        }\\n        dump=temp;\\n        return getAns(1,n); }\\n    public List<TreeNode> getAns(int beg, int end)\\n    {\\n        if(beg>end)\\n        {\\n            return new ArrayList<TreeNode>();\\n        }\\n        if(dump[beg-1][end-1]!=null)\\n            return dump[beg-1][end-1];\\n        List<TreeNode> res=new ArrayList<TreeNode>();\\n        if(beg==end)\\n        {            \\n            res.add(new TreeNode(beg));\\n            dump[beg-1][end-1]=res;\\n            return res;\\n        }\\n        for(int i=beg;i<=end;i++)\\n        {\\n            if(i==beg)\\n            {\\n                List<TreeNode> right=getAns(beg+1,end);\\n                for (TreeNode rnode: right)\\n                {\\n                    TreeNode root=new TreeNode(i);\\n                    root.left=null;\\n                    root.right=rnode;\\n                    res.add(root);\\n                }\\n                \\n            }\\n            else if(i==end)\\n            {\\n               // System.out.println(\"sd\");\\n                List<TreeNode> left=getAns(beg,end-1);\\n                for(TreeNode lnode:left)\\n                {\\n                    TreeNode root=new TreeNode(i);\\n                    root.left=lnode;\\n                   // root.right=null;\\n                    res.add(root);\\n                }\\n                \\n            }\\n            else{\\n            List<TreeNode> left=getAns(beg,i-1);\\n            List<TreeNode> right=getAns(i+1,end);\\n            for(TreeNode lnode: left)\\n            {\\n                for(TreeNode rnode:right)\\n                {\\n                    TreeNode root=new TreeNode(i);\\n                    root.left=lnode;\\n                    root.right=rnode;\\n                    res.add(root);\\n                }\\n            }\\n            }\\n            \\n            \\n        }\\n        dump[beg-1][end-1]=res;\\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    List[][] dump;\\n    public List<TreeNode> generateTrees(int n) {\\n        List[][] temp=new List[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                temp[i][j]=null;\\n            }\\n        }\\n        dump=temp;\\n        return getAns(1,n); }\\n    public List<TreeNode> getAns(int beg, int end)\\n    {\\n        if(beg>end)\\n        {\\n            return new ArrayList<TreeNode>();\\n        }\\n        if(dump[beg-1][end-1]!=null)\\n            return dump[beg-1][end-1];\\n        List<TreeNode> res=new ArrayList<TreeNode>();\\n        if(beg==end)\\n        {            \\n            res.add(new TreeNode(beg));\\n            dump[beg-1][end-1]=res;\\n            return res;\\n        }\\n        for(int i=beg;i<=end;i++)\\n        {\\n            if(i==beg)\\n            {\\n                List<TreeNode> right=getAns(beg+1,end);\\n                for (TreeNode rnode: right)\\n                {\\n                    TreeNode root=new TreeNode(i);\\n                    root.left=null;\\n                    root.right=rnode;\\n                    res.add(root);\\n                }\\n                \\n            }\\n            else if(i==end)\\n            {\\n               // System.out.println(\"sd\");\\n                List<TreeNode> left=getAns(beg,end-1);\\n                for(TreeNode lnode:left)\\n                {\\n                    TreeNode root=new TreeNode(i);\\n                    root.left=lnode;\\n                   // root.right=null;\\n                    res.add(root);\\n                }\\n                \\n            }\\n            else{\\n            List<TreeNode> left=getAns(beg,i-1);\\n            List<TreeNode> right=getAns(i+1,end);\\n            for(TreeNode lnode: left)\\n            {\\n                for(TreeNode rnode:right)\\n                {\\n                    TreeNode root=new TreeNode(i);\\n                    root.left=lnode;\\n                    root.right=rnode;\\n                    res.add(root);\\n                }\\n            }\\n            }\\n            \\n            \\n        }\\n        dump[beg-1][end-1]=res;\\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157293,
                "title": "my-python-ac-dfs-solution",
                "content": "```\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dfs(l, r):\\n            if r < l: return [None]\\n            arr = []\\n            for m in range(l, r + 1):\\n                left = dfs(l, m - 1)\\n                right = dfs(m + 1, r)\\n                for lNode in left:\\n                    for rNode in right:\\n                        new = TreeNode(m)\\n                        new.left = lNode\\n                        new.right = rNode\\n                        arr.append(new)\\n            return arr\\n        res = dfs(1, n)\\n        return [] if res == [None] else res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTrees(self, n):\\n        def dfs(l, r):\\n            if r < l: return [None]\\n            arr = []\\n            for m in range(l, r + 1):\\n                left = dfs(l, m - 1)\\n                right = dfs(m + 1, r)\\n                for lNode in left:\\n                    for rNode in right:\\n                        new = TreeNode(m)\\n                        new.left = lNode\\n                        new.right = rNode\\n                        arr.append(new)\\n            return arr\\n        res = dfs(1, n)\\n        return [] if res == [None] else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31572,
                "title": "share-my-11-lines-python-code",
                "content": "    def helper(self, n, start):\\n        ret = []\\n        for i in range(start, n + start):\\n            l = self.helper(i - start, start)\\n            r = self.helper(n + start - i - 1, i + 1)\\n            for x in (l if len(l) else [None]):\\n                for y in (r if len(r) else [None]):\\n                    root = TreeNode(i)\\n                    root.left, root.right = x, y\\n                    ret.append(root)\\n        return ret\\n    def generateTrees(self, n):\\n        return self.helper(n, 1)\\n\\nPretty standard top-down recursive approach. \"start\" is the starting number for tree node labeling.",
                "solutionTags": [],
                "code": "    def helper(self, n, start):\\n        ret = []\\n        for i in range(start, n + start):\\n            l = self.helper(i - start, start)\\n            r = self.helper(n + start - i - 1, i + 1)\\n            for x in (l if len(l) else [None]):\\n                for y in (r if len(r) else [None]):\\n                    root = TreeNode(i)\\n                    root.left, root.right = x, y\\n                    ret.append(root)\\n        return ret\\n    def generateTrees(self, n):\\n        return self.helper(n, 1)\\n\\nPretty standard top-down recursive approach. \"start\" is the starting number for tree node labeling.",
                "codeTag": "Python3"
            },
            {
                "id": 31557,
                "title": "clean-and-efficient-accepted-best-in-c",
                "content": "    struct TreeNode* push(struct TreeNode*** arr, int* returnSize, int a)\\n    {\\n        struct TreeNode *t = NULL;\\n        if(a > -1) //only valid value can be allocated;\\n        {\\n            t = (struct TreeNode*)malloc(sizeof(struct TreeNode));\\n            t->left = t->right = NULL;\\n            t->val = a;\\n        }\\n        *returnSize += 1;\\n        *arr = (struct TreeNode**)realloc(*arr, sizeof(struct TreeNode*)*(*returnSize));\\n        (*arr)[*returnSize-1] = t;\\n        return t; //return this node for -> root;\\n    }\\n    struct TreeNode* generate(int begin, int end, int* returnSize)\\n    {\\n        struct TreeNode** arr = (struct TreeNode**)malloc(sizeof(struct TreeNode*));\\n        if(begin >= end)\\n        {\\n            if(begin > end) \\n                push(&arr, returnSize, -1);\\n            if(begin == end)\\n                push(&arr, returnSize, begin);\\n            return arr;\\n        }\\n        for(int i = begin; i <= end; i++) //try to set each value as root;\\n        {\\n            int count0=0, count1=0;\\n            struct TreeNode **arr0 = generate(begin, i-1, &count0);\\n            struct TreeNode **arr1 = generate(i+1, end, &count1);\\n            for(int j = 0; j < count0; j++) //try to use different node as left and right child;\\n                for(int k = 0; k < count1; k++)\\n                {\\n                    struct TreeNode* t = push(&arr, returnSize, i);\\n                    t->left = arr0[j];\\n                    t->right = arr1[k];\\n                }\\n        }\\n        return arr;\\n    }\\n    \\n    //AC - 8ms;\\n    struct TreeNode** generateTrees(int n, int* returnSize)\\n    {\\n        *returnSize = 0;\\n        if(!n) return NULL;\\n        return generate(1, n, returnSize);\\n    }",
                "solutionTags": [],
                "code": "    struct TreeNode* push(struct TreeNode*** arr, int* returnSize, int a)\\n    {\\n        struct TreeNode *t = NULL;\\n        if(a > -1) //only valid value can be allocated;\\n        {\\n            t = (struct TreeNode*)malloc(sizeof(struct TreeNode));\\n            t->left = t->right = NULL;\\n            t->val = a;\\n        }\\n        *returnSize += 1;\\n        *arr = (struct TreeNode**)realloc(*arr, sizeof(struct TreeNode*)*(*returnSize));\\n        (*arr)[*returnSize-1] = t;\\n        return t; //return this node for -> root;\\n    }\\n    struct TreeNode* generate(int begin, int end, int* returnSize)\\n    {\\n        struct TreeNode** arr = (struct TreeNode**)malloc(sizeof(struct TreeNode*));\\n        if(begin >= end)\\n        {\\n            if(begin > end) \\n                push(&arr, returnSize, -1);\\n            if(begin == end)\\n                push(&arr, returnSize, begin);\\n            return arr;\\n        }\\n        for(int i = begin; i <= end; i++) //try to set each value as root;\\n        {\\n            int count0=0, count1=0;\\n            struct TreeNode **arr0 = generate(begin, i-1, &count0);\\n            struct TreeNode **arr1 = generate(i+1, end, &count1);\\n            for(int j = 0; j < count0; j++) //try to use different node as left and right child;\\n                for(int k = 0; k < count1; k++)\\n                {\\n                    struct TreeNode* t = push(&arr, returnSize, i);\\n                    t->left = arr0[j];\\n                    t->right = arr1[k];\\n                }\\n        }\\n        return arr;\\n    }\\n    \\n    //AC - 8ms;\\n    struct TreeNode** generateTrees(int n, int* returnSize)\\n    {\\n        *returnSize = 0;\\n        if(!n) return NULL;\\n        return generate(1, n, returnSize);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31594,
                "title": "10-line-concise-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<TreeNode*> get(int a, int b) {\\n            vector<TreeNode*> ans;\\n            if (a>b) {\\n                ans.push_back(NULL);\\n            } else {\\n                for (int i=a; i<=b; i++)\\n                    for (auto l : get(a, i-1)) \\n                        for (auto r : get(i+1, b))\\n                        {\\n                            ans.push_back(new TreeNode(i));\\n                            ans.back()->left=l, ans.back()->right=r;\\n                        }\\n            }\\n            return ans;\\n        }\\n        \\n        vector<TreeNode*> generateTrees(int n) {\\n            return get(1, n);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<TreeNode*> get(int a, int b) {\\n            vector<TreeNode*> ans;\\n            if (a>b) {\\n                ans.push_back(NULL);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31612,
                "title": "dp-solution-using-1-tabulation-20ms-and-2-memoization-24ms",
                "content": "Tabulation:\\n\\n    class Solution {\\n        \\n        using Trees = vector<TreeNode*>;\\n        \\n    public:\\n        vector<TreeNode*> generateTrees(int n) {\\n            if (n == 0)\\n            {\\n                return vector<TreeNode*>({NULL});\\n            }\\n            \\n            // the dp table: [i][j] -> all unique BSTs with nodes from i..j inclusive\\n            vector<vector<Trees>> dp(n + 1,\\n                                     vector<vector<TreeNode*>>(n + 1, Trees()));\\n                                     \\n            // initialize the dp table: [i][i] -> a single root node with value i, for all i in [1,n] inclusive\\n            for (int i = 1; i <= n; ++i)\\n            {\\n                dp[i][i].push_back(new TreeNode(i));\\n            }\\n            \\n            // the progressively build the table (bottom-up tabulation)\\n            for (int k = 1; k < n; ++k)\\n            {\\n                for (int i = 1; i <= n - k; ++i)\\n                {\\n                    int j = i + k;\\n                    Trees &unique_trees = dp[i][j]; assert (unique_trees.empty());  // this is what we're building right now\\n                    for (int root = i; root <= j; ++root)\\n                    {\\n                        int end_left = root - 1;\\n                        int start_right = root + 1;\\n                        Trees all_left;\\n                        if (end_left < i)\\n                        {\\n                            all_left.push_back(NULL);\\n                        }\\n                        else\\n                        {\\n                            all_left = dp[i][end_left];\\n                        }\\n                        Trees all_right;\\n                        if (j < start_right)\\n                        {\\n                            all_right.push_back(NULL);\\n                        }\\n                        else\\n                        {\\n                            all_right = dp[start_right][j];\\n                        }\\n                        for (TreeNode *left : all_left)\\n                        {\\n                            for (TreeNode *right : all_right)\\n                            {\\n                                TreeNode *root_node = new TreeNode(root);\\n                                root_node->left = left;\\n                                root_node->right = right;\\n                                unique_trees.push_back(root_node);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            return dp[1][n];\\n        }\\n    };\\n\\n\\nMemoization:\\n\\n    class Solution {\\n    private:\\n    \\n        using cache = map<pair<int, int>, vector<TreeNode*>>;   // {i,j} -> all unique BSTs with nodes from i..j inclusive\\n        \\n        vector<TreeNode*> generate_trees_dp(int start, int end, cache &dp)\\n        {\\n            vector<TreeNode*> result;\\n            \\n            if (end < start)\\n            {\\n                result.push_back(NULL);\\n                return result;\\n            }\\n            \\n            auto it = dp.find({start, end});\\n            if (it != dp.end())\\n            {\\n                return it->second;\\n            }\\n            \\n            for (int i = start; i <= end; ++i)\\n            {\\n                vector<TreeNode*> all_left = generate_trees_dp(start, i - 1, dp);\\n                vector<TreeNode*> all_right = generate_trees_dp(i + 1, end, dp);\\n                for (TreeNode *left_tree : all_left)\\n                {\\n                    for (TreeNode *right_tree : all_right)\\n                    {\\n                        TreeNode *root = new TreeNode(i);\\n                        root->left = left_tree;\\n                        root->right = right_tree;\\n                        result.push_back(root);\\n                    }\\n                }\\n            }\\n            \\n            dp[{start, end}] = result;\\n            return result;\\n        }\\n        \\n    public:\\n        vector<TreeNode*> generateTrees(int n) {\\n            cache dp;\\n            // initialize the dp cache: {i,i} -> a single root node with value i, for all i in [1,n] inclusive\\n            for (int i = 1; i <= n; ++i)\\n            {\\n                dp[{i,i}] = { new TreeNode(i), };\\n            }\\n            \\n            return generate_trees_dp(1, n, dp);\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n        \\n        using Trees = vector<TreeNode*>;\\n        \\n    public:\\n        vector<TreeNode*> generateTrees(int n) {\\n            if (n == 0)\\n            {\\n                return vector<TreeNode*>({NULL}",
                "codeTag": "Java"
            },
            {
                "id": 31637,
                "title": "recursive-java-solution-make-use-of-binary-search-characteristic",
                "content": "Given a consecutive sequence, eg. [2,3,4,5].\\n\\nThe way to generate every possible binary search tree for this sequence is take each number as root node and then assign both child.\\n\\nThus, [2,3,4,5] will be computed as,\\n\\nFirst take 2 as root node, then left child will be null, right child will be sequence [3,4,5].\\n\\nSecond take 3 as root node, then left child will be [2], right child will be sequence [4,5].\\n\\nThird take 4 as root node, then left child will be [2,3], right child will be [5].\\n\\n...\\n\\n    public List<TreeNode> generateTrees(int n) {\\n            return generateTree(1,n+1);\\n        }\\n        \\n        private List<TreeNode> generateTree(int min, int max){\\n            List<TreeNode> list = new ArrayList<TreeNode>();\\n            // base case\\n            if(min >= max){\\n                TreeNode node = null;\\n                list.add(node);\\n            }\\n            // general case\\n            for(int i = min;i < max;i++){\\n                List<TreeNode> left = generateTree(min,i);\\n                List<TreeNode> right = generateTree(i+1,max);\\n                for(int p = 0;p < left.size();p++){\\n                    for(int q = 0;q < right.size();q++){\\n                        TreeNode root = new TreeNode(i);\\n                        root.left = left.get(p);\\n                        root.right = right.get(q);\\n                        list.add(root);\\n                    }\\n                }\\n            }\\n            return list;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Given a consecutive sequence, eg. [2,3,4,5].\\n\\nThe way to generate every possible binary search tree for this sequence is take each number as root node and then assign both child.\\n\\nThus, [2,3,4,5] will be computed as,\\n\\nFirst take 2 as root node, then left child will be null, right child will be sequence [3,4,5].\\n\\nSecond take 3 as root node, then left child will be [2], right child will be sequence [4,5].\\n\\nThird take 4 as root node, then left child will be [2,3], right child will be [5].\\n\\n...\\n\\n    public List<TreeNode> generateTrees(int n) {\\n            return generateTree(1,n+1);\\n        }\\n        \\n        private List<TreeNode> generateTree(int min, int max){\\n            List<TreeNode> list = new ArrayList<TreeNode>();\\n            // base case\\n            if(min >= max){\\n                TreeNode node = null;\\n                list.add(node);\\n            }\\n            // general case\\n            for(int i = min;i < max;i++){\\n                List<TreeNode> left = generateTree(min,i);\\n                List<TreeNode> right = generateTree(i+1,max);\\n                for(int p = 0;p < left.size();p++){\\n                    for(int q = 0;q < right.size();q++){\\n                        TreeNode root = new TreeNode(i);\\n                        root.left = left.get(p);\\n                        root.right = right.get(q);\\n                        list.add(root);\\n                    }\\n                }\\n            }\\n            return list;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 31642,
                "title": "my-c-solution",
                "content": "    class Solution {\\n    private:\\n        vector<TreeNode *> getTrees(int n, int offset) {\\n            vector<TreeNode *> ans;\\n            if(n == 0) {\\n                ans.push_back(nullptr);\\n                return ans;\\n            }\\n            int i, j, k;\\n            for(i=1; i<=n; i++) {\\n                vector<TreeNode *> left = getTrees(i-1, offset);\\n                vector<TreeNode *> right = getTrees(n-i, i+offset);\\n                for(j=0; j<left.size(); j++) {\\n                    for(k=0; k<right.size(); k++) {\\n                        TreeNode *root = new TreeNode(i+offset);\\n                        root->left = left[j];\\n                        root->right = right[k];\\n                        ans.push_back(root);\\n                    }\\n                }\\n            }\\n            return ans;\\n        }\\n    public:\\n        vector<TreeNode *> generateTrees(int n) {\\n            return getTrees(n, 0);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        vector<TreeNode *> getTrees(int n, int offset) {\\n            vector<TreeNode *> ans;\\n            if(n == 0) {\\n                ans.push_back(nullptr);\\n                return ans;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31655,
                "title": "my-answer-with-c-28-lines",
                "content": "    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n    \\tint *f;\\n    \\tTreeNode* generateTree(int rank, int base, int n) {\\n    \\t\\tif (n == 0) return NULL;\\n    \\t\\tif (n == 1) return new TreeNode(base);\\n    \\t\\tfor (int i = 0; i < n; ++i) {\\n    \\t\\t\\trank -= f[i] * f[n - 1 - i];\\n    \\t\\t\\tif (rank < 0) {\\n    \\t\\t\\t\\tTreeNode* root = new TreeNode(base + i);\\n    \\t\\t\\t\\trank += f[i] * f[n - 1 - i];\\n    \\t\\t\\t\\troot->left = generateTree(rank % f[i], base, i);\\n    \\t\\t\\t\\troot->right = generateTree(rank / f[i], base + i + 1, n - 1 - i);\\n    \\t\\t\\t\\treturn root;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n        vector<TreeNode *> generateTrees(int n) {\\n            f = new int[n + 1];\\n    \\t\\tf[0] = f[1] = 1;\\n    \\t\\tfor (int i = 2; i <= n; ++i) {\\n    \\t\\t\\tf[i] = 0;\\n    \\t\\t\\tfor (int j = 0; j < i; ++j) f[i] += f[j] * f[i - 1 - j];\\n    \\t\\t}\\n    \\t\\tvector<TreeNode *> result;\\n    \\t\\tfor (int i = 0; i < f[n]; ++i) result.push_back(generateTree(i, 1, n));\\n    \\t\\treturn result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint *f;\\n    \\tTreeNode* generateTree(int rank, int base, int n) {\\n    \\t\\tif (n == 0) return NULL;\\n    \\t\\tif (n == 1) return new TreeNode(base);\\n    \\t\\tfor (int i = 0; i < n; ++i) {\\n    \\t\\t\\trank -= f[i] * f[n - 1 - i];\\n    \\t\\t\\tif (rank < 0) {\\n    \\t\\t\\t\\tTreeNode* root = new TreeNode(base + i);\\n    \\t\\t\\t\\trank += f[i] * f[n - 1 - i];\\n    \\t\\t\\t\\troot->left = generateTree(rank % f[i], base, i);\\n    \\t\\t\\t\\troot->right = generateTree(rank / f[i], base + i + 1, n - 1 - i);\\n    \\t\\t\\t\\treturn root;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3868393,
                "title": "easy-code-with-explanation",
                "content": "Note this code is combination of leetcode problem permutaion and creating bst and preorder traversal.... so if you have done that then do it.\\n# Code\\n```\\n\\n\\n//n points in a line has n! ways to arrange it thus for n=3 there are 6 ways but in answer only 5 are drawn why? since there are 2 fig which are symmetrical thus they are just written once...so how to check that it is unique or not? store it in set and then check.\\n\\n\\nclass Solution {\\npublic:\\nvector<TreeNode*>ans;\\nset<vector<int>>st;\\nvector<int>preo;\\n\\n// preorder\\nvoid traverse(TreeNode*root)\\n{\\n   if(root==NULL)\\n    return;\\n    preo.push_back(root->val);\\n    traverse(root->left);\\n    traverse(root->right);  \\n}\\nbool check(TreeNode*ptr)\\n{\\n  // return true if it is unique\\n   vector<int>preorder;\\n   preo=preorder;//reset the preo since it is global\\n   traverse(ptr);\\n   for(int i=0;i<preo.size();i++)\\n   cout<<preo[i]<<\" \";\\n   cout<<endl;\\n   if(st.find(preo)==st.end())\\n   {\\n     st.insert(preo);\\n   return true;\\n   }\\n   return false;\\n}\\n\\n//creating bst\\n\\nTreeNode*bst(TreeNode*root,int key)\\n{\\n    if(root==NULL)\\n    {\\n      TreeNode*temp=new TreeNode(key);\\n     temp->left=NULL;\\n     temp->right=NULL;\\n     return temp;\\n    }\\n\\n  if(key>root->val)\\n    root->right=bst(root->right,key);\\n  else\\n    root->left=bst(root->left,key);\\n\\n  return root;\\n}\\n\\nvoid create_bst(vector<int>&nums)\\n{\\nTreeNode*root=new TreeNode(nums[0]);//make root\\nroot->left=NULL;\\nroot->right=NULL;\\n\\n  for(int i=1;i<nums.size();i++)\\n   root=bst(root,nums[i]);//get always updated root\\n\\n   if(check(root))\\n    ans.push_back(root);\\n}\\n\\n//make all possible combination..permutation\\nvoid func(vector<int>&nums,int index)\\n{\\n  if(index==nums.size())\\n  {\\n      create_bst(nums);\\n      return;\\n  }\\n  for(int i=index;i<nums.size();i++)\\n  {\\n      swap(nums[index],nums[i]);\\n      func(nums,index+1);\\n      swap(nums[index],nums[i]);\\n  }\\n}\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<int>nums;\\n        for(int i=1;i<=n;i++)\\n         nums.push_back(i);\\n         func(nums,0);\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\n//n points in a line has n! ways to arrange it thus for n=3 there are 6 ways but in answer only 5 are drawn why? since there are 2 fig which are symmetrical thus they are just written once...so how to check that it is unique or not? store it in set and then check.\\n\\n\\nclass Solution {\\npublic:\\nvector<TreeNode*>ans;\\nset<vector<int>>st;\\nvector<int>preo;\\n\\n// preorder\\nvoid traverse(TreeNode*root)\\n{\\n   if(root==NULL)\\n    return;\\n    preo.push_back(root->val);\\n    traverse(root->left);\\n    traverse(root->right);  \\n}\\nbool check(TreeNode*ptr)\\n{\\n  // return true if it is unique\\n   vector<int>preorder;\\n   preo=preorder;//reset the preo since it is global\\n   traverse(ptr);\\n   for(int i=0;i<preo.size();i++)\\n   cout<<preo[i]<<\" \";\\n   cout<<endl;\\n   if(st.find(preo)==st.end())\\n   {\\n     st.insert(preo);\\n   return true;\\n   }\\n   return false;\\n}\\n\\n//creating bst\\n\\nTreeNode*bst(TreeNode*root,int key)\\n{\\n    if(root==NULL)\\n    {\\n      TreeNode*temp=new TreeNode(key);\\n     temp->left=NULL;\\n     temp->right=NULL;\\n     return temp;\\n    }\\n\\n  if(key>root->val)\\n    root->right=bst(root->right,key);\\n  else\\n    root->left=bst(root->left,key);\\n\\n  return root;\\n}\\n\\nvoid create_bst(vector<int>&nums)\\n{\\nTreeNode*root=new TreeNode(nums[0]);//make root\\nroot->left=NULL;\\nroot->right=NULL;\\n\\n  for(int i=1;i<nums.size();i++)\\n   root=bst(root,nums[i]);//get always updated root\\n\\n   if(check(root))\\n    ans.push_back(root);\\n}\\n\\n//make all possible combination..permutation\\nvoid func(vector<int>&nums,int index)\\n{\\n  if(index==nums.size())\\n  {\\n      create_bst(nums);\\n      return;\\n  }\\n  for(int i=index;i<nums.size();i++)\\n  {\\n      swap(nums[index],nums[i]);\\n      func(nums,index+1);\\n      swap(nums[index],nums[i]);\\n  }\\n}\\n    vector<TreeNode*> generateTrees(int n) {\\n        vector<int>nums;\\n        for(int i=1;i<=n;i++)\\n         nums.push_back(i);\\n         func(nums,0);\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3866084,
                "title": "one-liner-java-8-streams",
                "content": "\\n\\n# UPVOTE PLS \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\u2B06\\uFE0F\\u2B06\\uFE0F\\n```java []\\npublic List<TreeNode> generateTrees(int n) {\\n   return generateTrees(1, n).toList();\\n }\\nprivate Stream<TreeNode> generateTrees(int min, int max) {\\n  return  (min > max) ? Stream.of((TreeNode) null) : IntStream.rangeClosed(min, max).boxed().flatMap(i -> generateTrees(min, i - 1).flatMap(left -> generateTrees(i + 1, max).map(right ->new TreeNode(i, left, right))));\\n }\\n```\\n\\n# CLEAN & READABLE WAY\\n\\n```JAVA []\\npublic List<TreeNode> generateTrees(int n) {\\n       return generateTrees(1, n).toList();\\n }\\nprivate Stream<TreeNode> generateTrees(int min, int max) {\\n       return  (min > max) ? Stream.of((TreeNode) null) : \\n       IntStream.rangeClosed(min, max).boxed()\\n       .flatMap(i -> generateTrees(min, i - 1)\\n       .flatMap(left -> generateTrees(i + 1, max)\\n       .map(right ->   new TreeNode(i, left, right))));\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\npublic List<TreeNode> generateTrees(int n) {\\n   return generateTrees(1, n).toList();\\n }\\nprivate Stream<TreeNode> generateTrees(int min, int max) {\\n  return  (min > max) ? Stream.of((TreeNode) null) : IntStream.rangeClosed(min, max).boxed().flatMap(i -> generateTrees(min, i - 1).flatMap(left -> generateTrees(i + 1, max).map(right ->new TreeNode(i, left, right))));\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3865915,
                "title": "video-solution-java-c",
                "content": "# Intuition, approach, and complexity dicussed in detail in video solution.\\n\\nhttps://youtu.be/9A4J6fSO1Ws\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildBST(1, n);\\n    }\\n    private:\\n     vector<TreeNode*> buildBST(int start, int end){\\n        vector<TreeNode*> li;\\n        if(start > end){\\n            li.push_back(NULL);\\n            return li;\\n        }\\n        if(start == end){\\n            li.push_back(new TreeNode(start));\\n            return li;\\n        }\\n        for(int indx = start; indx<=end; indx++){\\n         vector<TreeNode*> leftNodeList = buildBST(start, indx-1);\\n         vector<TreeNode*> rightNodeList = buildBST(indx+1, end);\\n            for(TreeNode* leftSide : leftNodeList){\\n                for(TreeNode* rightSide : rightNodeList){\\n                    TreeNode* root = new TreeNode(indx);\\n                    root->left = leftSide;\\n                    root->right = rightSide;\\n                    li.push_back(root);\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n\\n        return buildBST(1, n);\\n    }\\n    public List<TreeNode> buildBST(int start, int end){\\n\\n        List<TreeNode> li = new ArrayList<>();\\n\\n        if(start > end){\\n            li.add(null);\\n            return li;\\n        }\\n        if(start == end){\\n            li.add(new TreeNode(start));\\n            return li;\\n        }\\n\\n        for(int indx = start; indx<=end; indx++){\\n         List<TreeNode> leftNodeList = buildBST(start, indx-1);\\n         List<TreeNode> rightNodeList = buildBST(indx+1, end);\\n            for(TreeNode rightSide : rightNodeList){\\n                for(TreeNode leftSide : leftNodeList){\\n                    TreeNode root = new TreeNode(indx);\\n                    root.left = leftSide;\\n                    root.right = rightSide;\\n                    li.add(root);\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        return buildBST(1, n);\\n    }\\n    private:\\n     vector<TreeNode*> buildBST(int start, int end){\\n        vector<TreeNode*> li;\\n        if(start > end){\\n            li.push_back(NULL);\\n            return li;\\n        }\\n        if(start == end){\\n            li.push_back(new TreeNode(start));\\n            return li;\\n        }\\n        for(int indx = start; indx<=end; indx++){\\n         vector<TreeNode*> leftNodeList = buildBST(start, indx-1);\\n         vector<TreeNode*> rightNodeList = buildBST(indx+1, end);\\n            for(TreeNode* leftSide : leftNodeList){\\n                for(TreeNode* rightSide : rightNodeList){\\n                    TreeNode* root = new TreeNode(indx);\\n                    root->left = leftSide;\\n                    root->right = rightSide;\\n                    li.push_back(root);\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<TreeNode> generateTrees(int n) {\\n\\n        return buildBST(1, n);\\n    }\\n    public List<TreeNode> buildBST(int start, int end){\\n\\n        List<TreeNode> li = new ArrayList<>();\\n\\n        if(start > end){\\n            li.add(null);\\n            return li;\\n        }\\n        if(start == end){\\n            li.add(new TreeNode(start));\\n            return li;\\n        }\\n\\n        for(int indx = start; indx<=end; indx++){\\n         List<TreeNode> leftNodeList = buildBST(start, indx-1);\\n         List<TreeNode> rightNodeList = buildBST(indx+1, end);\\n            for(TreeNode rightSide : rightNodeList){\\n                for(TreeNode leftSide : leftNodeList){\\n                    TreeNode root = new TreeNode(indx);\\n                    root.left = leftSide;\\n                    root.right = rightSide;\\n                    li.add(root);\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865419,
                "title": "recursion-easy-solution-using-left-and-right-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy using start and end variables to generate all the trees.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow let\\'s look how our helper function will work!\\n\\n1. As there will be trees with root as 1, 2, 3...n. Iterate through all values from start to end to construct tree rooted at i and construct its left and right subtree recursively.\\n2. We know that in Binary Search Tree all nodes in left subtree are smaller than root and in right subtree are larger than root. So for start = 1 and end = n, if we have ith number as root, all numbers from 1 to i-1 will be in left subtree and i+1 to n will be in right subtree.\\nTherefore, we will build the tree recursively for left and right subtrees rooted at i as leftSubTree = bst(start, i-1) and rightSubtree = bst(i + 1, end)\\nSo, till what moment we will recursively find the left and right subtrees?? Answer is until start < end!!\\nSo when start > end, add NULL to the list and return\\nThis will be our base case!\\n3. Now, we have leftSubtree and rightSubtree for node with root i. The last thing we need to do is connect leftSubTree and rightSubTree with root and add this tree(rooted at i) to the ans list!\\n\\uD83D\\uDCCC Here, we can have multiple left and right subtrees. So we need to loop through all left and right subtrees and connect every left subTree to right subTree and to current root(i) one by one.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n-> catalan Number(O(4^n/n^1.5)) * O(n) for generating the trees\\n-> O(4^n/n^0.5).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n-> recursion stack space.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generate(int i, int j) {\\n        vector<TreeNode*> res;\\n        if(i > j) {\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        for(int ind = i;ind <= j;ind++) {\\n            vector<TreeNode*> left = generate(i, ind-1);\\n            vector<TreeNode*> right = generate(ind+1, j);\\n            for(auto l: left) {\\n                for(auto r: right) {\\n                    TreeNode* root = new TreeNode(ind, l, r);\\n                    res.push_back(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return generate(1, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> generate(int i, int j) {\\n        vector<TreeNode*> res;\\n        if(i > j) {\\n            res.push_back(NULL);\\n            return res;\\n        }\\n        for(int ind = i;ind <= j;ind++) {\\n            vector<TreeNode*> left = generate(i, ind-1);\\n            vector<TreeNode*> right = generate(ind+1, j);\\n            for(auto l: left) {\\n                for(auto r: right) {\\n                    TreeNode* root = new TreeNode(ind, l, r);\\n                    res.push_back(root);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    vector<TreeNode*> generateTrees(int n) {\\n        return generate(1, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865343,
                "title": "c-solution-for-unique-binary-search-trees-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to generate all possible structurally unique binary search trees using a recursive approach. For each node in the tree, we consider it as the root and generate all possible left and right subtrees for it. The result will be a combination of these subtrees, forming all the structurally unique BSTs with n nodes and unique values from 1 to n.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach involves a recursive function that takes the range of values (from start to end) and generates all the structurally unique BSTs within that range. It iterates through each possible root value in the range and generates all possible left and right subtrees. The base case is when start > end, in which case we return a list with a single element (null), representing an empty subtree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is difficult to determine exactly due to the recursive nature. However, we can estimate it as follows: Let T(n) be the total number of unique BSTs generated for n nodes. For each node, we have to generate all possible left and right subtrees, and the total number of combinations will be the product of the number of left subtrees and the number of right subtrees. For i nodes in the left subtree and n-i-1 nodes in the right subtree (since i is the root), the number of combinations will be T(i) * T(n-i-1).\\n\\nSo, the overall time complexity can be approximated as T(n) = Sum(T(i) * T(n-i-1)) for i ranging from 0 to n-1. Calculating this sum is challenging, and it leads to the well-known Catalan Number, which grows at an exponential rate. The exact time complexity will be on the order of O(Catalan(n)), which is upper-bounded by O(4^n / (n^(3/2))). For the given constraints (n <= 8), this is a reasonable runtime.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is determined by the number of unique BSTs generated and stored in the result list. The maximum number of unique BSTs for n nodes will be equal to the n-th Catalan number, which is O(4^n / (n^(3/2))). Therefore, the space complexity is O(4^n / (n^(3/2))). Additionally, the recursive function will use space on the call stack, but since the maximum recursion depth is limited by n, the space complexity on the call stack is O(n).\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        if (n == 0) return new List<TreeNode>(); // Edge case: no nodes, return an empty list\\n        return GenerateTrees(1, n);\\n    }\\n    private IList<TreeNode> GenerateTrees(int start, int end) {\\n        IList<TreeNode> result = new List<TreeNode>();\\n        \\n        if (start > end) {\\n            result.Add(null);\\n            return result;\\n        }\\n        \\n        for (int i = start; i <= end; i++) {\\n            IList<TreeNode> leftSubtrees = GenerateTrees(start, i - 1);\\n            IList<TreeNode> rightSubtrees = GenerateTrees(i + 1, end);\\n            \\n            foreach (var leftSubtree in leftSubtrees) {\\n                foreach (var rightSubtree in rightSubtrees) {\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = leftSubtree;\\n                    root.right = rightSubtree;\\n                    result.Add(root);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<TreeNode> GenerateTrees(int n) {\\n        if (n == 0) return new List<TreeNode>(); // Edge case: no nodes, return an empty list\\n        return GenerateTrees(1, n);\\n    }\\n    private IList<TreeNode> GenerateTrees(int start, int end) {\\n        IList<TreeNode> result = new List<TreeNode>();\\n        \\n        if (start > end) {\\n            result.Add(null);\\n            return result;\\n        }\\n        \\n        for (int i = start; i <= end; i++) {\\n            IList<TreeNode> leftSubtrees = GenerateTrees(start, i - 1);\\n            IList<TreeNode> rightSubtrees = GenerateTrees(i + 1, end);\\n            \\n            foreach (var leftSubtree in leftSubtrees) {\\n                foreach (var rightSubtree in rightSubtrees) {\\n                    TreeNode root = new TreeNode(i);\\n                    root.left = leftSubtree;\\n                    root.right = rightSubtree;\\n                    result.Add(root);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865261,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        @lru_cache\\n        def dfs(start,end):\\n            if start>end:\\n                return [None]\\n\\n            ans=[]\\n            for i in range(start,end+1):\\n                left=dfs(start,i-1)\\n                right=dfs(i+1,end)\\n                for l in left:\\n                    for r in right:\\n                        root=TreeNode(i)\\n                        root.left=l\\n                        root.right=r\\n                        ans.append(root)\\n            return ans\\n\\n        return dfs(1,n)                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\\n        @lru_cache\\n        def dfs(start,end):\\n            if start>end:\\n                return [None]\\n\\n            ans=[]\\n            for i in range(start,end+1):\\n                left=dfs(start,i-1)\\n                right=dfs(i+1,end)\\n                for l in left:\\n                    for r in right:\\n                        root=TreeNode(i)\\n                        root.left=l\\n                        root.right=r\\n                        ans.append(root)\\n            return ans\\n\\n        return dfs(1,n)                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865256,
                "title": "kotlin-backtrack-bitmask-hash",
                "content": "![image.png](https://assets.leetcode.com/users/images/80b9e58a-96ec-4d58-b8e7-08e9915a8772_1691208464.22039.png)\\n\\n#### Join me on Telegram\\n\\nhttps://t.me/leetcode_daily_unstoppable/299\\n\\n#### Problem TLDR\\n\\nAll possible Binary Search Trees for 1..n numbers\\n\\n#### Intuition\\n\\nOne way to build all possible BST is to insert numbers in all possible ways. We can do this with a simple backtracking, given the small `n <= 8`. To remove duplicates, we can print the tree and use it as a hash key.\\n\\n#### Approach\\n\\n* use a bit mask and a Stack for backtracking\\n\\n#### Complexity\\n- Time complexity:\\n\\n$$O(n!* nlog(n))$$, as the recursion depth is n, each time iterations go as n * (n - 1) * (n - 2) * ... * 2 * 1, which is equal to n!. The final step of inserting elements is nlog(n), and building a hash is n, which is < nlogn, so not relevant.\\n\\n- Space complexity:\\n\\n$$O(n!)$$, is a number of permutations\\n\\n#### Code\\n\\n```kotlin\\n\\n\\n    fun insert(x: Int, t: TreeNode?): TreeNode = t?.apply {\\n        if (x > `val`) right = insert(x, right)\\n        else left = insert(x, left)\\n      } ?: TreeNode(x)\\n    fun print(t: TreeNode): String = \\n      \"[${t.`val`} ${t.left?.let { print(it) }} ${t.right?.let { print(it) }}]\"\\n    fun generateTrees(n: Int): List<TreeNode?> {\\n      val stack = Stack<Int>()\\n      val lists = mutableListOf<TreeNode>()\\n      fun dfs(m: Int): Unit = if (m == 0) \\n          lists += TreeNode(stack[0]).apply { for (i in 1 until n) insert(stack[i], this) }\\n        else for (i in 0 until n) if (m and (1 shl i) != 0) {\\n          stack.push(i + 1)\\n          dfs(m xor (1 shl i))\\n          stack.pop()\\n        }\\n      dfs((1 shl n) - 1)\\n      return lists.distinctBy { print(it) }\\n    }\\n\\n```\\nAnother divide-and-conquer solution, that I didn\\'t think of\\n![image.png](https://assets.leetcode.com/users/images/470b3a9f-5e0b-432b-a1fc-33a966ab2d36_1691213657.5075893.png)\\n\\n",
                "solutionTags": [
                    "Kotlin",
                    "Backtracking",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```kotlin\\n\\n\\n    fun insert(x: Int, t: TreeNode?): TreeNode = t?.apply {\\n        if (x > `val`) right = insert(x, right)\\n        else left = insert(x, left)\\n      } ?: TreeNode(x)\\n    fun print(t: TreeNode): String = \\n      \"[${t.`val`} ${t.left?.let { print(it) }} ${t.right?.let { print(it) }}]\"\\n    fun generateTrees(n: Int): List<TreeNode?> {\\n      val stack = Stack<Int>()\\n      val lists = mutableListOf<TreeNode>()\\n      fun dfs(m: Int): Unit = if (m == 0) \\n          lists += TreeNode(stack[0]).apply { for (i in 1 until n) insert(stack[i], this) }\\n        else for (i in 0 until n) if (m and (1 shl i) != 0) {\\n          stack.push(i + 1)\\n          dfs(m xor (1 shl i))\\n          stack.pop()\\n        }\\n      dfs((1 shl n) - 1)\\n      return lists.distinctBy { print(it) }\\n    }\\n\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1735731,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1849998,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1751837,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1574175,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1965487,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 2000434,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1571208,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1567854,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1567191,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 2000901,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1735731,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1849998,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1751837,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1574175,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1965487,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 2000434,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1571208,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1567854,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1567191,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 2000901,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "If you get this question during an interview, they don\\'t want to hire you."
                    },
                    {
                        "username": "Balerii",
                        "content": "Too bed for them \\uD83D\\uDE02. They\\'ll have to hire me."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "\\uD83D\\uDE01"
                    },
                    {
                        "username": "riteshnparkhi",
                        "content": "rofl"
                    },
                    {
                        "username": "Veeno_Rai",
                        "content": "true! lol"
                    },
                    {
                        "username": "Denis-onyango",
                        "content": "hahahhahaa"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Ordinarily, I feel a sense of pride when I solve a problem, but with this problem I will make an exception. I like my code, but I\\'m not happy that I had to write it.\\n\\nFor those who have stumbled onto this problem, blissfully ignorant of the treacherous path that lies ahead, heed the warnings of a wounded warrior, who made it to the end just to realize the only reward you will receive is the life you\\'ve spent and will never get back. Continue on your journey in another direction, and don\\'t look back upon the wasteland that is this problem."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Cannot agree more."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@AMerrill](/AMerrill) Hah! That\\'s why I don\\'t like Leetcode Discussion section because advices from sagacious warriors like you get drowned in spammy comments."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "How is this medium? Seriously? permutations and building binary search tree? For real?"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The problem really isn\\'t that complex if you have a good understanding of recursion. Particularly, this problem basically boils down to:\\n\\nPossible trees from [a, b) is exactly all combinations of trees from\\n[a, x) and [x, b) for all x in [a, b). Plus the base case where a==b being [None].\\n\\nIf you use itertools.product this can be done in like 10 lines of Python code total."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "To be honest I think medium is right. The problem is a little cumbersome at first with building trees as opposed to lists for instance. But once you start to code it out it is not so bad. They accept pretty naive solutions that serialize and serialize copies of the tree, due to the low constraint."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah,leetcode difficulty tags are broken nowdays"
                    },
                    {
                        "username": "mikel512",
                        "content": "Seriously, this is straight up alien stuff. Even when looking up the algorithm I had no idea how to implement it."
                    },
                    {
                        "username": "mcasavant",
                        "content": "I just think that the problem could have used more explanation. Looking at the question after having unlocked the answer it's now much more obvious what they are looking for. Perhaps on a problem like this one it would be a good idea to state the ask in more than one way. Be more specific. I think this question could easily have phrased:\n\n\"Construct every possible permutation of structurally unique trees from a range of numbers 1...n\".\n\nThat's about as long but twice as specific."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Why do people keep saying this's hard, I just go through the editorial and.... :D"
                    },
                    {
                        "username": "poundppx",
                        "content": "uhm .... since u step into another side can you give us some hint !!! one for all!"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "that\\'s why."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "hard enough to make u go through the editorial :v"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This is why i love leetcode, same concept problems will be given for somedays and increases the depth of questions day by day."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "can\\'t agree more. But to some degree it gives some hint which I don\\'t want to know, haha"
                    },
                    {
                        "username": "Gillu13",
                        "content": "I am wondering if it is relevant to keep 0 in the test cases? Indeed, it is clearly stated in the problem description that n in greater than 1, then testing 0 as an input is kind of \"off topic\", isn't it?"
                    },
                    {
                        "username": "Tony_Zhang",
                        "content": "The return type of generateTrees is a vector only, so when n = 0, it should return [], not [[]].\\n\\nplease let me know, if I am wrong."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Hey bro. It\\'s been some time. Just checking up on you if you\\'re alive and kicking :)"
                    },
                    {
                        "username": "exquiro",
                        "content": "This comment is of 2015... Give him a break guys xD"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) according to constraints, this shouldn\\'t be the way\\n"
                    },
                    {
                        "username": "void-pointer",
                        "content": "As per the constraints given for n. [1 <= n <= 8]\\nn cannot be 0."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it just means there is a tree possible , which has it\\'s root as NULL ."
                    },
                    {
                        "username": "dylan_yu",
                        "content": "I don't think it makes any sense to do so. When n is 0, we just cannot generate any trees, so the list should be empty."
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Can anybody tell me why unordered_map dp is giving Runtime error while map dp is getting accepted\nmap<pair<int,int>,vector<TreeNode*>> dp; // This dp is getting accepted \nwhile\nunordered_map<pair<int,int>,vector<TreeNode*>> dp; // This is giving Runtime error.\n\nhttps://leetcode.com/submissions/detail/1012767578/ \n Kindly provide some suggestion"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "[@HimanshuShekhar18](/HimanshuShekhar18) Thank you for clearing this"
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "valid keys datatype\\n      unordered_map<pair<int,int>, string>m;    //compilation error\\n      map<pair<int,int>, string>m;        // runs\\n\\n Reason:- Pair/vector/set don\\'t have inbuilt hash function defined, that\\'s why they won\\'t work with unordered map"
                    },
                    {
                        "username": "gulbi_bk",
                        "content": "I am also confused about this part. Someone please clarify this..."
                    },
                    {
                        "username": "OakNoob",
                        "content": "I am also confused about the same...!!.\\nIs there can who can clarify this..."
                    }
                ]
            },
            {
                "id": 1567855,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 1570582,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 1571209,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 1571210,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 2000375,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 2001657,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 2000446,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 2000428,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 1984547,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 2069142,
                "content": [
                    {
                        "username": "MitchellHe",
                        "content": "What does [{}] mean? An ArrayList<TreeNode> of length one containing one null value?\\n-------------------------------------------------------------------------------------------------------------\\nWrong Answer:\\n\\nInput: \\t0\\nOutput: \\t[]\\nExpected: \\t[{}]\\n\\nThanks in advance."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is how you represent empty array of array\nor vector<vector<datatype>> (in c++)\nbut here ,  it means that you have a tree with root as null pointer"
                    },
                    {
                        "username": "user6141Q",
                        "content": "Can someone please explain a little more about the question? For example:\\n1. In which order the first example is given?\\n2. Why [1, 2, 3] isn\\'t in the first example\\'s answer?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "2.\\nBecause, [1, 2, 3] IS a Binary Tree, but it IS NOT a Binary Search Tree"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "it is in level order traversal , that is why [1, 2 , 3] is not in the answer . \\n\\nif you make a binary search tree from [1,2,3]\\nyou will get ->\\n          1\\n        2    3 \\n\\nwhich is not a bst , as 2 > 1 it should be in the right subtree of 1 .\\nhope you got it .\\n  "
                    },
                    {
                        "username": "binhope",
                        "content": "Input:\\t2\\nOutput:\\t[{1,2},{1,#,2}]\\nExpected:\\t[{1,#,2},{2,1}]\\n.i'm confused with the expected.Is the answer is th unique?i think the struct of the tree is right,\\nbut the order is wrong. i want to ask what is the standard answer.thanks:)"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "your tree is wrong {1, 2} actually has 2 as the left child , which is wrong for a binary search tree , 2 > 1 so it should always be in the right subtree of 1 ."
                    },
                    {
                        "username": "makeittrue",
                        "content": "can't pass the judge, but give such output. I think this should be fine according to the problem?\\n\\nInput:\\t2\\nOutput:\\t[{2,#,1},{2,1}]\\nExpected:\\t[{1,#,2},{2,1}]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "bro  [2, #, 1] is wrong as  1 < 2 it should come in the left subtree , but it is coming in the right subtree , ( see the output is displayed in level order traversal ) "
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is related to Catalan numbers and done few days ago! Resubmit"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "Definitely a hard problem lol. Much harder than previous backtracking mediums"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "It is only Day 5 and Leetcode has decided to laugh on my skill. \\uD83D\\uDC38"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you see the answer in the editorial, it makes a lot more sense. I concur with other people who had a hard time knowing how to approach this... The thought struck me of building all the smaller subtrees first, but I was having a hard time figuring out how to implement it. Editorial is helpful in understanding the solution."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Once you are done with this question, you might want to try the following one which is a variation but is based on the same algorithm.\n\n[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/)\n\nIts a bit tricker as well."
                    },
                    {
                        "username": "vrajpatelll",
                        "content": "can i have some hints about solution of this question?"
                    }
                ]
            },
            {
                "id": 2066399,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2056253,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2048646,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2002955,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001639,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001616,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001604,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001592,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001476,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001084,
                "content": [
                    {
                        "username": "puppyslife",
                        "content": "Can someone please help me understand the time complexity for solution 1"
                    },
                    {
                        "username": "SeineAle",
                        "content": "IDK, But where was DP in that ?\\n"
                    },
                    {
                        "username": "AlexanderFSP",
                        "content": "A naive approach might be (brute force) - for each number from `1` to `n` define values that should be in the left and right subtrees. Do this recursively for each number in the left and right arrays. This recursive function must return the value of the currently processed node and all combinations between the resulting left and right subtrees. I hope this helps someone get closer to the answer or find their own better solution."
                    },
                    {
                        "username": "obbl",
                        "content": "I think that answer  for n = 3\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[2,1,null,null,3]`,[3,2,null,1]]\nis true as well, however it is suggested that the only true answer is\n[[1,null,2,null,3],[1,null,3,2],[2,1,3],`[3,1,null,null,2]`,[3,2,null,1]]\nwell, they are structurally the same and I don't get why one is true while the other isn't.\nDid I miss something or tests are not covering my solution? If I am wrong, please point where\n"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "Does anyone know the time complexity for the brute force solution?"
                    },
                    {
                        "username": "unters",
                        "content": "According to my very rough calculation, time complexity for worst brute force solution is `O( ( (2 ^ n)! * n! * (2 ^ n * n) ) / (2 ^ n - n)! )`.\n\nAs far as I understand, brute force consists of going through all possible arrays, that might or might not represent a valid BST.\n\nAs far as a BST with `n` nodes can not have height greater than `n`, an array representation of such BST can not contain more then `2 ^ n` elements.\n\nThere are `(2 ^ n)! / (2 ^ n - n)!` ways to choose `n` elements in an array of size `2 ^ n`.\n\nFor each choice of `n` elements there are n! ways to assign nodes with distinct values from `1` through `n` to these chosen elements (array is initially filled with `null`s).\n\nBuilding a BST using one array representation takes `O(2 ^ n * n)` time (`2 ^ n` elements in an array; inserting an element takes `O(log(2 ^ n))` time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "To my surprise, pure brute force worked!"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "Man, It fells so good to solve this on my own!! \\uD83E\\uDD70"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Some tips for this problem: Dont worry too much about runtime. So long as you write code somewhat efficiently, using an inefficient algorithm will be fine with this problem as in the input sizes are tiny. (I just mean, dont do foolish things like using .get() on a linked list rather than iterating through it, in that case use an array or an array list, etc). \\n\\nNotice that the left tree must always contain all values less than the head, and the right tree must always contain all values greater than the head. This makes for a really simple recursive solution. It is exponential time, but with a maximum input size of 8, its fine! \\n\\nA tip to make things even easier, just make the argument of your recursive function a list of all the nodes it needs to use. It should anyways output a list of all trees using those nodes. (This isn\\'t necessary at all, but it makes the logic easier atleast for me). "
                    },
                    {
                        "username": "breathermachine",
                        "content": "I didn't even pass in a list to my recursive function, only two int parameters: min and max. The recursive function then generates all trees using all the values from min to max:\n\nhttps://leetcode.com/problems/unique-binary-search-trees-ii/submissions/1013076716/"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/) \n\nThis question is a lot similar but I don't know why it has 82% acceptance rate I couldn't solve it."
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "how \n1\n    \\\\\\\\\\\\\n       3\n    /\n2\n\nis a BST? 2 is coming right side to 1. How is it a BST? Anyone please explain."
                    },
                    {
                        "username": "kush_sach",
                        "content": "If you write down the In-order traversal for this tree, as per the recursive rule \"(left subtree) root (right subtree)\", it shall be: 1,2,3. Perfectly correct.\\n\\nRemember that a subtree itself is a tree. So, first you choose 1 as a root, for which the right child is 3. Your order is:    1, <order of right subtree with root as 3>\\nTo fill in the order for the subtree that has 3 as its root, you must treat it as a tree in itself as well. Therefore, evidently, 1, < <left subtree with root as 2> , 3 >\\nWhich is simply: 1, 2, 3\\n\\nWhat I\\'ve said is merely a rephrased version of the other two replies. The in-order traversal is basically the same thing as the condition that all node elements in a left (sub)tree should be lesser than the root element, and the node elements in the right (sub)tree should all be larger."
                    },
                    {
                        "username": "unters",
                        "content": "In BST a key of each internal node is greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. Your BST satisfies this property."
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "as per BST, nodes to the right should be greater than root. 2 must come right to 1 only."
                    }
                ]
            },
            {
                "id": 2001067,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000948,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000937,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000916,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000895,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000783,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000771,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000707,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000698,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            },
            {
                "id": 2000494,
                "content": [
                    {
                        "username": "charant587",
                        "content": "I got up with dfs approach after think for an 20 minutes can we use dp for this????"
                    },
                    {
                        "username": "KirtanMakwana",
                        "content": "why unordered_map giving error and map doesnt? while memoization."
                    },
                    {
                        "username": "unters",
                        "content": "`std::unordered_map` organizes its elements using a hash table. This imposes requirements on the key-type:\n\n1. default hash functor `std::hash<>` must be specialized for key-type (there is no such requirement when using `std::map`);\n\n2. A comparison function for equality must be defined for key-type (when using `std::map` the equivalent requirement is that keys must be comparable).\n\nI guess you use a user-defined key-type that has no `std::hash<>` specialization, but that has comparison functions."
                    },
                    {
                        "username": "ahmed___",
                        "content": "Medium??"
                    },
                    {
                        "username": "algoacer",
                        "content": "call to implicitly-deleted default constructor of \\'Solution\\'.  Generate the required memo dp within the generate Trees function. Congrats on completing such an interesting problem."
                    },
                    {
                        "username": "dikshawali",
                        "content": "My solution is beating only 5% of users. \\n1. I have used DP\\n2. Despite having recursive solution, my program is having n3 time complexity.\\ncan anyone suggest ways to decrease time complexity?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Write a helper _generateTrees method that takes in two parameters: the min and the max then use it recursively to generate the subtrees.\\n\\nThe loop looks like:\\n```\\nfor i in min to max:\\n   leftTrees = generateTrees(min, i - 1)\\n   rightTrees = generateTrees(i + 1, max)\\n   // combine left and right subtrees using a double for loop\\nreturn\\n```\\n\\n"
                    },
                    {
                        "username": "sarvesh_mankar",
                        "content": "If you are finding this challenge really tough then try out [Leetcode Challenge 96](https://leetcode.com/problems/unique-binary-search-trees/) first! It will help you in developing this solution."
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "dkochetov",
                        "content": "I overcomplicated my solution by using bitmasking and memoization. You don\\'t need any of these for this problem :)"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Hate to say it but with N<=8 isn\\'t this question easy? "
                    },
                    {
                        "username": "a8hi",
                        "content": "LeetCode Daily Has been Real Kind"
                    }
                ]
            }
        ]
    },
    {
        "title": "Tenth Line",
        "question_content": "<p>Given a text file&nbsp;<code>file.txt</code>, print&nbsp;just the 10th line of the&nbsp;file.</p>\r\n\r\n<p><strong class=\"example\">Example:</strong></p>\r\n\r\n<p>Assume that <code>file.txt</code> has the following content:</p>\r\n\r\n<pre>\r\nLine 1\r\nLine 2\r\nLine 3\r\nLine 4\r\nLine 5\r\nLine 6\r\nLine 7\r\nLine 8\r\nLine 9\r\nLine 10\r\n</pre>\r\n\r\n<p>Your script should output the tenth line, which is:</p>\r\n\r\n<pre>\r\nLine 10\r\n</pre>\r\n\r\n<div class=\"spoilers\"><b>Note:</b><br />\r\n1. If the file contains less than 10 lines, what should you output?<br />\r\n2. There&#39;s at least three different solutions. Try to explore all possibilities.</div>\r\n",
        "solutions": [
            {
                "id": 55544,
                "title": "share-four-different-solutions",
                "content": "\\n    # Solution 1\\n    cnt=0\\n    while read line && [ $cnt -le 10 ]; do\\n      let 'cnt = cnt + 1'\\n      if [ $cnt -eq 10 ]; then\\n        echo $line\\n        exit 0\\n      fi\\n    done < file.txt\\n\\n    # Solution 2\\n    awk 'FNR == 10 {print }'  file.txt\\n    # OR\\n    awk 'NR == 10' file.txt\\n\\n    # Solution 3\\n    sed -n 10p file.txt\\n\\n    # Solution 4\\n    tail -n+10 file.txt|head -1",
                "solutionTags": [],
                "code": "\\n    # Solution 1\\n    cnt=0\\n    while read line && [ $cnt -le 10 ]; do\\n      let 'cnt = cnt + 1'\\n      if [ $cnt -eq 10 ]; then\\n        echo $line\\n        exit 0\\n      fi\\n    done < file.txt\\n\\n    # Solution 2\\n    awk 'FNR == 10 {print }'  file.txt\\n    # OR\\n    awk 'NR == 10' file.txt\\n\\n    # Solution 3\\n    sed -n 10p file.txt\\n\\n    # Solution 4\\n    tail -n+10 file.txt|head -1",
                "codeTag": "Unknown"
            },
            {
                "id": 55537,
                "title": "my-three-simple-solutions",
                "content": "    # Read from the file file.txt and output the tenth line to stdout.\\n    \\n    #Solution One:\\n    #head -n 10 file.txt | tail -n +10\\n    \\n    #Solution Two:\\n    #awk 'NR==10' file.txt\\n    \\n    #Solution Three:\\n    sed -n 10p file.txt",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and output the tenth line to stdout.\\n    \\n    #Solution One:\\n    #head -n 10 file.txt | tail -n +10\\n    \\n    #Solution Two:\\n    #awk 'NR==10' file.txt\\n    \\n    #Solution Three:\\n    sed -n 10p file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 3218908,
                "title": "195-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExplanation:\\n\\n- The sed command is used to edit a stream of text, and -n option is used to suppress the output.\\n- The 10p command prints only the 10th line of the input file. So, \\'10p\\' prints the 10th line.\\n\\nNote:\\n\\n- If the file has less than 10 lines, then the script will output nothing.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nThis can be solved using the sed command. Here\\'s a one-liner bash script that accomplishes this:\\n\\n```\\nsed -n \\'10p\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\nsed -n \\'10p\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2281857,
                "title": "easy-explaination-with-1-line-code",
                "content": "```\\nawk \\'NR==10\\' file.txt\\n```\\nHere awk is the build in function which is used to manipulate files, to extract data from files, NR is used for No. of Records which are usually no. of lines in the file. \\nfile.txt is the input file which has to be read.",
                "solutionTags": [],
                "code": "```\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693040,
                "title": "4-solutions-easy-understanding",
                "content": "**Solution 1**\\n```\\ncnt=0\\nwhile read line && [ $cnt -le 10 ]; do\\n  let \\'cnt = cnt + 1\\'\\n  if [ $cnt -eq 10 ]; then\\n    echo $line\\n    exit 0\\n  fi\\ndone < file.txt\\n```\\n\\n\\n**Solution 2**\\n\\n`awk \\'FNR == 10 {print }\\'  file.txt`\\n \\n**(*Another way of writing*)**\\n\\n```\\nawk \\'NR == 10\\' file.txt\\n```\\n\\n**Solution3**\\n```\\n\\nsed -n 10p file.txt\\n```\\n\\n**Solution 4**\\n\\n```\\n\\ntail -n+10 file.txt|head -1\\n```",
                "solutionTags": [],
                "code": "```\\ncnt=0\\nwhile read line && [ $cnt -le 10 ]; do\\n  let \\'cnt = cnt + 1\\'\\n  if [ $cnt -eq 10 ]; then\\n    echo $line\\n    exit 0\\n  fi\\ndone < file.txt\\n```\n```\\nawk \\'NR == 10\\' file.txt\\n```\n```\\n\\nsed -n 10p file.txt\\n```\n```\\n\\ntail -n+10 file.txt|head -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559470,
                "title": "bash-summarize-a-few-solutions",
                "content": "It is natural to consider `head -10 file.txt | tail -1` as the candidate which cannot output the 10th line if the file has fewer than 10 lines. But it can be easily fixed as below. \\n```\\ntail -n+10 file.txt | head -1\\n```\\n\\nAlternatively, `sed`, `awk`, `cut` and `mapfile` can do the job as well (e.g. below)\\n```\\nsed -n \\'10p\\' file.txt\\n```\\n\\n```\\ncut -f10 -d$\\'\\\\n\\' file.txt\\n```\\n\\n```\\nawk \\'NR==10\\' file.txt\\n```\\n\\n```\\nmapfile -s 9 -n 1 array < file.txt\\necho \"${array[0]}\" | head -1\\n```\\n\\nLast but not least, the most flexible solution would be writing ones own script. \\n```\\nno=0                                                                  \\nwhile IFS= read -r line                                               \\ndo                                                                        \\n    ((no=$no+1))\\n    if [[ $no -eq 10 ]]                                                   \\n    then                                                                      \\n        echo $line\\n\\t\\tbreak\\n    fi                                                                \\ndone < \"file.txt\"    \\n```",
                "solutionTags": [],
                "code": "```\\ntail -n+10 file.txt | head -1\\n```\n```\\nsed -n \\'10p\\' file.txt\\n```\n```\\ncut -f10 -d$\\'\\\\n\\' file.txt\\n```\n```\\nawk \\'NR==10\\' file.txt\\n```\n```\\nmapfile -s 9 -n 1 array < file.txt\\necho \"${array[0]}\" | head -1\\n```\n```\\nno=0                                                                  \\nwhile IFS= read -r line                                               \\ndo                                                                        \\n    ((no=$no+1))\\n    if [[ $no -eq 10 ]]                                                   \\n    then                                                                      \\n        echo $line\\n\\t\\tbreak\\n    fi                                                                \\ndone < \"file.txt\"    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1831670,
                "title": "python-one-liner-abomination",
                "content": "```\\npython3 -c \\'a = [l for l in open(\"file.txt\")]; print(\"\" if len(a) < 10 else a[9].strip())\\'\\n```",
                "solutionTags": [],
                "code": "```\\npython3 -c \\'a = [l for l in open(\"file.txt\")]; print(\"\" if len(a) < 10 else a[9].strip())\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1772093,
                "title": "tenth-line",
                "content": "```\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053537,
                "title": "simple-solution-without-using-sed-and-awk",
                "content": "Super Simple Solution....\\nUpvote it, if you like it....\\n\\n```\\na=`cat file.txt | wc -l`\\nb=9\\nif [[ $a -gt 9 ]]\\nthen\\n{\\ncat file.txt | head -n 10 | tail -n 1\\n}\\nfi\\n```",
                "solutionTags": [],
                "code": "```\\na=`cat file.txt | wc -l`\\nb=9\\nif [[ $a -gt 9 ]]\\nthen\\n{\\ncat file.txt | head -n 10 | tail -n 1\\n}\\nfi\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2241809,
                "title": "two-line-bash-code-solution",
                "content": "**Solution -**\\n1. Read first 10 lines from the file into an array.\\n2. Print the value of 10th index of the array.\\n\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n#!/bin/bash\\n\\nreadarray -n 10 -t arr < \\'file.txt\\' && echo \"${arr[9]}\"\\n```\\n\\nHope it is helpful to you. Please upvote, thank you.",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n#!/bin/bash\\n\\nreadarray -n 10 -t arr < \\'file.txt\\' && echo \"${arr[9]}\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 766136,
                "title": "simple-of-simple",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nindex=0\\ncat file.txt | while read line\\ndo\\n    index=$index+1\\n    if [[ index -eq 10 ]]; then\\n        echo $line\\n        break\\n    fi\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nindex=0\\ncat file.txt | while read line\\ndo\\n    index=$index+1\\n    if [[ index -eq 10 ]]; then\\n        echo $line\\n        break\\n    fi\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3471767,
                "title": "solution-with-sed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1620364,
                "title": "head-tail-trick",
                "content": "```\\nhead -n 10 file.txt | tail -n +10\\n```\\n\\nI\\'m sure someone already posted this, but....\\n\\n1) Pass file.txt through head, getting only 10 lines.\\n2) Pipe output of head to tail, getting everything from 10th line (which should just be the 10th line).\\n",
                "solutionTags": [],
                "code": "```\\nhead -n 10 file.txt | tail -n +10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2252727,
                "title": "simple-bash-solution",
                "content": "```\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1476608,
                "title": "84-11-faster-than-all-submissions-with-head-tail-command",
                "content": "```\\n head -n 10 file.txt | tail -n +10\\n ```",
                "solutionTags": [],
                "code": "```\\n head -n 10 file.txt | tail -n +10\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276426,
                "title": "a-few-solutions",
                "content": "`tail -n +10 file.txt | head -1`\\n`sed -n \\'10p\\' file.txt`\\n`awk \\'NR == 10\\' file.txt`\\n```\\n#!/usr/bin/bash\\ni=0 \\nwhile IFS= read -r l; do \\n        (( ++i == 10 )) && { \\n                echo \"$l\"\\n                exit 0\\n        } \\ndone <file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n#!/usr/bin/bash\\ni=0 \\nwhile IFS= read -r l; do \\n        (( ++i == 10 )) && { \\n                echo \"$l\"\\n                exit 0\\n        } \\ndone <file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1185039,
                "title": "pure-bash-solution",
                "content": "```\\n#Read from the file file.txt and output the tenth line to stdout.\\nline=0\\nwhile read l; do\\n    line=$(($line+1))\\n    if [[ $line -eq 10 ]]; then\\n        echo $l;\\n        exit;\\n    fi;\\ndone < file.txt\\necho \"\";\\n```\\n",
                "solutionTags": [],
                "code": "```\\n#Read from the file file.txt and output the tenth line to stdout.\\nline=0\\nwhile read l; do\\n    line=$(($line+1))\\n    if [[ $line -eq 10 ]]; then\\n        echo $l;\\n        exit;\\n    fi;\\ndone < file.txt\\necho \"\";\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1170820,
                "title": "100-faster-easy-solution",
                "content": "```\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115189,
                "title": "simple-solution-with-head-and-tac",
                "content": "Here\\'s my simple solution with `head` and `tac` commands (inverse of `cat`)\\n```\\nhead file.txt | tac | head -n -9\\n```",
                "solutionTags": [],
                "code": "```\\nhead file.txt | tac | head -n -9\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 962969,
                "title": "pure-bash-solution-for-printing-10th-line",
                "content": "No Awk, Sed, Grep, etc.  Just using straight bash scripting. If there is not at least 10 lines it doesn\\'t produce output and if there are more it just stops after the 10th line.\\n\\n# Read from the file file.txt and output the tenth line to stdout.\\n```\\ni=0\\nwhile IFS= read -r line\\ndo\\n        i=$((i+1))\\n        if [ \"$i\" = \"10\" ]; then\\n                echo \"$line\"\\n                break\\n        fi\\ndone < \"file.txt\"\\n```",
                "solutionTags": [],
                "code": "```\\ni=0\\nwhile IFS= read -r line\\ndo\\n        i=$((i+1))\\n        if [ \"$i\" = \"10\" ]; then\\n                echo \"$line\"\\n                break\\n        fi\\ndone < \"file.txt\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548822,
                "title": "sed-life",
                "content": "```sed -n \\'10\\'p file.txt```",
                "solutionTags": [],
                "code": "```sed -n \\'10\\'p file.txt```",
                "codeTag": "Unknown"
            },
            {
                "id": 55530,
                "title": "5ms-solution-with-sed-beats-94-of-bash-submissions",
                "content": "```\\ncat file.txt | sed -n '10p'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | sed -n '10p'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467822,
                "title": "awk-using-nr",
                "content": "# Code\\n```bash\\nawk \\'NR == 10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```bash\\nawk \\'NR == 10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887437,
                "title": "java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nsed \"10q;d\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nsed \"10q;d\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2583193,
                "title": "shell-simple-sed-command",
                "content": "```\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2552849,
                "title": "simple-solution-using-awk",
                "content": "```\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2403178,
                "title": "solution-with-head-and-tail-commands-only",
                "content": "```\\nhead -10 file.txt | tail +10\\n```",
                "solutionTags": [],
                "code": "```\\nhead -10 file.txt | tail +10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981678,
                "title": "awk-is-the-fastest",
                "content": "```bash\\n# Read from the file file.txt and output the tenth line to stdout.\\n# cat file.txt | tail -n +10 | head -n 1\\n# sed -n \\'10, 10p\\' file.txt\\nawk \\'NR==10\\' file.txt\\n# tail -n +10 file.txt | head -1\\n```\\n- `awk` 34ms faster than 74.46%",
                "solutionTags": [],
                "code": "```bash\\n# Read from the file file.txt and output the tenth line to stdout.\\n# cat file.txt | tail -n +10 | head -n 1\\n# sed -n \\'10, 10p\\' file.txt\\nawk \\'NR==10\\' file.txt\\n# tail -n +10 file.txt | head -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1963643,
                "title": "simple",
                "content": "![image](https://assets.leetcode.com/users/images/8bdd47a4-f42a-4b9c-a4f0-7f943da59c5c_1650369964.0566795.png)\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \\'10!d\\' file.txt",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/8bdd47a4-f42a-4b9c-a4f0-7f943da59c5c_1650369964.0566795.png)\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \\'10!d\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 1385684,
                "title": "pure-bash-and-easy-to-understand",
                "content": "```\\ni=0\\nwhile (( i++ < 10 ))\\ndo\\n  read line\\ndone < file.txt\\necho $line\\n```",
                "solutionTags": [],
                "code": "```\\ni=0\\nwhile (( i++ < 10 ))\\ndo\\n  read line\\ndone < file.txt\\necho $line\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 750564,
                "title": "solution-with-only-sed",
                "content": "```\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 653221,
                "title": "simple-using-head-tail",
                "content": "\\n\\n```tail -n +10 file.txt | head -1 || exit```",
                "solutionTags": [],
                "code": "```tail -n +10 file.txt | head -1 || exit```",
                "codeTag": "Unknown"
            },
            {
                "id": 549890,
                "title": "new-to-bash-solution-beats-73",
                "content": "Only started learning bash recently, accepting constructive criticism:\\n```\\ni=$((0))\\nwhile read -r || [[ $REPLY ]]; do\\n    i=$(($i + 1))\\n    if [[ $i -eq 10 ]]; then\\n        echo $REPLY\\n    fi\\ndone < file.txt",
                "solutionTags": [],
                "code": "Only started learning bash recently, accepting constructive criticism:\\n```\\ni=$((0))\\nwhile read -r || [[ $REPLY ]]; do\\n    i=$(($i + 1))\\n    if [[ $i -eq 10 ]]; then\\n        echo $REPLY\\n    fi\\ndone < file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 440631,
                "title": "sed",
                "content": "```bash\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 435778,
                "title": "my-solutions",
                "content": "One line with awk:\\n```bash\\nawk \\'{if(NR==10){print;exit}}\\' file.txt\\n```\\nOne line with sed, which is faster:\\n```bash\\nsed -n 10p file.txt\\n```\\nBut the fastest is to avoid spawning extra processes:\\n```bash\\nwhile read -r line; do\\n\\ti=$((i+1))\\n\\tif [ $i -eq 10 ]; then\\n\\t\\techo \"$line\"\\n\\t\\tbreak\\n\\tfi\\ndone <file.txt\\n```\\n",
                "solutionTags": [],
                "code": "```bash\\nawk \\'{if(NR==10){print;exit}}\\' file.txt\\n```\n```bash\\nsed -n 10p file.txt\\n```\n```bash\\nwhile read -r line; do\\n\\ti=$((i+1))\\n\\tif [ $i -eq 10 ]; then\\n\\t\\techo \"$line\"\\n\\t\\tbreak\\n\\tfi\\ndone <file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355296,
                "title": "very-simple-method-using-sed",
                "content": "```\\nsed -n \"10p\" file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n \"10p\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285925,
                "title": "1-line-faster-than-100",
                "content": "```\\ntail -n +10 file.txt | head -1\\n```",
                "solutionTags": [],
                "code": "```\\ntail -n +10 file.txt | head -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55531,
                "title": "a-very-simple-solution-using-cut",
                "content": "```\\ncat file.txt | cut -d $'\\\\n' -f 10\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | cut -d $'\\\\n' -f 10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55546,
                "title": "12-ms-awk-based-solution",
                "content": "This is all it takes. I tried to do the same thing with sed, but I couldn't remember how to do it with sed.\\n\\n    awk 'NR == 10' < file.txt\\n\\nGiven that the awk binary is slightly larger than the sed binary on my box I wonder if I'll get better runtime using sed, since some of the runtime will be affected by loading that binary before executing it. But given that those binaries are so small (on my OS X box), I wonder if it will make a difference.\\n\\n    panzani leetcode$ which sed\\n    /usr/bin/sed\\n    panzani leetcode$ du -h /usr/bin/sed\\n     20K\\t/usr/bin/sed\\n    panzani leetcode$ which awk \\n    /usr/bin/awk\\n    panzani leetcode$ du -h /usr/bin/awk \\n     52K\\t/usr/bin/awk",
                "solutionTags": [],
                "code": "This is all it takes. I tried to do the same thing with sed, but I couldn't remember how to do it with sed.\\n\\n    awk 'NR == 10' < file.txt\\n\\nGiven that the awk binary is slightly larger than the sed binary on my box I wonder if I'll get better runtime using sed, since some of the runtime will be affected by loading that binary before executing it. But given that those binaries are so small (on my OS X box), I wonder if it will make a difference.\\n\\n    panzani leetcode$ which sed\\n    /usr/bin/sed\\n    panzani leetcode$ du -h /usr/bin/sed\\n     20K\\t/usr/bin/sed\\n    panzani leetcode$ which awk \\n    /usr/bin/awk\\n    panzani leetcode$ du -h /usr/bin/awk \\n     52K\\t/usr/bin/awk",
                "codeTag": "Unknown"
            },
            {
                "id": 3918925,
                "title": "print-tenth-line",
                "content": "# Approach\\n Uses simple while loop to read the file line by line\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nn=1;\\nwhile read line ;\\ndo\\n    if [  $n -eq 10  ]; then\\n        echo \"$line\"\\n    fi\\n    n=$((n+1));\\ndone < file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nn=1;\\nwhile read line ;\\ndo\\n    if [  $n -eq 10  ]; then\\n        echo \"$line\"\\n    fi\\n    n=$((n+1));\\ndone < file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3801067,
                "title": "using-simple-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfile=\"file.txt\"\\ni=1;\\nfor i in {1..10} ; do\\nread line\\n\\tif [ $i == 10 ];\\n\\tthen\\n\\t\\techo $line;\\n    break\\n\\tfi\\n\\t#i=$((i+1))\\ndone < $file;\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nfile=\"file.txt\"\\ni=1;\\nfor i in {1..10} ; do\\nread line\\n\\tif [ $i == 10 ];\\n\\tthen\\n\\t\\techo $line;\\n    break\\n\\tfi\\n\\t#i=$((i+1))\\ndone < $file;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775483,
                "title": "pure-bash-3-lines-runtime-25-ms-beats-98-31",
                "content": "# Intuition\\nYou don\\'t need to use a for loop to iterate through every line and a counter variable to print the 10th line or empty line if input was less than 10 lines. You also do not need any external tools such as wc or sed (we do use echo in the winning example).\\n\\n# Approach\\nIf you know anything about how iterative arrays (numerical arrays) work in bash, if an array value is not initialized, it will evaluate to empty string and this in conjunction with echo (or printf) will print a newline.\\n\\nUsing the \\'-t\\' flag strips newlines which eliminates the possibility to add a 2nd newline if it read more than 10 lines from file.txt\\n\\nUsing \\'-n\\' flag with the argument \\'10\\' means it will only read a maximum of 10 lines. Because of this, the program runs in constant time (which is still slow because bash is \"too big and too slow\" -- known feature of bash).\\n\\nRemember, iterative arrays are 0-based.\\n\\n\"printf\" is a bash builtin which will work without requiring the use of echo (which is a separate binary and usually part of coreutils), but no runtime advantage was found for the second example.\\n\\nAlso, the declare statements are optional, they are only added for clarity.\\n\\nFor more information on bash...\\n\\nRead the bash manual here https://www.man7.org/linux/man-pages/man7/man.7.html if you are not on a system with online documentation and scroll down to the section for \"mapfile\" / \"readarray\".\\n\\nUse the LeetCode editor to test out your scripts if you don\\'t have bash on your OS. It should be on most Linux distros e.g. Ubuntu (typical distro used with Windows 10/11 and WSL). Otherwise it would be available in Windows 10/11 via Cygwin/MSYS2. Early versions of OS X should have it as the default shell, otherwise you would have to install it with MacPorts or Homebrew.\\n\\nSee examples here https://linuxopsys.com/topics/bash-readarray-with-examples\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\nWinning example using only echo\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ndeclare -a lines\\nreadarray -n10 -t lines <file.txt\\necho ${lines[9]}\\n```\\n2nd example using pure bash\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ndeclare -a lines\\nreadarray -n10 -t lines <file.txt\\nprintf \"${lines[9]}\\\\\\\\n\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ndeclare -a lines\\nreadarray -n10 -t lines <file.txt\\necho ${lines[9]}\\n```\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ndeclare -a lines\\nreadarray -n10 -t lines <file.txt\\nprintf \"${lines[9]}\\\\\\\\n\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519938,
                "title": "single-line-solution",
                "content": "\\n# Code\\n```\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519746,
                "title": "easy-and-simple-solution-with-explanation-wow-0-0",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n```\\nThis command uses the sed command to print the 10th line of the file. The -n option is used to suppress the default output and \\'10p\\' is used to print the 10th line of the file. Replace file.txt with your file name.",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2525104,
                "title": "tail-head-command-with-explanation",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\ntail -n+10 file.txt | head -n1\\n```\\n\\nFor explanation please refer\\nhttps://leet-codes.blogspot.com/2022/09/195-tenth-line.html",
                "solutionTags": [],
                "code": "```\\ntail -n+10 file.txt | head -n1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400814,
                "title": "2-easy-solution-in-bash",
                "content": "# awk \\'NR == 10\\' file.txt\\n**-----------------------------------------------------------------------------**\\n# tail -n+10 file.txt | head -n1",
                "solutionTags": [],
                "code": "# awk \\'NR == 10\\' file.txt\\n**-----------------------------------------------------------------------------**\\n# tail -n+10 file.txt | head -n1",
                "codeTag": "Unknown"
            },
            {
                "id": 2242237,
                "title": "solution-for-tenth-line-problem",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n# variable for counting lines\\ncounter=1\\n\\n# read file\\'s lines iteratively\\nwhile read -r line; do\\n\\n# print the 10th line \\nif [[ $counter -eq 10 ]]\\n    then echo $line\\nfi\\n\\n# incremenet counter after reading each line\\ncounter=$counter+1\\n\\ndone < file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n# variable for counting lines\\ncounter=1\\n\\n# read file\\'s lines iteratively\\nwhile read -r line; do\\n\\n# print the 10th line \\nif [[ $counter -eq 10 ]]\\n    then echo $line\\nfi\\n\\n# incremenet counter after reading each line\\ncounter=$counter+1\\n\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2191372,
                "title": "simple-sed",
                "content": "# Simple Bash Script with sed \\n```bash\\nsed -n \\'10{p;q;}\\' file.text\\n```\\n\\nwill solve the error",
                "solutionTags": [],
                "code": "```bash\\nsed -n \\'10{p;q;}\\' file.text\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081103,
                "title": "used-cat-head-wc-tail-59-02-time-81-44-space",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nif [[ $(cat file.txt | wc -l) -ge 10 ]]\\nthen \\n    cat file.txt | head -n 10 | tail -n 1\\nfi \\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nif [[ $(cat file.txt | wc -l) -ge 10 ]]\\nthen \\n    cat file.txt | head -n 10 | tail -n 1\\nfi \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2021075,
                "title": "bash-for-loop",
                "content": "\\n```bash\\n# Declare a counter\\ni=0\\n\\n# For each line in the file\\ncat file.txt | while read line; do\\n\\t# 1. Count the line\\n    ((i++))\\n\\n\\t# 2. If we\\'ve reached the 10th line, print\\n    if [[ $i -eq 10 ]]; then\\n        echo $line\\n    fi\\ndone\\n```",
                "solutionTags": [],
                "code": "```bash\\n# Declare a counter\\ni=0\\n\\n# For each line in the file\\ncat file.txt | while read line; do\\n\\t# 1. Count the line\\n    ((i++))\\n\\n\\t# 2. If we\\'ve reached the 10th line, print\\n    if [[ $i -eq 10 ]]; then\\n        echo $line\\n    fi\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2003061,
                "title": "bash-using-sed-with-specific-line",
                "content": "Using `sed` command and specific line number.\\n\\n```\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1945847,
                "title": "195-tenth-line",
                "content": "sed -n \\'10p\\' file.txt\\nvar=`sed -n \\'10p\\' file.txt`\\n\\nif [ -z \"$var\" ]\\nthen\\n        printf \"No 10th Line in file.txt\\\\n\"\\nfi",
                "solutionTags": [],
                "code": "sed -n \\'10p\\' file.txt\\nvar=`sed -n \\'10p\\' file.txt`\\n\\nif [ -z \"$var\" ]\\nthen\\n        printf \"No 10th Line in file.txt\\\\n\"\\nfi",
                "codeTag": "Unknown"
            },
            {
                "id": 1857511,
                "title": "super-simple-solution-using-while-loop-and-if",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncount=1\\nwhile read p; do\\n if [ $count -eq 10 ]\\n then\\n  echo \"$p\"\\nfi\\ncount=`expr $count + 1 `\\ndone <file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncount=1\\nwhile read p; do\\n if [ $count -eq 10 ]\\n then\\n  echo \"$p\"\\nfi\\ncount=`expr $count + 1 `\\ndone <file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1683730,
                "title": "bash-simple-loop",
                "content": "```\\ni=0\\nwhile IFS= read -r row; do\\n    rows[i++]=\"$row\"\\ndone < file.txt\\necho \"${rows[9]}\"\\n```",
                "solutionTags": [],
                "code": "```\\ni=0\\nwhile IFS= read -r row; do\\n    rows[i++]=\"$row\"\\ndone < file.txt\\necho \"${rows[9]}\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604416,
                "title": "tenth-line-using-head-tail-and-wc",
                "content": "This problem really frustrated me because it doesn\\'t say what you should print if line 10 doesn\\'t exist. It asks in the notes what you think it should output. Does it want us to print the last line? Turns out they want a blank line. So here\\'s my solution:\\n\\n```\\n[ $(wc -l < file.txt) -ge 10 ] && head -n10 file.txt | tail -n1\\n```",
                "solutionTags": [],
                "code": "```\\n[ $(wc -l < file.txt) -ge 10 ] && head -n10 file.txt | tail -n1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499350,
                "title": "100-fast-solution",
                "content": "```bash\\n# Count number of lines in file.txt\\nnum=$(wc -l < file.txt)\\ncount=9\\nif [ $num -gt $count ]\\nthen \\n\\thead -n 10 file.txt | tail -n 1\\nelse\\n\\techo \"\"\\nfi\\n```\\n",
                "solutionTags": [],
                "code": "```bash\\n# Count number of lines in file.txt\\nnum=$(wc -l < file.txt)\\ncount=9\\nif [ $num -gt $count ]\\nthen \\n\\thead -n 10 file.txt | tail -n 1\\nelse\\n\\techo \"\"\\nfi\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280083,
                "title": "one-liner-sed-solution",
                "content": "```\\nsed \\'10q;d\\' file.txt\\n```\\nRuntime: 4 ms, faster than 78.08% of Bash online submissions for Tenth Line.\\nMemory Usage: 3.6 MB, less than 82.55% of Bash online submissions for Tenth Line.",
                "solutionTags": [],
                "code": "```\\nsed \\'10q;d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162723,
                "title": "awk-solution",
                "content": "```\\nawk \\'NR == 10\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'NR == 10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1118595,
                "title": "simple-sol-by-sed-w-comment",
                "content": "Simple sol by \"sed\" \\n\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n# Only print 10th line from input file\\nsed -n \\'10p\\' file.txt\\n```\\n\\n---\\n\\nDemo:\\n\\n![image](https://assets.leetcode.com/users/images/309f2839-c8f2-427d-8464-92900f1ab836_1616245880.7717433.png)\\n\\n---\\n\\nReference:\\n\\n[1] [Stackexchange: What does `-n` option in sed do?](https://superuser.com/questions/852404/what-does-n-option-in-sed-do)\\n\\n[2] [GNU document about sed](https://www.gnu.org/software/sed/manual/html_node/index.html#SEC_Contents)\\n\\n",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n# Only print 10th line from input file\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084026,
                "title": "195-easy-solution-with-good-resource",
                "content": "resources: 1. [https://www.unix.com/shell-programming-and-scripting/243138-print-nth-line-file.html](http://)\\n\\t\\t\\t\\t  2. https://stackoverflow.com/questions/20675295/fetch-nth-line-of-a-text-file-using-non-interactive-shell-script\\n\\n\\n```\\nsed -n 10p file.txt\\n```\\n",
                "solutionTags": [],
                "code": "```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762047,
                "title": "simple-solution-with-explanation",
                "content": "**Concatenate(cat)**: command is very frequently used in Linux. It reads data from the file and gives their content as output. It helps us to create, view, concatenate files.\\n\\n**Stream Editor (sed)**: It can perform lot\\u2019s of function on file like, searching, find and replace, insertion or deletion. By using SED you can edit files even without opening it, which is much quicker way to find and replace.\\n\\n**Solution:**\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncat file.txt | sed -n 10p\\n```\\n\\nThis solution is suggested by @jmcdonagh\\n```\\nsed -n 10p file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncat file.txt | sed -n 10p\\n```\n```\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 625831,
                "title": "wc-head-and-tail",
                "content": "Not the most efficient... I didn\\'t know about the sed trick. But hey, it\\'s a one-liner! :)\\n\\n```(( $(wc -l < file.txt) >= 10 )) && head -10 file.txt | tail -1```",
                "solutionTags": [],
                "code": "```(( $(wc -l < file.txt) >= 10 )) && head -10 file.txt | tail -1```",
                "codeTag": "Unknown"
            },
            {
                "id": 496924,
                "title": "simple-solution-using-shell-parameter-expansion",
                "content": "Simple solution using [Shell Parameter Expansion](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=2ahUKEwi5lYeNqbLnAhXroosKHe1kCPkQFjAAegQIAhAB&url=https%3A%2F%2Fwww.gnu.org%2Fsoftware%2Fbash%2Fmanual%2Fhtml_node%2FShell-Parameter-Expansion.html&usg=AOvVaw2pT2UtRfrmlSSDB_3HLLVhhttp://)\\n```\\nlines=$(cat file.txt | wc -l)\\nif [ \"${lines%% *}\" -ge 10 ]; then\\n    cat file.txt | head -n 10 | tail -n 1\\nfi\\n```",
                "solutionTags": [],
                "code": "```\\nlines=$(cat file.txt | wc -l)\\nif [ \"${lines%% *}\" -ge 10 ]; then\\n    cat file.txt | head -n 10 | tail -n 1\\nfi\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 449313,
                "title": "tail-head",
                "content": "Just a simple line with tail that catches up to the 10th line, then a head that obtains the last result of the tail\\n```\\ntail -n +10 file.txt | head -n 1\\n```",
                "solutionTags": [],
                "code": "```\\ntail -n +10 file.txt | head -n 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433988,
                "title": "awk-easiest-one",
                "content": "```\\nawk \\'NR==10\\' file.txt \\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'NR==10\\' file.txt \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 415433,
                "title": "cat-awk-faster-than-100",
                "content": "using cat and awk commands\\n\\n```bash\\ncat file.txt | awk \\'NR==10\\'\\n```",
                "solutionTags": [],
                "code": "```bash\\ncat file.txt | awk \\'NR==10\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374922,
                "title": "sed-awk-solutions-faster-than-100",
                "content": "# sed\\nThe first is with the p (print) command, and the other is with the d (delete) command.\\nThe n option with the print command is used to only print lines explicitly indicated by the command.\\nFor example, sed will output the 10th line of file.txt with each of the commands below:\\n\\nprint/p command\\n```\\ncat file.txt | sed -n \\'10p\\'  # > 73%\\n```\\n \\ndelete/d command\\n```\\ncat file.txt | sed \\'10!d\\'  # > 73%\\n```\\n\\n\\n***\\n\\n# awk\\n\\n awk has a built in variable NR that keeps track of file/stream row numbers.\\n awk syntax and idioms can be hard to read, so below are three different ways to print line 10 of file.txt file using awk.\\n```\\ncat file.txt | awk \\'NR==10\\'     # > 73%\\ncat file.txt | awk \\'NR==10{print}\\'  # > 100%\\ncat file.txt | awk \\'{if(NR==10) print}\\'  # >73%\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | sed -n \\'10p\\'  # > 73%\\n```\n```\\ncat file.txt | sed \\'10!d\\'  # > 73%\\n```\n```\\ncat file.txt | awk \\'NR==10\\'     # > 73%\\ncat file.txt | awk \\'NR==10{print}\\'  # > 100%\\ncat file.txt | awk \\'{if(NR==10) print}\\'  # >73%\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 348906,
                "title": "all-different-way-to-print-10th-line-of-a-file",
                "content": "Different approaches using sed, head & tail, awk, and cut linux command.\\n```\\n#!/bin/bash\\n\\n#tail -n+10 \\'file.txt\\' | head -1\\n#sed -n \\'10p\\' \\'file.txt\\'\\n#awk \"NR==10\" file.txt\\n#cut -f10 -d$\\'\\\\n\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\n#tail -n+10 \\'file.txt\\' | head -1\\n#sed -n \\'10p\\' \\'file.txt\\'\\n#awk \"NR==10\" file.txt\\n#cut -f10 -d$\\'\\\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 341942,
                "title": "awk-solution",
                "content": "```\\ncat file.txt | awk \\'{if (NR==10){print $0}}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'{if (NR==10){print $0}}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 217162,
                "title": "the-shortest",
                "content": "```\\nawk \\'{if(NR==10){print $0}}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{if(NR==10){print $0}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208499,
                "title": "4-ms-faster-than-100-with-tail-and-head",
                "content": "```tail -n+10 file.txt | head -n1```",
                "solutionTags": [],
                "code": "```tail -n+10 file.txt | head -n1```",
                "codeTag": "Unknown"
            },
            {
                "id": 149734,
                "title": "dead-simple-bash",
                "content": "```\\ncat file.txt | sed -n 10p\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | sed -n 10p\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128426,
                "title": "simple-solution",
                "content": "```\\nsed \"10q;d\" file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed \"10q;d\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 117471,
                "title": "one-line-solution-using-head-and-tail",
                "content": "Check if `#line >= 10` and use `head` + `tail` to print out the 10th line:\n\n```\n[ $(cat file.txt | wc -l) -ge 10 ] && head -n10 file.txt | tail -n1\n```",
                "solutionTags": [],
                "code": "```\n[ $(cat file.txt | wc -l) -ge 10 ] && head -n10 file.txt | tail -n1\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55543,
                "title": "a-pure-bash-solution",
                "content": "    #!/bin/env bash\\n    # Read from the file file.txt and output the tenth line to stdout.\\n    \\n    filename=${1:-file.txt}\\n    lineth=${2:-10}\\n    \\n    i=$lineth\\n    while read line && ((--i))\\n    do\\n        :\\n    done <$filename\\n    \\n    if [[ $i -gt 0 ]]\\n    then\\n        #echo \"This file has not enough lines\"\\n        exit 1\\n    fi\\n    \\n    echo $line\\n\\nI had thought that this solution may has an better efficiency than such as `tail -n+10 file.txt|head -1` which forks other processes, but I am wrong.\\n\\nThe above solution only beats 3% submissions while `tail&&head` combination beats 17% submissions, I don't know why....",
                "solutionTags": [],
                "code": "    #!/bin/env bash\\n    # Read from the file file.txt and output the tenth line to stdout.\\n    \\n    filename=${1:-file.txt}\\n    lineth=${2:-10}\\n    \\n    i=$lineth\\n    while read line && ((--i))\\n    do\\n        :\\n    done <$filename\\n    \\n    if [[ $i -gt 0 ]]\\n    then\\n        #echo \"This file has not enough lines\"\\n        exit 1\\n    fi\\n    \\n    echo $line\\n\\nI had thought that this solution may has an better efficiency than such as `tail -n+10 file.txt|head -1` which forks other processes, but I am wrong.\\n\\nThe above solution only beats 3% submissions while `tail&&head` combination beats 17% submissions, I don't know why....",
                "codeTag": "Unknown"
            },
            {
                "id": 55551,
                "title": "checkout-my-solution-here",
                "content": "    #if file.txt does not contain enough lines, we just pad it with 10 empty lines.\\n    echo \"\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \" | cat file.txt - | head | tail -n 1\\n\\nI thought it simple enough for this question.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 4088206,
                "title": "print-10th-line-of-the-file",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ncat file.txt | sed -n \\'10p\\'\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat file.txt | sed -n \\'10p\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080340,
                "title": "for-solution",
                "content": "# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n head -n 10 file.txt | tail -n +10\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n head -n 10 file.txt | tail -n +10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077597,
                "title": "it-was-easy",
                "content": "\\u0628\\u0633\\u0645 \\u0627\\u0644\\u0644\\u0647 \\u0627\\u0644\\u0631\\u062D\\u0645\\u0646 \\nThe easiest way to solve this question was to use awk. like this :\\n```bash\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```bash\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070131,
                "title": "tenth-line",
                "content": "# Intuition\\nThe \"Tenth Line\" problem on LeetCode is typically solved using command-line tools like sed or awk \\n\\n# Approach\\nThis command will print the 10th line of the file, or nothing if the file has fewer than 10 lines. Since this problem is primarily about using command-line tools\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!-- \\n- Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n\\n# sed: Invokes the stream editor.\\n# -n: Suppresses automatic printing of pattern space.\\n# \\'10p\\': Specifies to print the 10th line (10p) of the input file.\\n# file.txt: The name of the input file.\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n\\n# sed: Invokes the stream editor.\\n# -n: Suppresses automatic printing of pattern space.\\n# \\'10p\\': Specifies to print the 10th line (10p) of the input file.\\n# file.txt: The name of the input file.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064540,
                "title": "easy-and-simple-solution-using-just-while-loop",
                "content": "# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n# cat file.txt | awk \\'{if (NR==10) print$0}\\'\\ncount=0\\nwhile read myVar\\ndo \\n    let count++;\\n    if [[ $count -eq 10 ]]\\n    then \\n        echo $myVar\\n    fi\\n\\ndone < file.txt\\n```\\n\\n# Please Do Upvote the Solution if you like \\uD83D\\uDE0D\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n# cat file.txt | awk \\'{if (NR==10) print$0}\\'\\ncount=0\\nwhile read myVar\\ndo \\n    let count++;\\n    if [[ $count -eq 10 ]]\\n    then \\n        echo $myVar\\n    fi\\n\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061750,
                "title": "pov",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n 10p file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051570,
                "title": "print-10-th-line",
                "content": "# Intuition\\nRead line by line till line 10 is reached, then print the line and end the processing.\\n\\n# Approach\\nIn a for loop read a line from the file. Check if the counter is already ten, then print the line and exit the loop. If it\\'s not yet ten, read the next line.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n#!/bin/bash\\n# Read from the file file.txt and output the tenth line to stdout.\\ni=1\\nwhile read line\\ndo\\n  if [[ $i -eq 10 ]]; then\\n    echo $line\\n    break\\n  fi\\n  ((i++))\\ndone <file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\n# Read from the file file.txt and output the tenth line to stdout.\\ni=1\\nwhile read line\\ndo\\n  if [[ $i -eq 10 ]]; then\\n    echo $line\\n    break\\n  fi\\n  ((i++))\\ndone <file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044039,
                "title": "bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029183,
                "title": "great-performance-99-one-line-with-read-and-counter-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nit=0; while read line; do ((it++)); if [ $it -eq 10 ]; then echo ${line}; exit 0; fi; done <file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nit=0; while read line; do ((it++)); if [ $it -eq 10 ]; then echo ${line}; exit 0; fi; done <file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025435,
                "title": "using-sed",
                "content": "\\n\\nsed \\'10q;d\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "\\n\\nsed \\'10q;d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004147,
                "title": "bash-simple-solution-sed",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```bash\\nsed -n \\'10p\\' file.txt\\n```\\n",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```bash\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3989029,
                "title": "bash-1-line",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n# Use awk to print the 10th line\\nawk \\'NR == 10\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n# Use awk to print the 10th line\\nawk \\'NR == 10\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976528,
                "title": "awk-3-solution",
                "content": "```\\nawk \\'NR==10 {print $0}\\' file.txt\\n```\\n\\nor\\n\\n```\\nawk \\'FNR==10 {print $0}\\' file.txt\\n```\\n\\nor\\n\\n```\\nawk \\'NR==10 {print $FILENAME}\\' file.txt\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nawk \\'NR==10 {print $0}\\' file.txt\\n```\n```\\nawk \\'FNR==10 {print $0}\\' file.txt\\n```\n```\\nawk \\'NR==10 {print $FILENAME}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3960197,
                "title": "easy-readable-bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3959332,
                "title": "one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942455,
                "title": "head-tail-and-wc",
                "content": "# Code\\n```\\nline_count=$(wc -l < \"file.txt\")\\nif [ \"$line_count\" -lt 10 ]; then\\n    echo \"\"\\nelse \\n    head -n 10 file.txt | tail -n 1\\nfi\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nline_count=$(wc -l < \"file.txt\")\\nif [ \"$line_count\" -lt 10 ]; then\\n    echo \"\"\\nelse \\n    head -n 10 file.txt | tail -n 1\\nfi\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938526,
                "title": "compile-a-c-program-with-gcc-and-run-it-lmao",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ngcc -x c - <<\\'EOF\\' && env PATH=\".:$PATH\" sh -c \\'a.out\\' < file.txt\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <stdint.h>\\nint main(void)\\n{\\n    uint8_t newlines = 0;\\n    int c;\\n    while ((c = getchar()) != EOF && newlines < 9)\\n        if (c == \\'\\\\n\\') ++newlines;\\n\\n    if (c == EOF) return 1;\\n\\n    putchar(c);\\n    while ((c = getchar()) != EOF && c != \\'\\\\n\\') {\\n        putchar(c);\\n    }\\n    return 0;\\n}\\nEOF\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ngcc -x c - <<\\'EOF\\' && env PATH=\".:$PATH\" sh -c \\'a.out\\' < file.txt\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <stdint.h>\\nint main(void)\\n{\\n    uint8_t newlines = 0;\\n    int c;\\n    while ((c = getchar()) != EOF && newlines < 9)\\n        if (c == \\'\\\\n\\') ++newlines;\\n\\n    if (c == EOF) return 1;\\n\\n    putchar(c);\\n    while ((c = getchar()) != EOF && c != \\'\\\\n\\') {\\n        putchar(c);\\n    }\\n    return 0;\\n}\\nEOF\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3938518,
                "title": "sed",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n 10p file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926688,
                "title": "simple-sed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -ne \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -ne \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915081,
                "title": "1-line",
                "content": "```\\nsed \\'10!d\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nsed \\'10!d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3910075,
                "title": "using-sed-command",
                "content": "# Approach\\nUsing sed\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905152,
                "title": "bash",
                "content": "```bash\\r\\n# sed -n 10p file.txt\\r\\n# awk NR==10 file.txt\\r\\nhead -10 file.txt | tail +10\\r\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```bash\\r\\n# sed -n 10p file.txt\\r\\n# awk NR==10 file.txt\\r\\nhead -10 file.txt | tail +10\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900830,
                "title": "sed",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nsed -n 10p file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3873381,
                "title": "195-tenth-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\ntail -n+10 file.txt | head -n1\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\ntail -n+10 file.txt | head -n1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825104,
                "title": "cheap-sed-solution-its-bash",
                "content": "# Intuition\\nI needed to be able to get inside of the file quicly, and the line is known. In this case, the solution is statically set to pull that specific line vs some dynamic set/piping, etc. One line should work. I would alias this in my shell if this was a usual command I used daily. \\n\\n# Approach\\nThis should be a 1 line answer, and should use a UNIX command in BASH. The stream editor would work as a way to open the file, and the line can be specified as 10, p for print, and -n to echo the specific line. file.txt was assumed to be in the same directory.\\n\\n# Complexity\\n- Time complexity:\\nN/A\\n\\n- Space complexity:\\nN/A\\n\\n# Code\\n```\\nsed -n \\'10p\\' < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nsed -n \\'10p\\' < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806093,
                "title": "easy-2-solution-using-bash-script",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n# awk \\'NR == 10 {print; exit}\\' file.txt\\n\\nsed -n \\'10p; 10q\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n# awk \\'NR == 10 {print; exit}\\' file.txt\\n\\nsed -n \\'10p; 10q\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805470,
                "title": "bash-sed",
                "content": "```\\n#!bin/bash\\n\\ncat file.txt | sed -n \\'10p\\'\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n#!bin/bash\\n\\ncat file.txt | sed -n \\'10p\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3791833,
                "title": "one-line-simple-solution-using-sed-command",
                "content": "thi script uses sed command to print the 10th line of the file and the (-n) is used for suppressthe output and for print the 10th line we used \"10p\" and file.txt is the file name.\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncat file.txt | sed -n 10p\\n```\\n\\nThis command uses the sed command to print the 10th line of the file. The -n option is used to suppress the default output and \\'10p\\' is used to print the 10th line of the file. Replace file.txt with your file name.",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncat file.txt | sed -n 10p\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3785694,
                "title": "another-sed-solution-d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\\\\\nsed \\'10!d\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\\\\\nsed \\'10!d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3750010,
                "title": "10th-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743063,
                "title": "sed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742153,
                "title": "1-line-easy-code",
                "content": "\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742151,
                "title": "1-line-easy-code",
                "content": "\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742150,
                "title": "1-line-easy-code",
                "content": "\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742149,
                "title": "1-line-easy-code",
                "content": "\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742146,
                "title": "1-line-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\r\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\r\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3713367,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nawk \\'NR == 10 { print; exit }\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nawk \\'NR == 10 { print; exit }\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3713025,
                "title": "tenth-line-souvik-hazra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR == 10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR == 10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680864,
                "title": "piping-iterative-solution",
                "content": "# Intuition\\nPipe the content until you get only the desired line\\n\\n# Approach\\n1. Show file contents\\n2. Filter to only get lines after 10th\\n3. Only show the first line of the bunch\\nI would not do this on large inputs, as showing the entire file and filtering does not really make sense, but if you just need something on the command line, it\\'s easy, logical and it works.\\n\\nHave also added a solution using an actual bash function\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncat file.txt | tail -n +10 | head -n 1\\n\\n# If you need this as a function with arguments:\\n#!/bin/bash\\n\\nshow_file_line () {\\n    FILENAME=$1\\n    LINE_NR=$2\\n\\n    NR_OF_LINES=`head -n $LINE_NR $FILENAME | wc -l`\\n\\n    if [ $NR_OF_LINES -ge $LINE_NR ]; then\\n        head -n $LINE_NR $FILENAME | tail -1\\n    fi\\n}\\n\\nshow_file_line \"file.txt\" 10\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncat file.txt | tail -n +10 | head -n 1\\n\\n# If you need this as a function with arguments:\\n#!/bin/bash\\n\\nshow_file_line () {\\n    FILENAME=$1\\n    LINE_NR=$2\\n\\n    NR_OF_LINES=`head -n $LINE_NR $FILENAME | wc -l`\\n\\n    if [ $NR_OF_LINES -ge $LINE_NR ]; then\\n        head -n $LINE_NR $FILENAME | tail -1\\n    fi\\n}\\n\\nshow_file_line \"file.txt\" 10\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3675918,
                "title": "bash",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670873,
                "title": "bash-command-to-print-last-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n#solution 1\\nsed -n \\'10p\\' file.txt\\n\\n#solution 2\\nawk \\'NR == 10\\' file.txt\\n\\n#solution 3\\ntail -n+10 file.txt|head -1",
                "solutionTags": [
                    "Bash"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n#solution 1\\nsed -n \\'10p\\' file.txt\\n\\n#solution 2\\nawk \\'NR == 10\\' file.txt\\n\\n#solution 3\\ntail -n+10 file.txt|head -1",
                "codeTag": "Unknown"
            },
            {
                "id": 3669450,
                "title": "awk",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3664907,
                "title": "solution-with-gawk",
                "content": "# Intuition\\nTo these questions which read and handle the text files or the record files, I am very likely to use the tool GAWK.\\n# Approach\\nUse the getline to explicitly read from the specific file, and use a for loop to calculate the number of lines, and when meet the line 10, output it by the print function.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ngawk \\'BEGIN{i = 0;\\n    while(getline < \"file.txt\")\\n    {\\n        i++;\\n        if(i == 10)\\n            print $0\\n    }\\n    }\\'        \\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ngawk \\'BEGIN{i = 0;\\n    while(getline < \"file.txt\")\\n    {\\n        i++;\\n        if(i == 10)\\n            print $0\\n    }\\n    }\\'        \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3632868,
                "title": "an-easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nnothing to say really, solution was too obvious\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAlternative solution, in case you want to make sure that the file has at least 10 lines and don\\'t want to look at its insides.\\n\\nFILE=\\'file.txt\\'\\n\\nLINE_COUNT=$(wc -l < \"$FILE\")\\n\\nif [ $LINE_COUNT -ge 10 ]; then\\n    sed -n \\'10p\\' \"$FILE\"\\nelse\\n    echo \"The file does not have at least 10 lines.\"\\nfi\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n#!/bin/bash\\n\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n#!/bin/bash\\n\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3623000,
                "title": "solution-with-sed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \\'10q;d\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \\'10q;d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612569,
                "title": "bash-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600696,
                "title": "using-counter-variable-bash-hyder-nabi",
                "content": "\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nfile=\"file.txt\"\\ni=1;\\nwhile read line; do\\n\\tif [ $i == 10 ];\\n\\tthen\\n\\t\\techo $line;\\n    break\\n\\tfi\\n\\ti=$((i+1))\\ndone < $file;\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nfile=\"file.txt\"\\ni=1;\\nwhile read line; do\\n\\tif [ $i == 10 ];\\n\\tthen\\n\\t\\techo $line;\\n    break\\n\\tfi\\n\\ti=$((i+1))\\ndone < $file;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3599093,
                "title": "simple-solution-bash",
                "content": "# Code\\n```\\nsed -n \\'10p\\' < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nsed -n \\'10p\\' < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586970,
                "title": "simple",
                "content": "\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3544103,
                "title": "sed-oneliner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10,10p; 11q\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10,10p; 11q\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505179,
                "title": "bash-while-loop",
                "content": "# Intuition\\nUse a while loop and line counter variable.\\n\\n# Approach\\nInitialise a variable to zero. Iterate over each line in a while loop. Increment the variable on each iteration. If the variable is 10 then echo the current line. If there are less than ten lines then nothing will be echoed.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\ncount=0\\nwhile read line; do\\n    ((count++))\\n    if [ \"$count\" == 10 ]\\n    then\\n        echo $line\\n    fi\\ndone < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncount=0\\nwhile read line; do\\n    ((count++))\\n    if [ \"$count\" == 10 ]\\n    then\\n        echo $line\\n    fi\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490411,
                "title": "intutive-and-practical-solution",
                "content": "# Intuition\\nWe will start with conventional method to reach the 10th line\\n\\n# Approach\\nDo while loop.\\n\\n# Code\\n```Bash\\n# Read from the file file.txt and output the tenth line to stdout.\\ncnt=0\\nwhile read line && [ $cnt -le 10 ]; do\\n  let \\'cnt = cnt + 1\\'\\n  if [ $cnt -eq 10 ]; then\\n    echo $line\\n    exit 0\\n  fi\\ndone < file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```Bash\\n# Read from the file file.txt and output the tenth line to stdout.\\ncnt=0\\nwhile read line && [ $cnt -le 10 ]; do\\n  let \\'cnt = cnt + 1\\'\\n  if [ $cnt -eq 10 ]; then\\n    echo $line\\n    exit 0\\n  fi\\ndone < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489811,
                "title": "print-line-number",
                "content": "Simple command for print line no.\\n\\n\\n---\\n\\n# Code\\n```\\ncat file.txt | sed -n \\'10p\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat file.txt | sed -n \\'10p\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3487540,
                "title": "195-tenth-line-solution-with-detailed-explanation",
                "content": "# Intuition\\n- The awk command is a powerful text processing tool that can read a file line by line and perform various operations on each line.\\n- In this solution, we use awk to print only the 10th line of the file.\\nThe awk command uses a pattern-action structure, where the pattern specifies which lines to operate on, and the action specifies what to do with those lines.\\n\\n# Approach\\n- The awk command is a popular tool for text processing in Unix-like systems, as it is fast and efficient.\\n- By using awk to print only the 10th line of the file, we avoid reading and processing the entire file, which can be inefficient for large files.\\n- The NR==10 pattern matches only the 10th line of the file, regardless of how many lines the file contains.\\n- Overall, this solution is a concise and efficient way to print the 10th line of a file using awk.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(N), where N is the number of lines in the file. The awk command reads the input file line by line and performs pattern matching to identify the 10th line. This process takes linear time, as it reads each line exactly once.\\n\\n- Space complexity:\\nThe space complexity of this solution is O(1), as it uses a constant amount of additional memory. The awk command processes the input file one line at a time, without storing the entire file in memory. Therefore, the space used by the awk command is constant, regardless of the size of the input file.\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nawk \\'NR == 10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nawk \\'NR == 10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464666,
                "title": "unix-printing-the-line-using-sed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nsed -n 10p file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3461864,
                "title": "just-a-one-line-of-code",
                "content": "I would suggest sed like this:\\n\\nsed ```\\'NUMq;d\\'``` file\\nWhere NUM is the number of the line you want to print; so, for example, ```sed \\'239q;d\\'``` file to print the 239th line of file.\\n\\nExplanation:\\n\\n```NUMq``` will quit immediately when the line number is ```NUM```.\\n\\n```d``` will delete the line instead of printing it; this is inhibited on the last line because the ```q``` causes the rest of the script to be skipped when quitting.\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \\'10q;d\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\'NUMq;d\\'```\n```sed \\'239q;d\\'```\n```NUMq```\n```NUM```\n```d```\n```q```\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \\'10q;d\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438299,
                "title": "sed-n-10p-file-txt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n```\\n# Upvote please if you find it helpful! \\uD83E\\uDD1F",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3437419,
                "title": "output-the-tenth-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n\\nsed -n 10p file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n\\nsed -n 10p file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3431456,
                "title": "solution-exiled",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3408345,
                "title": "simple-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406393,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n```\\n1.awk reads the first line of the file.\\n\\n2. NR==10 {print;exit} is an awk expression that checks if the current line number (NR) is equal to 10. If it is, the expression prints the line (print) and exits the awk program (exit).\\n\\n3.If the current line number is not 10, awk reads the next line of the file and repeats step 2.\\n\\n4.awk continues reading and processing lines of the file until it reaches the end of the file.\\n\\nWhen awk finds the 10th line of the file, it prints the line and exits the program. The exit statement ensures that awk stops processing the file after it finds the 10th line, so it doesn\\'t waste time processing the rest of the file unnecessarily.\\n\\nOverall, the command uses awk\\'s pattern matching capabilities to quickly find the 10th line of the file and print it.\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O()$$ -->\\nO(1)\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n#awk NR==\\'10\\' file.txt\\n#sed -n \\'10p\\' file.txt\\n#sed \\'10q;d\\' file.txt\\n#tail -n +10 file.txt | head -n 1\\n\\nawk \\'NR==10 {print;exit}\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n1.awk reads the first line of the file.\\n\\n2. NR==10 {print;exit} is an awk expression that checks if the current line number (NR) is equal to 10. If it is, the expression prints the line (print) and exits the awk program (exit).\\n\\n3.If the current line number is not 10, awk reads the next line of the file and repeats step 2.\\n\\n4.awk continues reading and processing lines of the file until it reaches the end of the file.\\n\\nWhen awk finds the 10th line of the file, it prints the line and exits the program. The exit statement ensures that awk stops processing the file after it finds the 10th line, so it doesn\\'t waste time processing the rest of the file unnecessarily.\\n\\nOverall, the command uses awk\\'s pattern matching capabilities to quickly find the 10th line of the file and print it.\\n```\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\n#awk NR==\\'10\\' file.txt\\n#sed -n \\'10p\\' file.txt\\n#sed \\'10q;d\\' file.txt\\n#tail -n +10 file.txt | head -n 1\\n\\nawk \\'NR==10 {print;exit}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3392568,
                "title": "best-4-solutions",
                "content": "# Solution 1\\n`awk` is damn fast when comes to text progression it beast tools like sed, head and head\\n```\\nawk \\'NR==10\\' file.txt\\n```\\n\\n# Solution 2\\nOne can also think of reading the file with read and then print the line when the counter `c` hits 10\\n```\\nc=0 # conuter\\nwhile read -r line\\ndo\\n  c=$((c+1))\\n  if [[ $c -eq 10 ]]; then\\n    echo $line\\n    exit\\n  fi\\ndone < file.txt\\n```\\n\\n# Solution 3\\n`sed` is great too but not as great as awk\\n```\\nsed -n 10p file.txt\\n```\\n\\n# Solution 4\\nUsing `head` and `tail` is also a possible solution\\n```\\ntail -n +10 file.txt | head -n 1\\n```\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nawk \\'NR==10\\' file.txt\\n```\n```\\nc=0 # conuter\\nwhile read -r line\\ndo\\n  c=$((c+1))\\n  if [[ $c -eq 10 ]]; then\\n    echo $line\\n    exit\\n  fi\\ndone < file.txt\\n```\n```\\nsed -n 10p file.txt\\n```\n```\\ntail -n +10 file.txt | head -n 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3386511,
                "title": "print-the-nth-line-from-a-file",
                "content": "# Intuition\\n**sed** works same as **head** and **tail** but **sed** is good for a large file. **head** and **tail** consume more time on large files.\\n\\n# Approach\\nHere **\"10q;d\"** means **10** is the line number that we want, **10q** will quit immediately when the line number is **10**, **d** will delete the line instead of printing it; this is inhibited on the last line because the **q** causes the rest of the script to be skipped when quitting.\\n\\nMake sure if you are using variable instead of 10 the you need to use double quotes instead of single.\\n\\n# Complexity\\n- Time complexity: **33 ms**\\n\\n- Space complexity: **3.6 MB**\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370727,
                "title": "195-tenth-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to print the 10th line of the given file. If there are fewer than 10 lines, the script should not print anything.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem can be solved using multiple approaches, such as using the sed command, the awk command, or the head and tail commands.\\nUsing the sed command:\\nThe sed command can be used to extract the 10th line from the file. The command sed -n \\'10p\\' file.txt prints the 10th line of the file. If the file contains fewer than 10 lines, the command will not print anything.\\n\\nUsing the awk command:\\nThe awk command can also be used to extract the 10th line from the file. The command awk \\'NR==10\\' file.txt prints the 10th line of the file. If the file contains fewer than 10 lines, the command will not print anything.\\n\\nUsing the head and tail commands:\\nThe head and tail commands can be used to extract the 10th line from the file. The command head -n 10 file.txt | tail -n +10 prints the 10th line of the file. If the file contains fewer than 10 lines, the command will not print anything.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAll three approaches have a time complexity of O(n), where n is the number of lines in the file.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAll three approaches have a space complexity of O(1), as they only require a constant amount of memory to store the commands and output.\\n\\n# Code\\nSolution 1:\\n\\nWe can use the sed command to print the 10th line of the file. The command for this is sed -n 10p file.txt. The -n option is used to suppress the default output, and 10p prints only the 10th line of the file.\\n\\nIf the file contains less than 10 lines, this command will not output anything.\\n\\nTime complexity: O(1) as we are just printing one line.\\nSpace complexity: O(1) as we are not using any extra space.\\n\\nSolution 2:\\n\\nWe can use the head command to print the first 10 lines of the file, and then use tail to print only the last line of that output. The command for this is head -10 file.txt | tail -1.\\n\\nIf the file contains less than 10 lines, this command will not output anything.\\n\\nTime complexity: O(n) as we are reading the first 10 lines of the file.\\nSpace complexity: O(1) as we are not using any extra space.\\n\\nSolution 3:\\n\\nWe can use a loop to read the file line by line, and keep a counter to keep track of the line number. When the counter reaches 10, we print that line and exit the loop. The command for this is:\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncounter=0\\nwhile read line && [ $counter -le 9 ]\\ndo\\n    counter=$((counter+1))\\n    if [ $counter -eq 10 ]\\n    then\\n        echo $line\\n        break\\n    fi\\ndone < file.txt\\n\\n```\\nIf the file contains less than 10 lines, this command will not output anything.\\n\\nTime complexity: O(n) as we are reading the file line by line.\\nSpace complexity: O(1) as we are not using any extra space.\\n\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\ncounter=0\\nwhile read line && [ $counter -le 9 ]\\ndo\\n    counter=$((counter+1))\\n    if [ $counter -eq 10 ]\\n    then\\n        echo $line\\n        break\\n    fi\\ndone < file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368168,
                "title": "solution-using-awk",
                "content": "# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nawk \\'NR==10\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3349059,
                "title": "1-liner-solution-with-awk",
                "content": "\\n\\'\\'\\'\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n```\\n\\n awk \\'NR==10 {print $0}\\' file.txt",
                "solutionTags": [
                    "Bash"
                ],
                "code": "\\n\\'\\'\\'\\n# Read from the file file.txt and output the tenth line to stdout.\\n\\n```\\n\\n awk \\'NR==10 {print $0}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 3344472,
                "title": "simple-solution-using-bash-sed-command",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337981,
                "title": "tenth-line-bash-solution-1-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n 10p file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n 10p file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3330966,
                "title": "read-10th-line-of-text-from-a-file",
                "content": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n#!/bin/bash\\n\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\n#!/bin/bash\\n\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3323503,
                "title": "chatgpt-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed -n \\'10p\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3279180,
                "title": "tenth-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nsed \"10q;d\" file.txt\\n```",
                "solutionTags": [
                    "Java",
                    "Bash"
                ],
                "code": "```\\nsed \"10q;d\" file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3173975,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and output the tenth line to stdout.\\nsed \"10q;d\" file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3167519,
                "title": "one-liner-with-cat-tr-and-cut",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\ncat file.txt\\n```\\nThis reads the file to stdout. \\n\\n```\\ntr -st \\'\\\\n\\' \\'^\\'\\n```\\nCombines different lines with the delimeter \\'^\\' (that does not occur in any string)\\n\\n```\\ncut -d \\'^\\' -f 10\\n```\\nThis \"cuts\" the string with delimeter \\'^\\' and prints the 10th field.\\n\\nThe final command is a combination of the above three commands  connected with pipes:\\n\\n# Code\\n```\\ncat file.txt | tr -st \\'\\\\n\\' \\'^\\' | cut -d \\'^\\' -f 10\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat file.txt\\n```\n```\\ntr -st \\'\\\\n\\' \\'^\\'\\n```\n```\\ncut -d \\'^\\' -f 10\\n```\n```\\ncat file.txt | tr -st \\'\\\\n\\' \\'^\\' | cut -d \\'^\\' -f 10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3165005,
                "title": "print-a-specific-line-from-a-file",
                "content": "# Approach\\nThis code prints the line of a file specified by the line_number variable. The command awk is used to search through the file specified by file_name and print the line that corresponds to the line_number variable.\\n#Code_Source: Grepper\\n\\n# Complexity\\n- Time complexity:\\n\\n    O(1)\\n\\n- Space complexity:\\nO(1) - This code has a constant time complexity as it only requires one pass through the file\\n\\n# Code\\n```\\nawk \\'{if(NR==10) print $0}\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nawk \\'{if(NR==10) print $0}\\' file.txt\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565037,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1565665,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1566370,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1565527,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1570679,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568457,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568193,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1567384,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568618,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568520,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1565037,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1565665,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1566370,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1565527,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1570679,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568457,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568193,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1567384,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568618,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1568520,
                "content": [
                    {
                        "username": "andyhansmall1001",
                        "content": "    awk 'NR == 10' file.txt\\n\\nNR: the current row number (start from 1).\\nBecause the default action of awk is {print $0}, we can ignore the action."
                    },
                    {
                        "username": "chammika",
                        "content": "Extract NLINES lines from STARTING line\\n\\n    STARTING=10; NLINES=1; cat file.txt | tail -n+${STARTING} | head -n${NLINES}"
                    },
                    {
                        "username": "bhargavsnv100",
                        "content": "\\n`tail file.txt -n +10 | head -n1`\\n\\nThat\\'s about it! `tail -n +10` takes lines from 10th onwards, so we take the first line of that `using head -n1`."
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    awk '{if(NR==10) print $0}' file.txt\\n\\nIf the record number (NR) is 10, print the entire record $0.\\nNR in AWK by default is any single line (en of record delimiter is \\\\n).\\nRecords start numbering from 1."
                    },
                    {
                        "username": "i_am_sai",
                        "content": "head -n 10 file.txt | tail -n +10\\n\\nhead -n 10 -> prints the first 10 lines\\ntail -n +10  -> prints from the 10th line\\n\\nAdding | makes the tail command to print from 10th line itself."
                    },
                    {
                        "username": "leunggexxxx",
                        "content": "`sed -n \\'10 p\\' file.txt`\\n\\n-n: slient output, which means sed will not output the file content\\n10: the tenth line\\np: print\\n"
                    },
                    {
                        "username": "vunnapr",
                        "content": "#This is the easiest way to get the 10th line or any line less than 10 is present\\n\\nhead file.txt | tail -1"
                    },
                    {
                        "username": "steven-bohao",
                        "content": "awk \\'{if (NR==10) print $0}\\' file.txt\\n\\nsed -n \\'10p\\' file.txt\\n\\nc=`cat file.txt | wc -l`\\nif [[ $c -gt 9 ]];then\\n    head -10 file.txt | tail -1\\nfi"
                    },
                    {
                        "username": "_shikha",
                        "content": "Using awk\\n\\t`cat file.txt | awk \\'{if (NR==10) print$0}\\'`\\n\\t\\nUsing sed\\n     `cat file.txt | sed -n \\'10p\\'`\\n\\n"
                    },
                    {
                        "username": "Nagaraju6242",
                        "content": "sed -n \\'10p\\' < file.txt"
                    }
                ]
            },
            {
                "id": 1567912,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1570440,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1570034,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1570011,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1569015,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1892861,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1576126,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1576064,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1576047,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1574756,
                "content": [
                    {
                        "username": "MonsieurWilson",
                        "content": "Since there already have solutions based on `awk` or `sed` or `head | tail`, here is a unique soluton.\\n\\n    IFS=$'\\\\n' ;arr=($(<file.txt)); echo ${arr[9]}"
                    },
                    {
                        "username": "pankajgupta20",
                        "content": "##### awk solution\\n\\tawk \\'NR==10\\' file.txt\\n##### sed solution\\n\\tsed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "jtsa0267",
                        "content": "![image](https://assets.leetcode.com/users/images/49a84700-0198-469f-b60f-5ebff9b85e4b_1593762455.829133.png)\\n"
                    },
                    {
                        "username": "azhar24u",
                        "content": "sed -n 10p file.txt"
                    },
                    {
                        "username": "iziang",
                        "content": "Only one line in awk\\n    \\n    awk 'NR == 10' file.txt"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "\"\\nNote:\\n1. If the file contains less than 10 lines, what should you output?\\n\"\\n\\nWhy would I know, shouldn\\'t it be included in problem description?"
                    },
                    {
                        "username": "crazydar",
                        "content": "Exactly what I was thinking. This is ridiculous - an exercise in mind reading..."
                    },
                    {
                        "username": "powernoob",
                        "content": "sed -n \\'10p\\' file.txt"
                    },
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "apgokul",
                        "content": "The sed command below will retrieve the 10th line from the file `file.txt`\\n\\n#### solution :\\n\\n`sed \\'10q;d\\' file`"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "`awk \\'NR == 10\\' file.txt`"
                    }
                ]
            },
            {
                "id": 1574416,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1573754,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1573451,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1573408,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1572640,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1572408,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1572270,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1575820,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 1574716,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            },
            {
                "id": 2056576,
                "content": [
                    {
                        "username": "rajattandonmit",
                        "content": "awk \\'NR==10\\' file.txt"
                    },
                    {
                        "username": "somayyah_mohd",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "user3154L",
                        "content": "`awk \\'NR==10\\' file.txt`"
                    },
                    {
                        "username": "echobash",
                        "content": "cat file.txt | awk \\'{if(NR==10)print} \\'"
                    },
                    {
                        "username": "zhoucego",
                        "content": "awk \\'NR == 10\\' file.txt\\n\\n\\n"
                    },
                    {
                        "username": "chinmay93",
                        "content": "sed \\'10q;d\\' file.txt"
                    },
                    {
                        "username": "variable_infiltration",
                        "content": "`if [ $(wc -l file.txt | awk \\'{print $1}\\') -gt 9 ]; then cat file.txt | head -n10 | tail -1; fi`"
                    },
                    {
                        "username": "hazem1911",
                        "content": "`cat file.txt | cut -d$\\'\\\\n\\' -f10`"
                    },
                    {
                        "username": "Motherbrain",
                        "content": "sed -n \\'10p\\' < file.txt"
                    },
                    {
                        "username": "RetroCoder80s",
                        "content": "This problem is tagged as \"bash\" so it should be possible to use ANY command line tool that works in bash like \"bat\" - i.e: bat -r 10:10 file.txt !"
                    }
                ]
            }
        ]
    }
]