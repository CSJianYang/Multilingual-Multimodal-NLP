[
    {
        "title": "Sum of Subsequence Widths",
        "question_content": "The width of a sequence is the difference between the maximum and minimum elements in the sequence.\nGiven an array of integers nums, return the sum of the widths of all the non-empty subsequences of nums. Since the answer may be very large, return it modulo 109 + 7.\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n&nbsp;\nExample 1:\n\nInput: nums = [2,1,3]\nOutput: 6\nExplanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].\nThe corresponding widths are 0, 0, 0, 1, 1, 2, 2.\nThe sum of these widths is 6.\n\nExample 2:\n\nInput: nums = [2]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 161267,
                "title": "java-c-python-sort-and-one-pass",
                "content": "# **Explanation**\\nThe order in initial arrays doesn\\'t matter,\\nmy first intuition is to sort the array.\\n\\nFor each number `A[i]`:\\n\\n1. There are `i` smaller numbers,\\nso there are `2 ^ i` sequences in which `A[i]` is maximum.\\nwe should do `res += A[i] * 2^i`\\n\\n2. There are `n - i - 1` bigger numbers,\\nso there are `2 ^ (n - i - 1)` sequences in which `A[i]` is minimum.\\nwe should do `res -= A[i] * 2^(n - i - 1)`\\n\\nDone.\\n<br>\\n\\n# **Time Complexity**:\\nTime `O(NlogN)`\\nSpace `O(1)`\\n<br>\\n\\n\\n# **FAQ**\\n**Q. why do we plus mod before return?**\\n**A** In Cpp and Java, mod on negative number will still get a negative number.\\n<br>\\n\\n**Java:**\\n```java\\n    public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        long c = 1, res = 0, mod = (long)1e9 + 7;\\n        for (int i = 0, n = A.length; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (int)((res + mod) % mod);\\n    }\\n```\\n**C++:**\\n```cpp\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n```\\n**1-line Python:**\\n```py\\n    def sumSubseqWidths(self, A):\\n        return sum(((1 << i) - (1 << len(A) - i - 1)) * a for i, a in enumerate(sorted(A))) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        long c = 1, res = 0, mod = (long)1e9 + 7;\\n        for (int i = 0, n = A.length; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (int)((res + mod) % mod);\\n    }\\n```\n```cpp\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n```\n```py\\n    def sumSubseqWidths(self, A):\\n        return sum(((1 << i) - (1 << len(A) - i - 1)) * a for i, a in enumerate(sorted(A))) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161263,
                "title": "c-solution-o-n-log-n-sort-o-n-calculate",
                "content": "We only care about the subsequences and max/min values, so the order of the elements does not matter. Therefore, we sort the array at first.\\n\\nFor a sorted subarray A=[p,......,q], there are 2^(len(A)-2) subsequences which has min value=p, and max value=q. Because we can choose any numbers between p and q, there are 2^(len(A)-2) ways to choose.\\n\\nFor example, a given array is `[0,1,3,4,7]`.\\nFor the subarray `[1,3,4,7]`, there are 2^2 subsequences which has min value=1 and max value=7.\\n\\nThen we got an O(N^2) solution:\\nthe answer is `sum((max(Ai)-min(Ai))\\xD72^(len(Ai)-2))`, for all subarrays `Ai` where `len(Ai) > 1`.  \\nFor the example above, it is:\\n\\n```\\n1*2^0+3*2^1+4*2^2+7*2^3       // = x0\\n     +2*2^0+3*2^1+6*2^2       // = x1\\n           +1*2^0+4*2^1       // = x2\\n                 +3*2^0       // = x3\\n```\\n\\n***\\nOf course the efficiency is not enough. Observe the table above\\u2191, we can find that\\n\\n```\\nx0-1*(2^0+2^1+2^2+2^3)=x1*2\\nx1-2*(2^0+2^1+2^2)=x2*2\\nx2-1*(2^0+2^1)=x3*2\\nx3-3*(2^0)=0\\n```\\n\\nwe can then calculate x3, x2, x1, x0 one by one: \\n\\n```\\nx4=0;\\nx3=x4*2 + (A4-A3)*(2^0)\\nx2=x3*2 + (A3-A2)*(2^0+2^1)\\nx1=x2*2 + (A2-A1)*(2^0+2^1+2^2)\\nx0=x1*2 + (A1-A0)*(2^0+2^1+2^2+2^3)\\n\\nresult=x4+x3+x2+x1+x0\\n```\\n\\nHere is my code:\\n\\n```cpp\\n#define M 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        vector<ll> diff;\\n        for (int i = 0; i < A.size() - 1; i++) diff.push_back(A[i + 1] - A[i]);\\n        ll result = 0;\\n        ll x = 0;\\n        ll sum2 = 1;\\n        int len = diff.size();\\n        reverse(diff.begin(), diff.end());\\n        for (int i = 0; i < len; i++) {\\n            x <<= 1;\\n            x += sum2 * diff[i];\\n            x %= M;\\n            sum2 <<= 1;\\n            sum2++;\\n            sum2 %= M;\\n            result += x;\\n            result %= M;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1*2^0+3*2^1+4*2^2+7*2^3       // = x0\\n     +2*2^0+3*2^1+6*2^2       // = x1\\n           +1*2^0+4*2^1       // = x2\\n                 +3*2^0       // = x3\\n```\n```\\nx0-1*(2^0+2^1+2^2+2^3)=x1*2\\nx1-2*(2^0+2^1+2^2)=x2*2\\nx2-1*(2^0+2^1)=x3*2\\nx3-3*(2^0)=0\\n```\n```\\nx4=0;\\nx3=x4*2 + (A4-A3)*(2^0)\\nx2=x3*2 + (A3-A2)*(2^0+2^1)\\nx1=x2*2 + (A2-A1)*(2^0+2^1+2^2)\\nx0=x1*2 + (A1-A0)*(2^0+2^1+2^2+2^3)\\n\\nresult=x4+x3+x2+x1+x0\\n```\n```cpp\\n#define M 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        vector<ll> diff;\\n        for (int i = 0; i < A.size() - 1; i++) diff.push_back(A[i + 1] - A[i]);\\n        ll result = 0;\\n        ll x = 0;\\n        ll sum2 = 1;\\n        int len = diff.size();\\n        reverse(diff.begin(), diff.end());\\n        for (int i = 0; i < len; i++) {\\n            x <<= 1;\\n            x += sum2 * diff[i];\\n            x %= M;\\n            sum2 <<= 1;\\n            sum2++;\\n            sum2 %= M;\\n            result += x;\\n            result %= M;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456511,
                "title": "c-o-nlogn-approach-sum-of-subsequence-widths",
                "content": "**Logic -**\\n**Observations 1**: Order doesn\\'t matter \\n**Observations 2**: Every numbers contribute based on its index in the sorted array.\\n\\n**Mathematical Derivations -**\\nConsider that there are total (n) number in a sorted array, then (i) numbers will be <= nums[i] and (n-i-1) numbers will be >= A[i]\\n\\nA[i] will be upper bound of (2^i) subsequences         <-------- when A[i] as maxm value\\nA[i] will be lower bound of (2^(n-i-1)) subsequences <-------- when A[i] as minm value\\n\\n```\\nso, contribution of A[i] = upper - lower = A[i]*(2^i) - A[i]*(2^(n-i-1))\\n                                          \\nAns  = Sum{A[i]* 2^i - A[i] * 2^(n-i-1)}  , for 0 <= i < n \\n     = (A[0]*2^0 - A[0]*2^(n-1) + (A[1]*2^1 - A[1]*2^(n-2) + ... \\n       + (A[i]*2^i - A[i]*2^(n-i-1) + ...  + (A[n-i-1]*2^(n-i-1) - A[n-i-1]*2^i + ... + (A[n-1] * 2^(n-1) - A[n-1]*2^0)\\n        \\n\\t\\t//some of the terms in above expression will cancel each other,\\n\\t\\t\\nAns = Sum{A[i] * 2^i - A[n-i-1]* 2^i} ..........on taking 2^(i) common, the sum can be re-written as \\n     =Sum{ (A[i] - A[n-i-1]) * 2^(i)  }\\n\\n```\\n\\n**Now,**\\n**Step 1 :** Sort the array first,\\n**Step 2 :** Once array is sorted, Calculate the result by summation of above derived results.\\n\\n```\\nint sumSubseqWidths(vector<int>& nums) {\\n\\n    int n = nums.size();\\n    int ans = 0; \\n\\n    // sort the array\\n    sort(nums.begin(),nums.end());                        // O(nlogn)\\n\\n    // create the vector to store power terms\\n    vector<long> exp(n, 0);\\n    exp[0] = 1;\\n\\n    // Pre-Calculate the value of exp for each (i) so need not to do again. \\n\\t// Note- Divide by mod to keep the answer in range. \\n    for (int i = 1; i < n; i++) {\\n        exp[i] = exp[i - 1] * 2 % mod;\\n    }\\n\\n    // Iterate the array and calculate the sum using above mathematical expression\\n    for(int i=0;i<n;i++){\\n        ans = ( ans + exp[i]*(nums[i] - nums[n-i-1])) %mod;\\n    }    \\n    return ans; \\n}\\n\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nso, contribution of A[i] = upper - lower = A[i]*(2^i) - A[i]*(2^(n-i-1))\\n                                          \\nAns  = Sum{A[i]* 2^i - A[i] * 2^(n-i-1)}  , for 0 <= i < n \\n     = (A[0]*2^0 - A[0]*2^(n-1) + (A[1]*2^1 - A[1]*2^(n-2) + ... \\n       + (A[i]*2^i - A[i]*2^(n-i-1) + ...  + (A[n-i-1]*2^(n-i-1) - A[n-i-1]*2^i + ... + (A[n-1] * 2^(n-1) - A[n-1]*2^0)\\n        \\n\\t\\t//some of the terms in above expression will cancel each other,\\n\\t\\t\\nAns = Sum{A[i] * 2^i - A[n-i-1]* 2^i} ..........on taking 2^(i) common, the sum can be re-written as \\n     =Sum{ (A[i] - A[n-i-1]) * 2^(i)  }\\n\\n```\n```\\nint sumSubseqWidths(vector<int>& nums) {\\n\\n    int n = nums.size();\\n    int ans = 0; \\n\\n    // sort the array\\n    sort(nums.begin(),nums.end());                        // O(nlogn)\\n\\n    // create the vector to store power terms\\n    vector<long> exp(n, 0);\\n    exp[0] = 1;\\n\\n    // Pre-Calculate the value of exp for each (i) so need not to do again. \\n\\t// Note- Divide by mod to keep the answer in range. \\n    for (int i = 1; i < n; i++) {\\n        exp[i] = exp[i - 1] * 2 % mod;\\n    }\\n\\n    // Iterate the array and calculate the sum using above mathematical expression\\n    for(int i=0;i<n;i++){\\n        ans = ( ans + exp[i]*(nums[i] - nums[n-i-1])) %mod;\\n    }    \\n    return ans; \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2361648,
                "title": "c-sum-of-subsequence-widths",
                "content": "After solving this ques, go for this ques https://www.codechef.com/problems/DECOSUB \\n\\nThe approach to the solution can be started by observing max and min(max-min) value of all subsequence and then go for simple maths as shown below:\\n\\n![image](https://assets.leetcode.com/users/images/237be303-4f7e-4146-8a64-a6d2c7c504d2_1659301276.4129994.jpeg)\\n\\nHere is my code for the approach.....\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& a) {\\n        \\n        int n=a.size(),i,j=n-1;\\n        \\n        sort(a.begin(),a.end());\\n        \\n        long long int p=1;\\n        \\n        long long int ans=0;\\n        \\n        long long int mod=1000000007;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            ans=(ans+p*a[i]-p*a[j])%mod;\\n            \\n            p=(p*2)%mod;\\n            \\n            j--;\\n        }\\n        return (int)ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& a) {\\n        \\n        int n=a.size(),i,j=n-1;\\n        \\n        sort(a.begin(),a.end());\\n        \\n        long long int p=1;\\n        \\n        long long int ans=0;\\n        \\n        long long int mod=1000000007;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            ans=(ans+p*a[i]-p*a[j])%mod;\\n            \\n            p=(p*2)%mod;\\n            \\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 162318,
                "title": "o-nlogn-solution",
                "content": "Sort the array cost <code>O(nlogn)</code>;\\nThe number of subset that fixed <code>A[i]</code> as minimum element and <code>A[j]</code> as maximum element (<code>i<j</code>) is <code>2^{j-i-1}</code>:\\n\\n1. when <code>j-i=1</code>, we can get <code>T_{1}=(A[2]-A[1])*2^{0} + (A[3]-A[2])*2^{0} + ...+(A[n]-A[n-1])*2^{0} = (A[n]-A[1])*2^{0}</code>\\n2. when <code>j-i=2</code>, we can get <code>T_{2}=(A[3]-A[1])*2^{1} + (A[4]-A[2])*2^{1} + ...+(A[n]-A[n-2])*2^{1} = (A[n]+A[n-1]-A[2]-A[1])*2^{1}</code>\\n3. when <code>j-i=3</code>, we can get <code>T_{3}=(A[4]-A[1])*2^{2} + (A[5]-A[2])*2^{2} + ...+(A[n]-A[n-3])*2^{2} = (A[n]+A[n-1]+A[n-2]-A[3]-A[2]-A[1])*2^{2}</code>\\n4. when <code>j-i=k</code>, we can get <code>T_{k}=(sum[n-k+1][n] - sum[1][k])*2^{k-1}</code>\\n5. Finally, <code>ans=T_{1}+T_{2}+...+T_{k}</code>\\n\\nIn my code, <code>lsum</code> referred to <code>sum[1][k]</code>, <code>rsum</code> referred to <code>sum[n-k+1][n]</code>, and <code>d</code> referred to <code>2^{k-1}</code>\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int l = 0, r = A.size()-1;\\n        int lsum = 0, rsum = 0;\\n        long long d = 1, ans = 0, mod = 1000000007;\\n        while(l < A.size()){\\n            lsum += A[l++];\\n            rsum += A[r--];\\n            ans += (rsum-lsum)*d;\\n            ans %= mod;\\n            d = d * 2 % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int l = 0, r = A.size()-1;\\n        int lsum = 0, rsum = 0;\\n        long long d = 1, ans = 0, mod = 1000000007;\\n        while(l < A.size()){\\n            lsum += A[l++];\\n            rsum += A[r--];\\n            ans += (rsum-lsum)*d;\\n            ans %= mod;\\n            d = d * 2 % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161327,
                "title": "leetcode-weekly-contest-98-screencast",
                "content": "https://www.youtube.com/watch?v=KpPDMI02LVQ\\n\\nDid a really bad job this time. One out-of-boundary issue bite me and I was thinking there must be some LC bug all the time until I stopped screencast.",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=KpPDMI02LVQ\\n\\nDid a really bad job this time. One out-of-boundary issue bite me and I was thinking there must be some LC bug all the time until I stopped screencast.",
                "codeTag": "Unknown"
            },
            {
                "id": 881805,
                "title": "c-simple-sol-with-comments-beats-88",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        long power = 1, res = 0, mod = 1e9+7,n = arr.size();\\n        \\n        //adding maximums\\n        //number of times this item will be maximum\\n        for(int i=0;i<n;i++){\\n            res = (res + arr[i]*power)%mod;\\n            power = (power*2)%mod;\\n        }\\n        \\n        //subtracting minimums\\n        //number of times this item will be minimum\\n        power = 1;\\n        for(int i=n-1;i>=0;i--){\\n            res = (res - arr[i]*power +mod)%mod;\\n            power = (power*2)%mod;\\n        }\\n        return (res+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        long power = 1, res = 0, mod = 1e9+7,n = arr.size();\\n        \\n        //adding maximums\\n        //number of times this item will be maximum\\n        for(int i=0;i<n;i++){\\n            res = (res + arr[i]*power)%mod;\\n            power = (power*2)%mod;\\n        }\\n        \\n        //subtracting minimums\\n        //number of times this item will be minimum\\n        power = 1;\\n        for(int i=n-1;i>=0;i--){\\n            res = (res - arr[i]*power +mod)%mod;\\n            power = (power*2)%mod;\\n        }\\n        return (res+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161318,
                "title": "pythonic-o-nlogn-sorting",
                "content": "First, the brute force solution is to check every index `(i, j)` pair. The total number of of subsequence with `i` the smallest and `j` the largest value is `2^(j-i-1)`. Time complexity is `O(n^2)`, which gets TLE.\\n```\\nclass Solution(object):\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res=0\\n        A.sort()\\n        for i in range(len(A)):\\n            for j in range(i+1, len(A)):\\n                res+=2**(j-i-1)*(A[j]-A[i])\\n                res%=10**9+7\\n        return res\\n```\\nThen to optimize, we find that for the same difference of index `i`, `j` (say `k=j-i`), their sum would be:\\n`2^(k-1)*(A[k]-A[0]+A[k+1]-A[1]+A[k+2]-A[2]+....+A[len(A)-1]-A[len(A)-1-k])=2^(k-1)*(sum of last k numbers in A - sum of first k numbers in A)`\\nWe can use a `preSum` and a `postSum` array to calculate the difference above. Building both arrays take O(n), final counting part is also O(n), sorting is O(nlogn), total would be O(nlogn).\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        l=len(A)\\n        preSum, postSum=[A[0]]*l, [A[-1]]*l\\n        for i in range(1, l):\\n            preSum[i]=preSum[i-1]+A[i]\\n            postSum[i]=postSum[i-1]+A[l-1-i]\\n        s=0\\n        for i in range(len(A)-1):\\n            s+=(1<<i)*(postSum[i]-preSum[i])\\n            s%=10**9+7\\n        return s\\n```\\nA more pythonic solution to add to the result only one pass:\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        res=0\\n        for i in range(len(A)):\\n            res*=2\\n            res-=A[i]\\n            res+=A[~i]\\n            res%=10**9+7\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res=0\\n        A.sort()\\n        for i in range(len(A)):\\n            for j in range(i+1, len(A)):\\n                res+=2**(j-i-1)*(A[j]-A[i])\\n                res%=10**9+7\\n        return res\\n```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        l=len(A)\\n        preSum, postSum=[A[0]]*l, [A[-1]]*l\\n        for i in range(1, l):\\n            preSum[i]=preSum[i-1]+A[i]\\n            postSum[i]=postSum[i-1]+A[l-1-i]\\n        s=0\\n        for i in range(len(A)-1):\\n            s+=(1<<i)*(postSum[i]-preSum[i])\\n            s%=10**9+7\\n        return s\\n```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        res=0\\n        for i in range(len(A)):\\n            res*=2\\n            res-=A[i]\\n            res+=A[~i]\\n            res%=10**9+7\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768402,
                "title": "python3-sort-and-1-pass-derived-from-dp-solution",
                "content": "I\\'m pretty happy to have found the solution to that one alone, so I would like to share here my line of thinking.\\n\\nFirst things first, we notice that we can sort the array without changing the problem, as the order of values in sub-sequences do not have importance.\\n\\nLet us suppose we have a sorted array. For example, `[1, 2, 2, 3, 4, 5, 5, 6, 9]`. What information do we need to find the answer while iterating over the array? For example, let us suppose we are considering the `4`, what information from `[1, 2, 2, 3]` do we need to find the answer for the array up to `4`?\\n\\nWe notice that the difference between min and max in that case is the difference between `4` and the first element of all previous sub-sequences. Therefore, to sum the differences for all subsequences, we must have the count of all subsequences in `[1, 2, 2, 3]` starting with any of its values.\\n\\nOnce we have that, we can:\\n* Update the total value by adding `(4 - value) * count` for each `value, count` pair existing,\\n* Update our table of counts by multiplying each existing value by `2` (each previous sub-sequence is split in two, one without and one with `4` appended), as well as adding one more for `4`, for the sub-sequence `[4]`.\\n\\nThis gives us the following code:\\n\\n```python\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        ans = 0\\n        dp = defaultdict(int)\\n        for right in A:\\n            for left, cnt in dp.items():\\n                ans = (ans + (right - left) * cnt) % self.BASE\\n                dp[left] = (cnt * 2) % self.BASE\\n            dp[right] += 1\\n        return ans\\n```\\n\\nThe problem is, although correct, this code is in `O(n^2)`, which is too slow. The main issue is the second loop inside, iterating over `dp`. Now, is it possible to write this loop as a single iteration?\\n\\nIf we rewrite our expression, we notice that it is equivalent to:\\n\\n```\\nans += sum(right * cnt_i) - sum(left_i * cnt_i) = right * sum(cnt_i) - sum(left_i * cnt_i)\\n```\\n\\nAs we multiply each `cnt_i` by 2 in the loop, and add `1` for `right` at the end of the loop, we can rewrite these expressions as standalone variables. I name `total_cnt = sum(cnt_i)` and `total_prod = sum(left_i * cnt_i)`.\\n\\n```\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        total_cnt = 0\\n        total_prod = 0\\n        ans = 0\\n        for num in A:\\n            ans = (ans + total_cnt * num - total_prod) % self.BASE\\n            total_cnt = (2 * total_cnt + 1) % self.BASE\\n            total_prod = (2 * total_prod + num) % self.BASE\\n        return ans\\n```\\n\\nThis solution is in `O(n log(n))` and `O(1)` space, and passes without TLE.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        ans = 0\\n        dp = defaultdict(int)\\n        for right in A:\\n            for left, cnt in dp.items():\\n                ans = (ans + (right - left) * cnt) % self.BASE\\n                dp[left] = (cnt * 2) % self.BASE\\n            dp[right] += 1\\n        return ans\\n```\n```\\nans += sum(right * cnt_i) - sum(left_i * cnt_i) = right * sum(cnt_i) - sum(left_i * cnt_i)\\n```\n```\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        total_cnt = 0\\n        total_prod = 0\\n        ans = 0\\n        for num in A:\\n            ans = (ans + total_cnt * num - total_prod) % self.BASE\\n            total_cnt = (2 * total_cnt + 1) % self.BASE\\n            total_prod = (2 * total_prod + num) % self.BASE\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708434,
                "title": "easy-explanation-with-example-java-o-nlogn",
                "content": "Let\\'s say,\\nThis is our array:\\n[3,1,2,4]\\n\\nSubsequences:\\n\\n\\t\\t\\t\\tmax - min\\n\\t3\\t\\t\\t3-3 = 0\\n\\t1\\t\\t\\t1-1 = 0\\n\\t2\\t\\t\\t2-2 = 0\\n\\t4\\t\\t\\t4-4 = 0\\n\\t3,1\\t\\t\\t3-1 = 2\\n\\t3,2\\t\\t\\t3-2 = 1\\n\\t3,4\\t\\t\\t4-3 = 1\\n\\t1,2\\t\\t\\t2-1 = 1\\n\\t1,4\\t\\t\\t4-1 = 3\\n\\t2,4\\t\\t\\t4-2 = 2\\n\\t3,1,2\\t\\t3-1 = 2\\n\\t3,1,4\\t\\t4-1 = 3\\n\\t3,2,4\\t\\t4-2 = 2\\n\\t1,2,4\\t\\t4-1 = 3\\n\\t3,1,2,4\\t\\t4-1 = 3\\n\\nanswer = 0+0+0+0+2+1+1+1+3+2+2+3+2+3+3 = 23 **-------------------- reference (1)**\\n\\nLet us calculate the total number of occurrences of maximum and minimum elements from these subsequence .\\n\\nMaximum side occurrences: **-------------------- reference (2)**\\n\\'3\\' occurred 4 times\\n\\'1\\' occurred 1 times\\n\\'2\\' occurred 2 times\\n\\'4\\' occurred 8 times\\n\\nMinimum side occurrences:  **-------------------- reference (3)**\\n\\'3\\' occurred 2 times\\n\\'1\\' occurred 8 times\\n\\'2\\' occurred 4 times\\n\\'4\\' occurred 1 times\\n\\nultimately the effective frequencies of elements would be:\\n\\'4\\' occurred 8-1 = 7 times\\n\\'3\\' occurred 4-2 = 2 times\\n\\'2\\' occurred 2-4 = -2 times\\n\\'1\\' occurred 1-8 = -7 times\\n\\nanswer would be:\\n(7 * 4) + (2 * 3) + (-2 * 2) + (-7 * 1) = 28+6-4-7 = 23\\nsame answer right? (**reference (1)**)\\n\\nNow let us get a detailed view of the maximum side occurrences of **4**:\\n\\n\\t4\\t\\t\\t4-4 = 0\\n\\t3,4\\t\\t\\t4-3 = 1\\n\\t1,4\\t\\t\\t4-1 = 3\\n\\t2,4\\t\\t\\t4-2 = 2\\n\\t3,1,4\\t\\t4-1 = 3\\n\\t3,2,4\\t\\t4-2 = 2\\n\\t1,2,4\\t\\t4-1 = 3\\n\\t3,1,2,4\\t\\t4-1 = 3\\n\\nsubsequence  with \\nlength 4 occurred 1 times\\nlength 3 occurred 3 times\\nlength 2 occurred 3 times\\nlength 1 occurred 1 times\\n\\nLet us sort the array in ascending order,\\n[1,2,3,4]\\n\\nSo, to generate subsequence with length 4 we need to include 3 elements from the remaining 3 elements = 3C3 \\t= 1\\nto generate subsequence with length 3 we need to include 2 elements from the remaining 3 elements = 3C2\\t\\t= 3\\nto generate subsequence with length 2 we need to include 1 elements from the remaining 3 elements = 3C1\\t\\t= 3\\nto generate subsequence with length 1 we need to include 0 elements from the remaining 3 elements = 3C0\\t\\t= 1\\n\\nSo, total occurrence of 4:\\n3C3 + 3C2 + 3C1 + 3C0 = 2^3 = 8 (nC0 + nC1 + nC2 + ... + nCn = 2^n)\\n\\nSimilarly, for the whole array,\\n[1,2,3,4]\\n\\n4 -> 2^3 = 8\\n3 -> 2^2 = 4\\n2 -> 2^1 = 2\\n1 -> 2^0 = 1\\nBasically 2 to the power of remaining elements those are lesser than the current element.\\n\\nSimilarly to get the occurrences of minimum side:\\n[1,2,3,4]\\n\\n1 -> 2^3 = 8\\n2 -> 2^2 = 4\\n3 -> 2^1 = 2\\n4 -> 2^0 = 1\\n\\nTo get the effective frequencies we need to subtract the minimum side occurrence of each element from its maximum side occurrence.\\nThe answer would be:\\n((8-1)*4) + ((4-2)*3) + ((2-4)*2) + ((1-8)*1) = 28+6-4-7 = 23\\n\\nBasically, to get the effective frequencies, we need to generate the 2 power array, and reversed version of the 2 power array and then subtract each element.\\ni.e. \\n\\n\\t[8,4,2,1] - \\n\\t[1,2,4,8]\\n\\t= [8-1, 4-2, 2-4, 1-8]\\n\\t= [7, 2, -2, -7]\\n\\nAnd ultimately we multiply them with values of our sorted array ([1,2,3,4]).\\n\\nHere is the code:\\n\\n```\\npublic int sumSubseqWidths(int[] nums) {\\n       long twoPower [] =new long[nums.length];\\n       long mod = 1000000007L;\\n       twoPower[0] =1;\\n\\t   // generating 2 power array\\n       for (int i = 1; i< nums.length; i++){\\n           twoPower[i] = (twoPower[i-1]*2)%mod;\\n       }\\n       long effective[] = new long[nums.length];\\n\\t   // generating effective frequency array  by subtracting the 2 power array\\'s elements from its reverse view\\n       for (int i = 0; i< nums.length; i++) {\\n    \\t   effective[i] = (twoPower[i]- twoPower[nums.length- i-1]);\\n       }\\n       Arrays.sort(nums); // sorting the array\\n       long ans = 0;\\n\\t   // now, to get the answer we multiply the elements of the sorted array with the effective frequency array elements\\n       for (int i = 0; i< nums.length; i++) {\\n    \\t   ans = (ans+ effective[i]*nums[i])%mod;\\n       }\\n       return (int) ans;\\n   }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int sumSubseqWidths(int[] nums) {\\n       long twoPower [] =new long[nums.length];\\n       long mod = 1000000007L;\\n       twoPower[0] =1;\\n\\t   // generating 2 power array\\n       for (int i = 1; i< nums.length; i++){\\n           twoPower[i] = (twoPower[i-1]*2)%mod;\\n       }\\n       long effective[] = new long[nums.length];\\n\\t   // generating effective frequency array  by subtracting the 2 power array\\'s elements from its reverse view\\n       for (int i = 0; i< nums.length; i++) {\\n    \\t   effective[i] = (twoPower[i]- twoPower[nums.length- i-1]);\\n       }\\n       Arrays.sort(nums); // sorting the array\\n       long ans = 0;\\n\\t   // now, to get the answer we multiply the elements of the sorted array with the effective frequency array elements\\n       for (int i = 0; i< nums.length; i++) {\\n    \\t   ans = (ans+ effective[i]*nums[i])%mod;\\n       }\\n       return (int) ans;\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1667728,
                "title": "python-sort-and-sum-the-contribution",
                "content": "My solution was largely inspired by [this solution for question 2104](https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624416/python3-stack/1203869). I happened to saw the question yesterday, and loved the idea there. Similar to that question, we can solve this question by counting the contribution to the max values and min values separately. The only difference is that [question 2104](https://leetcode.com/problems/sum-of-subarray-ranges/) is asking for sub arrays, but this one is asking for subsequences. But the general idea behind the solution is the same.\\n\\nThe core idea is, for each subsequence, we have one max and one min (can be the same), so when we have the `(max1-min1) + (max2 - min2) + ... + (max_n - min_n)`, we can just separate them to `max_val = max1 + max2 + ... + max_n` and `min_val = min1 + min2 + ... min_n`. The final answer if `max_val - min_val`. \\n\\nThe trick for finding the `max_val` and `min_val` lies in **the number of times a number `x` contributes to the `min_val` or `max_val`**.  Think about this, if we have a **sorted** array `[a, b, 1, c]`, we know `1` can be the max, if a subsequence containing only `1` and `a`, `b`. Similarly, any subsequence containing `1` and `c` will have `1` as `min_val`. \\n\\nLet\\'s do an example for `1` as `max_val`, we can have subsequence `[1]`, `[a, 1]`, `[b, 1]`, and `[a, b, 1]`. In another words, we are selecting elements from `a` and `b`. The number of subsequences with `1` as `max_val` is `choose(0, 2) + choose(1, 2) + choose(2, 2)` (`choose` is the function nCr or combination in math). Therefore, we know `1` contributes *4 times* to the `max_val`. \\n\\nUsing the same method, we can calculate the number of times a number contributes to the max and min. Then we have the answer.\\n\\nHere is the code:\\n```python\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        max_val = min_val = 0\\n        MOD = 10 ** 9 + 7\\n        size = len(nums)\\n        for index, num in enumerate(nums):\\n            max_val = (max_val + num * pow(2, index, MOD)) % MOD\\n            min_val = (min_val + num * pow(2, size - index - 1, MOD)) % MOD\\n        return (max_val - min_val) % MOD\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        max_val = min_val = 0\\n        MOD = 10 ** 9 + 7\\n        size = len(nums)\\n        for index, num in enumerate(nums):\\n            max_val = (max_val + num * pow(2, index, MOD)) % MOD\\n            min_val = (min_val + num * pow(2, size - index - 1, MOD)) % MOD\\n        return (max_val - min_val) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204444,
                "title": "solution-using-fenwick-tree-binary-indexed-tree",
                "content": "We can solve this problem without sorting, instead using\\n a Fenwick Tree (a.k.a. Binary Indexed Tree, BIT).\\n\\n\\n### How Fenwick Trees Work\\nFor those who have not heard of Fenwick Trees before, it would be helpful to take a look at https://en.wikipedia.org/wiki/Fenwick_tree .\\n\\nIn short, a Fenwick Tree is an array and provides two interfaces. Let `bit` be an array expressing a Fenwick Tree initialized by a certain **1-indexed** array `X`. it offers the following operations:\\n- `query_sum(bit, idx)` : returns `X[1] + ... + X[idx]`\\n- `add_sum(bit, idx, value)`: add `value` to `X[idx]`\\nLet N be `len(X)`. Both operations are done in O(logN) time. \\n\\nThe happy thing is that you can implement them very concisely:\\n\\n```Python\\ndef query_sum(bit, idx):\\n    sum_ = 0\\n    while idx > 0:\\n        sum_ += bit[idx]\\n        idx -= idx & -idx\\n    return sum_\\n\\ndef add_sum(bit, idx, value):\\n    while idx <= len(bit):\\n        bit[idx] += value\\n        idx += idx & -idx\\n```\\nNote again that this is 1-indexed.\\n\\n### My Solution\\nWe can create a Fenwick tree `bit`  such that `query_sum(bit, item)` returns how many items smaller than `item`  there are in `A`, namely each index of `bit` has the number of `item - 1\\n`s in `A` and you can calculate the total number of occurrances of `1, 2, .., item - 1` by `query(bit, item)` in O(lgW) time, where W is `max(A)`.\\nMy solution has mainly 3 parts:\\n1. initialize `bit` from `A`\\n2. Count the number of each item of `A`\\n3. For each `item` and its `count`,  calculate how many times it appears as the minimum or maximum value  of all the subarrays\\n    - We easily know how many items in ` A` are smaller or larger than `item` by:\\n\\t\\t- `num_smaller = query_sum(bit, item)`\\n\\t\\t- `num_larger = N - num_smaller - count`\\n    - The number of subarrays which have `item` as maximum is `(2**num_smaller - 1) * (2**count - 1)` . Likewise, the number of subarrays having `item` as minimum is `(2**num_larger - 1) * (2**count - 1)`\\n    - Add the total contribution of `(2**smaller - 2**larger) * item * (2**count - 1)` to `ans`\\n \\n **Python**\\n ```\\nfrom collections import defaultdict\\n\\n\\ndef query_sum(bit, idx):\\n    sum_ = 0\\n    while idx > 0:\\n        sum_ += bit[idx]\\n        idx -= idx & -idx\\n    return sum_\\n\\n\\ndef add_sum(bit, idx, value):\\n    \"\"\"\\n    add value to a[i].\\n    \"\"\"\\n    while idx <= len(bit):\\n        bit[idx] += value\\n        idx += idx & -idx\\n\\n\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MOD = 10**9 + 7\\n        N = len(A)\\n\\n        # 1, 2: initialize bit and count items in A\\n        max_item = max(A)\\n        bit = [0] * (max_item + 100)\\n        ans = 0\\n        counter_A = [0] * (max_item + 1)\\n        for item in A:\\n            add_sum(bit, item + 1, 1)\\n            counter_A[item] += 1\\n\\n        # trivial: it is faster to calculate pow(2, hoge) beforehand\\n        pows = [1]\\n        for _ in range(N):\\n            pows.append(pows[-1] * 2 % MOD)\\n        \\n        # 3: add up each contribution\\n        for item, count in enumerate(counter_A[1:], start=1):\\n            if count == 0: continue\\n            num_smallers = query_sum(bit, item)\\n            num_largers = N - num_smallers - count\\n            ans += (pows[num_smallers] - pows[num_largers]) * item * (pows[count] - 1)\\n            ans %= MOD\\n        return ans\\n ```\\n \\n **C++**\\n ```\\n#include <bits/stdc++.h>\\n#define ll long long\\nusing namespace std;\\n\\n\\nint query_sum(vector<int>& bit, int idx) {\\n    int sum_ = 0;\\n    while (idx > 0) {\\n        sum_ += bit.at(idx);\\n        idx -= idx & -idx;\\n    }\\n    return sum_;\\n}\\n\\nvoid add_sum(vector<int>& bit, int idx, int value) {\\n    while (idx <= bit.size()) {\\n        bit.at(idx) += value;\\n        idx += idx & -idx;\\n    }\\n    return;\\n}\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        const ll MOD = 1000000000 + 7;\\n        const int N = A.size();\\n        int max_A = 0;\\n        for (int i = 0; i < N; i++) {\\n            max_A = max(max_A, A.at(i));\\n        }\\n        vector<int> bit(max_A + 100, 0);\\n        vector<int> counter(max_A + 100, 0);\\n        for (int i = 0; i < N; i++) {\\n            int item = A.at(i);\\n            add_sum(bit, item + 1, 1);\\n            counter.at(item) += 1;\\n        }\\n\\n        vector<ll> pows(N + 1, 1);\\n        for (int i = 1; i < N + 1; i++) {\\n            ll prev_pow = pows.at(i - 1);\\n            pows.at(i) = prev_pow * 2 % MOD;\\n        }\\n\\n        ll ans = 0;\\n        for (int item = 1; item < max_A + 1; item++) {\\n            int count = counter.at(item);\\n            if (count == 0) continue;\\n            int num_smallers = query_sum(bit, item);\\n            int num_largers = N - num_smallers - count;\\n            ans += (pows.at(num_smallers) - pows.at(num_largers)) * item % MOD * (pows.at(count) - 1) % MOD;\\n            ans %= MOD;\\n        }\\n        return ans;\\n    }\\n};\\n ```\\nThe total time complexity is O(N + NlgW) and space complexity is O(N + W), where N and W are `len(A)` and `max(A)` respectively.\\nHope this will give you a new perspective!!",
                "solutionTags": [],
                "code": "```Python\\ndef query_sum(bit, idx):\\n    sum_ = 0\\n    while idx > 0:\\n        sum_ += bit[idx]\\n        idx -= idx & -idx\\n    return sum_\\n\\ndef add_sum(bit, idx, value):\\n    while idx <= len(bit):\\n        bit[idx] += value\\n        idx += idx & -idx\\n```\n```\\nfrom collections import defaultdict\\n\\n\\ndef query_sum(bit, idx):\\n    sum_ = 0\\n    while idx > 0:\\n        sum_ += bit[idx]\\n        idx -= idx & -idx\\n    return sum_\\n\\n\\ndef add_sum(bit, idx, value):\\n    \"\"\"\\n    add value to a[i].\\n    \"\"\"\\n    while idx <= len(bit):\\n        bit[idx] += value\\n        idx += idx & -idx\\n\\n\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MOD = 10**9 + 7\\n        N = len(A)\\n\\n        # 1, 2: initialize bit and count items in A\\n        max_item = max(A)\\n        bit = [0] * (max_item + 100)\\n        ans = 0\\n        counter_A = [0] * (max_item + 1)\\n        for item in A:\\n            add_sum(bit, item + 1, 1)\\n            counter_A[item] += 1\\n\\n        # trivial: it is faster to calculate pow(2, hoge) beforehand\\n        pows = [1]\\n        for _ in range(N):\\n            pows.append(pows[-1] * 2 % MOD)\\n        \\n        # 3: add up each contribution\\n        for item, count in enumerate(counter_A[1:], start=1):\\n            if count == 0: continue\\n            num_smallers = query_sum(bit, item)\\n            num_largers = N - num_smallers - count\\n            ans += (pows[num_smallers] - pows[num_largers]) * item * (pows[count] - 1)\\n            ans %= MOD\\n        return ans\\n ```\n```\\n#include <bits/stdc++.h>\\n#define ll long long\\nusing namespace std;\\n\\n\\nint query_sum(vector<int>& bit, int idx) {\\n    int sum_ = 0;\\n    while (idx > 0) {\\n        sum_ += bit.at(idx);\\n        idx -= idx & -idx;\\n    }\\n    return sum_;\\n}\\n\\nvoid add_sum(vector<int>& bit, int idx, int value) {\\n    while (idx <= bit.size()) {\\n        bit.at(idx) += value;\\n        idx += idx & -idx;\\n    }\\n    return;\\n}\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        const ll MOD = 1000000000 + 7;\\n        const int N = A.size();\\n        int max_A = 0;\\n        for (int i = 0; i < N; i++) {\\n            max_A = max(max_A, A.at(i));\\n        }\\n        vector<int> bit(max_A + 100, 0);\\n        vector<int> counter(max_A + 100, 0);\\n        for (int i = 0; i < N; i++) {\\n            int item = A.at(i);\\n            add_sum(bit, item + 1, 1);\\n            counter.at(item) += 1;\\n        }\\n\\n        vector<ll> pows(N + 1, 1);\\n        for (int i = 1; i < N + 1; i++) {\\n            ll prev_pow = pows.at(i - 1);\\n            pows.at(i) = prev_pow * 2 % MOD;\\n        }\\n\\n        ll ans = 0;\\n        for (int item = 1; item < max_A + 1; item++) {\\n            int count = counter.at(item);\\n            if (count == 0) continue;\\n            int num_smallers = query_sum(bit, item);\\n            int num_largers = N - num_smallers - count;\\n            ans += (pows.at(num_smallers) - pows.at(num_largers)) * item % MOD * (pows.at(count) - 1) % MOD;\\n            ans %= MOD;\\n        }\\n        return ans;\\n    }\\n};\\n ```",
                "codeTag": "C++"
            },
            {
                "id": 161299,
                "title": "this-is-bulls-2-xx-gives-me-tle-whereas-passed-seriously",
                "content": "I spent the last 40 minutes trying to come up w/ a better than O(nlonn) solution, which I don\\'t think exists. So I\\'m curious and waiting for smarter solution... And it turned out that the catch is the bit-wise opearting when computing power of 2s. \\n\\nIf you un-comment the code you will find that you get TLE... \\n\\nI understand bit-wise operator is faster than ** , but if this is the speed limit, I don\\'t think its fair. Plus who cares whether its ** or a more hacky << ? \\n\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        CONST = 10 ** 9 + 7\\n        A = sorted(A, key=lambda x: -x)\\n        n = len(A)\\n        ans = 0\\n        for i in range(n):\\n            ans += A[i] * (2 ** (n-i-1) - 2 ** i)         # <- This you get TLE \\n            # ans += A[i] * ((1 << (n-i-1)) - (1 << i))       # <- This you pass\\n        return ans % CONST\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        CONST = 10 ** 9 + 7\\n        A = sorted(A, key=lambda x: -x)\\n        n = len(A)\\n        ans = 0\\n        for i in range(n):\\n            ans += A[i] * (2 ** (n-i-1) - 2 ** i)         # <- This you get TLE \\n            # ans += A[i] * ((1 << (n-i-1)) - (1 << i))       # <- This you pass\\n        return ans % CONST\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961298,
                "title": "python3-a-much-easier-way-to-build-the-math-logic",
                "content": "\\tclass Solution:\\n\\t\\tdef sumSubseqWidths(self, A: List[int]) -> int:\\n\\t\\t\\t# Note:  sub sequence, not sub array\\n\\t\\t\\t# after sorting, for each i \\n\\t\\t\\t# -  A[i] will serve as max for 2**i combinations with elements from A[:i], which makes additions to res\\n\\t\\t\\t# -  A[i] will serve as min for 2**(n-1-i) combinations with elements from A[i+1:n], which makes deductions to res\\n\\t\\t\\t# we just need to enumerate i, and update the res\\n\\n\\t\\t\\tA = sorted(A)\\n\\t\\t\\tM = 10**9 + 7\\n\\t\\t\\tP = [(2**i)%M for i in range(len(A))] \\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(len(A)):\\n\\t\\t\\t\\tadd = P[i] * A[i]\\n\\t\\t\\t\\tded = P[len(A)-1-i]* A[i]\\n\\t\\t\\t\\tres += (add - ded)%M\\n\\t\\t\\t\\tres = res%M\\n\\t\\t\\treturn res\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sumSubseqWidths(self, A: List[int]) -> int:\\n\\t\\t\\t# Note:  sub sequence, not sub array\\n\\t\\t\\t# after sorting, for each i \\n\\t\\t\\t# -  A[i] will serve as max for 2**i combinations with elements from A[:i], which makes additions to res\\n\\t\\t\\t# -  A[i] will serve as min for 2**(n-1-i) combinations with elements from A[i+1:n], which makes deductions to res\\n\\t\\t\\t# we just need to enumerate i, and update the res\\n\\n\\t\\t\\tA = sorted(A)\\n\\t\\t\\tM = 10**9 + 7\\n\\t\\t\\tP = [(2**i)%M for i in range(len(A))] \\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(len(A)):\\n\\t\\t\\t\\tadd = P[i] * A[i]\\n\\t\\t\\t\\tded = P[len(A)-1-i]* A[i]\\n\\t\\t\\t\\tres += (add - ded)%M\\n\\t\\t\\t\\tres = res%M\\n\\t\\t\\treturn res\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 161265,
                "title": "black-magic",
                "content": "```\\nA.sort()\\nlookup = [1] * len(A)\\nfor i in xrange(1, len(A)):\\n\\tlookup[i] = (lookup[i-1]) * 2 % 1000000007 \\nreturn sum([A[i] * (lookup[i] - lookup[len(A)-i-1]) for i in xrange(len(A))]) % 1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nA.sort()\\nlookup = [1] * len(A)\\nfor i in xrange(1, len(A)):\\n\\tlookup[i] = (lookup[i-1]) * 2 % 1000000007 \\nreturn sum([A[i] * (lookup[i] - lookup[len(A)-i-1]) for i in xrange(len(A))]) % 1000000007\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 162583,
                "title": "python-solution-with-detailed-steps",
                "content": "dp[i] represent A[:i+1]\\'s sum of subsequence widths.\\nobviously, dp[0] = 0(only A[0]), dp[1] = A[1]-A[0]\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/2017111303/image_1535013111.png)\\ncare about 2^i, it\\'s very large(i<20000), so we should mod 1e9+7 before we calculate the result!\\nI use rec[i] represent 2^i,as a global variable\\n\\n```python\\nrec,mod,s = [],10**9+7,1\\nfor i in range(20000):\\n    rec.append(s)\\n    s *= 2\\n    s %= mod\\n\\ndef sumSubseqWidths(A):\\n\\tA.sort()\\n\\tdp = [0] * len(A)\\n\\tdp[0],dp[1] = 0,A[1]-A[0]\\n\\tfor i in range(2,len(dp)):\\n\\t\\tdp[i] = (3*dp[i-1] - 2*dp[i-2] + (A[i]-A[i-1]) * (rec[i]-1)) % mod\\n\\treturn dp[-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\nrec,mod,s = [],10**9+7,1\\nfor i in range(20000):\\n    rec.append(s)\\n    s *= 2\\n    s %= mod\\n\\ndef sumSubseqWidths(A):\\n\\tA.sort()\\n\\tdp = [0] * len(A)\\n\\tdp[0],dp[1] = 0,A[1]-A[0]\\n\\tfor i in range(2,len(dp)):\\n\\t\\tdp[i] = (3*dp[i-1] - 2*dp[i-2] + (A[i]-A[i-1]) * (rec[i]-1)) % mod\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3963373,
                "title": "calculate-contribution-of-each-element",
                "content": "# Intuition\\nSince the contraints are very strict to try and go for brute force approach, we try to solve this question by calculating contribution of each element\\n\\n# Approach\\nSort the array firstly. Then at each index we have to calculate in how many subsequence will the current element be maximum and minimum.\\n1) Maximum case\\n   All the subsequences ending at current index will have the maximum  element as nums[i]. 2*i subsequences\\n2) Minimum case\\nAll the subsequences starting at current index will have minimum element as nums[i]. 2*(n-i-1) subsequences\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    #define ll long long\\n    int mod = 1e9+7;\\n    int power(ll x, ll y) {\\n        int res = 1;  \\n        x = x % mod; \\n        if (x == 0) return 0;\\n    \\n        while (y > 0) {\\n            if (y & 1)\\n                res = (res*x) % mod;\\n    \\n            y = y>>1; \\n            x = (x*x) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        ll ans = 0, n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0 ; i<n ; ++i) {\\n            ans = (ans + nums[i]*1ll*power(2,i))%mod;\\n            ans = (ans - nums[i]*1ll*power(2,n-i-1))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\n    int mod = 1e9+7;\\n    int power(ll x, ll y) {\\n        int res = 1;  \\n        x = x % mod; \\n        if (x == 0) return 0;\\n    \\n        while (y > 0) {\\n            if (y & 1)\\n                res = (res*x) % mod;\\n    \\n            y = y>>1; \\n            x = (x*x) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        ll ans = 0, n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0 ; i<n ; ++i) {\\n            ans = (ans + nums[i]*1ll*power(2,i))%mod;\\n            ans = (ans - nums[i]*1ll*power(2,n-i-1))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545992,
                "title": "c-891-sum-of-subsequence-widths",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size(), MOD = 1\\'000\\'000\\'007; \\n        vector<long> p(n, 1); \\n        for (int i = 1; i < n; ++i) p[i] = 2*p[i-1]%MOD; \\n        \\n        long ans = 0; \\n        sort(nums.begin(), nums.end()); \\n        for (int i = 0; i < n; ++i) \\n            ans = (ans + nums[i] * (p[i] - p[n-1-i])) % MOD; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size(), MOD = 1\\'000\\'000\\'007; \\n        vector<long> p(n, 1); \\n        for (int i = 1; i < n; ++i) p[i] = 2*p[i-1]%MOD; \\n        \\n        long ans = 0; \\n        sort(nums.begin(), nums.end()); \\n        for (int i = 0; i < n; ++i) \\n            ans = (ans + nums[i] * (p[i] - p[n-1-i])) % MOD; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550718,
                "title": "java-sol",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        int mod=1000000007;\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        long first=0;\\n        long second=0;\\n        long pow[]=new long[n+1];\\n        pow[0] = 1;\\n        for (int i = 1; i<n;i++){\\n            pow[i] = (pow[i-1] * 2) % mod;\\n        }    \\n        for(int i=1;i<nums.length;i++){\\n            long a=nums[i];\\n            long r=2;\\n            int len=i;\\n            long sum=((a*(pow[len]-1))/(r-1))%mod;\\n            first=(first+sum)%mod;\\n        }\\n         \\n        for(int j=0;j<nums.length-1;j++){\\n            long a=nums[j];\\n            long r=2;\\n            int len=n-j-1;\\n            long sum=((a*(pow[len]-1))/(r-1))%mod;\\n            second=(second+sum)%mod;\\n        }\\n        long res=first-second;\\n        if(res<0)res+=mod;\\n        return (int)(res);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        int mod=1000000007;\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        long first=0;\\n        long second=0;\\n        long pow[]=new long[n+1];\\n        pow[0] = 1;\\n        for (int i = 1; i<n;i++){\\n            pow[i] = (pow[i-1] * 2) % mod;\\n        }    \\n        for(int i=1;i<nums.length;i++){\\n            long a=nums[i];\\n            long r=2;\\n            int len=i;\\n            long sum=((a*(pow[len]-1))/(r-1))%mod;\\n            first=(first+sum)%mod;\\n        }\\n         \\n        for(int j=0;j<nums.length-1;j++){\\n            long a=nums[j];\\n            long r=2;\\n            int len=n-j-1;\\n            long sum=((a*(pow[len]-1))/(r-1))%mod;\\n            second=(second+sum)%mod;\\n        }\\n        long res=first-second;\\n        if(res<0)res+=mod;\\n        return (int)(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511726,
                "title": "solution",
                "content": "```C++ []\\nconst long M=1e9+7;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long sum=0, cnt=1;\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i=0, j=n-1; i<n; sum=(sum+(nums[i++]-nums[j--])*cnt)%M, cnt=cnt*2%M) {}\\n        return sum;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = 10**9 + 7\\n        nums.sort()\\n        ans, pow2 = 0, 1\\n        for x, y in zip(nums, reversed(nums)):\\n            ans += (x - y) * pow2\\n            pow2 = pow2 * 2 % mod\\n        return ans % mod\\n```\\n\\n```Java []\\nclass Solution {\\n\\tpublic int sumSubseqWidths(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tlong c = 1;\\n\\t\\tlong result = 0;\\n\\t\\tlong mod = 1000000007L;\\n\\t\\tfor (int i = 0, j = nums.length - 1; i < nums.length; i++, j--) {\\n\\t\\t\\tresult = (result + (nums[i] * c) - (nums[j] * c)) % mod;\\n\\t\\t\\tc = (c * 2) % mod;\\n\\t\\t}\\n\\t\\treturn (int) ((result + mod) % mod);\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nconst long M=1e9+7;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long sum=0, cnt=1;\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i=0, j=n-1; i<n; sum=(sum+(nums[i++]-nums[j--])*cnt)%M, cnt=cnt*2%M) {}\\n        return sum;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = 10**9 + 7\\n        nums.sort()\\n        ans, pow2 = 0, 1\\n        for x, y in zip(nums, reversed(nums)):\\n            ans += (x - y) * pow2\\n            pow2 = pow2 * 2 % mod\\n        return ans % mod\\n```\n```Java []\\nclass Solution {\\n\\tpublic int sumSubseqWidths(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tlong c = 1;\\n\\t\\tlong result = 0;\\n\\t\\tlong mod = 1000000007L;\\n\\t\\tfor (int i = 0, j = nums.length - 1; i < nums.length; i++, j--) {\\n\\t\\t\\tresult = (result + (nums[i] * c) - (nums[j] * c)) % mod;\\n\\t\\t\\tc = (c * 2) % mod;\\n\\t\\t}\\n\\t\\treturn (int) ((result + mod) % mod);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791666,
                "title": "c-easy-shorts",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740307,
                "title": "golang-runtime-283-ms-faster-than-16-67",
                "content": "- Runtime: 283 ms, faster than 16.67% of Go online submissions for Sum of Subsequence Widths.\\n- Memory Usage: 8.4 MB, less than 100.00% of Go online submissions for Sum of Subsequence Widths.\\n```\\nfunc sumSubseqWidths(nums []int) int {\\n    sort.Ints(nums)\\n\\tres, mod, n, p := 0, 1000000007, len(nums), 1\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tres = (res + (nums[i]-nums[n-1-i])*p) % mod\\n\\t\\tp = (p << 1) % mod\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc sumSubseqWidths(nums []int) int {\\n    sort.Ints(nums)\\n\\tres, mod, n, p := 0, 1000000007, len(nums), 1\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tres = (res + (nums[i]-nums[n-1-i])*p) % mod\\n\\t\\tp = (p << 1) % mod\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2537337,
                "title": "magical-solution-true-for-all-complexity-nlogn",
                "content": "\\n![image](https://assets.leetcode.com/users/images/1ed44939-621b-4e4b-b1ac-6d9d638a9075_1662429184.0499213.png)\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "\\n![image](https://assets.leetcode.com/users/images/1ed44939-621b-4e4b-b1ac-6d9d638a9075_1662429184.0499213.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2350649,
                "title": "simple-easy-method-for-those-who-did-not-understand-c",
                "content": "In this question if we deeply try to think then we can able to understand that order of elements does not matter because we are actually choosing the all subsequences and take the difference of maximum and minimum values.\\nNow coming to max and min values, we wants to find the contribution of each array elements in thier subsequence they are part with where they are minimum and maximum.\\n1) There are 2 ^ i sequence are possible in which a[i]th element are maxmium. \\ne.g. [2, 3, 5] => here 2 is contibuting in sequnces [2], [2, 3] , [2, 5], [2, 3, 5] now we can easily see that 2 is maximum in only single sequnce which is [2].\\n2) Now whatever the sequence left i.e. 2 ^( n - i - 1) sequences are possible in which a[i]th element is minimum.\\n\\nNow the problem is solved , but some might get memory limit exceeded due to not perfom the mod operation in right way here we just use mod operation as simpe way and do addition first so that answer will always be positive so there will be no chance of mistake.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        vector < long long > pow(nums.size() ); \\n        pow[0] = 1;\\n          for(int i = 1 ; i<nums.size(); i++){ \\n             pow[i] = pow[i-1] * 2 % 1000000007; \\n          }\\n        sort(nums.begin() , nums.end()); \\n       long long ans = 0 ;   \\n        for(int i = 0 ; i<nums.size(); i++){ \\n              ans = (ans + pow[i]*nums[i]) % 1000000007; \\n               ans = (ans - pow[nums.size()-i-1] * (long long)nums[i] ) % 1000000007; \\n           \\n          } \\n        return ans; \\n    }\\n};\\n```\\n\\n```\\nwhile(1){ \\nif(likes == true){ \\n  upvotes +=1; \\n}\\nelse { \\nlike = true; \\ncontinue; \\n}\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        vector < long long > pow(nums.size() ); \\n        pow[0] = 1;\\n          for(int i = 1 ; i<nums.size(); i++){ \\n             pow[i] = pow[i-1] * 2 % 1000000007; \\n          }\\n        sort(nums.begin() , nums.end()); \\n       long long ans = 0 ;   \\n        for(int i = 0 ; i<nums.size(); i++){ \\n              ans = (ans + pow[i]*nums[i]) % 1000000007; \\n               ans = (ans - pow[nums.size()-i-1] * (long long)nums[i] ) % 1000000007; \\n           \\n          } \\n        return ans; \\n    }\\n};\\n```\n```\\nwhile(1){ \\nif(likes == true){ \\n  upvotes +=1; \\n}\\nelse { \\nlike = true; \\ncontinue; \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159982,
                "title": "py-3-sorting-no-comments-video-refrence",
                "content": "[ Credits PepCoding](https://www.youtube.com/watch?v=kSo8W6ZGYqw&list=PL-Jc9J83PIiE-TR27GB7V5TBLQRT5RnSl&index=50&ab_channel=Pepcoding)\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = 0\\n        for i in range(n):\\n            ans += nums[i] * 1<<i\\n            ans -= nums[i] * 1<<(n-i-1)\\n        return ans%(10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = 0\\n        for i in range(n):\\n            ans += nums[i] * 1<<i\\n            ans -= nums[i] * 1<<(n-i-1)\\n        return ans%(10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027479,
                "title": "2-line-python-sorting-subset-with-thought-process-when-being-asked-during-interviews",
                "content": "### Sorting + Subset\\nThis problem is similar with the [2104. Sum of Subarray Ranges](https://leetcode.com/problems/sum-of-subarray-ranges/), while the solution is significantly different. But the idea is similar, we just get the sum of maximum and sum of minimum respetively, then get the final answer by subtraction.\\n\\nInteresting tips:\\n * Use stack when seeing maximum/minimum of subarrays since order matters.\\n * Use sorting when seeing maximum/minimum of subsequences since order doesn\\'t matter with removal.\\n\\nThen the first step is that for each number `nums[i]`, we need calculate the sum of subsequences that the `nums[i]` is maximum. In order to have `nums[i]` maximum, we can only put the numbers that are smaller than `nums[i]`. For instance, `[1,2,3,4]`, we want to calculate the sum of subsequences for `3`, then only `[1, 2]` can be put into the subsequences, finally add `3`. \\n\\nSo the second step is that how many subsequences we can construct given list of numbers? It\\'s `2 ^ size of list`. Why?\\nBecause for each number, we have only 2 options to include it or not, if all included, it\\'s `[1,2]`, otherwise if all not included, it\\'s empty set/list `[]`. \\nThen the number of subsets/subsequences we can construct is `2 ^ size of list`.\\nFinally, it\\'s quite simply, we need to know the number of integers that are smaller than `nums[i]`, so sorting is the solution.\\nLet\\'s put it all together:\\n1. sort the `nums`\\n2. iterate each number and sum up of `nums[i] * ((1 << i) - (1 << n - i - 1))`\\n3. modulus the result.\\n\\nYou might find that you got TLE with this solution, because shifting bit is expensive when `n` is large. So we can modulus `M` whenever shifting bits. \\nAlternatively use `pow(2, i, M)`.\\n\\n```python\\ndef sumSubseqWidths(self, nums: List[int]) -> int:\\n\\t# 1Cn + 2Cn + 3Cn ... nCn\\n    # 1 * 2 ^ 0 + 2 * 2 ^ 1 + 3 * 2 ^ 2 = 1 + 4 + 12 = 17\\n    # 1 * 2 ^ 2 + 2 * 2 ^ 1 + 3 * 2 ^ 0 = 4 + 4 + 3 = 11\\n    # 2 ^ number of subsets        \\n    n, M = len(nums),10 ** 9 + 7\\n    return sum(nums[index] * (pow(2, i, M) - pow(2, n - i - 1, M)) for i, index in enumerate(sorted(range(n), key=lambda x: nums[x]))) % M\\n```\\n\\n*Time Complexity*= **O(NlgN)**\\n*Space Complexity*= **O(1)**\\n\\n\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```python\\ndef sumSubseqWidths(self, nums: List[int]) -> int:\\n\\t# 1Cn + 2Cn + 3Cn ... nCn\\n    # 1 * 2 ^ 0 + 2 * 2 ^ 1 + 3 * 2 ^ 2 = 1 + 4 + 12 = 17\\n    # 1 * 2 ^ 2 + 2 * 2 ^ 1 + 3 * 2 ^ 0 = 4 + 4 + 3 = 11\\n    # 2 ^ number of subsets        \\n    n, M = len(nums),10 ** 9 + 7\\n    return sum(nums[index] * (pow(2, i, M) - pow(2, n - i - 1, M)) for i, index in enumerate(sorted(range(n), key=lambda x: nums[x]))) % M\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1753530,
                "title": "c-solution-time-complexity-o-n-log-n-space-complexity-o-1",
                "content": "For each number we have 2 choices, whether to include it in our subsequence or not. So for any choosen subsequence we have 2 choices for every element except for min and max element. \\n\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        long long two=1;\\n        int i=0,j=nums.size()-1;\\n        long long left=0,right=0;\\n        while(j>=0){\\n            left=left+nums[i++];\\n            right=right+nums[j--];\\n            long long sum=((right-left)*two)%int(1e9+7);\\n            ans=(ans+sum)%int(1e9+7);\\n            two=(two*2)%int(1e9+7);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        long long two=1;\\n        int i=0,j=nums.size()-1;\\n        long long left=0,right=0;\\n        while(j>=0){\\n            left=left+nums[i++];\\n            right=right+nums[j--];\\n            long long sum=((right-left)*two)%int(1e9+7);\\n            ans=(ans+sum)%int(1e9+7);\\n            two=(two*2)%int(1e9+7);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694290,
                "title": "c-solution-math-combinatorics-explained",
                "content": "Observation: The answer will be sum of Max element of each subsequence - sum of Min elements of each subsequence\\n\\nLength of nums = N\\nLets consider and element X which occurs xn times, there are L numbers strictly less than X and G numbers strictly greater than X.\\n\\nTherefore,\\nnx + L + G = N\\n\\nthe number of subsequences where X is the minimum is (there is atleast one X):\\n\\t(number of X\\'s we can chhose from nx X\\'s ) * (number of susequences formed from the Greater G elements)\\n\\t\\n\\tsub_x_min = (nxC1 + nxC2 + ... nxCnx) * (GC0 + GC1 + GC2 + ... GCG)\\n\\tsub_x_min = ( 2 ^ (nx) - 1 ) * (2 ^ (G))\\nTherefore for every X in nums the sum of Min elements of each subsequence will be:\\n\\t= sum(sub_x_min*X) for every X\\n\\t\\nRepeat the same Process but find Sum of Max elements of each subsequence\\n\\nReturn the difference of these sums.\\n\\n```\\nclass Solution {\\npublic:\\n    int MAX = 1000000007;\\n    \\n    // function for modular exponentiation to find (2^n)%MAX\\n    long long expo(vector<int>& dp, int n){\\n        if(n < 2) return n+1;\\n        if(dp[n]) return dp[n];\\n        \\n        if(n % 2 == 0){\\n            long long temp = expo(dp, n/2) % MAX;\\n            dp[n] = (temp*temp) % MAX;\\n            return dp[n];\\n        } else{\\n            dp[n] = (2 * expo(dp, n-1)) % MAX;\\n            return dp[n];\\n        }\\n    }\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mpGreater;\\n        \\n        int resHigh = 0, resLow = 0;\\n        \\n        //count of each element\\n        for(int a : nums) mpGreater[a]++;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int> dp(nums.size());\\n        \\n        for(auto current : mpGreater){\\n            // number of elements greater than current element\\n            int greater = nums.end() - upper_bound(nums.begin(), nums.end(), current.first); \\n            //elements strictly lesser than current\\n            int lesser = n - current.second - greater;\\n\\n            int temp1 = expo(dp, current.second)-1;\\n            resLow = (resLow + (((expo(dp, greater) * temp1) * current.first)%MAX)) % MAX;\\n            resHigh = (resHigh + (((expo(dp, lesser) * temp1) * current.first)%MAX))%MAX;\\n            \\n        }\\n        \\n        int res = resHigh%MAX - resLow%MAX;\\n        \\n        return res < 0 ? res % MAX + MAX : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MAX = 1000000007;\\n    \\n    // function for modular exponentiation to find (2^n)%MAX\\n    long long expo(vector<int>& dp, int n){\\n        if(n < 2) return n+1;\\n        if(dp[n]) return dp[n];\\n        \\n        if(n % 2 == 0){\\n            long long temp = expo(dp, n/2) % MAX;\\n            dp[n] = (temp*temp) % MAX;\\n            return dp[n];\\n        } else{\\n            dp[n] = (2 * expo(dp, n-1)) % MAX;\\n            return dp[n];\\n        }\\n    }\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mpGreater;\\n        \\n        int resHigh = 0, resLow = 0;\\n        \\n        //count of each element\\n        for(int a : nums) mpGreater[a]++;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int> dp(nums.size());\\n        \\n        for(auto current : mpGreater){\\n            // number of elements greater than current element\\n            int greater = nums.end() - upper_bound(nums.begin(), nums.end(), current.first); \\n            //elements strictly lesser than current\\n            int lesser = n - current.second - greater;\\n\\n            int temp1 = expo(dp, current.second)-1;\\n            resLow = (resLow + (((expo(dp, greater) * temp1) * current.first)%MAX)) % MAX;\\n            resHigh = (resHigh + (((expo(dp, lesser) * temp1) * current.first)%MAX))%MAX;\\n            \\n        }\\n        \\n        int res = resHigh%MAX - resLow%MAX;\\n        \\n        return res < 0 ? res % MAX + MAX : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489381,
                "title": "c-with-explanation-93-solution",
                "content": "Take a simple example\\n```\\n\\t\\tnums = [3,1,2]\\n\\t\\tWe will have \"2\"  as a highest number in \"How many sub-sequence\" ?\\n\\t\\tAns. \\n\\t\\t\\tIf we sort nums = [1, 2, 3]\\n\\t\\t\\twe will have \"2 as a highest number in 2^1 sub-sequence \"\\n\\t\\t\\tNamely [1, 2] and [2]\\n\\t\\t\\tOr we can say 2^index number of subarrays\\n\\t\\tAs we have number of time in which a certain index will be the highest number \\n\\t\\twe need to find the lowest number in each of the sub-sequence\\n\\t\\t\\n\\t\\tNow think about index => 2 \\n\\t\\t[1 ,  2,  3]  => lowest 1\\n\\t    [1,        3] => lowest 1\\n\\t\\t\\t  [2,  3] => lowest 2\\n\\t\\t\\t       [3] => lowest 3\\n\\t\\tnumber of times 1 was smallest is equal to  \"2^( index_of_3 - index_of_1  - 1) == 2 ^ (2 - 0 - 1) = 2 \\n\\t\\tnumber of times 2 was smallest is equal to  \"2^( index_of_3 - index_of_2  - 1) == 2 ^ (2 - 1 - 1) = 1 \\n\\t\\t\\n\\t\\tNow 3 as a highest number will add \\n\\t\\t\\t\\t(3 - 1) + (3 - 1) + (3 - 2) + (3 - 3) ==  3 * (  (2 ^ index_of_3) - 1 ) - 1 * 2^( index_of_3 - index_of_1  - 1) - 2 * 2^( index_of_3 - index_of_2  - 1) \\n\\t\\t\\n\\t\\tSimilary do for the remaing element starting from 0 index\\n\\t\\t\\n```\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        sort(begin(nums), end(nums));\\n        int n = nums.size();\\n        \\n        long long ans = 0, last = 0, p = 1;\\n        \\n        long long mod = 1e9 + 7, temp;\\n        \\n        for(int i = 0 ; i < n ; ++i){\\n            \\n            temp = ((p-1ll)*nums[i] - last ) % mod;\\n            \\n            ans = (ans + temp ) % mod;\\n            \\n            p = (p*2ll) % mod;\\n            \\n            last = (2*last + 1ll*nums[i]) % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tnums = [3,1,2]\\n\\t\\tWe will have \"2\"  as a highest number in \"How many sub-sequence\" ?\\n\\t\\tAns. \\n\\t\\t\\tIf we sort nums = [1, 2, 3]\\n\\t\\t\\twe will have \"2 as a highest number in 2^1 sub-sequence \"\\n\\t\\t\\tNamely [1, 2] and [2]\\n\\t\\t\\tOr we can say 2^index number of subarrays\\n\\t\\tAs we have number of time in which a certain index will be the highest number \\n\\t\\twe need to find the lowest number in each of the sub-sequence\\n\\t\\t\\n\\t\\tNow think about index => 2 \\n\\t\\t[1 ,  2,  3]  => lowest 1\\n\\t    [1,        3] => lowest 1\\n\\t\\t\\t  [2,  3] => lowest 2\\n\\t\\t\\t       [3] => lowest 3\\n\\t\\tnumber of times 1 was smallest is equal to  \"2^( index_of_3 - index_of_1  - 1) == 2 ^ (2 - 0 - 1) = 2 \\n\\t\\tnumber of times 2 was smallest is equal to  \"2^( index_of_3 - index_of_2  - 1) == 2 ^ (2 - 1 - 1) = 1 \\n\\t\\t\\n\\t\\tNow 3 as a highest number will add \\n\\t\\t\\t\\t(3 - 1) + (3 - 1) + (3 - 2) + (3 - 3) ==  3 * (  (2 ^ index_of_3) - 1 ) - 1 * 2^( index_of_3 - index_of_1  - 1) - 2 * 2^( index_of_3 - index_of_2  - 1) \\n\\t\\t\\n\\t\\tSimilary do for the remaing element starting from 0 index\\n\\t\\t\\n```\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        sort(begin(nums), end(nums));\\n        int n = nums.size();\\n        \\n        long long ans = 0, last = 0, p = 1;\\n        \\n        long long mod = 1e9 + 7, temp;\\n        \\n        for(int i = 0 ; i < n ; ++i){\\n            \\n            temp = ((p-1ll)*nums[i] - last ) % mod;\\n            \\n            ans = (ans + temp ) % mod;\\n            \\n            p = (p*2ll) % mod;\\n            \\n            last = (2*last + 1ll*nums[i]) % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449195,
                "title": "python-two-o-nlogn-approaches",
                "content": "Let `n` be the length of `nums`. We need to first sort `nums`. For the element at index `i` (0-based) in sorted `nums`, there are `2^i` subsequences where that element is the maximum and there are `2^(n - i - 1)` subsequences where that element is the minimum. Then, we get the following solution.\\n\\nApproach 1:\\n`O(nlogn) + O(nlogn) = O(nlogn)`\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = int(1e9 + 7)\\n        return sum(n * (pow(2, i, mod) - pow(2, len(nums) - i - 1, mod)) for i,n in enumerate(sorted(nums))) % mod\\n```\\n\\nWe can optimize our second step by caluculating the powers of two as we go while adding and substracting the elements using the power of two at each step.\\n\\nApproach 2:\\n`O(nlogn) + O(n) = O(nlogn)`\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mod = int(1e9 + 7)\\n        res = 0\\n        cur_pow = 1\\n        for i in range(len(nums)):\\n            res = (res + cur_pow * (nums[i] - nums[len(nums) - i - 1])) % mod\\n            cur_pow = cur_pow * 2 % mod\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = int(1e9 + 7)\\n        return sum(n * (pow(2, i, mod) - pow(2, len(nums) - i - 1, mod)) for i,n in enumerate(sorted(nums))) % mod\\n```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mod = int(1e9 + 7)\\n        res = 0\\n        cur_pow = 1\\n        for i in range(len(nums)):\\n            res = (res + cur_pow * (nums[i] - nums[len(nums) - i - 1])) % mod\\n            cur_pow = cur_pow * 2 % mod\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104026,
                "title": "java-array-math-14ms-beats-96-t-c-o-nlogn-s-c-o-n",
                "content": "\\n    public int sumSubseqWidths(int[] A) {\\n        int len = A.length, mod = 1000000007;\\n\\t\\tlong sum = 0;\\n\\t\\tArrays.sort(A);\\n\\t\\tlong[] dp = new long[len];\\n\\t\\tdp[0] = 1;\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tdp[i] = (dp[i - 1] * 2) % mod;\\n\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tsum = (sum + (A[i] * (dp[i] - dp[len - 1 - i]))) % mod;\\n\\n\\t\\treturn (int) (sum % mod);\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int sumSubseqWidths(int[] A) {\\n        int len = A.length, mod = 1000000007;\\n\\t\\tlong sum = 0;\\n\\t\\tArrays.sort(A);\\n\\t\\tlong[] dp = new long[len];\\n\\t\\tdp[0] = 1;\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tdp[i] = (dp[i - 1] * 2) % mod;\\n\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tsum = (sum + (A[i] * (dp[i] - dp[len - 1 - i]))) % mod;\\n\\n\\t\\treturn (int) (sum % mod);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1093550,
                "title": "c-o-n-log-n",
                "content": "```\\nconst int m=1e9+7;\\nclass Solution {\\npublic:\\n    vector<int>POW;\\n    void init(int n)\\n    {\\n        POW.clear();\\n        POW.push_back(1);\\n        for(int i=1;i<=n;i++){\\n            int temp=POW[i-1]*2;\\n            temp%=m;\\n            POW.push_back(temp);\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            POW[i]=(POW[i-1]%m+POW[i]%m)%m;\\n        }\\n    }\\n    int mul(long long int a,long long int b)\\n    {\\n        return ((a%m)*(b%m))%m;\\n    }\\n    int sumSubseqWidths(vector<int>& A) {\\n        int n=A.size();\\n        init(n);\\n        sort(A.begin(),A.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int less=i-1;\\n            int more=n-i-2;\\n            int temp=0;\\n            if(less>=0)\\n            {\\n                temp=mul(POW[less],A[i]);\\n            }\\n            if(more>=0)\\n            {\\n                temp=(temp%m+((-1*mul(POW[more],A[i]))%m+m)%m)%m;\\n            }\\n            ans=(ans%m+temp%m)%m;            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nconst int m=1e9+7;\\nclass Solution {\\npublic:\\n    vector<int>POW;\\n    void init(int n)\\n    {\\n        POW.clear();\\n        POW.push_back(1);\\n        for(int i=1;i<=n;i++){\\n            int temp=POW[i-1]*2;\\n            temp%=m;\\n            POW.push_back(temp);\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            POW[i]=(POW[i-1]%m+POW[i]%m)%m;\\n        }\\n    }\\n    int mul(long long int a,long long int b)\\n    {\\n        return ((a%m)*(b%m))%m;\\n    }\\n    int sumSubseqWidths(vector<int>& A) {\\n        int n=A.size();\\n        init(n);\\n        sort(A.begin(),A.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int less=i-1;\\n            int more=n-i-2;\\n            int temp=0;\\n            if(less>=0)\\n            {\\n                temp=mul(POW[less],A[i]);\\n            }\\n            if(more>=0)\\n            {\\n                temp=(temp%m+((-1*mul(POW[more],A[i]))%m+m)%m)%m;\\n            }\\n            ans=(ans%m+temp%m)%m;            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974489,
                "title": "java-o-n-logn",
                "content": "```\\nclass Solution {\\n    //1-6 (number of elements in between 1 and 6) = (6-1-1) = 4  \\n    //length of sub seq 2 -> 4C0 3 -> 4C1 ; 4 -> 4c2 ; 5 -> 4C3  6 -> 4C4  4c0 + 4c1 + 4c2 + 4c3 + 4c4 1+4+6+4+1=16\\n    //1-5 3c0 + 3c1 + 3c2 + 3c3  = 8 \\n    //1-4 2c0 + 2c1 2c2 = 4\\n    //1-3 1c0 + 1c1  = 2\\n    //1-2 1c0 = 1\\n    \\n    /*16+8+4+2+1(for 1 as min) 8+4+2+1(for 2 as min)  4+2+1(for 3 as min)  2+1(for 4 as min)  1(for 5 as min)  \\n    -1*nums[0]*31 + nums[1]*1 + nums[2]*2 + nums[3]*4 + nums[4]*8 + nums[5]*16\\n        -1*nums[1]*15 + nums[2]*1 +nums[3]*2 + nums[4]*4 + nums[5]*8\\n        -1*nums[2]*7 + nums[3]*1 + nums[4]*2 + nums[5]*4\\n        -1*nums[3]*3 + nums[4]*1 + nums[5]*2\\n        -1*nums[4]*1 + nums[5]*1\\n        \\n        -nums[0]*31 + -nums[1]*15 - nums[2]*7 - nums[3]*3 - nums[4]*1\\n        nums[1]*1 + nums[2]*3 + nums[3]*7 + nums[4]*15 + nums[5]*31\\n    \\n    (-1)*nums[0]*(pow[6-1-0]-1) + (-1)*nums[1]*(pow[6-1-1]-1) + (-1)*nums[2]*(pow[6-1-2]-1)\\n    ... (-1)* nums[5]*(pow[6-1-5]-1)  \\n    + nums[1]*(pow[1]-1) + nums[2]*(pow[2]-1) + .... + nums[5]*(pow[5]-1)\\n    \\n    (-1)*A[i]*(pow[l-1-i]-1) + A[i]*(pow[i]-1)        \\n*/\\n    public int sumSubseqWidths(int[] A) {\\n        int MOD = 1_000_000_007;\\n        Arrays.sort(A);\\n        int l = A.length;\\n        long[] pow = new long[l];\\n        pow[0]=1;\\n        for(int i=1;i<l;i++){\\n            pow[i]=pow[i-1]*2 % MOD;\\n        }\\n        long res = 0;\\n        for(int i=0;i<l;i++){\\n            res = (res + (-1)*A[i]*(pow[l-1-i]-1) + A[i]*(pow[i]-1))%MOD;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //1-6 (number of elements in between 1 and 6) = (6-1-1) = 4  \\n    //length of sub seq 2 -> 4C0 3 -> 4C1 ; 4 -> 4c2 ; 5 -> 4C3  6 -> 4C4  4c0 + 4c1 + 4c2 + 4c3 + 4c4 1+4+6+4+1=16\\n    //1-5 3c0 + 3c1 + 3c2 + 3c3  = 8 \\n    //1-4 2c0 + 2c1 2c2 = 4\\n    //1-3 1c0 + 1c1  = 2\\n    //1-2 1c0 = 1\\n    \\n    /*16+8+4+2+1(for 1 as min) 8+4+2+1(for 2 as min)  4+2+1(for 3 as min)  2+1(for 4 as min)  1(for 5 as min)  \\n    -1*nums[0]*31 + nums[1]*1 + nums[2]*2 + nums[3]*4 + nums[4]*8 + nums[5]*16\\n        -1*nums[1]*15 + nums[2]*1 +nums[3]*2 + nums[4]*4 + nums[5]*8\\n        -1*nums[2]*7 + nums[3]*1 + nums[4]*2 + nums[5]*4\\n        -1*nums[3]*3 + nums[4]*1 + nums[5]*2\\n        -1*nums[4]*1 + nums[5]*1\\n        \\n        -nums[0]*31 + -nums[1]*15 - nums[2]*7 - nums[3]*3 - nums[4]*1\\n        nums[1]*1 + nums[2]*3 + nums[3]*7 + nums[4]*15 + nums[5]*31\\n    \\n    (-1)*nums[0]*(pow[6-1-0]-1) + (-1)*nums[1]*(pow[6-1-1]-1) + (-1)*nums[2]*(pow[6-1-2]-1)\\n    ... (-1)* nums[5]*(pow[6-1-5]-1)  \\n    + nums[1]*(pow[1]-1) + nums[2]*(pow[2]-1) + .... + nums[5]*(pow[5]-1)\\n    \\n    (-1)*A[i]*(pow[l-1-i]-1) + A[i]*(pow[i]-1)        \\n*/\\n    public int sumSubseqWidths(int[] A) {\\n        int MOD = 1_000_000_007;\\n        Arrays.sort(A);\\n        int l = A.length;\\n        long[] pow = new long[l];\\n        pow[0]=1;\\n        for(int i=1;i<l;i++){\\n            pow[i]=pow[i-1]*2 % MOD;\\n        }\\n        long res = 0;\\n        for(int i=0;i<l;i++){\\n            res = (res + (-1)*A[i]*(pow[l-1-i]-1) + A[i]*(pow[i]-1))%MOD;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669883,
                "title": "java-my-solution-with-explanation-runs-in-o-n-log-n-time-fermat-s-little-theorem",
                "content": "Let\\'s fix `i`-th element and `j`-th element in array.  The difference is `max(A[i], A[j]) - min(A[i], A[j])`. How many times do we need to add it? If there exist such an element `A[k]` with property `min(A[i], A[j]) <= A[k] <= max(A[i], A[j])` then we can place it in between and our difference will remains the same.\\nLet\\'s sort the array. Then it can be proven that there exist exactly `2 ^ (j - i)` such selections of numbers `k` where `i < j` (we can decide to place number in between or not to place it. This gives us 2 possibilities per such `k`. If there exist `n` such `k` numbers then we have `2 ^ n` possibilities to place some set of them). Now our time complexity is `O(n ^ 2)`. But it\\'s now enought to solve it.\\nWe can express our computations as following: \\n* `answer = sum((a[j] - a[i]) * 2 ^ (j - i))`\\n* `answer = (2^j - 1) * a[j] - (a[j - 1] * 2 ^ 0 + a[j - 2] * 2 ^ 1 + a[j - 3] * 2 ^ 2) `\\n\\nLet `prefix[i] = a[0] * 2^ (n - 1) + a[1] * 2 ^ (n - 2) + a[2] * 2 ^ (n - 3) + ... + a[i] * 2 ^ (n - i - 1)`. We can transform `prefix[3]` to `a[0] * 2 ^ 2 + a[1] * 2 ^ 1 + a[2] * 2 ^ 0` by dividing `prefix[i]` on `2 ^ (n - i - 1)`.\\n\\n* `answer = (2^j - 1) * a[j] - prefix[j-1] / 2 ^ (n - j)`\\n\\nSuch division is possible on Python, Ruby, but in Java we can\\'t divide because all our numbers are remainder by division on `MOD`. Common solution to do the division is [Fermat\\'s little theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem). \\n\\n* `2 ^ -(n - j) = 2 ^ (MOD - (n - j) - 1) % MOD`\\n\\n```\\nclass Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n    \\n    public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        \\n        int n = A.length;\\n        int[] bitsMod = calculateBits(n);\\n        long[] prefixSum = new long[n];\\n        \\n        long answer = 0;\\n        long divisor = power(power(2, MOD - 2), n);\\n        for (int i = 0; i < n; i++) {\\n            prefixSum[i] = i == 0 ? 0 : prefixSum[i-1];\\n            prefixSum[i] = (prefixSum[i] + (long) bitsMod[n - i - 1] * A[i]) % MOD;\\n            \\n            if (i > 0) {\\n                long multiplier = bitsMod[i] - 1;\\n                if (multiplier < 0) multiplier = MOD - 1;\\n                \\n                long firstTerm = A[i] * multiplier % MOD;\\n                long secondTerm = prefixSum[i - 1] * divisor % MOD;\\n                answer = (answer + firstTerm - secondTerm) % MOD;\\n                \\n                if (answer < 0) {\\n                    answer += MOD;\\n                }\\n            }\\n            \\n            divisor = (divisor * 2) % MOD;\\n        }\\n        \\n        return (int) answer;\\n    }\\n    \\n    private int[] calculateBits(int n) {\\n        int[] bits = new int[n];\\n        bits[0] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            bits[i] = (bits[i-1] << 1) % MOD;\\n        }\\n        \\n        return bits;\\n    }\\n    \\n    private long power(long a, long b) {\\n        if (b == 0) {\\n            return 1;\\n        }\\n        \\n        if (b % 2 == 0) {\\n            return power(a * a % MOD, b / 2);\\n        } else {\\n            return a * power(a, b - 1) % MOD;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n    \\n    public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        \\n        int n = A.length;\\n        int[] bitsMod = calculateBits(n);\\n        long[] prefixSum = new long[n];\\n        \\n        long answer = 0;\\n        long divisor = power(power(2, MOD - 2), n);\\n        for (int i = 0; i < n; i++) {\\n            prefixSum[i] = i == 0 ? 0 : prefixSum[i-1];\\n            prefixSum[i] = (prefixSum[i] + (long) bitsMod[n - i - 1] * A[i]) % MOD;\\n            \\n            if (i > 0) {\\n                long multiplier = bitsMod[i] - 1;\\n                if (multiplier < 0) multiplier = MOD - 1;\\n                \\n                long firstTerm = A[i] * multiplier % MOD;\\n                long secondTerm = prefixSum[i - 1] * divisor % MOD;\\n                answer = (answer + firstTerm - secondTerm) % MOD;\\n                \\n                if (answer < 0) {\\n                    answer += MOD;\\n                }\\n            }\\n            \\n            divisor = (divisor * 2) % MOD;\\n        }\\n        \\n        return (int) answer;\\n    }\\n    \\n    private int[] calculateBits(int n) {\\n        int[] bits = new int[n];\\n        bits[0] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            bits[i] = (bits[i-1] << 1) % MOD;\\n        }\\n        \\n        return bits;\\n    }\\n    \\n    private long power(long a, long b) {\\n        if (b == 0) {\\n            return 1;\\n        }\\n        \\n        if (b % 2 == 0) {\\n            return power(a * a % MOD, b / 2);\\n        } else {\\n            return a * power(a, b - 1) % MOD;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451179,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        l=len(A)\\n        res=0\\n        for i in range(l):\\n            res+=(A[i]<<i)-(A[i]<<(l-i-1))\\n        return res%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        l=len(A)\\n        res=0\\n        for i in range(l):\\n            res+=(A[i]<<i)-(A[i]<<(l-i-1))\\n        return res%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374028,
                "title": "bucket-sort-o-n-max-a-detailed-intuition",
                "content": "I will first give the intuition, then the solution using Sort, and then the solution using bucket Sort.\\n\\nThe intuition for this problem is pretty much the same as [sum of subarray minimums](https://leetcode.com/problems/sum-of-subarray-minimums/), where we compute the contribution of each A[i] to the result. (No worries if you haven\\'t yet seen that problem)\\n\\nThe first idea is to notice that  `sumWidths = sum(max - min) = sumMaxs - sumMins`\\n\\nFor [2, 4, 3], we have these subsequences: `[2], [4], [3], [2, 3], [2, 4], [4, 3], [2, 4, 3]`.\\n`3` will show up as maximum in 2 subsequences: `[3], [2, 3]` => So We add `3`*2 to sumMaxs.\\nAnd then as minimum in 2 subsequences: `[3], [4, 3]` => We add `3`*2 to sumMins.\\n\\nNow we can focus on how we can efficiently compute the number of contributions of an A[i] to sumMins (computing sumMaxs is similar)\\n\\nFor example in [1, 2, 4, 3], 2 appears as minimum in these subsequences:\\n`{2}, {2, 3}, {2, 4}, {2, 4, 3}`\\n\\nDiscarding the 2 from these subsequences we get: `{}, {3}, {4}, {3, 4}`.\\nThese are the *subsets* of {3, 4} !\\n\\nThe number of appearances of 2 in sumMins = the number of subsets of the set of elements higher than it\\nThe number of subsets of a set with size N is 2^N.\\n\\nSimilarly, the number of appearances of 2 in sumMaxs = the number of subsets of the set of elements smaller than it.\\n\\nThere is a small detail with duplicates, for a subsequence like [2, 2, 3, 4] we need to make sure we add 2 *once and only once* to sumMins\\n\\nThe first attempt to compute the number of elements higher and less than A[i] is to iterate over A for each i. This will have O(N^2) time complexity.\\nIf we sort the array the number of elements greater than A[i] is len(A)-i-1 and the number of elements smaller is i, which are computed in constant time.\\n\\nOrdering the array doesn\\'t have any effect on the result because min(A) = min(Sorted(A)) and max(A) = max(Sorted(A))\\n\\nDuplicates will be handled automatically when we sort.\\n\\nSo the overall time complexity is O(NlogN)\\n\\n```python\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n\\tdef nb_sets(size):\\n\\t\\treturn 1<<size\\n\\tA.sort()\\n\\tsumWidths = 0\\n\\tfor i, num in enumerate(A):\\n\\t\\tsumWidths += nb_sets(i)*num - nb_sets(len(A)-i-1)*num\\n\\treturn sumWidths % 1000000007\\n```\\n\\nNow, because max(A) is in the order of N like mentioned in the description, we can use bucket sort instead !\\nIn each bucket i we have the number of occurences of i in A.\\nWe maintain a variable `nbSmallerElements` that cumulates the count of numbers.\\n\\n```python\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n\\tdef nb_sets(size):\\n\\t\\treturn 1<<size\\n\\t\\t\\n\\tbuckets = [0]*(max(A)+1)\\n\\tfor num in A:\\n\\t\\tbuckets[num] += 1\\n\\n\\tsumWidths, nbSmallerElements = 0, 0\\n\\tfor num in range(len(buckets)):\\n\\t\\tfor _ in range(buckets[num]):\\n\\t\\t\\tsumWidths += nb_sets(nbSmallerElements)*num - nb_sets(len(A)-nbSmallerElements-1)*num\\n\\t\\t\\tnbSmallerElements += 1\\n\\treturn sumWidths % 1000000007\\n```\\n\\nThe time complexity is O(N+max(A)).",
                "solutionTags": [],
                "code": "```python\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n\\tdef nb_sets(size):\\n\\t\\treturn 1<<size\\n\\tA.sort()\\n\\tsumWidths = 0\\n\\tfor i, num in enumerate(A):\\n\\t\\tsumWidths += nb_sets(i)*num - nb_sets(len(A)-i-1)*num\\n\\treturn sumWidths % 1000000007\\n```\n```python\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n\\tdef nb_sets(size):\\n\\t\\treturn 1<<size\\n\\t\\t\\n\\tbuckets = [0]*(max(A)+1)\\n\\tfor num in A:\\n\\t\\tbuckets[num] += 1\\n\\n\\tsumWidths, nbSmallerElements = 0, 0\\n\\tfor num in range(len(buckets)):\\n\\t\\tfor _ in range(buckets[num]):\\n\\t\\t\\tsumWidths += nb_sets(nbSmallerElements)*num - nb_sets(len(A)-nbSmallerElements-1)*num\\n\\t\\t\\tnbSmallerElements += 1\\n\\treturn sumWidths % 1000000007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161275,
                "title": "mathematical-sequence-problem-related-to-subsets",
                "content": "This is a mathematical sequence problem related to subsets. Obviously the order does not matter so we sort the numbers. Then for any two numbers with index i and j, ```0 <= i < j < n```, there are 2^(j-i-1) subsets with the same max-min difference. A naive approach to try all (i,j) pair would be O(N^2) time but we can optimize by calculating the coefficiences of each number linearly which leads to solution with O(N*log(N)) time complexcity.\\n\\nSpecifically by looking at all subsets with a[0] be the min/max number, the coefficient for a[0] is ```k[0] = -(2^0 + 2^1 + ... + 2^(n-2))=1-2^(n-1)```, by looking at all subsets with a[0] be the min/max number, coefficient for a[1] is ```k[1]=2^0-(2^0+2^1+...+2^(n-3)) = k[0]+2^0+2^(n-2)``` and in general ```k[i]=k[i-1]+2^(i-1)+2^(n-i-1)```. Code below:\\n\\n```\\n    public static int sumSubseqWidths(int[] A) {\\n        final long mod = 1000000007L;\\n        Arrays.sort(A);\\n        int n = A.length;\\n        // calculate power of 2 modular MOD\\n        long[] mp = new long[n];\\n        mp[0] = 1;\\n        for (int i = 1; i < n; i++) mp[i] = (mp[i-1] * 2) % mod;\\n        // calculate coefficients for each number\\n        long[] k = new long[n];\\n        k[0] = (1 + mod - mp[n-1]) % mod;\\n        for (int i = 1; i < n; i++) {\\n            k[i] = (k[i-1] + mp[i-1] + mp[n-i-1]) % mod;\\n        }\\n        // calculate total sum.\\n        long output = 0;\\n        for (int i = 0; i < n; i++) {\\n            output += k[i] * A[i];\\n        }\\n        return (int) (output % mod);\\n    }",
                "solutionTags": [],
                "code": "```0 <= i < j < n```\n```k[0] = -(2^0 + 2^1 + ... + 2^(n-2))=1-2^(n-1)```\n```k[1]=2^0-(2^0+2^1+...+2^(n-3)) = k[0]+2^0+2^(n-2)```\n```k[i]=k[i-1]+2^(i-1)+2^(n-i-1)```",
                "codeTag": "Unknown"
            },
            {
                "id": 161272,
                "title": "891-sum-of-subsequence-widths-c-sort-and-math-with-brief-explanation",
                "content": "1. Sort the array, because we need to know the largest number and smallest number for each pair.\\n2. \\tFor pair A[i] and A[j],they can have 2^(j - i - 1) different subsequence(s) in the array, which means that you can insert 2^(j - i - 1) possibilities and the largest and smallest values are A[j] and A[i].\\n3. \\tMath: For the length of k, k is the distance of max number A[j] and min number A[i]\\nand k = j - i\\nk = 1: A[1] - A[0], A[2] - A[1] ....., A[n-1] - A[n-2], sum all of them: which is just A[n-1] - A[0]\\nso: generally, for length k, the sum of withds are:\\nA[n-1] + A[n-2] + .... + A[n-k] - A[0] - A[1] - ... - A[k - 1]\\nso we can use S to store the sum at every step.\\n\\n\\n\\n\\t\\n\\t\\n\\n\\n\\n\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint sumSubseqWidths(vector<int>& A) {\\n\\t\\t\\t\\t\\t\\tint MOD = 1000000007;\\n\\t\\t\\t\\t\\t\\tsort(A.begin(), A.end());\\n\\t\\t\\t\\t\\t\\tint n = A.size();\\n\\t\\t\\t\\t\\t\\tvector<long> vec(n, 1);\\n\\t\\t\\t\\t\\t\\tfor(int i = 1; i < n; ++i){\\n\\t\\t\\t\\t\\t\\t\\t\\tvec[i] = vec[i-1]*2 % MOD;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\t\\t\\tint i = n-1;\\n\\t\\t\\t\\t\\t\\tint S = 0;\\n\\t\\t\\t\\t\\t\\tfor(int len = 1; len < n; ++len){\\n\\t\\t\\t\\t\\t\\t\\t\\tS = S + A[i] - A[n - 1 - i];\\n\\t\\t\\t\\t\\t\\t\\t\\tres = (res + S * vec[len - 1] % MOD) % MOD;\\n\\t\\t\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint sumSubseqWidths(vector<int>& A) {\\n\\t\\t\\t\\t\\t\\tint MOD = 1000000007;\\n\\t\\t\\t\\t\\t\\tsort(A.begin(), A.end());\\n\\t\\t\\t\\t\\t\\tint n = A.size();\\n\\t\\t\\t\\t\\t\\tvector<long> vec(n, 1);\\n\\t\\t\\t\\t\\t\\tfor(int i = 1; i < n; ++i){\\n\\t\\t\\t\\t\\t\\t\\t\\tvec[i] = vec[i-1]*2 % MOD;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4073740,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    long MOD=1000000007;\\n    public int sumSubseqWidths(int[] nums) {\\n        int i=0;\\n        int j=nums.length-1;\\n        long multi=1;\\n        long width=0;\\n        Arrays.sort(nums);\\n        while(i<nums.length&&j>=0){\\n            width=(width+nums[i]*multi-nums[j]*multi)%MOD;\\n            multi=(multi*2)%MOD;\\n            i++;\\n            j--;\\n        }\\n        return (int)width;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    int power(long long a,long long b){\\n        long long res = 1;\\n        while(b){\\n            if(b&1) res = (res * a) % mod;\\n            b = b >> 1;\\n            a = (a * a) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> suffix(n);\\n        for(int i=0,weight=1;i<n;i++){\\n            suffix[i] = (weight*1LL*nums[i]) % mod;\\n            weight = (weight * 2LL) % mod;\\n        }\\n\\n        for(int i=n-2;i>=0;i--) suffix[i] = (suffix[i] + suffix[i+1]) % mod;\\n        \\n        long long expanse = 0LL;\\n        for(int i=0;i<n-1;i++){\\n            long long diff = ( (suffix[i+1]%mod) * power(power(2,i+1),mod-2)%mod) % mod - (nums[i]*1LL*(power(2,n-i-1)-1)%mod);\\n            expanse = (expanse + diff + mod) % mod;\\n        }\\n        return expanse;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = val = 0 \\n        p = 1\\n        for i in range(1, len(nums)): \\n            p = p * 2 % MOD\\n            val = (2*val + (nums[i]-nums[i-1])*(p-1)) % MOD \\n            ans = (ans + val) % MOD \\n        return ans \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    long MOD=1000000007;\\n    public int sumSubseqWidths(int[] nums) {\\n        int i=0;\\n        int j=nums.length-1;\\n        long multi=1;\\n        long width=0;\\n        Arrays.sort(nums);\\n        while(i<nums.length&&j>=0){\\n            width=(width+nums[i]*multi-nums[j]*multi)%MOD;\\n            multi=(multi*2)%MOD;\\n            i++;\\n            j--;\\n        }\\n        return (int)width;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    int power(long long a,long long b){\\n        long long res = 1;\\n        while(b){\\n            if(b&1) res = (res * a) % mod;\\n            b = b >> 1;\\n            a = (a * a) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> suffix(n);\\n        for(int i=0,weight=1;i<n;i++){\\n            suffix[i] = (weight*1LL*nums[i]) % mod;\\n            weight = (weight * 2LL) % mod;\\n        }\\n\\n        for(int i=n-2;i>=0;i--) suffix[i] = (suffix[i] + suffix[i+1]) % mod;\\n        \\n        long long expanse = 0LL;\\n        for(int i=0;i<n-1;i++){\\n            long long diff = ( (suffix[i+1]%mod) * power(power(2,i+1),mod-2)%mod) % mod - (nums[i]*1LL*(power(2,n-i-1)-1)%mod);\\n            expanse = (expanse + diff + mod) % mod;\\n        }\\n        return expanse;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = val = 0 \\n        p = 1\\n        for i in range(1, len(nums)): \\n            p = p * 2 % MOD\\n            val = (2*val + (nums[i]-nums[i-1])*(p-1)) % MOD \\n            ans = (ans + val) % MOD \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924148,
                "title": "python-solution-less-than-10-lines-faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe input size is large so we find an approach that accumulates the answer at the position `i` with the information from the position `i-1`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort `nums` and compute the answer from the smallest to the largest. \\nAt `i` (`nums[0] < nums[1] < ... < nums[i]`), we define $$A_i$$ as the sum of widths of all the subsequences of `nums[0:i]` that ends at `i`. \\n\\n$$A_i = \\\\sum_{j=0}^{i-1}\\\\left( A_j + 2^j (\\\\textrm{nums}[i] - \\\\textrm{nums}[j])\\\\right) = A_{i-1} + \\\\delta_i$$\\n\\nwhere $$\\\\delta_i = \\\\sum_{j=0}^{i-1}2^j (\\\\textrm{nums}[i] - \\\\textrm{nums}[j])$$ that be defined in a recursive way as follows: \\n\\n$$ \\\\delta_i = \\\\delta_{i-1} + \\\\sum_{k=0}^{i-1}2^k (\\\\textrm{nums}[i] - \\\\textrm{nums}[i-1]) $$\\n\\nIn this way, we can maintain $$A_i$$ and $$\\\\delta_i$$ iteractively and obtain the final solution in linear time. \\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$ for sorting\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Only $$O(1)$$ extra memory\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = delta = 0\\n        accu_k = k = 1\\n        for u, v in zip(nums, nums[1:]):\\n            delta = (delta + accu_k * (v - u)) % 1000000007 \\n            ans = (ans + ans + delta) % 1000000007\\n            k = (k * 2) % 1000000007\\n            accu_k = (accu_k + k) % 1000000007\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = delta = 0\\n        accu_k = k = 1\\n        for u, v in zip(nums, nums[1:]):\\n            delta = (delta + accu_k * (v - u)) % 1000000007 \\n            ans = (ans + ans + delta) % 1000000007\\n            k = (k * 2) % 1000000007\\n            accu_k = (accu_k + k) % 1000000007\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885067,
                "title": "cpp-amazon-most-asked-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n         sort(nums.begin(),nums.end());\\n    vector<long>p(n,0);\\n    p[0]=1;\\n    for(int i=1;i<n;i++){\\n        p[i]=(p[i-1]*2) % (1000000007);\\n    }\\n      \\n        for(int i=0;i<n;i++){\\n            ans=(ans+nums[i]*(p[i]-p[n-i-1])) % (1000000007);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n         sort(nums.begin(),nums.end());\\n    vector<long>p(n,0);\\n    p[0]=1;\\n    for(int i=1;i<n;i++){\\n        p[i]=(p[i-1]*2) % (1000000007);\\n    }\\n      \\n        for(int i=0;i<n;i++){\\n            ans=(ans+nums[i]*(p[i]-p[n-i-1])) % (1000000007);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866425,
                "title": "easy-to-understand-java-solution",
                "content": "class Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans=0;\\n        long mod=1000000007;\\n        int n=nums.length;\\n        long[] pow=new long[n];\\n        pow[0]=1;\\n\\n        for(int i=1;i<n;i++){\\n            pow[i]=(pow[i-1]*2)%mod;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            ans+=nums[i]*pow[i];\\n            ans-=nums[i]*pow[n-i-1];\\n            ans=ans%mod;\\n        }\\n\\n        return (int) ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans=0;\\n        long mod=1000000007;\\n        int n=nums.length;\\n        long[] pow=new long[n];\\n        pow[0]=1;\\n\\n        for(int i=1;i<n;i++){\\n            pow[i]=(pow[i-1]*2)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3820577,
                "title": "dp",
                "content": "\\n# Code\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        mod = 10**9 + 7\\n\\n        # Calculate powers of 2 modulo mod\\n        powers_of_2 = [1]\\n        for i in range(1, n):\\n            powers_of_2.append((powers_of_2[-1] * 2) % mod)\\n\\n        # Calculate the sum of widths\\n        ans = 0\\n        for i in range(n):\\n            ans = (ans + nums[i] * (powers_of_2[i] - powers_of_2[n-i-1])) % mod\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        mod = 10**9 + 7\\n\\n        # Calculate powers of 2 modulo mod\\n        powers_of_2 = [1]\\n        for i in range(1, n):\\n            powers_of_2.append((powers_of_2[-1] * 2) % mod)\\n\\n        # Calculate the sum of widths\\n        ans = 0\\n        for i in range(n):\\n            ans = (ans + nums[i] * (powers_of_2[i] - powers_of_2[n-i-1])) % mod\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804670,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    int power(long long a,long long b){\\n        long long res = 1;\\n        while(b){\\n            if(b&1) res = (res * a) % mod;\\n            b = b >> 1;\\n            a = (a * a) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> suffix(n);\\n        for(int i=0,weight=1;i<n;i++){\\n            suffix[i] = (weight*1LL*nums[i]) % mod;\\n            weight = (weight * 2LL) % mod;\\n        }\\n\\n        for(int i=n-2;i>=0;i--) suffix[i] = (suffix[i] + suffix[i+1]) % mod;\\n        \\n        long long expanse = 0LL;\\n        for(int i=0;i<n-1;i++){\\n            long long diff = ( (suffix[i+1]%mod) * power(power(2,i+1),mod-2)%mod) % mod - (nums[i]*1LL*(power(2,n-i-1)-1)%mod);\\n            expanse = (expanse + diff + mod) % mod;\\n        }\\n        return expanse;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    int power(long long a,long long b){\\n        long long res = 1;\\n        while(b){\\n            if(b&1) res = (res * a) % mod;\\n            b = b >> 1;\\n            a = (a * a) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> suffix(n);\\n        for(int i=0,weight=1;i<n;i++){\\n            suffix[i] = (weight*1LL*nums[i]) % mod;\\n            weight = (weight * 2LL) % mod;\\n        }\\n\\n        for(int i=n-2;i>=0;i--) suffix[i] = (suffix[i] + suffix[i+1]) % mod;\\n        \\n        long long expanse = 0LL;\\n        for(int i=0;i<n-1;i++){\\n            long long diff = ( (suffix[i+1]%mod) * power(power(2,i+1),mod-2)%mod) % mod - (nums[i]*1LL*(power(2,n-i-1)-1)%mod);\\n            expanse = (expanse + diff + mod) % mod;\\n        }\\n        return expanse;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626631,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def sumSubseqWidths(nums: Array[Int]): Int = {\\n      val twoPower = Array.ofDim[Long](nums.length)\\n      val mod = 1000000007L\\n      twoPower(0) = 1\\n      for (i <- 1 until nums.length) twoPower(i) = (twoPower(i - 1) * 2) % mod\\n      val effective = Array.ofDim[Long](nums.length)\\n      for (i <- nums.indices) effective(i) = twoPower(i) - twoPower(nums.length - i - 1)\\n      val sorted= nums.sorted\\n      var ans = 0L\\n      for (i <- nums.indices) ans = (ans + effective(i) * sorted(i)) % mod\\n      ans.toInt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def sumSubseqWidths(nums: Array[Int]): Int = {\\n      val twoPower = Array.ofDim[Long](nums.length)\\n      val mod = 1000000007L\\n      twoPower(0) = 1\\n      for (i <- 1 until nums.length) twoPower(i) = (twoPower(i - 1) * 2) % mod\\n      val effective = Array.ofDim[Long](nums.length)\\n      for (i <- nums.indices) effective(i) = twoPower(i) - twoPower(nums.length - i - 1)\\n      val sorted= nums.sorted\\n      var ans = 0L\\n      for (i <- nums.indices) ans = (ans + effective(i) * sorted(i)) % mod\\n      ans.toInt\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3453393,
                "title": "easy-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nPhase-1-> ans=0+(1-3)*1\\n          ans=-2%kmod\\n          exp=1*2%kmod\\nPhase-2-> ans=(-2)+(2-2)*2\\n          ans=-2%kmod\\n          exp=2*2%kmod\\nPhase-3-> ans=(-2)+(3-1)*4\\n          ans=6%kmod\\n          exp=4*2%kmod \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        kMod = 10**9+7\\n        n = len(nums)\\n        ans = 0\\n        exp = 1\\n        nums.sort()\\n        for i in range(n):\\n            ans += (nums[i] - nums[n - i - 1]) * exp\\n            ans %= kMod\\n            exp = exp * 2 % kMod\\n        return ans\\n\\n\\n    # pass only 19 test cases occer TLE problem\\n         result = [[]]\\n         for i in nums:\\n             n = len(result)\\n             for j in range(n):\\n                 r = result[j] + [i]\\n                 result.append(r)        \\n         s=[]\\n         for i in result[1:]:\\n             a=max(i)\\n             b=min(i)\\n             s.append(a-b)\\n         return sum(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        kMod = 10**9+7\\n        n = len(nums)\\n        ans = 0\\n        exp = 1\\n        nums.sort()\\n        for i in range(n):\\n            ans += (nums[i] - nums[n - i - 1]) * exp\\n            ans %= kMod\\n            exp = exp * 2 % kMod\\n        return ans\\n\\n\\n    # pass only 19 test cases occer TLE problem\\n         result = [[]]\\n         for i in nums:\\n             n = len(result)\\n             for j in range(n):\\n                 r = result[j] + [i]\\n                 result.append(r)        \\n         s=[]\\n         for i in result[1:]:\\n             a=max(i)\\n             b=min(i)\\n             s.append(a-b)\\n         return sum(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393106,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        LL M = 1e9 + 7 ;\\n        int n = nums.size() ;\\n        sort(nums.begin(), nums.end()) ;\\n        vector<LL>pow(n) ;\\n        pow[0] = 1 ;\\n        for(int i = 1; i < n; i++){\\n            pow[i] = (pow[i-1]*2) % M ;\\n        }\\n        \\n        LL sum = 0 ;\\n        for(int i = n-1; i >= 0; i--){\\n            sum = (sum + nums[i] * pow[i]%M) % M ;\\n            sum = (sum - nums[i] * pow[n-1-i]%M + M) % M ;\\n        }\\n        return sum ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        LL M = 1e9 + 7 ;\\n        int n = nums.size() ;\\n        sort(nums.begin(), nums.end()) ;\\n        vector<LL>pow(n) ;\\n        pow[0] = 1 ;\\n        for(int i = 1; i < n; i++){\\n            pow[i] = (pow[i-1]*2) % M ;\\n        }\\n        \\n        LL sum = 0 ;\\n        for(int i = n-1; i >= 0; i--){\\n            sum = (sum + nums[i] * pow[i]%M) % M ;\\n            sum = (sum - nums[i] * pow[n-1-i]%M + M) % M ;\\n        }\\n        return sum ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384340,
                "title": "c-simple-and-explained-solution-o-n-log-n-sort-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nafter sorting we just have to figure out how many subsequences will be there in which a particular number will be maximum and other  minimum\\nhowever our final ans will be=diff1 x (no of subsequence whose width is this max and min are same) + diff2 x n2 + diff3 x n3+...\\nNow, this can be expanded into\\nans=max1(no. of subseq. in which max1 is maximum)+max2xn2+...-min1 x (n1) - min2*(n2)-...    ..eq 1(say)\\nas ...+diff(i)*(n)+..=...+(max(i)-min(i)) x (n)+..\\n=..+max(i)xn-min(i)xn+...\\nnow separating positive and negative terms will give us eqn 1.\\nnow in a sorted array\\narr[0],arr[1],...,arr[i],..arr[j],..arr[n-1]\\nstarting from arr[1]->arr[n-1] calculating how many subsequences can be there where these will be the maximum \\nno of subsequences in which arr[i] can be the maximum = no. of subsequences  that can end at arr[i] and containing zero or more elements smaller than this for ith index no of elements smaller than this i =c(i,0) + c(i,1)+c(i,2)+..+c(i,i)=2^i - 1\\nnow using this formula we can evaluate no of subsequences in which arr[i] will be maximum and add the max_i x (ni) to ans\\nand similarly for minimums in reverse fashion from n-2 -> 0 subsequences will contain elements afyer this ith element (>=arr[i])\\nans-=min_i*(n_i);\\nreturn this ans\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorting + maths\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n x log(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n\\n\\n**PLS UPVOTE IF IT HELPED**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        long long ans=0;\\n        int m=1e9+7;\\n        sort(nums.begin(),nums.end());\\n        long long pre=0;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            pre=2*pre+1;\\n            pre%=m;\\n            ans-=nums[i]*(pre);\\n            ans%=m;\\n        }\\n        pre=0;\\n        for(int i=1;i<nums.size();i++){\\n            pre=2*pre+1;\\n            pre%=m;\\n            ans+=nums[i]*(pre);\\n            ans%=m;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        long long ans=0;\\n        int m=1e9+7;\\n        sort(nums.begin(),nums.end());\\n        long long pre=0;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            pre=2*pre+1;\\n            pre%=m;\\n            ans-=nums[i]*(pre);\\n            ans%=m;\\n        }\\n        pre=0;\\n        for(int i=1;i<nums.size();i++){\\n            pre=2*pre+1;\\n            pre%=m;\\n            ans+=nums[i]*(pre);\\n            ans%=m;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294924,
                "title": "basic-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        int n= nums.size();\\n        int i;\\n        int j = n-1;\\n        sort(nums.begin(), nums.end());\\n        long long int m=1;\\n        long long int x = 1e9+7;\\n        int result =0;\\n        for(int i=0; i<n; i++)\\n        {\\n            result = (result + m*nums[i] - m*nums[j])%x;\\n            m = (m*2)%x;\\n            j--;\\n        }\\n        return (int)result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        int n= nums.size();\\n        int i;\\n        int j = n-1;\\n        sort(nums.begin(), nums.end());\\n        long long int m=1;\\n        long long int x = 1e9+7;\\n        int result =0;\\n        for(int i=0; i<n; i++)\\n        {\\n            result = (result + m*nums[i] - m*nums[j])%x;\\n            m = (m*2)%x;\\n            j--;\\n        }\\n        return (int)result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195161,
                "title": "o-max-time-complexity-counting-sort-python",
                "content": "Since the range of numbers are small, we can sort number in ```O(n)``` time complexity with counting sort.\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = int(1e9 + 7)\\n        mx = max(nums)\\n        cnt = [0] * (mx + 1)\\n        for num in nums:\\n            cnt[num] += 1\\n        \\n        smaller = [0] + list(accumulate(cnt))\\n        greater = list(accumulate(cnt[::-1]))[::-1] + [0]\\n\\n        ans = 0\\n        nums = set(nums)\\n        for num in nums:\\n            ans += (pow(2, smaller[num], mod) - pow(2, greater[num + 1], mod)) * (pow(2, cnt[num], mod) - 1) * num\\n            ans %= mod\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```O(n)```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = int(1e9 + 7)\\n        mx = max(nums)\\n        cnt = [0] * (mx + 1)\\n        for num in nums:\\n            cnt[num] += 1\\n        \\n        smaller = [0] + list(accumulate(cnt))\\n        greater = list(accumulate(cnt[::-1]))[::-1] + [0]\\n\\n        ans = 0\\n        nums = set(nums)\\n        for num in nums:\\n            ans += (pow(2, smaller[num], mod) - pow(2, greater[num + 1], mod)) * (pow(2, cnt[num], mod) - 1) * num\\n            ans %= mod\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184377,
                "title": "java-current-element-effect",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    long[] power;\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        power = new long[len];\\n        initPower();\\n        long ans = 0;\\n        for (int i = 0; i < len; i++) {\\n            ans = (ans + (nums[i] * effect(i, len)) % mod) % mod;\\n        }\\n        return (int)ans % mod;\\n    }\\n\\n    private long effect(int curr, int len) {\\n        long plus = power[curr];\\n        long minus = power[len - curr - 1];\\n        return (plus - minus + mod) % mod;\\n    }\\n    private void initPower() {\\n        power[0] = 1;\\n        for (int i = 1; i < power.length; i ++)\\n            power[i] = (2 * power[i-1]) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    long[] power;\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        power = new long[len];\\n        initPower();\\n        long ans = 0;\\n        for (int i = 0; i < len; i++) {\\n            ans = (ans + (nums[i] * effect(i, len)) % mod) % mod;\\n        }\\n        return (int)ans % mod;\\n    }\\n\\n    private long effect(int curr, int len) {\\n        long plus = power[curr];\\n        long minus = power[len - curr - 1];\\n        return (plus - minus + mod) % mod;\\n    }\\n    private void initPower() {\\n        power[0] = 1;\\n        for (int i = 1; i < power.length; i ++)\\n            power[i] = (2 * power[i-1]) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178235,
                "title": "solve-on-paper-first-for-sorted-array",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        M = 10 ** 9 + 7\\n        n = len(nums)\\n        nums.sort()\\n        res = 0\\n        powt = [1] * (n + 1)\\n        for i in range(1, n + 1):\\n            powt[i] = 2 * powt[i - 1]\\n            powt[i] %= M\\n        res = 0\\n        for i in range(n):\\n            res += nums[i] * (powt[i] - 1)\\n            res -= nums[i] * (powt[n - i - 1] - 1)\\n            res %= M\\n        return (M + res) % M\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        M = 10 ** 9 + 7\\n        n = len(nums)\\n        nums.sort()\\n        res = 0\\n        powt = [1] * (n + 1)\\n        for i in range(1, n + 1):\\n            powt[i] = 2 * powt[i - 1]\\n            powt[i] %= M\\n        res = 0\\n        for i in range(n):\\n            res += nums[i] * (powt[i] - 1)\\n            res -= nums[i] * (powt[n - i - 1] - 1)\\n            res %= M\\n        return (M + res) % M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166228,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nExpression can  be broken down to\\n```\\nsum of widths of all subsequences = sum of maximuns of all subsequences - sum of minimums of all subsequences.\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCounting contribution of each number to wanted expression, i.e. number of subsequences in which number is maximum or minimum.\\nOther details in code comments\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*log(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n  public int sumSubseqWidths(int[] nums) {\\n    // For N numbers there are 2^N subsequences (either take or don\\'t the next element for N elements)\\n    //\\n    // Rearranging wanted expression we get to:\\n    //    \\n    //    -> Sum of subsequence widths = Sum of subsequence max - (Sum of subsequence mins)\\n    //\\n    // For each number n in nums, find the number of subsequences in \\n    // which n is the maximum, and the number of subsequences in which\\n    // n is the minimum.\\n    //                                                   pows: [ 1, 2, 4]\\n    // E.g. nums = [3, -1, 7], sorting the array for easily counting: [-1, 3, 7]\\n    //\\n    // From the 2^3 = 8 subsequences, how -1 contributes? It is the maximum of 1 (2\\u2070) sequences,\\n    // and the minimum of 4 (2\\xB2)\\n    //\\n    // How 3 contribues? It is the maximum of 2 sequences (2\\xB9) and minimum of 2 sequences (2\\xB9)\\n    //\\n    // how 7 contributes? It is the maximum of 4 sequences (2\\xB2) and minimum of 1 (2\\u2070) \\n    //\\n    // Sum of maximums: -1 * 1 + 3 * 2 + 7 * 4\\n    // Sum of minimums: -1 * 4 + 3 * 2 + 7 * 1\\n    // ----------------------------------------\\n    //                  -1 * (-3) + 7 * 3         = 3 + 21 = 24 \\n    //\\n    //\\n    //\\n    //\\n    // Also notice some modulo properties:\\n    //\\n    // (a + b) % c = ((a % c) + b) % c\\n    // (a * b) % c = ((a % c) * b) % c\\n    //\\n    //\\n    long mod = 1000000007;\\n    int n = nums.length;\\n    long[] pow = new long[n];\\n    pow[0] = 1;\\n    for (int i = 1; i < n; i ++)\\n      pow[i] = (2 * pow[i-1]) % mod;\\n    Arrays.sort(nums);\\n    int ans = 0;\\n    for (int i = 0; i < n; i++) {\\n      // number of subsequences in which nums[i] is the maximum\\n      long largest = pow[i];\\n      // number of subsequences in which nums[i] is the minimum\\n      long smallest = pow[n-i-1];\\n      // Contribution of nums[i] = largest * nums[i] - smallest * nums[i]\\n      //                         = (largest - smallest) * nums[i]\\n      ans = (int) ((ans + (nums[i] * (largest - smallest) % mod) % mod) % mod);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nsum of widths of all subsequences = sum of maximuns of all subsequences - sum of minimums of all subsequences.\\n```\n```\\nclass Solution {\\n\\n\\n  public int sumSubseqWidths(int[] nums) {\\n    // For N numbers there are 2^N subsequences (either take or don\\'t the next element for N elements)\\n    //\\n    // Rearranging wanted expression we get to:\\n    //    \\n    //    -> Sum of subsequence widths = Sum of subsequence max - (Sum of subsequence mins)\\n    //\\n    // For each number n in nums, find the number of subsequences in \\n    // which n is the maximum, and the number of subsequences in which\\n    // n is the minimum.\\n    //                                                   pows: [ 1, 2, 4]\\n    // E.g. nums = [3, -1, 7], sorting the array for easily counting: [-1, 3, 7]\\n    //\\n    // From the 2^3 = 8 subsequences, how -1 contributes? It is the maximum of 1 (2\\u2070) sequences,\\n    // and the minimum of 4 (2\\xB2)\\n    //\\n    // How 3 contribues? It is the maximum of 2 sequences (2\\xB9) and minimum of 2 sequences (2\\xB9)\\n    //\\n    // how 7 contributes? It is the maximum of 4 sequences (2\\xB2) and minimum of 1 (2\\u2070) \\n    //\\n    // Sum of maximums: -1 * 1 + 3 * 2 + 7 * 4\\n    // Sum of minimums: -1 * 4 + 3 * 2 + 7 * 1\\n    // ----------------------------------------\\n    //                  -1 * (-3) + 7 * 3         = 3 + 21 = 24 \\n    //\\n    //\\n    //\\n    //\\n    // Also notice some modulo properties:\\n    //\\n    // (a + b) % c = ((a % c) + b) % c\\n    // (a * b) % c = ((a % c) * b) % c\\n    //\\n    //\\n    long mod = 1000000007;\\n    int n = nums.length;\\n    long[] pow = new long[n];\\n    pow[0] = 1;\\n    for (int i = 1; i < n; i ++)\\n      pow[i] = (2 * pow[i-1]) % mod;\\n    Arrays.sort(nums);\\n    int ans = 0;\\n    for (int i = 0; i < n; i++) {\\n      // number of subsequences in which nums[i] is the maximum\\n      long largest = pow[i];\\n      // number of subsequences in which nums[i] is the minimum\\n      long smallest = pow[n-i-1];\\n      // Contribution of nums[i] = largest * nums[i] - smallest * nums[i]\\n      //                         = (largest - smallest) * nums[i]\\n      ans = (int) ((ans + (nums[i] * (largest - smallest) % mod) % mod) % mod);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093598,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 10**9+7\\n        ans = 0 \\n        for i, x in enumerate(sorted(nums)): \\n            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))\\n        return ans % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 10**9+7\\n        ans = 0 \\n        for i, x in enumerate(sorted(nums)): \\n            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))\\n        return ans % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912273,
                "title": "my-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        long c = 1, res = 0, mod = (long)1e9 + 7;\\n        for (int i = 0, n = A.length; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (int)((res + mod) % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        long c = 1, res = 0, mod = (long)1e9 + 7;\\n        for (int i = 0, n = A.length; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (int)((res + mod) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864499,
                "title": "beats-95-6-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long a = 1;\\n        long res = 0;\\n        long mod = (long) 1e9 + 7;\\n        for(int i = 0; i < nums.length; ++i, a = (a * 2) % mod) res = (res + nums[i] * a - nums[nums.length - i - 1] * a) % mod;\\n        return (int) ((res + mod) % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long a = 1;\\n        long res = 0;\\n        long mod = (long) 1e9 + 7;\\n        for(int i = 0; i < nums.length; ++i, a = (a * 2) % mod) res = (res + nums[i] * a - nums[nums.length - i - 1] * a) % mod;\\n        return (int) ((res + mod) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839381,
                "title": "math-dp",
                "content": "# Code\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        nums.sort()\\n\\n        dp = [0] * n\\n\\n        p = 2\\n        temp = nums[0]\\n\\n        for i in range(1, n):\\n            dp[i] = ((dp[i-1] + ((p-1)*nums[i])%MOD)%MOD - temp)%MOD\\n            p = (2*p)%MOD\\n            temp = ((2*temp)%MOD + nums[i])%MOD\\n        \\n        return dp[n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        nums.sort()\\n\\n        dp = [0] * n\\n\\n        p = 2\\n        temp = nums[0]\\n\\n        for i in range(1, n):\\n            dp[i] = ((dp[i-1] + ((p-1)*nums[i])%MOD)%MOD - temp)%MOD\\n            p = (2*p)%MOD\\n            temp = ((2*temp)%MOD + nums[i])%MOD\\n        \\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839218,
                "title": "rust-version",
                "content": "# Code\\nCredit: https://leetcode.com/problems/sum-of-subsequence-widths/solutions/2791666/c-easy-shorts/\\n```\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn sum_subseq_widths(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n\\n        let mut c = 1;\\n        let mut result: i64 = 0;\\n        let n = nums.len();\\n\\n        for i in 0..n {\\n            result = (result + nums[i] as i64 * c - nums[n - i - 1] as i64 * c) % MOD;\\n            c = c * 2 % MOD;\\n        }\\n\\n        ((result + MOD) % MOD) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn sum_subseq_widths(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n\\n        let mut c = 1;\\n        let mut result: i64 = 0;\\n        let n = nums.len();\\n\\n        for i in 0..n {\\n            result = (result + nums[i] as i64 * c - nums[n - i - 1] as i64 * c) % MOD;\\n            c = c * 2 % MOD;\\n        }\\n\\n        ((result + MOD) % MOD) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2825898,
                "title": "python-solution-math-property-faster-than-98-time-o-nlog-space-o-1",
                "content": "\\tclass Solution:\\n\\t\\tdef sumSubseqWidths(self, nums: List[int]) -> int:\\n\\t\\t\\tk_mod = 10**9 + 7\\n\\t\\t\\tnums.sort()\\n\\t\\t\\tnums_len = len(nums)\\n\\n\\t\\t\\tp = 2**0\\n\\t\\t\\tres = 0 \\n\\t\\t\\tfor i in range(nums_len): \\n\\t\\t\\t\\tres += (nums[i] - nums[nums_len-i-1])*p % k_mod\\n\\t\\t\\t\\tp = (p<<1) % k_mod\\n\\t\\t\\treturn res % k_mod        \\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sumSubseqWidths(self, nums: List[int]) -> int:\\n\\t\\t\\tk_mod = 10**9 + 7\\n\\t\\t\\tnums.sort()\\n\\t\\t\\tnums_len = len(nums)\\n\\n\\t\\t\\tp = 2**0\\n\\t\\t\\tres = 0 \\n\\t\\t\\tfor i in range(nums_len): \\n\\t\\t\\t\\tres += (nums[i] - nums[nums_len-i-1])*p % k_mod\\n\\t\\t\\t\\tp = (p<<1) % k_mod\\n\\t\\t\\treturn res % k_mod        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2724415,
                "title": "javascript-sort-and-one-traversal",
                "content": "```\\nvar sumSubseqWidths = function(nums) {\\n    nums.sort((b, a) => b - a);\\n\\n    let sumOfWidths = 0, mod = 1000000007;\\n\\n    for (let i = 0, nCr = 1; i < nums.length; i++) {\\n        sumOfWidths = (sumOfWidths + nCr * (nums[i] - nums[nums.length - 1 - i]) % mod) % mod;\\n        nCr = (nCr << 1) % mod;\\n    }\\n\\n    return sumOfWidths;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar sumSubseqWidths = function(nums) {\\n    nums.sort((b, a) => b - a);\\n\\n    let sumOfWidths = 0, mod = 1000000007;\\n\\n    for (let i = 0, nCr = 1; i < nums.length; i++) {\\n        sumOfWidths = (sumOfWidths + nCr * (nums[i] - nums[nums.length - 1 - i]) % mod) % mod;\\n        nCr = (nCr << 1) % mod;\\n    }\\n\\n    return sumOfWidths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589963,
                "title": "reminder-subsequences-with-same-elements-in-same-order-are-different",
                "content": "For [1,2,2], if we ignore the dublicate, here are all subsequences, [1], [2], [2], [1,2], [1,2], [1,2,2]. \\n0+0+0+1+1+1 = 3\\nWe get the answer is 3.\\n[1,2] and [1,2] are treated as different sequence in this problem.",
                "solutionTags": [],
                "code": "For [1,2,2], if we ignore the dublicate, here are all subsequences, [1], [2], [2], [1,2], [1,2], [1,2,2]. \\n0+0+0+1+1+1 = 3\\nWe get the answer is 3.\\n[1,2] and [1,2] are treated as different sequence in this problem.",
                "codeTag": "Unknown"
            },
            {
                "id": 2589520,
                "title": "c-the-most-complicated-solution",
                "content": "```cpp\\n#define all(x) begin(x), end(x)\\n#define has(c, x) (c.find(x) != c.end())\\n#define vec vector\\n#define umap unordered_map\\n#define uset unordered_set\\n#define valid(i, j, m, n) (i >= 0 && i < m && j >= 0 && j < n)\\n\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\ntemplate <typename T> T &amax(T &a, const T &b) { return a = max(a, b); }\\n\\nusing ll = long long;\\nusing pii = pair<int, int>;\\nusing pll = pair<ll, ll>;\\nusing vi = vec<int>;\\nusing vvi = vec<vec<int>>;\\nusing vvvi = vec<vec<vec<int>>>;\\nusing vl = vec<ll>;\\nusing vvl = vec<vec<ll>>;\\nusing vs = vec<string>;\\nusing vvs = vec<vec<string>>;\\nusing vpii = vec<pii>;\\nusing vvpii = vec<vec<pii>>;\\nusing tiii = tuple<int, int, int>;\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, -1, 1, 0, -1, 1, -1, 1};\\nconstexpr int MXN = (int)1e6;\\nconstexpr int INF = (int)1e9 + 15;\\nconstexpr ll INFL = ll(1e18) + 15;\\nconstexpr double EPS = 1e-9;\\nconstexpr int P = 31;\\nconstexpr int P2 = 33;\\nconstexpr int M = (int)1e9 + 7;\\nconstexpr int M2 = (int)1e9 + 9;\\n\\nconstexpr ll binpow(ll a, ll b, ll m) {\\n  a %= m;\\n  ll res = 1;\\n  while (b > 0) {\\n    if (b & 1)\\n      res = res * a % m;\\n    a = a * a % m;\\n    b >>= 1;\\n  }\\n  return res;\\n}\\nconstexpr int extended_gcd(int a, int b, int &x, int &y) {\\n  x = 1, y = 0;\\n  int x1 = 0, y1 = 1, a1 = a, b1 = b;\\n  while (b1) {\\n    int q = a1 / b1;\\n    tie(x, x1) = make_tuple(x1, x - q * x1);\\n    tie(y, y1) = make_tuple(y1, y - q * y1);\\n    tie(a1, b1) = make_tuple(b1, a1 - q * b1);\\n  }\\n  return a1;\\n}\\n\\nclass Solution {\\npublic:\\n  int sumSubseqWidths(vector<int> &nums) {\\n    map<int, int> mp;\\n    for (int v : nums) {\\n      mp[v]++;\\n    }\\n    vpii p(all(mp));\\n    int n = p.size();\\n\\n    ll ans = 0, res = 0, between_subsets = 1, subsets_cnt = 0;\\n    for (int i = 1; i < n; i++) {\\n      ll diff = p[i].first - p[0].first;\\n      ll left_subsets = binpow(2, p[0].second, M) - 1;\\n      ll right_subsets = binpow(2, p[i].second, M) - 1;\\n      ll end_subsets = (left_subsets * right_subsets) % M;\\n\\n      res += (diff * (end_subsets * between_subsets) % M) % M;\\n      res %= M;\\n\\n      subsets_cnt += (end_subsets * between_subsets) % M;\\n      subsets_cnt %= M;\\n\\n      between_subsets *= right_subsets + 1;\\n      between_subsets %= M;\\n    }\\n    for (int i = 0; i < n - 1; i++) {\\n      ans += res;\\n      ans %= M;\\n\\n      ll diff = p[i + 1].first - p[i].first;\\n      ll left_subsets = binpow(2, p[i].second, M) - 1;\\n      ll right_subsets = binpow(2, p[i + 1].second, M) - 1;\\n\\n      res -= (diff * (left_subsets * right_subsets) % M) % M;\\n      res = (res % M + M) % M;\\n      subsets_cnt -= (left_subsets * right_subsets) % M;\\n      subsets_cnt = (subsets_cnt % M + M) % M;\\n\\n      ll k = n - i - 2;\\n      ll remove = (k * (left_subsets * (right_subsets + 1) % M) % M) % M;\\n      int inv_remove, y;\\n      extended_gcd(remove, M, inv_remove, y);\\n      inv_remove = (inv_remove % M + M) % M;\\n\\n      res *= inv_remove;\\n      res %= M;\\n      res *= (k * right_subsets) % M;\\n      res %= M;\\n\\n      subsets_cnt *= inv_remove;\\n      subsets_cnt %= M;\\n      subsets_cnt *= (k * right_subsets) % M;\\n      subsets_cnt %= M;\\n\\n      res -= (subsets_cnt * diff) % M;\\n      res = (res % M + M) % M;\\n    }\\n    return ans;\\n  }\\n};\\n#endif\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```cpp\\n#define all(x) begin(x), end(x)\\n#define has(c, x) (c.find(x) != c.end())\\n#define vec vector\\n#define umap unordered_map\\n#define uset unordered_set\\n#define valid(i, j, m, n) (i >= 0 && i < m && j >= 0 && j < n)\\n\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\ntemplate <typename T> T &amax(T &a, const T &b) { return a = max(a, b); }\\n\\nusing ll = long long;\\nusing pii = pair<int, int>;\\nusing pll = pair<ll, ll>;\\nusing vi = vec<int>;\\nusing vvi = vec<vec<int>>;\\nusing vvvi = vec<vec<vec<int>>>;\\nusing vl = vec<ll>;\\nusing vvl = vec<vec<ll>>;\\nusing vs = vec<string>;\\nusing vvs = vec<vec<string>>;\\nusing vpii = vec<pii>;\\nusing vvpii = vec<vec<pii>>;\\nusing tiii = tuple<int, int, int>;\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, -1, 1, 0, -1, 1, -1, 1};\\nconstexpr int MXN = (int)1e6;\\nconstexpr int INF = (int)1e9 + 15;\\nconstexpr ll INFL = ll(1e18) + 15;\\nconstexpr double EPS = 1e-9;\\nconstexpr int P = 31;\\nconstexpr int P2 = 33;\\nconstexpr int M = (int)1e9 + 7;\\nconstexpr int M2 = (int)1e9 + 9;\\n\\nconstexpr ll binpow(ll a, ll b, ll m) {\\n  a %= m;\\n  ll res = 1;\\n  while (b > 0) {\\n    if (b & 1)\\n      res = res * a % m;\\n    a = a * a % m;\\n    b >>= 1;\\n  }\\n  return res;\\n}\\nconstexpr int extended_gcd(int a, int b, int &x, int &y) {\\n  x = 1, y = 0;\\n  int x1 = 0, y1 = 1, a1 = a, b1 = b;\\n  while (b1) {\\n    int q = a1 / b1;\\n    tie(x, x1) = make_tuple(x1, x - q * x1);\\n    tie(y, y1) = make_tuple(y1, y - q * y1);\\n    tie(a1, b1) = make_tuple(b1, a1 - q * b1);\\n  }\\n  return a1;\\n}\\n\\nclass Solution {\\npublic:\\n  int sumSubseqWidths(vector<int> &nums) {\\n    map<int, int> mp;\\n    for (int v : nums) {\\n      mp[v]++;\\n    }\\n    vpii p(all(mp));\\n    int n = p.size();\\n\\n    ll ans = 0, res = 0, between_subsets = 1, subsets_cnt = 0;\\n    for (int i = 1; i < n; i++) {\\n      ll diff = p[i].first - p[0].first;\\n      ll left_subsets = binpow(2, p[0].second, M) - 1;\\n      ll right_subsets = binpow(2, p[i].second, M) - 1;\\n      ll end_subsets = (left_subsets * right_subsets) % M;\\n\\n      res += (diff * (end_subsets * between_subsets) % M) % M;\\n      res %= M;\\n\\n      subsets_cnt += (end_subsets * between_subsets) % M;\\n      subsets_cnt %= M;\\n\\n      between_subsets *= right_subsets + 1;\\n      between_subsets %= M;\\n    }\\n    for (int i = 0; i < n - 1; i++) {\\n      ans += res;\\n      ans %= M;\\n\\n      ll diff = p[i + 1].first - p[i].first;\\n      ll left_subsets = binpow(2, p[i].second, M) - 1;\\n      ll right_subsets = binpow(2, p[i + 1].second, M) - 1;\\n\\n      res -= (diff * (left_subsets * right_subsets) % M) % M;\\n      res = (res % M + M) % M;\\n      subsets_cnt -= (left_subsets * right_subsets) % M;\\n      subsets_cnt = (subsets_cnt % M + M) % M;\\n\\n      ll k = n - i - 2;\\n      ll remove = (k * (left_subsets * (right_subsets + 1) % M) % M) % M;\\n      int inv_remove, y;\\n      extended_gcd(remove, M, inv_remove, y);\\n      inv_remove = (inv_remove % M + M) % M;\\n\\n      res *= inv_remove;\\n      res %= M;\\n      res *= (k * right_subsets) % M;\\n      res %= M;\\n\\n      subsets_cnt *= inv_remove;\\n      subsets_cnt %= M;\\n      subsets_cnt *= (k * right_subsets) % M;\\n      subsets_cnt %= M;\\n\\n      res -= (subsets_cnt * diff) % M;\\n      res = (res % M + M) % M;\\n    }\\n    return ans;\\n  }\\n};\\n#endif\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557241,
                "title": "c-solution-with-explanation",
                "content": "The idea is to count in how many subsets an element will be minimum and maximum, by summing all the values will give the answer.\\n\\nFor an elements A_i to be minimum in a subset, all the elements in the subset must be greater or equal to A_i, and for it to be maximum all the elements in the subset must be lesser or equal to A_i. \\n\\nTo obtain the number of subsets that are possible with A_i as minimum, we can sort the whole array, and if for any element index at i, all the numbers above will be greater and all the subsets that can be formed with those elements have minimum >= i_th element, if we add a_i to every set that is possible with the elements greater than a_i will always be minimum in those sets. And similarly we can do for i_th element to be maximum by looking at number of elements in below it. \\n\\nThus, the contribution of A_i(0-indexing), in a sorted array, to the whole sum is \\n (2^i)*A_i - 2^(n-i-1)*A_i\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll mod = 1e9+7;\\n    ll power(ll x, ll y , ll mod) {\\n        ll ans = 1;\\n        while (y) {\\n            if (y&1) ans = (ans*x)%mod;\\n            x = (x*x)%mod;\\n            y/=2;\\n        }\\n        return ans;\\n    }\\n    int sumSubseqWidths(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        ll ans = 0, n = nums.size();\\n        for (int i = 0; i < n;i++) {\\n            ans = (ans + power(2, i,mod)*nums[i] - power(2,n-1-i,mod)*nums[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll mod = 1e9+7;\\n    ll power(ll x, ll y , ll mod) {\\n        ll ans = 1;\\n        while (y) {\\n            if (y&1) ans = (ans*x)%mod;\\n            x = (x*x)%mod;\\n            y/=2;\\n        }\\n        return ans;\\n    }\\n    int sumSubseqWidths(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        ll ans = 0, n = nums.size();\\n        for (int i = 0; i < n;i++) {\\n            ans = (ans + power(2, i,mod)*nums[i] - power(2,n-1-i,mod)*nums[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553573,
                "title": "java-solution-runtime-734-ms-faster-than-5-21-of-java-online-submissions",
                "content": "class Solution {\\n     //inbuilt power function wont work for hard test so implement custom power function with Tc - logn\\n   static long pow(int A, int B, int C){\\n\\n    //Base condition for recursive call\\n        //Base condition for recursive call\\n        long num  = A;\\n        if(B == 0)\\n\\t\\t{\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n        long square_number = pow((int)num, B/2 , C);\\n\\t\\tlong power_square = (square_number  * square_number ) % C;\\n\\t\\tpower_square=(power_square+C)%C;\\n\\n        if(B % 2 == 0)\\n\\t\\t{\\n\\t\\t\\treturn power_square;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t    power_square=((num * power_square)+C)%C;\\n\\t\\t\\treturn (power_square);\\n\\t\\t}\\n\\n    }\\n    public int sumSubseqWidths(int[] nums) {\\n        \\n         int mod=1000000007;\\n        //Collections.sort(A);\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n\\n        long max = 0;\\n        long min = 0;\\n\\n        for(int i = 0 ; i < nums.length ; i++)\\n        {\\n            max = ((max + (long)nums[n-i-1] * pow(2 , n-i-1 , mod)) % mod);\\n            min = ((min + (long)nums[i] * pow(2 , n-i-1 , mod)) % mod);\\n        }\\n\\n        return (int)(max-min+mod)%mod; \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n     //inbuilt power function wont work for hard test so implement custom power function with Tc - logn\\n   static long pow(int A, int B, int C){\\n\\n    //Base condition for recursive call\\n        //Base condition for recursive call\\n        long num  = A;\\n        if(B == 0)\\n\\t\\t{\\n\\t\\t\\treturn 1;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2535420,
                "title": "c-math-problem",
                "content": "First sort the array. Then for each index i. \\narr[i] is the maximum number of any subsqeuence of [0, 1, ...i]\\narr[i] is the minimum number of any subsequence of [i, i+1,... n-1]\\nSo we just count the # of appearances of arr[i] as the minimum number and as the maximum number.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll big = 1e9 + 7;\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> pow(n+1, 1);\\n        for(int i=1; i<n+1; ++i) pow[i] = (pow[i-1] * 2) % big;\\n        \\n        sort(nums.begin(), nums.end());\\n        ll ans = 0;\\n        for(int i=0; i<n; ++i) {\\n            ll pos = pow[i] - 1, neg = pow[n-1-i] - 1;\\n            ans = (ans + (pos - neg) * nums[i]) % big; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll big = 1e9 + 7;\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> pow(n+1, 1);\\n        for(int i=1; i<n+1; ++i) pow[i] = (pow[i-1] * 2) % big;\\n        \\n        sort(nums.begin(), nums.end());\\n        ll ans = 0;\\n        for(int i=0; i<n; ++i) {\\n            ll pos = pow[i] - 1, neg = pow[n-1-i] - 1;\\n            ans = (ans + (pos - neg) * nums[i]) % big; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373322,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        int MOD = (int)1e9 + 7;\\n        Arrays.sort(nums);\\n        \\n        long ans = 0;\\n        long p = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            ans = (ans + p * nums[i] - p * nums[nums.length - 1 - i]) % MOD;\\n            p = (p * 2) % MOD;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        int MOD = (int)1e9 + 7;\\n        Arrays.sort(nums);\\n        \\n        long ans = 0;\\n        long p = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            ans = (ans + p * nums[i] - p * nums[nums.length - 1 - i]) % MOD;\\n            p = (p * 2) % MOD;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370250,
                "title": "short-trick-to-remove-integer-overflow-c",
                "content": "```\\n int mod=1000000007;\\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        //Step 1--> Sort krke ans nikalna is same as normally ans nikalna as at the end hmse max-min pucha hai 4 8 3 ka b (max-min) same hoga aur 3 4 8 ka bhi..\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        long long power2[n];\\n        power2[0]=1;\\n        \\n        //Step 2--> Power 2 bohat bdi bn skti hai as n=10^5 so mod krte chalo and bar bar krna na pde to 2^i ko store krte chalo array me \\n        for(int i=1;i<n;i++)\\n        power2[i]=(power2[i-1]*2)%mod;\\n            \\n        long long sum=0;\\n        \\n         //Step 3 --> VERY VERY IMPORTANT TO REMOVE OVERFLOW --> sum=sum+(xyz) means long long variable pehle likhdiya to overflow nahi hoga long long dominate kr jayega int ko \\n        for(int i=0;i<n;i++)\\n            sum=(sum+nums[i]*(power2[i]-power2[n-i-1]))%mod;  //sum+= nahi chlega yaha pe \\n\\n        return sum%mod;       \\n    }",
                "solutionTags": [],
                "code": "```\\n int mod=1000000007;\\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        //Step 1--> Sort krke ans nikalna is same as normally ans nikalna as at the end hmse max-min pucha hai 4 8 3 ka b (max-min) same hoga aur 3 4 8 ka bhi..\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        long long power2[n];\\n        power2[0]=1;\\n        \\n        //Step 2--> Power 2 bohat bdi bn skti hai as n=10^5 so mod krte chalo and bar bar krna na pde to 2^i ko store krte chalo array me \\n        for(int i=1;i<n;i++)\\n        power2[i]=(power2[i-1]*2)%mod;\\n            \\n        long long sum=0;\\n        \\n         //Step 3 --> VERY VERY IMPORTANT TO REMOVE OVERFLOW --> sum=sum+(xyz) means long long variable pehle likhdiya to overflow nahi hoga long long dominate kr jayega int ko \\n        for(int i=0;i<n;i++)\\n            sum=(sum+nums[i]*(power2[i]-power2[n-i-1]))%mod;  //sum+= nahi chlega yaha pe \\n\\n        return sum%mod;       \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2359247,
                "title": "java-sorting",
                "content": "```\\nclass Solution {\\n    long MOD=1000000007;\\n    public int sumSubseqWidths(int[] nums) {\\n        int i=0;\\n        int j=nums.length-1;\\n        long multi=1;\\n        long width=0;\\n        Arrays.sort(nums);\\n        while(i<nums.length&&j>=0){\\n            width=(width+nums[i]*multi-nums[j]*multi)%MOD;\\n            multi=(multi*2)%MOD;\\n            i++;\\n            j--;\\n        }\\n        return (int)width;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    long MOD=1000000007;\\n    public int sumSubseqWidths(int[] nums) {\\n        int i=0;\\n        int j=nums.length-1;\\n        long multi=1;\\n        long width=0;\\n        Arrays.sort(nums);\\n        while(i<nums.length&&j>=0){\\n            width=(width+nums[i]*multi-nums[j]*multi)%MOD;\\n            multi=(multi*2)%MOD;\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2357334,
                "title": "java-prefix-sum-o-nlogn",
                "content": "I now understand this is not the optimal solution but I am sharing it regardless. \\n- Sort the array first because the order doesn\\'t matter.\\n\\n- Consider each index ending in `i` being the max element, there are `[0, i-1]` min element choice, with each choice giving some `2^j` where `j` is the gap between the min and the max element.\\n\\n- Now Consider the whole array. If we fixed \"gap\", we will realize that for each specific gap `j`, the contribution of it is the suffix sum - prefix sum of the same size.\\n\\n#### Java \\n```Java\\n// Time O(nlogn)\\n// Space O(n)\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length, two = 1, ans = 0, M = (int)1e9+7;\\n        long[] pre = new long[n];\\n        for (int i = 0; i < n; i++){\\n            pre[i] = i == 0? nums[i] : nums[i] + pre[i-1];\\n        }\\n        for (int i = 1; i < n; i++){\\n            long g = pre[n-1] - pre[i-1]; // suffix sum\\n            long l = pre[n-1-i]; // prefix sum\\n            ans += two * (g-l) % M; // contribution of the current gap.\\n            ans %= M;\\n            two = 2*two%M;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\n// Time O(nlogn)\\n// Space O(n)\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length, two = 1, ans = 0, M = (int)1e9+7;\\n        long[] pre = new long[n];\\n        for (int i = 0; i < n; i++){\\n            pre[i] = i == 0? nums[i] : nums[i] + pre[i-1];\\n        }\\n        for (int i = 1; i < n; i++){\\n            long g = pre[n-1] - pre[i-1]; // suffix sum\\n            long l = pre[n-1-i]; // prefix sum\\n            ans += two * (g-l) % M; // contribution of the current gap.\\n            ans %= M;\\n            two = 2*two%M;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355112,
                "title": "easy-c-solution-with-explanation",
                "content": "Observations-\\n1- Since we need to find sum of width (difference between largest and smallest element) so the sequence of elements doesn\\'t matter.\\n2- sorting array to make things easier\\n\\nExample - [1,2,3,4]\\n\\nNow problem is boil down to find number of subsequence ends with an element (that element will be greater in that subsequences ) and number of subsequence starts with an element (that element will be smaller in that subsequences )\\n\\nlet say element 2\\nsubsequences ends with 2 => [1,2] [2]  (2 subsquences )\\nsubsequences starts with 2 => [2] [2,3] [2,4] [2,3,4] (4 subsquences)\\n\\ncontribution of these subsqences width in answer  can be calculated by ( 2* 4 - 2 * 2 )\\n\\n\\n\\n`````\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int mod=1e9+7;\\n        int n=nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<int>pow(n,1);\\n        pow[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            pow[i]=(pow[i-1]*2)%mod;\\n        }\\n        \\n        long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=(ans+1ll*nums[i]*(pow[i]-pow[n-i-1]))%mod;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int mod=1e9+7;\\n        int n=nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<int>pow(n,1);\\n        pow[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            pow[i]=(pow[i-1]*2)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2355044,
                "title": "sum-of-subsequence-widths",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        //sorting the array so we can easily get max and min as width=max-min\\n        Arrays.sort(nums);\\n        long ans=0;\\n        int n=nums.length;\\n        long mod=1000000007;    //answer can go beyond int range so mod it to come it in range\\n        \\n        long[] pow=new long[n];     //array to store power of 2\\n        \\n        pow[0]=1;   //power of 2^0==1 \\n\\n        \\n        //use to store power of 2\\n        //2^0,2^1,2^2....\\n        //we store power of two as we need total no of subsequence and to find no. of subsequence of n digit is 2^n\\n        for(int i=1;i<n;i++){\\n           pow[i]=(2*pow[i-1])%mod;\\n        }\\n        \\n        \\n        //width==max-min\\n        //n-i-1 for count of left element and then take the power of 2 from pow array which store power of 2\\n        for(int i=0;i<n;i++){\\n            //for ith element we have to find no of subsequence till me and no of subsequence after ith element \\n            //ith element can be in maximum element in previous subsequence and min in next subsequence as array is sorted\\n            //so as we already store power of 2 in pow array we just need count of element till prevoius and after i to               //last element , so we can take no of subsequence from pow\\n            //width=max*subsequence-min*subsequence\\n            ans=(ans+nums[i]*pow[i]-nums[i]*pow[n-i-1])%mod;\\n            System.out.println(ans);\\n            \\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n}\\n//1 2 3\\n//1 2 4\\n//0+1-1*4==-3\\n//-3+2*2-2*2==-3\\n//-3+3*4-3*1==-3+12-3=6\\n```\\nif have any query i will suggest you to go through this video \\nhttps://www.youtube.com/watch?v=kSo8W6ZGYqw",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        //sorting the array so we can easily get max and min as width=max-min\\n        Arrays.sort(nums);\\n        long ans=0;\\n        int n=nums.length;\\n        long mod=1000000007;    //answer can go beyond int range so mod it to come it in range\\n        \\n        long[] pow=new long[n];     //array to store power of 2\\n        \\n        pow[0]=1;   //power of 2^0==1 \\n\\n        \\n        //use to store power of 2\\n        //2^0,2^1,2^2....\\n        //we store power of two as we need total no of subsequence and to find no. of subsequence of n digit is 2^n\\n        for(int i=1;i<n;i++){\\n           pow[i]=(2*pow[i-1])%mod;\\n        }\\n        \\n        \\n        //width==max-min\\n        //n-i-1 for count of left element and then take the power of 2 from pow array which store power of 2\\n        for(int i=0;i<n;i++){\\n            //for ith element we have to find no of subsequence till me and no of subsequence after ith element \\n            //ith element can be in maximum element in previous subsequence and min in next subsequence as array is sorted\\n            //so as we already store power of 2 in pow array we just need count of element till prevoius and after i to               //last element , so we can take no of subsequence from pow\\n            //width=max*subsequence-min*subsequence\\n            ans=(ans+nums[i]*pow[i]-nums[i]*pow[n-i-1])%mod;\\n            System.out.println(ans);\\n            \\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n}\\n//1 2 3\\n//1 2 4\\n//0+1-1*4==-3\\n//-3+2*2-2*2==-3\\n//-3+3*4-3*1==-3+12-3=6\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311848,
                "title": "python-users-pow-2-i-function-is-slow",
                "content": "Either use ```<<``` or construct the power array manually. I found that constructing the pow2 array as in the solution is the fastest",
                "solutionTags": [],
                "code": "```<<```",
                "codeTag": "Unknown"
            },
            {
                "id": 2229984,
                "title": "o-nlog-n-time-complexity",
                "content": "```\\nclass Solution {\\n    private : int mod=pow(10,9)+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<long long >size(A.size(),0);\\n        vector<long long >sum(A.size(),0);\\n        long long  real=0;\\n        size[0]=1;\\n        sum[0]=A[0];\\n        vector<long long >temp(A.size(),0);\\n        \\n        for(int i=1;i<A.size();i++){\\n            real=((A[i]*size[i-1])%mod-sum[i-1]+mod)%mod;\\n            temp[i]=real;\\n            size[i]=(2*size[i-1]+1)%mod;\\n            sum[i]=( (sum[i-1]+sum[i-1])%mod+A[i]+mod)%mod;\\n            \\n        }\\n        real=0;\\n        for(int i=0;i<temp.size();i++){\\n            real=(real+temp[i]+mod)%mod;\\n        }\\n        \\n        return real;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    private : int mod=pow(10,9)+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<long long >size(A.size(),0);\\n        vector<long long >sum(A.size(),0);\\n        long long  real=0;\\n        size[0]=1;\\n        sum[0]=A[0];\\n        vector<long long >temp(A.size(),0);\\n        \\n        for(int i=1;i<A.size();i++){\\n            real=((A[i]*size[i-1])%mod-sum[i-1]+mod)%mod;\\n            temp[i]=real;\\n            size[i]=(2*size[i-1]+1)%mod;\\n            sum[i]=( (sum[i-1]+sum[i-1])%mod+A[i]+mod)%mod;\\n            \\n        }\\n        real=0;\\n        for(int i=0;i<temp.size();i++){\\n            real=(real+temp[i]+mod)%mod;\\n        }\\n        \\n        return real;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222412,
                "title": "sum-of-subsequence-widths-easy-to-understand-solution-java",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans=0;\\n        int n=nums.length;\\n        long mod=1000000007;\\n        \\n        long []pow=new long[n];\\n        \\n        pow[0]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            pow[i]=(2*pow[i-1])%mod;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans=(ans+nums[i]*(pow[i]-pow[n-i-1]))%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n\\n//for p numbers there are 2^p subsequences possible\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans=0;\\n        int n=nums.length;\\n        long mod=1000000007;\\n        \\n        long []pow=new long[n];\\n        \\n        pow[0]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            pow[i]=(2*pow[i-1])%mod;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans=(ans+nums[i]*(pow[i]-pow[n-i-1]))%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n\\n//for p numbers there are 2^p subsequences possible\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181862,
                "title": "java-easy-understanding-solution",
                "content": "class Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n      \\n       Arrays.sort(nums);\\n        int n = nums.length;\\n        \\n        long[] power = new long[n];\\n        long mod = 1000000007L;\\n        power[0] = 1;\\n        \\n        for(int i =1; i<n; i++){\\n            power[i] = (power[i-1]*2)%mod;\\n        }\\n        \\n        long ans = 0;\\n        \\n        for(int i = 0; i<n; i++){\\n            ans = (ans + nums[i]*power[i] - nums[i]*power[n-i-1])%mod;\\n        }\\n        return (int) ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n      \\n       Arrays.sort(nums);\\n        int n = nums.length;\\n        \\n        long[] power = new long[n];\\n        long mod = 1000000007L;\\n        power[0] = 1;\\n        \\n        for(int i =1; i<n; i++){\\n            power[i] = (power[i-1]*2)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2179790,
                "title": "c-simple-solution-no-power",
                "content": "```\\nint sumSubseqWidths(vector<int>& A) {\\n        int N = A.size();\\n        long mn = 0, mx = 0, mod = 1000000007;\\n\\n        sort(A.begin(), A.end());\\n        for(int i=0; i<N; i++) {\\n            mn = (mn*2)%mod;\\n            mn = (mn + A[i])%mod;\\n        }\\n\\n        for(int i=N-1; i>=0; i--) {\\n            mx = (mx*2)%mod;\\n            mx = (mx + A[i])%mod;\\n        }\\n        return (mx-mn + mod)%mod;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint sumSubseqWidths(vector<int>& A) {\\n        int N = A.size();\\n        long mn = 0, mx = 0, mod = 1000000007;\\n\\n        sort(A.begin(), A.end());\\n        for(int i=0; i<N; i++) {\\n            mn = (mn*2)%mod;\\n            mn = (mn + A[i])%mod;\\n        }\\n\\n        for(int i=N-1; i>=0; i--) {\\n            mx = (mx*2)%mod;\\n            mx = (mx + A[i])%mod;\\n        }\\n        return (mx-mn + mod)%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176301,
                "title": "java-easy-commented-solution",
                "content": "class Solution {\\n\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] pow = new long[n]; //this array keeps count of number of subsequences till a particular index\\n        pow[0] = 1;\\n        long mod = 1000000007;\\n        \\n        for(int i = 1; i<n; i++){\\n            pow[i] =( pow[i-1]*2)%mod;\\n        }\\n        \\n        long ans = 0;\\n        for(int i = 0; i<n; i++){\\n            //an element occurs adds in the answer only when it appears as mas of a subsequence and subtracts only when it occurs as min of a subarray so we calculated this and then kept on appending it in the answer\\n            ans = (ans + nums[i]*pow[i] - nums[i]*pow[n-i-1])%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] pow = new long[n]; //this array keeps count of number of subsequences till a particular index\\n        pow[0] = 1;\\n        long mod = 1000000007;\\n        \\n        for(int i = 1; i<n; i++){\\n            pow[i] =( pow[i-1]*2)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2162427,
                "title": "python-easy-sort-count",
                "content": "(1) first sort the array;\\n(2) ith item, + times=2**i-1, -times=2**(n-1-i)-1 times;\\n(3) sum up\\n\\n```\\ndef sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod=10**9+7\\n        nums.sort()\\n        n=len(nums)\\n        ct=[1]*n\\n        a=1/2\\n        for i in range(n):\\n            a=int(a*2)%mod\\n            ct[i]=a\\n        res=0\\n        for i in range(n):\\n            count=ct[i]-1\\n            count-=ct[-i-1]-1\\n            res+=(mod+nums[i]*count)%mod\\n            res=res%mod\\n        return res",
                "solutionTags": [],
                "code": "(1) first sort the array;\\n(2) ith item, + times=2**i-1, -times=2**(n-1-i)-1 times;\\n(3) sum up\\n\\n```\\ndef sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod=10**9+7\\n        nums.sort()\\n        n=len(nums)\\n        ct=[1]*n\\n        a=1/2\\n        for i in range(n):\\n            a=int(a*2)%mod\\n            ct[i]=a\\n        res=0\\n        for i in range(n):\\n            count=ct[i]-1\\n            count-=ct[-i-1]-1\\n            res+=(mod+nums[i]*count)%mod\\n            res=res%mod\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2069229,
                "title": "detailed-explanation-brute-force-optimised-algorithm-java-solution-89-faster",
                "content": "https://www.youtube.com/watch?v=LuiCMG_hBWc&t=223s",
                "solutionTags": [
                    "Math"
                ],
                "code": "https://www.youtube.com/watch?v=LuiCMG_hBWc&t=223s",
                "codeTag": "Unknown"
            },
            {
                "id": 2014439,
                "title": "simple-straight-forward-solution-no-tricks",
                "content": "This one is inspired by https://leetcode.com/problems/sum-of-subsequence-widths/discuss/881805/C%2B%2B-simple-sol-with-comments-beats-88\\n\\nWhere we find out the number of subsets a number would be a part of ending on that number and we sum those counts. Similarly, we subtract all the counts where the number would be a part of a subset starting from that index.\\n\\n```\\nvar sumSubseqWidths = function(nums) {\\n    const mod = 1000000007;\\n    nums.sort((a, b) => a - b), total = 0, power = 1;\\n    for(let i = 0; i < nums.length; i++) {\\n        total = (total + nums[i] * power) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    power = 1;\\n    for(let i = nums.length - 1; i >= 0; i--) {\\n        total = (total - nums[i] * power + mod) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    return (total + mod) % mod\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sumSubseqWidths = function(nums) {\\n    const mod = 1000000007;\\n    nums.sort((a, b) => a - b), total = 0, power = 1;\\n    for(let i = 0; i < nums.length; i++) {\\n        total = (total + nums[i] * power) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    power = 1;\\n    for(let i = nums.length - 1; i >= 0; i--) {\\n        total = (total - nums[i] * power + mod) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    return (total + mod) % mod\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969433,
                "title": "python-sort-and-linear-scan-o-nlogn-explained",
                "content": "Let A be the array nums.\\nLet n be len(A).\\nFirst sort A.\\nFor each A[i] there are 2^i cases when A[i] becomes the minimum in a subsequence, and 2^(n-1-i) cases when A[i] becomes the maximum.\\nWith a linear scan, process at each position.\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        M = 10**9+7\\n        res = 0\\n        le = 1\\n        re = pow(2, n-1, M)\\n        #by Fermat\\'s Little Thm\\n        #inverse of 2 modulo M\\n        inv = pow(2, M-2, M)\\n        for num in nums:\\n            res = (res + num * (le - re))%M\\n            le = (le * 2) % M\\n            re = (re * inv) % M\\n        return res",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "Let A be the array nums.\\nLet n be len(A).\\nFirst sort A.\\nFor each A[i] there are 2^i cases when A[i] becomes the minimum in a subsequence, and 2^(n-1-i) cases when A[i] becomes the maximum.\\nWith a linear scan, process at each position.\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        M = 10**9+7\\n        res = 0\\n        le = 1\\n        re = pow(2, n-1, M)\\n        #by Fermat\\'s Little Thm\\n        #inverse of 2 modulo M\\n        inv = pow(2, M-2, M)\\n        for num in nums:\\n            res = (res + num * (le - re))%M\\n            le = (le * 2) % M\\n            re = (re * inv) % M\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1949106,
                "title": "sum-of-subsequence-widths-solution-java",
                "content": "class Solution {\\n  public int sumSubseqWidths(int[] nums) {\\n    final int kMod = (int) 1e9 + 7;\\n    final int n = nums.length;\\n    long ans = 0;\\n    long exp = 1;\\n\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i < n; ++i, exp = exp * 2 % kMod) {\\n      ans += (nums[i] - nums[n - i - 1]) * exp;\\n      ans %= kMod;\\n    }\\n\\n    return (int) ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "class Solution {\\n  public int sumSubseqWidths(int[] nums) {\\n    final int kMod = (int) 1e9 + 7;\\n    final int n = nums.length;\\n    long ans = 0;\\n    long exp = 1;\\n\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i < n; ++i, exp = exp * 2 % kMod) {\\n      ans += (nums[i] - nums[n - i - 1]) * exp;\\n      ans %= kMod;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1944862,
                "title": "python-sorting-solution",
                "content": "Sort the list since order won\\'t matter for subsequences.\\nThen just need to observer greatest item will be used 2^(len(nums) - 1) times next largest will used 2^(len(nums) - 2) times ...\\n\\nWe can just calculate this directly since Python ints are unbounded. \\n\\nSame for the mins.\\n\\nThen can just subtract the two.\\n\\n\\n\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        maxes, mins = 0, 0\\n        for i in range(len(nums) - 1, -1, -1):\\n            maxes += nums[i] * (1 << i)\\n        for i in range(len(nums)):\\n            mins += nums[i] * (1 << (len(nums) - i - 1))\\n        return (maxes - mins) % int(1e9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        maxes, mins = 0, 0\\n        for i in range(len(nums) - 1, -1, -1):\\n            maxes += nums[i] * (1 << i)\\n        for i in range(len(nums)):\\n            mins += nums[i] * (1 << (len(nums) - i - 1))\\n        return (maxes - mins) % int(1e9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934391,
                "title": "c-o-n-solution-in-one-linear-scan",
                "content": "```\\nconstexpr long p = 1000000007;\\nclass Solution \\n{\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        long totalWidth = 0;\\n        long numSubSets = 1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            totalWidth = (totalWidth + numSubSets * (nums[i] - nums[n - 1 - i])) % p;\\n            numSubSets = (numSubSets * 2) % p;\\n        }\\n        return totalWidth % p;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconstexpr long p = 1000000007;\\nclass Solution \\n{\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        long totalWidth = 0;\\n        long numSubSets = 1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            totalWidth = (totalWidth + numSubSets * (nums[i] - nums[n - 1 - i])) % p;\\n            numSubSets = (numSubSets * 2) % p;\\n        }\\n        return totalWidth % p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881830,
                "title": "python-easy-to-read-and-understand-sorting",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            mx = (2**i)*nums[i]\\n            mn = (2**(n-1-i))*nums[i]\\n            ans += (mx-mn)\\n        \\n        return ans%(10**9+7)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            mx = (2**i)*nums[i]\\n            mn = (2**(n-1-i))*nums[i]\\n            ans += (mx-mn)\\n        \\n        return ans%(10**9+7)",
                "codeTag": "Java"
            },
            {
                "id": 1855046,
                "title": "java-mathematics-logic-easy-to-understand",
                "content": "# public int sumSubseqWidths(int[] nums) {\\n        long res = 0;\\n        long mod = 1000000007;\\n        Arrays.sort(nums);\\n        long[] powers = new long[nums.length];\\n        powers[0] = 1;\\n        for (int i = 1; i < powers.length; i++) {\\n            powers[i] = (powers[i - 1] * 2) % mod;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            res = (res + nums[i] * (powers[i] - powers[nums.length - i - 1])) % mod;\\n        }\\n        return (int) res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "# public int sumSubseqWidths(int[] nums) {\\n        long res = 0;\\n        long mod = 1000000007;\\n        Arrays.sort(nums);\\n        long[] powers = new long[nums.length];\\n        powers[0] = 1;\\n        for (int i = 1; i < powers.length; i++) {\\n            powers[i] = (powers[i - 1] * 2) % mod;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            res = (res + nums[i] * (powers[i] - powers[nums.length - i - 1])) % mod;\\n        }\\n        return (int) res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1833525,
                "title": "c-o-nlogn-explained-completely-new-approach",
                "content": "**Intuition and Approach:** \\n\\nClearly, generating all subsequences is not possible because of huge constraints. So, try thinking about what each element can contribute to the answer. For each subsequence, we have to find the maximum and minimum element. \\n\\nThinking on a broader expectation, it can be said that pick two elements, consider one as max and one as min, and just multiply their absolute difference with the number of times they will be maximum and minimum in the subsequences generated.\\n\\nSort the array, such that no extra time could be taken to find max and min elements. \\n\\nlet sorted array be [1,2,3,4,5,6,7,8] \\n\\nLets consider 1 as min and 4 as max for a subsequence \\n\\n1 and 4 can have 3 elements in between as per the given array\\n\\n1 _   _   _  4\\n1 2 2 2 1\\n\\n**By permutations, we can say that the number of such possible subsequences are 1x2x2x2x1=8. Thus (4-1) will come 8 times in the total subsequences and will contribute (4-1)x8 to the answer.**\\n\\nThus, anwer is:\\n `for(i = 0 to n - 2) for(j = i + 1 to n - 1) ans+=(Aj - Ai) X (2^(j - i + 1))          ------------------> Eqn 1`\\n\\nWhere Aj and Ai are the max and min elements. \\n\\n**But if you simply run the above snippet, you will again get TLE because it is again O(N^2).**\\n\\nKeeping the same idea intact, try reducing `Eqn 1 `to its reduced version. \\n\\n**Consider elements [a,b,c,d] such that a <= b <= c <= d. Here n=4, place all values of i and j**\\n\\n```\\n= { A1 (2^0) + A2 (2^1) + A3 (2^2) + A2 (2^0) + A3 (2^1) + A3 (2^0) }  - { A0 (2^0) + A0 (2^1) + A0 (2^2) + A1 (2^0) + A1 (2^1) + A2 (2^0) }    \\n\\n= { (2^0)(A1+A2+A3) + (2^1)(A2+A3) + (2^2)(A3) }  - { (2^0)(A0+A1+A2) + (2^1)(A0+A1) + (2^2)(A0) }\\n```\\n\\nTo generalize this,  we can say that\\n\\n```\\nFor (i = 0 to n-1) ans = ans + 2^i * (prefix[n-1] - prefix[i]) - 2^i * prefix[n-2-i];\\n```\\nWe have to handle this under modulo.\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    int md=1e9+7;\\n    using ll=long long;\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n\\n        vector<ll> pow(n), pref(n);\\n        pow[0]=1;\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++) {\\n            pow[i]=(2*pow[i-1]) % md;\\n            pref[i]=(pref[i-1]%md+nums[i]%md)%md;\\n        }\\n        \\n        ll ans=0;\\n         for(int i=0;i<n-1;i++) {\\n            ans+=(pow[i] * (pref[n-1]-pref[i])) % md  -  (pow[i] * pref[n-2-i] + md) % md;\\n            ans=(ans+md)%md;\\n         }\\n        return ans%md;\\n    }\\n};\\n```\\n\\n**Time: O(NlogN)\\nSpace: O(N)**\\n\\nUpvote if you liked!!\\nLet me know your doubts in the comment section!!",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n= { A1 (2^0) + A2 (2^1) + A3 (2^2) + A2 (2^0) + A3 (2^1) + A3 (2^0) }  - { A0 (2^0) + A0 (2^1) + A0 (2^2) + A1 (2^0) + A1 (2^1) + A2 (2^0) }    \\n\\n= { (2^0)(A1+A2+A3) + (2^1)(A2+A3) + (2^2)(A3) }  - { (2^0)(A0+A1+A2) + (2^1)(A0+A1) + (2^2)(A0) }\\n```\n```\\nFor (i = 0 to n-1) ans = ans + 2^i * (prefix[n-1] - prefix[i]) - 2^i * prefix[n-2-i];\\n```\n```\\nclass Solution {\\npublic:\\n    int md=1e9+7;\\n    using ll=long long;\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n\\n        vector<ll> pow(n), pref(n);\\n        pow[0]=1;\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++) {\\n            pow[i]=(2*pow[i-1]) % md;\\n            pref[i]=(pref[i-1]%md+nums[i]%md)%md;\\n        }\\n        \\n        ll ans=0;\\n         for(int i=0;i<n-1;i++) {\\n            ans+=(pow[i] * (pref[n-1]-pref[i])) % md  -  (pow[i] * pref[n-2-i] + md) % md;\\n            ans=(ans+md)%md;\\n         }\\n        return ans%md;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789008,
                "title": "java-easy-solution-o-nlogn-time-complexity",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] arr1) {\\n        Arrays.sort(arr1);\\n        int n=arr1.length;\\n        int mod=(int)1e9+7;\\n        long ans=0l;\\n        long power=1l;\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            ans=((ans%mod)+power*(arr1[i]-arr1[n-i-1])+mod)%mod;\\n            power=(power<<1)%mod;\\n        }\\n        \\n        return (int)(ans%mod);\\n    }   \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int sumSubseqWidths(int[] arr1) {\\n        Arrays.sort(arr1);\\n        int n=arr1.length;\\n        int mod=(int)1e9+7;\\n        long ans=0l;\\n        long power=1l;\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            ans=((ans%mod)+power*(arr1[i]-arr1[n-i-1])+mod)%mod;\\n            power=(power<<1)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1788362,
                "title": "nlog-n-time-complexity-and-o-n-space-complexity",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] arr) {\\n        \\n        Arrays.sort(arr);\\n        long ans = 0;\\n        long mod = 1000000007;\\n        long[] pow = new long[arr.length];\\n        pow[0] = 1;\\n        for(int i = 1 ; i < pow.length ; i++){\\n            pow[i] = (pow[i-1]*2)%mod; \\n        }\\n        \\n        for(int i = 0 ; i < arr.length ; i++){\\n            ans = (ans + arr[i]*(pow[i] - pow[arr.length - i - 1]))%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] arr) {\\n        \\n        Arrays.sort(arr);\\n        long ans = 0;\\n        long mod = 1000000007;\\n        long[] pow = new long[arr.length];\\n        pow[0] = 1;\\n        for(int i = 1 ; i < pow.length ; i++){\\n            pow[i] = (pow[i-1]*2)%mod; \\n        }\\n        \\n        for(int i = 0 ; i < arr.length ; i++){\\n            ans = (ans + arr[i]*(pow[i] - pow[arr.length - i - 1]))%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755006,
                "title": "query-regarding-java-code",
                "content": "The mathematical base of this approach is correct for smaller lengths but for larger arrays I am getting a negative answer. Can someone help me to figure this out!\\n```\\n   Arrays.sort(a);\\n        long curr = 0;\\n        int n = a.length;\\n        int max=-1;\\n        long ans=0;\\n      \\n        long[] pow = new long[n+1];\\n        long cp =1;\\n        pow[0]=1;\\n        for(int i=1;i<=n;i++){\\n            cp = (cp*2)%mod;\\n            if(cp<0){\\n                cp+=mod;\\n            }\\n            pow[i] = cp;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            curr = (curr+(pow[max+1]*((long)(a[n-1])-(long)(a[i])))%mod)%mod;\\n            max++;\\n           \\n        }\\n        ans+=curr;\\n        \\n        for(int j= n-2;j>=0;j--){\\n          \\n            curr= (curr- (long)(a[j+1])+(long)(a[j]))%mod;\\n          \\n            curr/=2;\\n            max--;\\n            int nc= 0;\\n            if(max>=0){\\n                long k = ((pow[max+1]-1)%mod*((long)(a[j+1])-(long)(a[j]))%mod)%mod;\\n\\n                curr= (curr - k)%mod;\\n           \\n\\n            }\\n          \\n            \\n            ans = (ans+curr)%mod;\\n        }\\n        \\n        return (int)(ans%mod);\\n```",
                "solutionTags": [],
                "code": "```\\n   Arrays.sort(a);\\n        long curr = 0;\\n        int n = a.length;\\n        int max=-1;\\n        long ans=0;\\n      \\n        long[] pow = new long[n+1];\\n        long cp =1;\\n        pow[0]=1;\\n        for(int i=1;i<=n;i++){\\n            cp = (cp*2)%mod;\\n            if(cp<0){\\n                cp+=mod;\\n            }\\n            pow[i] = cp;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            curr = (curr+(pow[max+1]*((long)(a[n-1])-(long)(a[i])))%mod)%mod;\\n            max++;\\n           \\n        }\\n        ans+=curr;\\n        \\n        for(int j= n-2;j>=0;j--){\\n          \\n            curr= (curr- (long)(a[j+1])+(long)(a[j]))%mod;\\n          \\n            curr/=2;\\n            max--;\\n            int nc= 0;\\n            if(max>=0){\\n                long k = ((pow[max+1]-1)%mod*((long)(a[j+1])-(long)(a[j]))%mod)%mod;\\n\\n                curr= (curr - k)%mod;\\n           \\n\\n            }\\n          \\n            \\n            ans = (ans+curr)%mod;\\n        }\\n        \\n        return (int)(ans%mod);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730973,
                "title": "n-logn-time-complexity",
                "content": "In Swift, we don\\'t have anyway to store a number more than 2^63 - 1. So, for larger numbers we will get runtime error.\\n\\n```\\nfunc sumSubseqWidths(_ nums: [Int]) -> Int {\\n    let sortedNums = nums.sorted()\\n    var output: Int64 = 0\\n    let n = sortedNums.count\\n    \\n    for i in 0..<n {\\n        let num = Int64(sortedNums[i])\\n        let leftElements = i\\n        let rightElements = n-1-i\\n        let leftSubSeq: Int64 = Int64(truncating: NSDecimalNumber(decimal: (pow(2, leftElements))))%10000000007\\n        let rightSubseq: Int64 = Int64(truncating: NSDecimalNumber(decimal: (pow(2, rightElements))))%10000000007\\n        let diff: Int64 = (leftSubSeq-rightSubseq)%10000000007\\n        output += num*diff\\n    }\\n    \\n    return Int(output%10000000007)\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nfunc sumSubseqWidths(_ nums: [Int]) -> Int {\\n    let sortedNums = nums.sorted()\\n    var output: Int64 = 0\\n    let n = sortedNums.count\\n    \\n    for i in 0..<n {\\n        let num = Int64(sortedNums[i])\\n        let leftElements = i\\n        let rightElements = n-1-i\\n        let leftSubSeq: Int64 = Int64(truncating: NSDecimalNumber(decimal: (pow(2, leftElements))))%10000000007\\n        let rightSubseq: Int64 = Int64(truncating: NSDecimalNumber(decimal: (pow(2, rightElements))))%10000000007\\n        let diff: Int64 = (leftSubSeq-rightSubseq)%10000000007\\n        output += num*diff\\n    }\\n    \\n    return Int(output%10000000007)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677485,
                "title": "sum-of-subsequence-widths",
                "content": "Why does the solution (in java) do a mod of 1000000007 when calculating 2 power array. As per the question, the mod of 1000000007 should only be performed on the result. isnt it?",
                "solutionTags": [],
                "code": "Why does the solution (in java) do a mod of 1000000007 when calculating 2 power array. As per the question, the mod of 1000000007 should only be performed on the result. isnt it?",
                "codeTag": "Unknown"
            },
            {
                "id": 1627929,
                "title": "python-with-explanation",
                "content": "First, sort the nums as the order doesn\\'t matter in this case\\nSecond, let\\'s take a look which subarrays will be used and how many times they will be counted.\\n\\nAssume the length is *l*, and the subarrays are:\\n[0,1] once, [0,2] twice, [0,3] three times, .. [0,l-1] l times\\n\\t\\t\\t\\t\\t   [1,2] once, [1,3] twice, ..        [1,l-1] l-1 times\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t[2,3] once, ..            [2,l-1] l-2 times\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t[l-2,l-1] once\\nif we use an array res to represent the sum with different length *l* \\n        ****when l=2:****\\n        res[l=2] = (nums[1]-nums[0])*1 = nums[1]*2^0 - nums[0]*2^0\\n        ****when l=3:****\\n        res[l=3] = (nums[2]-nums[1])*1 + (nums[2]-nums[0])*2 + (nums[1]-nums[0])*1\\n\\t\\t\\t\\t\\t= res[l=2] + nums[2]*(2^0+2^1) - nums[1]*2^0 + nums[0]*2^1\\n        ****when l=4:****            \\n        res[l=4] = (nums[1]-nums[0])*1 + (nums[2]-nums[1])*1 + (nums[3]-nums[2])*1 + \\n                (nums[2]-nums[0])*2 + (nums[3]-nums[1])*2 +\\n                (nums[3]-nums[0])*2^2\\n            = nums[3]*(4+2+1)-nums[0]*(2^0+2^1+2^2) + nums[2]*(2) - nums[1]*(2)\\n            = res[3] + (nums[3]-nums[2])*1 + (nums[3]-nums[1])*2 + (nums[3]-nums[0])*2^2\\n            = res[l=3] + nums[3]*(1+2+4) - nums[2]*1 - nums[1]*2 - nums[0]*2^2\\n       ****when l=5:****\\n        res[l=5] = (nums[1]-nums[0])*1 + (nums[2]-nums[1])*1 + (nums[3]-nums[2])*1 + (nums[4]-nums[3])*1 +\\n                (nums[2]-nums[0])*2 + (nums[3]-nums[1])*2 + (nums[4]-nums[2])*2 +\\n                (nums[3]-nums[0])*2^2 + (nums[4]-nums[1])*2^2 +\\n                (nums[4]-nums[0])*2^3\\n            = res[l=4] + (nums[4]-nums[3])*1 + (nums[4]-nums[2])*2 + (nums[4]-nums[1])*2^2 + (nums[4]-nums[0])*2^3\\n            = res[l=4] + nums[4]*(2^0+2^1+2^2+2^3) - nums[3] - nums[2]*2 - nums[1]*2^2 - nums[0]*2^3\\n        ****when l=6:****\\n        res[l=6] = res[l=5] + nums[5]*(1+...+2^4) - nums[4] - nums[3]*2 - nums[2]*2^2 - nums[1]*2^3 - nums[0]*2^4\\n\\nIt\\'s easy to write code like this:\\n```\\nnums = sorted(nums)\\n        l = len(nums)\\n        res = 0\\n        n = 0\\n        s = 0\\n        m = 10**9+7\\n        for i in range(1,l):\\n            n = (n*2+nums[i-1])%m\\n            s = (s*2+1)%m\\n            res = (res + s*nums[i] - n)%m\\n        return res%m\\n```",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nnums = sorted(nums)\\n        l = len(nums)\\n        res = 0\\n        n = 0\\n        s = 0\\n        m = 10**9+7\\n        for i in range(1,l):\\n            n = (n*2+nums[i-1])%m\\n            s = (s*2+1)%m\\n            res = (res + s*nums[i] - n)%m\\n        return res%m\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590029,
                "title": "c-maths-sorting-greedy",
                "content": "class Solution {\\npublic:\\n    \\n    long long M=1e9+7;\\n    \\n    long long mod(long long a){\\n        \\n        return ((a%M)+M)%M;\\n        \\n    }\\n    \\n    long long mul(long long a,long long b){\\n        \\n        return mod(mod(a)*mod(b));\\n        \\n    }\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n      \\n        long long n=nums.size();\\n        \\n        vector<long long>pow(n);\\n        \\n        pow[0]=1LL;\\n        \\n        for(long i=1;i<n;i++){\\n            \\n            pow[i]=mul(2,pow[i-1]);\\n            \\n        }\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        long long ans=0;\\n        \\n        for(long i=0;i<n;i++){\\n            \\n            long long val=(pow[i]-pow[n-i-1])*nums[i];\\n            \\n            ans=(ans+val)%M;\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    long long M=1e9+7;\\n    \\n    long long mod(long long a){\\n        \\n        return ((a%M)+M)%M;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1545974,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = val = 0 \\n        p = 1\\n        for i in range(1, len(nums)): \\n            p = p * 2 % MOD\\n            val = (2*val + (nums[i]-nums[i-1])*(p-1)) % MOD \\n            ans = (ans + val) % MOD \\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        ans = 0 \\n        for i, x in enumerate(sorted(nums)): \\n            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))\\n        return ans % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = val = 0 \\n        p = 1\\n        for i in range(1, len(nums)): \\n            p = p * 2 % MOD\\n            val = (2*val + (nums[i]-nums[i-1])*(p-1)) % MOD \\n            ans = (ans + val) % MOD \\n        return ans \\n```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        ans = 0 \\n        for i, x in enumerate(sorted(nums)): \\n            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))\\n        return ans % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461971,
                "title": "somthing-wrong-with-this-test-case",
                "content": "[2,1] returns 1 as a test case and in my local dev env with python 3, but when I submit, I got a 0 as output. What am I missing here?\\n\\n![image](https://assets.leetcode.com/users/images/bde95861-01ba-4ad4-9dd2-fc8e8b21b7fe_1631562000.1102972.png)\\n",
                "solutionTags": [],
                "code": "[2,1] returns 1 as a test case and in my local dev env with python 3, but when I submit, I got a 0 as output. What am I missing here?\\n\\n![image](https://assets.leetcode.com/users/images/bde95861-01ba-4ad4-9dd2-fc8e8b21b7fe_1631562000.1102972.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1455321,
                "title": "python-time-complexity-nlogn",
                "content": "\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, a: List[int]) -> int:\\n        mod=int(1e9)+7\\n        p=1\\n        ans=0\\n        n=len(a)\\n        a.sort()\\n        for i in range(0,n):\\n            ans=(ans+((a[i]-a[n-i-1])*p))%mod\\n            p=(p<<1)%mod\\n        return ans%mod\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, a: List[int]) -> int:\\n        mod=int(1e9)+7\\n        p=1\\n        ans=0\\n        n=len(a)\\n        a.sort()\\n        for i in range(0,n):\\n            ans=(ans+((a[i]-a[n-i-1])*p))%mod\\n            p=(p<<1)%mod\\n        return ans%mod\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419500,
                "title": "can-anyone-help-in-telling-me-the-issue-with-my-approach",
                "content": "My appaoach is that from result we substract and add in such a way that\\n1. Substract No. of subsequences in which nums[i] is minimum * nums[i]\\n2. Add no. of subsequences in which nums[i] is maximum * nums[i]\\n3. No of subsequences = 2^ (elements to left OR right of nums[i])\\n\\n\\n```\\npublic int sumSubseqWidths(int[] nums) {\\n        int MOD = 1000000007;\\n        long res =0, n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i=0;i<n;i++) {\\n            res = (res - ((long)Math.pow(2, n-1-i)*(long)nums[i]))%MOD;\\n            res = (res + ((long)Math.pow(2, i)*(long)nums[i]))%MOD;\\n        }\\n        return (int)(res % MOD);\\n    }\\n```\\n\\nIt is failing for following test case\\n[96,87,191,197,40,101,108,35,169,50,168,182,95,80,144,43,18,60,174,13,77,173,38,46,80,117,13,19,11,6,13,118,39,80,171,36,86,156,165,190,53,49,160,192,57,42,97,35,124,200,84,70,145,180,54,141,159,42,66,66,25,95,24,136,140,159,71,131,5,140,115,76,151,137,63,47,69,164,60,172,153,183,6,70,40,168,133,45,116,188,20,52,70,156,44,27,124,59,42,172]",
                "solutionTags": [],
                "code": "```\\npublic int sumSubseqWidths(int[] nums) {\\n        int MOD = 1000000007;\\n        long res =0, n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i=0;i<n;i++) {\\n            res = (res - ((long)Math.pow(2, n-1-i)*(long)nums[i]))%MOD;\\n            res = (res + ((long)Math.pow(2, i)*(long)nums[i]))%MOD;\\n        }\\n        return (int)(res % MOD);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1289099,
                "title": "c-nlogn-99-faster",
                "content": "logic:\\n1.Here we are considering every subsequence hence ordering don\\'t matter.Hence sort it ..work will become easy.\\n2.We know n elements can form 2^n subsequences\\n3.In sorted array A[i] will be maximum in 2^(i-1)subsequences and smallest in 2^(n-i-1) subsequences .\\n```\\n    int sumSubseqWidths(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        long long n=a.size(),i,ans=0,x=1,m=1e9+7;\\n        for(i=0;i<n;i++)\\n        {\\n            x%=m;\\n            ans=(ans+(x*a[i])%m-(x*(a[n-i-1]))%m)%m;\\n            x*=2;\\n        }\\n        \\n        return (ans+m)%m;\\n    }",
                "solutionTags": [],
                "code": "logic:\\n1.Here we are considering every subsequence hence ordering don\\'t matter.Hence sort it ..work will become easy.\\n2.We know n elements can form 2^n subsequences\\n3.In sorted array A[i] will be maximum in 2^(i-1)subsequences and smallest in 2^(n-i-1) subsequences .\\n```\\n    int sumSubseqWidths(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        long long n=a.size(),i,ans=0,x=1,m=1e9+7;\\n        for(i=0;i<n;i++)\\n        {\\n            x%=m;\\n            ans=(ans+(x*a[i])%m-(x*(a[n-i-1]))%m)%m;\\n            x*=2;\\n        }\\n        \\n        return (ans+m)%m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1274191,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    private  int mod = 1000000007;\\n\\n        public  int SumSubseqWidths(int[] nums)\\n        {\\n\\n            long ans = 0;\\n            Array.Sort(nums);\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                ans = (ans + (cChe(2L, i) - 1) * nums[i] % mod) % mod;\\n                ans = (ans - (cChe(2L, nums.Length - 1 - i) - 1) * nums[i] % mod) % mod;\\n            }\\n\\n            return (int)ans;\\n        }\\n\\n        private  long cChe(long x, long y)\\n        {\\n            long res = 1;\\n            while (y > 0)\\n            {\\n                if (y % 2 != 0)\\n                    res = res * x % mod;\\n                x = x * x % mod;\\n                y /= 2;\\n            }\\n            return res % mod;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private  int mod = 1000000007;\\n\\n        public  int SumSubseqWidths(int[] nums)\\n        {\\n\\n            long ans = 0;\\n            Array.Sort(nums);\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                ans = (ans + (cChe(2L, i) - 1) * nums[i] % mod) % mod;\\n                ans = (ans - (cChe(2L, nums.Length - 1 - i) - 1) * nums[i] % mod) % mod;\\n            }\\n\\n            return (int)ans;\\n        }\\n\\n        private  long cChe(long x, long y)\\n        {\\n            long res = 1;\\n            while (y > 0)\\n            {\\n                if (y % 2 != 0)\\n                    res = res * x % mod;\\n                x = x * x % mod;\\n                y /= 2;\\n            }\\n            return res % mod;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213909,
                "title": "c-o-nlgn",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    #define ll long long int\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        ll pow2[n];\\n        pow2[0]=1;\\n        for(int i=1;i<n;i++)\\n            pow2[i]=(2*pow2[i-1])%mod;\\n        ll res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            res=(res+(pow2[i]-pow2[n-i-1])*nums[i])%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    #define ll long long int\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        ll pow2[n];\\n        pow2[0]=1;\\n        for(int i=1;i<n;i++)\\n            pow2[i]=(2*pow2[i-1])%mod;\\n        ll res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            res=(res+(pow2[i]-pow2[n-i-1])*nums[i])%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203276,
                "title": "c-concise-code",
                "content": "```\\n#define mod 1000000007\\nint sumSubseqWidths(vector<int>& arr) \\n{\\n\\tsort(arr.begin(),arr.end());\\n\\tlong val=0,ret=0,_2=1;\\n\\tfor(int i=arr.size()-2;i>=0;--i)\\n\\t{\\n\\t\\tval=val*2+arr[i+1];\\n\\t\\t_2<<=1;\\n\\t\\t_2%=mod;\\n\\t\\tret+=(val-(_2-1)*arr[i]);\\n\\t\\tval%=mod;\\n\\t\\tret%=mod;\\n\\t}\\n\\treturn (ret+mod)%mod;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define mod 1000000007\\nint sumSubseqWidths(vector<int>& arr) \\n{\\n\\tsort(arr.begin(),arr.end());\\n\\tlong val=0,ret=0,_2=1;\\n\\tfor(int i=arr.size()-2;i>=0;--i)\\n\\t{\\n\\t\\tval=val*2+arr[i+1];\\n\\t\\t_2<<=1;\\n\\t\\t_2%=mod;\\n\\t\\tret+=(val-(_2-1)*arr[i]);\\n\\t\\tval%=mod;\\n\\t\\tret%=mod;\\n\\t}\\n\\treturn (ret+mod)%mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1160960,
                "title": "ruby",
                "content": "```\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef sum_subseq_widths(a)\\n  mod = 10 ** 9 + 7\\n  n = a.size\\n  a.sort!\\n  \\n  pow2 = Array.new(n)\\n  pow2[0] = 1\\n  \\n  (1..n).each do |i|\\n    pow2[i] = pow2[i - 1] * 2 % mod\\n  end\\n  \\n  ans = 0\\n  (0..n - 1).each do |i|\\n    ans = (ans + (pow2[i] - pow2[n-1-i]) * a[i]) % mod\\n  end\\n  \\n  ans\\n\\nend\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef sum_subseq_widths(a)\\n  mod = 10 ** 9 + 7\\n  n = a.size\\n  a.sort!\\n  \\n  pow2 = Array.new(n)\\n  pow2[0] = 1\\n  \\n  (1..n).each do |i|\\n    pow2[i] = pow2[i - 1] * 2 % mod\\n  end\\n  \\n  ans = 0\\n  (0..n - 1).each do |i|\\n    ans = (ans + (pow2[i] - pow2[n-1-i]) * a[i]) % mod\\n  end\\n  \\n  ans\\n\\nend\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1112290,
                "title": "how-this-can-be-optimized",
                "content": "Intution: I have use recurssive top to down approch for the given problem. My solution is divided into 3 parts. \\nPart 1: storing each subset into a temporary vector.\\nPart 2: I use a width vector to store width of each subset.\\nPart 3: Finally, adding all the values of width vector\\n\\nI am getting TLE. can anyone there to help me out where I can do optimization. Here is the code\\n```\\n\\tclass Solution {\\npublic:\\n    vector<long long int>width;\\nvoid subsequence(vector<int> &arr, int index, vector<int> &temp) \\n{\\n\\n\\tif (index == arr.size()) {\\n\\t\\tlong long int MAX = *max_element(temp.begin(),temp.end());\\n\\t\\tlong long int MIN = *min_element(temp.begin(),temp.end());\\n\\t\\twidth.push_back(MAX-MIN);\\n\\t\\treturn;\\n\\t}\\n\\telse {\\n\\n\\t\\ttemp.push_back(arr[index]);\\n\\t\\tsubsequence(arr, index + 1, temp); //  including\\n\\t\\ttemp.pop_back();\\n\\t\\tsubsequence(arr, index + 1, temp); // Not Including\\n\\n\\t\\treturn;\\n\\t}\\n}\\nint sumSubseqWidths(vector<int>& A) {\\n        vector<int> temp;\\n        subsequence(A, 0, temp);\\n        long long int ans = 0;\\n        for(auto i:width){\\n            ans+= i;\\n            ans = ans%1000000007;\\n        }\\n\\t    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    vector<long long int>width;\\nvoid subsequence(vector<int> &arr, int index, vector<int> &temp) \\n{\\n\\n\\tif (index == arr.size()) {\\n\\t\\tlong long int MAX = *max_element(temp.begin(),temp.end());\\n\\t\\tlong long int MIN = *min_element(temp.begin(),temp.end());\\n\\t\\twidth.push_back(MAX-MIN);\\n\\t\\treturn;\\n\\t}\\n\\telse {\\n\\n\\t\\ttemp.push_back(arr[index]);\\n\\t\\tsubsequence(arr, index + 1, temp); //  including\\n\\t\\ttemp.pop_back();\\n\\t\\tsubsequence(arr, index + 1, temp); // Not Including\\n\\n\\t\\treturn;\\n\\t}\\n}\\nint sumSubseqWidths(vector<int>& A) {\\n        vector<int> temp;\\n        subsequence(A, 0, temp);\\n        long long int ans = 0;\\n        for(auto i:width){\\n            ans+= i;\\n            ans = ans%1000000007;\\n        }\\n\\t    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077876,
                "title": "c-faster-than-97-braindead-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& v) {\\n        int n = v.size();\\n        const long long mod = 1000000007;\\n        sort(v.begin(), v.end());\\n        vector<long long> power_2(n, 1);\\n        for(int i = 1;i < n;i++)\\n            power_2[i] = (power_2[i - 1] << 1) % mod;\\n        long long res = 0;\\n        for(int i = 0;i < n;i++)\\n            res = (res + v[i] * (power_2[i] - power_2[n - i - 1])) % mod;\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& v) {\\n        int n = v.size();\\n        const long long mod = 1000000007;\\n        sort(v.begin(), v.end());\\n        vector<long long> power_2(n, 1);\\n        for(int i = 1;i < n;i++)\\n            power_2[i] = (power_2[i - 1] << 1) % mod;\\n        long long res = 0;\\n        for(int i = 0;i < n;i++)\\n            res = (res + v[i] * (power_2[i] - power_2[n - i - 1])) % mod;\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1042236,
                "title": "doubt",
                "content": "I see that the collection of  subsequences resemble the power set except null.Is there any relevant approach in that direction?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1035119,
                "title": "p23-5",
                "content": "Hint -> Sort the array, subseq when olny checking fo rmin and max does not effect after sorting\\nHint -> Complexity will be nlog(n)\\nHint -> For every element, find for how many it will be max, and for how many it will be min",
                "solutionTags": [],
                "code": "Hint -> Sort the array, subseq when olny checking fo rmin and max does not effect after sorting\\nHint -> Complexity will be nlog(n)\\nHint -> For every element, find for how many it will be max, and for how many it will be min",
                "codeTag": "Unknown"
            },
            {
                "id": 800350,
                "title": "can-someone-help-me-find-the-issue-in-this-code",
                "content": "The below mentioned solution passes 20/61 test cases. The ones in which it fails are very close to the answer. For example, actual answer = 8724365, my answer = 8724364\\n\\n\\n    int sumSubseqWidths(vector<int>& A) {\\n        int m = *max_element(A.begin(), A.end());\\n        long long int arr[m+1];\\n        for(int i = 0; i <= m; i++) {\\n            arr[i] = 0;\\n        }\\n\\t\\t\\n        for(int i = 0; i < A.size(); i++) {\\n            arr[A[i]]++;\\n        }\\n        \\n        //prefix sum\\n        for(int i = 1; i <= m; i++) {\\n            arr[i] += arr[i-1];\\n        }\\n        \\n        long long int ans = 0;\\n        for(int i = 1; i <= m-1; i++) {\\n            if(arr[i] == arr[i-1]) {\\n                continue;\\n            }\\n            for(int j = i+1; j <= m; j++) {\\n                if(arr[j] == arr[j-1]) {\\n                    continue;\\n                }\\n                long long int start = arr[i]-arr[i-1];\\n                long long int end = arr[j]-arr[j-1];\\n                long long int mid = arr[j-1]-arr[i];\\n                ans += (j-i)*pow(2, mid)*(pow(2, start)-1)*(pow(2, end)-1);\\n                ans = ans%1000000007;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n",
                "solutionTags": [],
                "code": "The below mentioned solution passes 20/61 test cases. The ones in which it fails are very close to the answer. For example, actual answer = 8724365, my answer = 8724364\\n\\n\\n    int sumSubseqWidths(vector<int>& A) {\\n        int m = *max_element(A.begin(), A.end());\\n        long long int arr[m+1];\\n        for(int i = 0; i <= m; i++) {\\n            arr[i] = 0;\\n        }\\n\\t\\t\\n        for(int i = 0; i < A.size(); i++) {\\n            arr[A[i]]++;\\n        }\\n        \\n        //prefix sum\\n        for(int i = 1; i <= m; i++) {\\n            arr[i] += arr[i-1];\\n        }\\n        \\n        long long int ans = 0;\\n        for(int i = 1; i <= m-1; i++) {\\n            if(arr[i] == arr[i-1]) {\\n                continue;\\n            }\\n            for(int j = i+1; j <= m; j++) {\\n                if(arr[j] == arr[j-1]) {\\n                    continue;\\n                }\\n                long long int start = arr[i]-arr[i-1];\\n                long long int end = arr[j]-arr[j-1];\\n                long long int mid = arr[j-1]-arr[i];\\n                ans += (j-i)*pow(2, mid)*(pow(2, start)-1)*(pow(2, end)-1);\\n                ans = ans%1000000007;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 788784,
                "title": "o-n-log-n-sort-compact-14-lines",
                "content": "```\\n#define MOD__ ((int)(1e9 + 7))\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1;\\n        int res = 0;\\n        \\n        for (int i = 0; i < A.size(); i++, c = c * 2 % MOD__)\\n            res = (res + A[i] * c - A[A.size() - i - 1] * c) % MOD__;\\n        \\n        return (res + MOD__) % MOD__;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define MOD__ ((int)(1e9 + 7))\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1;\\n        int res = 0;\\n        \\n        for (int i = 0; i < A.size(); i++, c = c * 2 % MOD__)\\n            res = (res + A[i] * c - A[A.size() - i - 1] * c) % MOD__;\\n        \\n        return (res + MOD__) % MOD__;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738182,
                "title": "o-n-logn-sort-o-n-loop",
                "content": "```\\n#define M 1000000007\\n    int modularExponentiation(long long int x,long long int n)\\n    {\\n        long long int result=1;\\n        while(n>0)\\n        {\\n            if(n % 2 ==1)\\n                result=(result * x)%M;\\n            x=(x*x)%M;\\n            n=n/2;\\n        }\\n        return result;\\n    }\\n    \\n\\n    int sumSubseqWidths(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        long long int sumf=0,sumb=0;\\n        long long int ans=0;\\n        for(int i=0;i<n/2;++i){\\n            sumf+=v[i];\\n            sumb+=v[n-1-i];\\n            if(2*(i+1)==n){\\n                ans=(ans+(sumb-sumf)*(modularExponentiation(2,i))%M)%M;\\n            }\\n            else{\\n                 ans=(ans+(sumb-sumf)*(modularExponentiation(2,i)+modularExponentiation(2,n-2-i))%M)%M;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n#define M 1000000007\\n    int modularExponentiation(long long int x,long long int n)\\n    {\\n        long long int result=1;\\n        while(n>0)\\n        {\\n            if(n % 2 ==1)\\n                result=(result * x)%M;\\n            x=(x*x)%M;\\n            n=n/2;\\n        }\\n        return result;\\n    }\\n    \\n\\n    int sumSubseqWidths(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        long long int sumf=0,sumb=0;\\n        long long int ans=0;\\n        for(int i=0;i<n/2;++i){\\n            sumf+=v[i];\\n            sumb+=v[n-1-i];\\n            if(2*(i+1)==n){\\n                ans=(ans+(sumb-sumf)*(modularExponentiation(2,i))%M)%M;\\n            }\\n            else{\\n                 ans=(ans+(sumb-sumf)*(modularExponentiation(2,i)+modularExponentiation(2,n-2-i))%M)%M;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 725360,
                "title": "dp-c",
                "content": "```\\nclass Solution {\\n    int M=1e9+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        int N=A.size();\\n        sort(A.begin(),A.end());\\n        vector<long> dp(N),s(N);\\n        s[0]=A[0];\\n        long power=1;\\n        for(int i=1;i<N;++i)\\n        {\\n            power=power*2%M;\\n            dp[i]=(dp[i-1]+((power-1)*A[i])-s[i-1])%M;\\n            s[i]=(2*s[i-1]%M+A[i])%M;\\n        }\\n        return dp[N-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int M=1e9+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        int N=A.size();\\n        sort(A.begin(),A.end());\\n        vector<long> dp(N),s(N);\\n        s[0]=A[0];\\n        long power=1;\\n        for(int i=1;i<N;++i)\\n        {\\n            power=power*2%M;\\n            dp[i]=(dp[i-1]+((power-1)*A[i])-s[i-1])%M;\\n            s[i]=(2*s[i-1]%M+A[i])%M;\\n        }\\n        return dp[N-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721887,
                "title": "python-easy-and-concise-o-nlogn-sort-o-n-scan",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort(reverse=True)\\n         \\n        # a b c d\\n        # [a], scan b -> (b - a) * 1\\n        # [a, b], scan c -> (c - a) * 2 + (c - b) * 1\\n        # [a, b, c], scan d -> (d - a) * 4 + (d - b) * 2 + (d - c) * 1\\n        \\n        # b - a                  -> b   - (a)\\n        # 3c - 2a - b            -> 3c  - (2a + b)\\n        # 7d - 4a - 2b - c       -> 7d  - (4a + 2b + c)\\n        # 15e - 8a - 4b - 2c - d -> 15e - (8a + 4b + 2c + d)\\n        \\n        MOD = 10 ** 9 + 7\\n        total, incre, prev = 0, 2, A.pop()\\n        while A:\\n            number = A.pop()\\n            total = (total + (incre - 1) * number - prev) % MOD\\n            prev = (prev * 2 + number) % MOD\\n            incre = (incre * 2) % MOD\\n            \\n        return total\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort(reverse=True)\\n         \\n        # a b c d\\n        # [a], scan b -> (b - a) * 1\\n        # [a, b], scan c -> (c - a) * 2 + (c - b) * 1\\n        # [a, b, c], scan d -> (d - a) * 4 + (d - b) * 2 + (d - c) * 1\\n        \\n        # b - a                  -> b   - (a)\\n        # 3c - 2a - b            -> 3c  - (2a + b)\\n        # 7d - 4a - 2b - c       -> 7d  - (4a + 2b + c)\\n        # 15e - 8a - 4b - 2c - d -> 15e - (8a + 4b + 2c + d)\\n        \\n        MOD = 10 ** 9 + 7\\n        total, incre, prev = 0, 2, A.pop()\\n        while A:\\n            number = A.pop()\\n            total = (total + (incre - 1) * number - prev) % MOD\\n            prev = (prev * 2 + number) % MOD\\n            incre = (incre * 2) % MOD\\n            \\n        return total\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701032,
                "title": "c-o-n-log-n-solution",
                "content": "```\\n        public class Solution\\n        {\\n            public int SumSubseqWidths(int[] A)\\n            {\\n                BigInteger modolo = BigInteger.Pow(10, 9) + 7;\\n                if (A.Length <= 1)\\n                {\\n                    return 0;\\n                }\\n                if (A.Length == 2)\\n                {\\n                    return (int)Math.Abs(A[1] - A[0]);\\n                }\\n                Array.Sort(A);\\n                BigInteger subSize = 1;\\n                BigInteger valueA = new BigInteger(A[1] - A[0]);\\n                int sum = (int)valueA;\\n                for (int i = 2; i < A.Length; i++)\\n                {\\n                    valueA = 2 * (valueA + subSize * (A[i] - A[i - 1])) +(A[i] - A[i - 1]);\\n                    sum += (int)(valueA % modolo);\\n                    sum = sum % (int)modolo;\\n                    subSize = (2 * subSize + 1);\\n            }\\n\\n                return  (sum %(int) modolo);\\n            }\\n        }\\n",
                "solutionTags": [],
                "code": "class Solution\\n        {\\n            public int SumSubseqWidths(int[] A)\\n            {\\n                BigInteger modolo = BigInteger.Pow(10, 9) + 7;\\n                if (A.Length <= 1)\\n                {\\n                    return 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 647841,
                "title": "c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint sumSubseqWidths(vector<int>& A) {\\n\\t\\t\\tint kMod=1e9+7;\\n\\t\\t\\tvector<long> powOf2(20001);\\n\\t\\t\\tpowOf2[0]=1;\\n\\t\\t\\tfor(int i=1;i<=20000;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpowOf2[i]=(powOf2[i-1]*2)%kMod;\\n\\t\\t\\t}\\n\\t\\t\\tsort(A.begin(),A.end());\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tint n=A.size();\\n\\t\\t\\tfor(int i=0;i<A.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans-=A[i]*(powOf2[n-1-i+1-1]-1)%kMod;\\n\\t\\t\\t\\tans+=A[i]*(powOf2[i]-1)%kMod;\\n\\t\\t\\t\\tans%=kMod;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint sumSubseqWidths(vector<int>& A) {\\n\\t\\t\\tint kMod=1e9+7;\\n\\t\\t\\tvector<long> powOf2(20001);\\n\\t\\t\\tpowOf2[0]=1;\\n\\t\\t\\tfor(int i=1;i<=20000;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpowOf2[i]=(powOf2[i-1]*2)%kMod;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 643916,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475268,
                "title": "simple-java-solution-cost-19ms",
                "content": "```java\\nclass Solution {\\n    public int sumSubseqWidths(int[] A) {\\n        if (A == null || A.length <= 1) {\\n            return 0;\\n        }\\n        Arrays.sort(A);\\n        int[] sum = new int[A.length];\\n        sum[0] = A[0];\\n        for(int i = 1; i < A.length; ++i) {\\n            sum[i] = sum[i - 1] + A[i];\\n        }\\n        long[] twoPow = new long[A.length];\\n        twoPow[0] = 1;\\n        for(int i = 1; i < A.length; ++i) {\\n            twoPow[i] = (twoPow[i - 1] << 1) % 1000000007l;\\n        }\\n        long res = 0;\\n        for(int i = 0; i < A.length - 1; ++i) {\\n            long tail = sum[A.length - 1] - sum[A.length - i - 2];\\n            long head = sum[i];\\n            res += (tail - head) * twoPow[A.length - i - 2];\\n            res = res % 1000000007l;\\n        }\\n        return (int) res;\\n    }\\n    \\n    // public long pow(long num, long exp) {\\n    //     if (exp == 0) {\\n    //         return 1l;\\n    //     }\\n    //     if (exp == 1) {\\n    //         return num;\\n    //     }\\n    //     long tmp = (exp & 1) == 0 ? 1 : num;\\n    //     long value = pow(num, exp / 2) % 1000000007l;\\n    //     return (tmp * value * value) % 1000000007l;\\n    // }\\n}\\n\\n//[1, 2, 3]\\n//[1, 3] * 2 + [1, 2] * 1\\n//[2, 3] * 1\\n\\n//[1, 3, 3]\\n\\n//[1, 3]\\n//[1, 3, 3]\\n//(a[0] - a[10]) * 8 + (a[0] - a[9]) * 7 + (a[0] - a[8]) * 6 + .... (a[0] - a[1])\\n//(a[1] - a[10]) * 7 + (a[1] - a[9]) * 6\\n//(a[2] - a[10]) * 6 ....\\n//(a[i] - a[10]) * (n - i - 2)\\n//(a[9] - a[10])\\n\\n\\n// ((a[n] + a[n - 1] ... + a[n - i]) - (a[0] + a[1] + ... + a[i])) * (n - i - 2)",
                "solutionTags": [],
                "code": "class Solution {\\n    public int sumSubseqWidths(int[] A) {\\n        if (A == null || A.length <= 1) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 474540,
                "title": "a-ordinary-solution-for-ordinary-people-but-simple-and-easy-to-come-up-with",
                "content": "After sorting the array. We group the A[i], A[j] pairs by the length (j - i - 1). Then we notice that the contribution of pairs with the same length can be calculated with the help of presum in one time.  \\n```\\nclass Solution {\\n    private static final int mod = (int)1e9 + 7;\\n    \\n    public int sumSubseqWidths(int[] A) {\\n        int n = A.length;\\n        int[] pow = new int[n + 1];\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * 2) % mod;\\n        \\n        Arrays.sort(A);\\n        int[] presum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) presum[i] = (presum[i - 1] + A[i - 1]) % mod;\\n        \\n        long res = 0;\\n        for (int j = 0; j <= n - 2; j++) {\\n            long cur = (presum[n] - presum[j + 1] - presum[n - j - 1] + mod) % mod;\\n            cur = (cur * pow[j]) % mod;\\n            res = (res + cur) % mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int mod = (int)1e9 + 7;\\n    \\n    public int sumSubseqWidths(int[] A) {\\n        int n = A.length;\\n        int[] pow = new int[n + 1];\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * 2) % mod;\\n        \\n        Arrays.sort(A);\\n        int[] presum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) presum[i] = (presum[i - 1] + A[i - 1]) % mod;\\n        \\n        long res = 0;\\n        for (int j = 0; j <= n - 2; j++) {\\n            long cur = (presum[n] - presum[j + 1] - presum[n - j - 1] + mod) % mod;\\n            cur = (cur * pow[j]) % mod;\\n            res = (res + cur) % mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415126,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int SumSubseqWidths(int[] arr) \\n    {\\n        Array.Sort(arr);\\n        long res = 0, mod = 1_000_000_007, pow = 1, n = arr.Length;\\n        for(int i = 0; i < arr.Length; i++, pow = (2 * pow) % mod)\\n            res =  (res + (long) arr[i] * pow - (long) arr[n - i - 1] * pow) % mod;\\n        return  (int) res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int SumSubseqWidths(int[] arr) \\n    {\\n        Array.Sort(arr);\\n        long res = 0, mod = 1_000_000_007, pow = 1, n = arr.Length;\\n        for(int i = 0; i < arr.Length; i++, pow = (2 * pow) % mod)\\n            res =  (res + (long) arr[i] * pow - (long) arr[n - i - 1] * pow) % mod;\\n        return  (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380768,
                "title": "python-solution-suggestions-for-improvement-are-welcome",
                "content": "For each element we count the number of subsequences it is the maximum element of, like wise for the minimum. Multiply the counts with the values and subtract the minSum from the maxSum. I wonder where I can improve my code\\'s speed ? Maybe the powers of 2 can be done faster using merging ?? \\n\\n```\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        S = 0\\n        B = [1]*len(A)\\n        for i in range(1,len(B)):\\n            B[i] = 2*B[i-1]\\n        for i in range(len(A)):\\n            S += (B[i]-B[-1-i])*A[i]\\n        return S%((10**9)+7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        S = 0\\n        B = [1]*len(A)\\n        for i in range(1,len(B)):\\n            B[i] = 2*B[i-1]\\n        for i in range(len(A)):\\n            S += (B[i]-B[-1-i])*A[i]\\n        return S%((10**9)+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 380613,
                "title": "javascript-why-its-failing-for",
                "content": "Failing for\\n\\n[5,69,89,92,31,16,25,45,63,40,16,56,24,40,75,82,40,12,50,62,92,44,67,38,92,22,91,24,26,21,100,42,23,56,64,43,95,76,84,79,89,4,16,94,16,77,92,9,30,13]\\nOutput:\\n102383039574557488\\nExpected:\\n857876214\\n\\n```var sumSubseqWidths = function(A) {\\n  let min = 0;\\n  let max = 0;\\n  let N = A.length;\\n  A = A.sort((a,b) => a-b);\\n  for(let i =0; i < N;i++){\\n      let minTemp = Math.floor(Math.pow(2, i ) - 1)\\n      max += A[i]*(minTemp)\\n      min += A[i]*( Math.pow(2, (N - i - 1)) - 1);\\n  }\\n  result = max - min;\\n  return result\\n};```",
                "solutionTags": [],
                "code": "```var sumSubseqWidths = function(A) {\\n  let min = 0;\\n  let max = 0;\\n  let N = A.length;\\n  A = A.sort((a,b) => a-b);\\n  for(let i =0; i < N;i++){\\n      let minTemp = Math.floor(Math.pow(2, i ) - 1)\\n      max += A[i]*(minTemp)\\n      min += A[i]*( Math.pow(2, (N - i - 1)) - 1);\\n  }\\n  result = max - min;\\n  return result\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 376893,
                "title": "simple-explanation-cpp",
                "content": "first sort the array \\nso we have (2^i-1)  (selecting certain element or not selecting 2^i-1 options ) options for making certain a[i] maximum in the sorted array and (2^(n-i-1)-1) options for making it minimum for i (  0 to  n-1) \\n\\nso adding (2^i-1)a[i] ans subtracting (2^(n-1-i) -1)a[i]  for every i \\n\\n\\n\\n\\n#define ll  long long\\nconst ll m= 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n\\n    int sumSubseqWidths(vector<int>& a) \\n\\t\\n    {\\n\\t\\n\\t\\t\\tll res = 0, n = a.size();\\n\\t\\t\\tsort(a.begin(), a.end());\\n\\t\\t\\tll dp[20001];\\n\\t\\t\\tmemset(dp,0,sizeof(dp));\\n\\t\\t\\tdp[0] = 1;\\n\\t\\t\\tfor(int i = 1; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i] = (dp[i - 1] % m * 2) % m;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres += a[i] * (dp[i] - dp[n - i - 1]);\\n\\t\\t\\t\\tres %= m;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n};\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int sumSubseqWidths(vector<int>& a) \\n\\t\\n    {\\n\\t\\n\\t\\t\\tll res = 0, n = a.size();\\n\\t\\t\\tsort(a.begin(), a.end());\\n\\t\\t\\tll dp[20001];\\n\\t\\t\\tmemset(dp,0,sizeof(dp));\\n\\t\\t\\tdp[0] = 1;\\n\\t\\t\\tfor(int i = 1; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i] = (dp[i - 1] % m * 2) % m;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 297594,
                "title": "java-solution-in-dp-but-always-time-limit-exceeded",
                "content": "```\\n    public int sumSubseqWidths(int[] A) {\\n        List<MinMaxPair> subseqList = new ArrayList<>();\\n        int result = 0;\\n        for (int num : A) {\\n            if (subseqList.isEmpty()) {\\n                MinMaxPair pair = new MinMaxPair(num, num);\\n                subseqList.add(pair);\\n            } else {\\n                int size = subseqList.size();\\n                for (int i = 0; i < size; i++) {\\n                    MinMaxPair oldPair = subseqList.get(i);\\n                    MinMaxPair newPair = new MinMaxPair(oldPair);\\n                    subseqList.add(newPair);\\n                    if (num < newPair.min) {\\n                        newPair.min = num;\\n                    }\\n                    if (num > newPair.max) {\\n                        newPair.max = num;\\n                    }\\n                    result += (newPair.max - newPair.min);\\n                }\\n                MinMaxPair pair = new MinMaxPair(num, num);\\n                subseqList.add(pair);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    class MinMaxPair {\\n        public int min;\\n        public int max;\\n\\n        MinMaxPair(int min, int max) {\\n            this.min = min;\\n            this.max = max;\\n        }\\n\\n        MinMaxPair(MinMaxPair pair) {\\n            this.min = pair.min;\\n            this.max = pair.max;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int sumSubseqWidths(int[] A) {\\n        List<MinMaxPair> subseqList = new ArrayList<>();\\n        int result = 0;\\n        for (int num : A) {\\n            if (subseqList.isEmpty()) {\\n                MinMaxPair pair = new MinMaxPair(num, num);\\n                subseqList.add(pair);\\n            } else {\\n                int size = subseqList.size();\\n                for (int i = 0; i < size; i++) {\\n                    MinMaxPair oldPair = subseqList.get(i);\\n                    MinMaxPair newPair = new MinMaxPair(oldPair);\\n                    subseqList.add(newPair);\\n                    if (num < newPair.min) {\\n                        newPair.min = num;\\n                    }\\n                    if (num > newPair.max) {\\n                        newPair.max = num;\\n                    }\\n                    result += (newPair.max - newPair.min);\\n                }\\n                MinMaxPair pair = new MinMaxPair(num, num);\\n                subseqList.add(pair);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    class MinMaxPair {\\n        public int min;\\n        public int max;\\n\\n        MinMaxPair(int min, int max) {\\n            this.min = min;\\n            this.max = max;\\n        }\\n\\n        MinMaxPair(MinMaxPair pair) {\\n            this.min = pair.min;\\n            this.max = pair.max;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291698,
                "title": "go-most-fast-solution-without-power-or-multiply",
                "content": "```go\\nfunc sumSubseqWidths(A []int) int {\\n\\tsort.Ints(A)\\n\\tvar ans int = 0\\n\\tfor i:=0; i<len(A); i++ {\\n\\t\\tans *= 2\\n\\t\\tans += A[len(A)-1-i] - A[i]\\n\\t\\tans %= 1E9+7\\n\\t}\\n\\tif ans < 0 { ans += 1E9+7 }\\n\\treturn ans\\n}\\n```\\n\\nWe can do it top-down so that we can avoid multiply or shift or power\\nThis could help if A is extremely long",
                "solutionTags": [],
                "code": "```go\\nfunc sumSubseqWidths(A []int) int {\\n\\tsort.Ints(A)\\n\\tvar ans int = 0\\n\\tfor i:=0; i<len(A); i++ {\\n\\t\\tans *= 2\\n\\t\\tans += A[len(A)-1-i] - A[i]\\n\\t\\tans %= 1E9+7\\n\\t}\\n\\tif ans < 0 { ans += 1E9+7 }\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 281708,
                "title": "super-nice-and-clean-java",
                "content": "\\n```\\nimport java.math.BigInteger;\\nimport java.util.Arrays;\\n\\nclass Solution {\\n\\n    public int sumSubseqWidths(final int[] arr) {\\n        if (arr.length == 1) {\\n            return 0;\\n        }\\n\\n        Arrays.sort(arr);\\n        BigInteger count = BigInteger.ZERO;\\n\\n        for (int gap = 0; gap < arr.length - 1; gap++) {\\n            long sumPerGap = 0L;\\n\\n            for (int i = 0; i + gap + 1 < arr.length; i++) {\\n                sumPerGap = sumPerGap + (arr[i + gap + 1] - arr[i]);\\n            }\\n\\n            count = count.add(BigInteger.valueOf(sumPerGap).multiply(BigInteger.valueOf(2).pow(gap)));\\n        }\\n\\n        return count.remainder(BigInteger.valueOf((long)Math.pow(10, 9) + 7)).intValue();\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\nimport java.util.Arrays;\\n\\nclass Solution {\\n\\n    public int sumSubseqWidths(final int[] arr) {\\n        if (arr.length == 1) {\\n            return 0;\\n        }\\n\\n        Arrays.sort(arr);\\n        BigInteger count = BigInteger.ZERO;\\n\\n        for (int gap = 0; gap < arr.length - 1; gap++) {\\n            long sumPerGap = 0L;\\n\\n            for (int i = 0; i + gap + 1 < arr.length; i++) {\\n                sumPerGap = sumPerGap + (arr[i + gap + 1] - arr[i]);\\n            }\\n\\n            count = count.add(BigInteger.valueOf(sumPerGap).multiply(BigInteger.valueOf(2).pow(gap)));\\n        }\\n\\n        return count.remainder(BigInteger.valueOf((long)Math.pow(10, 9) + 7)).intValue();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222325,
                "title": "o-n-nlog-n",
                "content": "1.sort the array\\n2.iterate from 1 to n\\n3.using the fact that # subsequence upto i is equal to sum(# subsequence from [0,n-1])+1\\n4.use long long int to handel higher test cases\\n\\n```\\nclass Solution {\\n    private : int mod=pow(10,9)+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<long long >size(A.size(),0);\\n        vector<long long >sum(A.size(),0);\\n        long long  real=0;\\n        size[0]=1;\\n        sum[0]=A[0];\\n        vector<long long >temp(A.size(),0);\\n        \\n        for(int i=1;i<A.size();i++){\\n            real=((A[i]*size[i-1])%mod-sum[i-1]+mod)%mod;\\n            temp[i]=real;\\n            size[i]=(2*size[i-1]+1)%mod;\\n            sum[i]=( (sum[i-1]+sum[i-1])%mod+A[i]+mod)%mod;\\n            \\n        }\\n        real=0;\\n        for(int i=0;i<temp.size();i++){\\n            real=(real+temp[i]+mod)%mod;\\n        }\\n        \\n        return real;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private : int mod=pow(10,9)+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<long long >size(A.size(),0);\\n        vector<long long >sum(A.size(),0);\\n        long long  real=0;\\n        size[0]=1;\\n        sum[0]=A[0];\\n        vector<long long >temp(A.size(),0);\\n        \\n        for(int i=1;i<A.size();i++){\\n            real=((A[i]*size[i-1])%mod-sum[i-1]+mod)%mod;\\n            temp[i]=real;\\n            size[i]=(2*size[i-1]+1)%mod;\\n            sum[i]=( (sum[i-1]+sum[i-1])%mod+A[i]+mod)%mod;\\n            \\n        }\\n        real=0;\\n        for(int i=0;i<temp.size();i++){\\n            real=(real+temp[i]+mod)%mod;\\n        }\\n        \\n        return real;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213939,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def sumSubseqWidths(self, A):\\n        s = diff = 0 \\n        k = 1 << max(len(A)-2,0)\\n        A.sort() \\n        for i in range(len(A)):\\n            diff += A[~i] - A[i] \\n            s += k * diff \\n            k >>= 1 \\n        return s % (10 ** 9 + 7)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def sumSubseqWidths(self, A):\\n        s = diff = 0 \\n        k = 1 << max(len(A)-2,0)\\n        A.sort() \\n        for i in range(len(A)):\\n            diff += A[~i] - A[i] \\n            s += k * diff \\n            k >>= 1 \\n        return s % (10 ** 9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 190386,
                "title": "could-someone-help-me-why-my-algorithm-is-not-correct",
                "content": "I think algorithm is straightforward.\\n1. We sort the array.\\n2. We loop from smallest to largest number.\\n3. For each number we calculate in how many subsequences we can have when we pick minimum and maximum, A[i] and A[j] in the code, the number will be pow(2, j - i - 1)\\n\\n failed at:\\n[96,87,191,197,40,101,108,35,169,50,168,182,95,80,144,43,18,60,174,13,77,173,38,46,80,117,13,19,11,6,13,118,39,80,171,36,86,156,165,190,53,49,160,192,57,42,97,35,124,200,84,70,145,180,54,141,159,42,66,66,25,95,24,136,140,159,71,131,5,140,115,76,151,137,63,47,69,164,60,172,153,183,6,70,40,168,133,45,116,188,20,52,70,156,44,27,124,59,42,172]\\nmy outcome is: 931507168\\nthe expected is: 136988321\\n\\nMuch appreciated.\\n```\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long result = 0;\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int j = i + 1; j < A.size(); j++) {\\n                int gap = A[j] - A[i];\\n                long count = pow(2, j - i - 1);\\n                count %= mod;\\n                result += count * gap;\\n                result %= mod;\\n            }\\n        }\\n        return result % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long result = 0;\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int j = i + 1; j < A.size(); j++) {\\n                int gap = A[j] - A[i];\\n                long count = pow(2, j - i - 1);\\n                count %= mod;\\n                result += count * gap;\\n                result %= mod;\\n            }\\n        }\\n        return result % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185577,
                "title": "explaining-the-nlogn-n-thought-process",
                "content": "```\\n# Note that 1 << k == 2**k\\ndef sum_subsequence_widths(nums):\\n    nums.sort()\\n    mod = 10**9 + 7\\n    result = 0\\n    for i, n in enumerate(nums):\\n        # I am min for all the subsequences that start at me and end to the right.\\n        # For each of the subsequences that end to my right, subtract me once as min.\\n        result = (result - n*(1 << len(nums)-i-1)) % mod\\n        # I am max for all the subsequences that end at me.\\n        # For each of the subsequences that begin to my left, add me once as max.\\n        result = (result + n*(1 << i)) % mod\\n    \\n    return result\\n```",
                "solutionTags": [],
                "code": "```\\n# Note that 1 << k == 2**k\\ndef sum_subsequence_widths(nums):\\n    nums.sort()\\n    mod = 10**9 + 7\\n    result = 0\\n    for i, n in enumerate(nums):\\n        # I am min for all the subsequences that start at me and end to the right.\\n        # For each of the subsequences that end to my right, subtract me once as min.\\n        result = (result - n*(1 << len(nums)-i-1)) % mod\\n        # I am max for all the subsequences that end at me.\\n        # For each of the subsequences that begin to my left, add me once as max.\\n        result = (result + n*(1 << i)) % mod\\n    \\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 169511,
                "title": "lookup-table-of-the-power-of-2-for-acceleration",
                "content": "Use the dp lookup table to save the computation time.\\n```cpp\\n#define ll  long long\\nconst ll MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) \\n    {\\n        ll res = 0, sz = A.size();\\n        sort(A.begin(), A.end());\\n        ll dp[20001] = {0};\\n        dp[0] = 1;\\n        for(int i = 1; i < sz; i++)\\n        {\\n            dp[i] = (dp[i - 1] % MOD * 2) % MOD;\\n        }\\n        for(int i = 0; i < sz; i++)\\n        {\\n            res += A[i] * (dp[i] - dp[sz - i - 1]);\\n            res %= MOD;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n#define ll  long long\\nconst ll MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) \\n    {\\n        ll res = 0, sz = A.size();\\n        sort(A.begin(), A.end());\\n        ll dp[20001] = {0};\\n        dp[0] = 1;\\n        for(int i = 1; i < sz; i++)\\n        {\\n            dp[i] = (dp[i - 1] % MOD * 2) % MOD;\\n        }\\n        for(int i = 0; i < sz; i++)\\n        {\\n            res += A[i] * (dp[i] - dp[sz - i - 1]);\\n            res %= MOD;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167688,
                "title": "better-choice-of-modulo",
                "content": "Problems like this should have a smaller modulo so that the calculations never run into long type. Wrong answer due to use of **int** when answer is expected in **int** is simply infuriating.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 163661,
                "title": "what-is-the-error-in-this",
                "content": "```\\nsubs,r={()},0\\n        for num in nums:\\n            subs |= {sub+(num,)\\n                    for sub in subs}\\n        \\n        for i in subs:\\n            if len(i)>1: r+=max(i)-min(i)\\n                \\n        return r%((pow(10,9)+7))\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nsubs,r={()},0\\n        for num in nums:\\n            subs |= {sub+(num,)\\n                    for sub in subs}\\n        \\n        for i in subs:\\n            if len(i)>1: r+=max(i)-min(i)\\n                \\n        return r%((pow(10,9)+7))\\n\\t\\t\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 161885,
                "title": "python-math-time-o-nlogn",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        length=len(A)\\n        if(length==1):\\n            return 0\\n        p1=length-1\\n        p2=0\\n        P1=2**(length-1)\\n        P2=2**0\\n        index=0\\n        A.sort()\\n        mod=10**9+7\\n        while(p1>p2):\\n            index+=((P1-P2)*(A[p1]-A[p2]))\\n            index%=mod\\n            p1-=1\\n            p2+=1\\n            P1//=2\\n            P2*=2\\n        return index\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        length=len(A)\\n        if(length==1):\\n            return 0\\n        p1=length-1\\n        p2=0\\n        P1=2**(length-1)\\n        P2=2**0\\n        index=0\\n        A.sort()\\n        mod=10**9+7\\n        while(p1>p2):\\n            index+=((P1-P2)*(A[p1]-A[p2]))\\n            index%=mod\\n            p1-=1\\n            p2+=1\\n            P1//=2\\n            P2*=2\\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161842,
                "title": "c-math-dp-solution-easy-to-explain-and-impl-in-20mins",
                "content": "```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nconst int MOD = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n\\n        long long cur = 0;\\n        long long base = 1;\\n        long long res = 0;\\n\\n        int n = A.size();\\n        for (int i = 1; i < n; ++i) {\\n            long long delta = A[i] - A[i - 1];\\n            base = (base * 2) % MOD;\\n            cur = (cur * 2 + delta * (base - 1)) % MOD;\\n            res = (res + cur) % MOD;\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nconst int MOD = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n\\n        long long cur = 0;\\n        long long base = 1;\\n        long long res = 0;\\n\\n        int n = A.size();\\n        for (int i = 1; i < n; ++i) {\\n            long long delta = A[i] - A[i - 1];\\n            base = (base * 2) % MOD;\\n            cur = (cur * 2 + delta * (base - 1)) % MOD;\\n            res = (res + cur) % MOD;\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 161742,
                "title": "my-c-o-nlgn-time-o-1-space-solution-with-detail-explanation",
                "content": "1. Sort the array first.\\n2.  For each pair `[j, i]`, if we choose elements between `j` ans `i`, then the maximum element is `A[i]`, and the minimum element is `A[j]`.\\n3.  We will choose at least two elements(which is `A[j]` and `A[i]`) and at most `i-j+1` elements.\\n4.  The total sum of pair `[j, i]` is \\n`(A[i] - A[j]) * (C(0, i-j-1) + C(1, i-j-1) + ... + C(i-j-1, i-j-1))`\\n`=(A[i] - A[j]) * (2^(i-j-1))`  \\n(`C(x, y)` means the total combinations of `y` numbers select `x` numbers)\\n5. Given an `i`, we can calculate all pairs `[j, i]`(`0 <= j < i`), use `S` to store\\n`S[i] = A[i] * (2^(i-1) + 2^(i-2) + ... + 2^(i-j-1) + ... + 2^1 + 2^0) `\\n`- (A[0] * 2^(i-1) + A[1] * 2^(i-2) + ... + A[j] * 2^(i-j-1) + ... + A[i-1] * 2^0)`\\n`= A[i] * (2^i - 1) -  (A[0] * 2^(i-1) + A[1] * 2^(i-2) + ... + A[j] * 2^(i-j-1) + ... + A[i-1] * 2^0)` \\n6. Use `sum` to store the right part of `-`, so we get this:\\n`S[i] = A[i] * (2^i - 1) -  sum[i]`\\n`sum[i] = 2 * sum[i-1] + A[i-1]`\\n7. The answer is sum of `S`, (by the way don\\'t forget mod `1000000007`)\\nthe c++ code below use two varible(`ans` and `sum`) to save the space.\\n```\\nclass Solution {\\npublic:\\n    #define M 1000000007\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long long ans=0, sum=A[0], p=2;\\n        for (int i=1;i<A.size();++i){\\n            ans=(ans+(p-1)*A[i]-sum)%M;\\n            sum=(2*sum+A[i])%M;\\n            p=(p<<1)%M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define M 1000000007\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long long ans=0, sum=A[0], p=2;\\n        for (int i=1;i<A.size();++i){\\n            ans=(ans+(p-1)*A[i]-sum)%M;\\n            sum=(2*sum+A[i])%M;\\n            p=(p<<1)%M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161393,
                "title": "19-64-test-pass-i-don-t-know-why-i-was-wrong-i-think-i-am-right",
                "content": "```\\n public  int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        for(int i:A)System.out.println(i);\\n        int sum=0;\\n        for(int n=2;n<=A.length;n++)\\n        {\\n            for(int m=0;m<=n-2;m++)\\n            {\\n                sum+=(A[n-1]-A[m])*(Math.pow(2,n-2-m));\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public  int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        for(int i:A)System.out.println(i);\\n        int sum=0;\\n        for(int n=2;n<=A.length;n++)\\n        {\\n            for(int m=0;m<=n-2;m++)\\n            {\\n                sum+=(A[n-1]-A[m])*(Math.pow(2,n-2-m));\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1568049,
                "content": [
                    {
                        "username": "leetgugu",
                        "content": "Firstly I used  a simple way as the provided solution like this:\\n       //sort A first\\n       sum += (A[j] - A[i]) * pow(2, j-i-1);\\nThen I realized the duplicated number is different and should be treated in a different way.\\n\\nLook the testcase array: [2,3,3,7]. The sum should be calculated with such steps:\\n1) subarray [2,3,3]:    non-zero sequence [2,3]  and [2,3,3] then sum += 2*1\\n2) subarray [2,3,3,7]: non-zero sequence [2,7], [2,3,7], [2,3,3,7]. then sum += 3*5\\n3) subarray [3,3]: sum += 0\\n4) subarray [3,3,7]: non-zero sequence [3,7],[3,3,7],  then sum += 2*4\\n\\nSo the final result is 25, rather than 35.\\n\\n35 is calculated by this way:\\n[2,3]   ----> [2,3]                sum += 1 * 1\\n[2,3,3] ---->[2,3](the number  3 is the number at last pos),[2,3,3]      sum += 2 * 1\\n[2,3,3,7] --->[2,7],[2,3,7],[2,3,7],[2,3,3,7]       sum += 4 * 5\\n[3,3,7].  ----> [3,7],[3,3,7].                sum += 2 * 4\\n[3,7]. -------->[3,7]                   sum += 1 * 4\\nthen sum =35\\n\\nbut I think when the duplicated numbers in different postions are picked into a subsequence, the original postion does not make any sense, so some subsequences which are equal should be ignored. Then the final sum is 25 in this testcase.\\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* **Sort**: Since Q does\\'t involve subarray, and sorting doesn\\'t affect the min-max in a subsequence, SORT!\\n* **Element contribution**: Instead of condiering the naive 2^N backtracking approach, consider each element being min and max. For this pre-computation of sort BECAME HANDY.\\n* **Subsequence property**: No. of subsequences ending at index i = 2^i\\n\\n**Similar**: https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/\\n\\n**Subsequences properties**:\\n![image](https://assets.leetcode.com/users/images/c6097e86-b794-4ae0-9612-9834a590ab75_1633799786.4522336.jpeg)\\n\\n"
                    },
                    {
                        "username": "huyalvchuan",
                        "content": "\\u5148\\u6392\\u5E8F\\u5F97\\u5230\\u6392\\u5E8F\\u540E\\u7684A\\n\\u7136\\u540E\\u6211\\u4EEC\\u901A\\u8FC7\\u89C2\\u5BDF\\u5F97\\u5230\\u4E0B\\u9762\\u7684\\u4E00\\u4E2A\\u516C\\u5F0F\\uFF1A\\nf(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u5BBD\\u3002\\nk(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u4E2A\\u6570\\n\\u90A3\\u4E48f(i) = 2 * (f(i - 1) + A[i] - A[i - 1]) + (A[i] - A[i - 1])"
                    }
                ]
            },
            {
                "id": 1567677,
                "content": [
                    {
                        "username": "leetgugu",
                        "content": "Firstly I used  a simple way as the provided solution like this:\\n       //sort A first\\n       sum += (A[j] - A[i]) * pow(2, j-i-1);\\nThen I realized the duplicated number is different and should be treated in a different way.\\n\\nLook the testcase array: [2,3,3,7]. The sum should be calculated with such steps:\\n1) subarray [2,3,3]:    non-zero sequence [2,3]  and [2,3,3] then sum += 2*1\\n2) subarray [2,3,3,7]: non-zero sequence [2,7], [2,3,7], [2,3,3,7]. then sum += 3*5\\n3) subarray [3,3]: sum += 0\\n4) subarray [3,3,7]: non-zero sequence [3,7],[3,3,7],  then sum += 2*4\\n\\nSo the final result is 25, rather than 35.\\n\\n35 is calculated by this way:\\n[2,3]   ----> [2,3]                sum += 1 * 1\\n[2,3,3] ---->[2,3](the number  3 is the number at last pos),[2,3,3]      sum += 2 * 1\\n[2,3,3,7] --->[2,7],[2,3,7],[2,3,7],[2,3,3,7]       sum += 4 * 5\\n[3,3,7].  ----> [3,7],[3,3,7].                sum += 2 * 4\\n[3,7]. -------->[3,7]                   sum += 1 * 4\\nthen sum =35\\n\\nbut I think when the duplicated numbers in different postions are picked into a subsequence, the original postion does not make any sense, so some subsequences which are equal should be ignored. Then the final sum is 25 in this testcase.\\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* **Sort**: Since Q does\\'t involve subarray, and sorting doesn\\'t affect the min-max in a subsequence, SORT!\\n* **Element contribution**: Instead of condiering the naive 2^N backtracking approach, consider each element being min and max. For this pre-computation of sort BECAME HANDY.\\n* **Subsequence property**: No. of subsequences ending at index i = 2^i\\n\\n**Similar**: https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/\\n\\n**Subsequences properties**:\\n![image](https://assets.leetcode.com/users/images/c6097e86-b794-4ae0-9612-9834a590ab75_1633799786.4522336.jpeg)\\n\\n"
                    },
                    {
                        "username": "huyalvchuan",
                        "content": "\\u5148\\u6392\\u5E8F\\u5F97\\u5230\\u6392\\u5E8F\\u540E\\u7684A\\n\\u7136\\u540E\\u6211\\u4EEC\\u901A\\u8FC7\\u89C2\\u5BDF\\u5F97\\u5230\\u4E0B\\u9762\\u7684\\u4E00\\u4E2A\\u516C\\u5F0F\\uFF1A\\nf(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u5BBD\\u3002\\nk(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u4E2A\\u6570\\n\\u90A3\\u4E48f(i) = 2 * (f(i - 1) + A[i] - A[i - 1]) + (A[i] - A[i - 1])"
                    }
                ]
            },
            {
                "id": 1572356,
                "content": [
                    {
                        "username": "leetgugu",
                        "content": "Firstly I used  a simple way as the provided solution like this:\\n       //sort A first\\n       sum += (A[j] - A[i]) * pow(2, j-i-1);\\nThen I realized the duplicated number is different and should be treated in a different way.\\n\\nLook the testcase array: [2,3,3,7]. The sum should be calculated with such steps:\\n1) subarray [2,3,3]:    non-zero sequence [2,3]  and [2,3,3] then sum += 2*1\\n2) subarray [2,3,3,7]: non-zero sequence [2,7], [2,3,7], [2,3,3,7]. then sum += 3*5\\n3) subarray [3,3]: sum += 0\\n4) subarray [3,3,7]: non-zero sequence [3,7],[3,3,7],  then sum += 2*4\\n\\nSo the final result is 25, rather than 35.\\n\\n35 is calculated by this way:\\n[2,3]   ----> [2,3]                sum += 1 * 1\\n[2,3,3] ---->[2,3](the number  3 is the number at last pos),[2,3,3]      sum += 2 * 1\\n[2,3,3,7] --->[2,7],[2,3,7],[2,3,7],[2,3,3,7]       sum += 4 * 5\\n[3,3,7].  ----> [3,7],[3,3,7].                sum += 2 * 4\\n[3,7]. -------->[3,7]                   sum += 1 * 4\\nthen sum =35\\n\\nbut I think when the duplicated numbers in different postions are picked into a subsequence, the original postion does not make any sense, so some subsequences which are equal should be ignored. Then the final sum is 25 in this testcase.\\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* **Sort**: Since Q does\\'t involve subarray, and sorting doesn\\'t affect the min-max in a subsequence, SORT!\\n* **Element contribution**: Instead of condiering the naive 2^N backtracking approach, consider each element being min and max. For this pre-computation of sort BECAME HANDY.\\n* **Subsequence property**: No. of subsequences ending at index i = 2^i\\n\\n**Similar**: https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/\\n\\n**Subsequences properties**:\\n![image](https://assets.leetcode.com/users/images/c6097e86-b794-4ae0-9612-9834a590ab75_1633799786.4522336.jpeg)\\n\\n"
                    },
                    {
                        "username": "huyalvchuan",
                        "content": "\\u5148\\u6392\\u5E8F\\u5F97\\u5230\\u6392\\u5E8F\\u540E\\u7684A\\n\\u7136\\u540E\\u6211\\u4EEC\\u901A\\u8FC7\\u89C2\\u5BDF\\u5F97\\u5230\\u4E0B\\u9762\\u7684\\u4E00\\u4E2A\\u516C\\u5F0F\\uFF1A\\nf(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u5BBD\\u3002\\nk(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u4E2A\\u6570\\n\\u90A3\\u4E48f(i) = 2 * (f(i - 1) + A[i] - A[i - 1]) + (A[i] - A[i - 1])"
                    }
                ]
            }
        ]
    },
    {
        "title": "Replace Elements with Greatest Element on Right Side",
        "question_content": "<p>Given an array <code>arr</code>,&nbsp;replace every element in that array with the greatest element among the elements to its&nbsp;right, and replace the last element with <code>-1</code>.</p>\n\n<p>After doing so, return the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [17,18,5,4,6,1]\n<strong>Output:</strong> [18,6,6,6,1,-1]\n<strong>Explanation:</strong> \n- index 0 --&gt; the greatest element to the right of index 0 is index 1 (18).\n- index 1 --&gt; the greatest element to the right of index 1 is index 4 (6).\n- index 2 --&gt; the greatest element to the right of index 2 is index 4 (6).\n- index 3 --&gt; the greatest element to the right of index 3 is index 4 (6).\n- index 4 --&gt; the greatest element to the right of index 4 is index 5 (1).\n- index 5 --&gt; there are no elements to the right of index 5, so we put -1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [400]\n<strong>Output:</strong> [-1]\n<strong>Explanation:</strong> There are no elements to the right of index 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 463249,
                "title": "java-c-python-straight-forward",
                "content": "## **Explanation**\\nIterate from the back to the start,\\nWe initilize `mx = -1`, where `mx` represent the max on the right.\\nEach round, we set `A[i] = mx`, where `mx` is its mas on the right.\\nAlso we update `mx = max(mx, A[i])`, where `A[i]` is its  original value.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int[] replaceElements(int[] A) {\\n        for (int i = A.length - 1, mx = -1; i >= 0; --i)\\n            mx = Math.max(A[i], A[i] = mx);\\n        return A;\\n    }\\n```\\n\\n**Java, expanded version:**\\n```java\\n    public int[] replaceElements2(int[] A) {\\n        int mx = -1, n = A.length, a;\\n        for (int i = n - 1; i >= 0; --i) {\\n            a = A[i];\\n            A[i] = mx;\\n            mx = Math.max(mx, a);\\n        }\\n        return A;\\n    }\\n```\\n\\n**C++:**\\n@0xFFFFFFFF suggest using `exchange`\\n```cpp\\n    vector<int> replaceElements(vector<int>& A, int mx = -1) {\\n        for (int i = A.size() - 1; i >= 0; --i)\\n            mx = max(mx, exchange(A[i], mx));\\n        return A;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def replaceElements(self, A, mx = -1):\\n        for i in xrange(len(A) - 1, -1, -1):\\n            A[i], mx = mx, max(mx, A[i])\\n        return A\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[] replaceElements(int[] A) {\\n        for (int i = A.length - 1, mx = -1; i >= 0; --i)\\n            mx = Math.max(A[i], A[i] = mx);\\n        return A;\\n    }\\n```\n```java\\n    public int[] replaceElements2(int[] A) {\\n        int mx = -1, n = A.length, a;\\n        for (int i = n - 1; i >= 0; --i) {\\n            a = A[i];\\n            A[i] = mx;\\n            mx = Math.max(mx, a);\\n        }\\n        return A;\\n    }\\n```\n```cpp\\n    vector<int> replaceElements(vector<int>& A, int mx = -1) {\\n        for (int i = A.size() - 1; i >= 0; --i)\\n            mx = max(mx, exchange(A[i], mx));\\n        return A;\\n    }\\n```\n```python\\n    def replaceElements(self, A, mx = -1):\\n        for i in xrange(len(A) - 1, -1, -1):\\n            A[i], mx = mx, max(mx, A[i])\\n        return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 799052,
                "title": "easy-c-solution-o-n-faster-than-99-44",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        int n=arr.size(),temp,mx=-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            temp=arr[i];\\n            arr[i]=mx;\\n            mx=max(mx,temp);\\n        }\\n     return arr;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        int n=arr.size(),temp,mx=-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            temp=arr[i];\\n            arr[i]=mx;\\n            mx=max(mx,temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3340519,
                "title": "java-easy-similar-to-leaders-in-an-array",
                "content": "**T.C.:- O(N)\\nS.C.:- O(1)**\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max=-1;\\n        for(int i=arr.length-1;i>=0;i--){\\n            if(arr[i]>max){\\n                int temp=max;\\n                max=arr[i];\\n                arr[i]=temp;\\n            }\\n            else\\n                arr[i]=max;\\n        }\\n        return arr;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/1bde3f1a-2bb3-45d1-92c0-4d579992e1c6_1679762566.7449884.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max=-1;\\n        for(int i=arr.length-1;i>=0;i--){\\n            if(arr[i]>max){\\n                int temp=max;\\n                max=arr[i];\\n                arr[i]=temp;\\n            }\\n            else\\n                arr[i]=max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544507,
                "title": "i-don-t-understand-the-question",
                "content": "> Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.\\n\\nAfter doing so, return the array.\\n\\n \\n\\nExample 1:\\n\\nInput: arr = [17,18,5,4,6,1]\\nOutput: [18,6,6,6,1,-1]\\n\\n-------------------------------------\\n\\nEvery element in `arr` is `[17,18,5,4,6,1]`. If we replace every element with the greatest element among the elements to its right.. Well there is no other element to the right of the array. After the array, the input is ended. \\n\\nIf they meant repalce _each_ value in that array with the value of the greatest element to that element\\'s right, that\\'s different. Every and each have specific and distinct meaning.\\n\\nWhy are they lying in their question again? To confuse us?\\n\\nFollowing what I\\'ve written, whcih is different, we can get it to pass. We take ` [17,18,5,4,6,1]` and result in  [**18**,18,5,4,6,1], then [18,**6**,5,4,6,1], then [18,6,**6**,4,6,1], then [18,6,6,**6**,6,1], then , then [18,6,6,6,1,1]. \\n\\nAnd then, replacing the last element with `-1`, it becomes [18,6,6,6,1,-**1**].\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nconst replaceElements = function(arr) {\\n    const b = Array.from(arr);\\n    for(let i = 0; i < b.length; i++) {\\n        b[i] = Math.max(...b.slice(i+1));\\n    }\\n    b[b.length-1] = -1;\\n    return b;\\n};\\n```\\nIs it a problem with LeetCode not knowing English? Or do they not know how to proofread? Or are they deliberately fucking the questions up to make easy questions impossible?",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nconst replaceElements = function(arr) {\\n    const b = Array.from(arr);\\n    for(let i = 0; i < b.length; i++) {\\n        b[i] = Math.max(...b.slice(i+1));\\n    }\\n    b[b.length-1] = -1;\\n    return b;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557857,
                "title": "easy-to-understand-simple-python-solution",
                "content": "```\\ndef replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        i = len(arr) -1 \\n        while i >= 0:\\n            temp = arr[i]\\n            arr[i] = m\\n            if temp > m:\\n                m = temp\\n            i-= 1\\n        return arr\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        i = len(arr) -1 \\n        while i >= 0:\\n            temp = arr[i]\\n            arr[i] = m\\n            if temp > m:\\n                m = temp\\n            i-= 1\\n        return arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 487742,
                "title": "javascript-optimal-solution-w-explanation",
                "content": "First of all, I created a base array in which I will write the results.\\n\\nInitially, I already know that there will be a shift in the array: the first value will disappear, and the last will be `-1`. That\\'s why I know that the last `result` value is `-1`.\\n\\nThen, I go through the input `arr` from the end, each time checking the current value `arr[i]` with the previous value that has already been changed (which has the same index in the resulting array `result[i]`) and set the next bigger value in `result[i-1]` because as I go from the end.\\n\\nThe solution is good because in the end, you no longer need to modify the array. It just needs to be returned.\\n<br/>\\n\\n```javascript\\nconst replaceElements = arr => {\\n    const result = new Array(arr.length);\\n    result[arr.length - 1] = -1;\\n    \\n    for (let i = arr.length - 1; i > 0; i -= 1) {\\n        result[i - 1] = Math.max(arr[i], result[i]);\\n    }\\n    \\n    return result;\\n};\\n```\\n\\n<br/>\\n\\nI hope this explanation will be useful to you.\\n\\n<br/>\\n\\n**Results**:\\n\\nRuntime: **72 ms**, faster than **94.81%** of JavaScript online submissions.\\nMemory Usage: **37.9 MB**, less than **100.00%** of JavaScript online submissions.\\n\\n<br/>",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst replaceElements = arr => {\\n    const result = new Array(arr.length);\\n    result[arr.length - 1] = -1;\\n    \\n    for (let i = arr.length - 1; i > 0; i -= 1) {\\n        result[i - 1] = Math.max(arr[i], result[i]);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463227,
                "title": "java-python-3-scan-from-right-to-left",
                "content": "```java\\n    public int[] replaceElements(int[] arr) {\\n        for (int i = arr.length - 1, max = -1; i >= 0; --i) {\\n            int tmp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, tmp);\\n        }\\n        return arr;\\n    }\\n```\\n```python\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        mx = -1\\n        for i in range(len(arr) - 1, -1, -1):\\n            arr[i], mx = mx, max(arr[i], mx)\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int[] replaceElements(int[] arr) {\\n        for (int i = arr.length - 1, max = -1; i >= 0; --i) {\\n            int tmp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, tmp);\\n        }\\n        return arr;\\n    }\\n```\n```python\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        mx = -1\\n        for i in range(len(arr) - 1, -1, -1):\\n            arr[i], mx = mx, max(arr[i], mx)\\n        return arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 482693,
                "title": "java-o-n-time-o-1-space-simple-clear-100-solution",
                "content": "This is the straightforward and simple Java solution to this question\\n```\\n// Replace Elements with Greatest Element on Right Side\\n\\n    public int[] replaceElements(int[] arr) {\\n        int maxSoFar = arr[arr.length - 1]; //take last element in array as maxVal\\n        arr[arr.length - 1] = -1;\\n\\t\\t//start array traversal from right to left\\n        for(int i = arr.length - 2; i > -1; i--){\\n            int currVal = arr[i];\\n            arr[i] = maxSoFar;\\n            maxSoFar = Math.max(maxSoFar, currVal);\\n\\t\\t\\t//keep updating maxRight element encountered so far\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Replace Elements with Greatest Element on Right Side\\n\\n    public int[] replaceElements(int[] arr) {\\n        int maxSoFar = arr[arr.length - 1]; //take last element in array as maxVal\\n        arr[arr.length - 1] = -1;\\n\\t\\t//start array traversal from right to left\\n        for(int i = arr.length - 2; i > -1; i--){\\n            int currVal = arr[i];\\n            arr[i] = maxSoFar;\\n            maxSoFar = Math.max(maxSoFar, currVal);\\n\\t\\t\\t//keep updating maxRight element encountered so far\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463190,
                "title": "java-traverse-backwards",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int n = arr.length;\\n        if(n == 0) return arr;\\n        int max = arr[n - 1];\\n        for(int i = n - 2; i >= 0; i--){\\n            int temp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, temp);\\n        }\\n        arr[n - 1] = -1;\\n        return arr;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int n = arr.length;\\n        if(n == 0) return arr;\\n        int max = arr[n - 1];\\n        for(int i = n - 2; i >= 0; i--){\\n            int temp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1068886,
                "title": "java-fast-solution-beats-100-o-n",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        var max = -1;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            var tmp = arr[i];\\n            arr[i] = max;\\n            if (tmp > max) {\\n                max = tmp;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        var max = -1;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            var tmp = arr[i];\\n            arr[i] = max;\\n            if (tmp > max) {\\n                max = tmp;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522807,
                "title": "python-in-place-clean-4-lines-fast-96ms-99-with-explanation",
                "content": "The standard approach ... we start from the end, use `me` to track the max element to the right value.\\n\\n1. we start with setting me to the value of the last element and setting the last element to -1\\n2. now we slide down to the beginning of the lest and for each step we set the arr[i] to the current me and then we update me to be the max of the current me or the arr[i] value before it was updated. Actually, Python allows both steps to be done in one line without extra temp variables. that is nice. So if you look at `arr[i],me = me,max(me,arr[i])` - the me and arr[i] on the right side are before they were updated and on the left side - after. Neat, right?\\n\\nOk, now we just return arr.\\n\\n```\\nclass Solution(object):\\n    def replaceElements(self, arr):\\n    \\n        me,arr[-1] = arr[-1],-1\\n        \\n        for i in range(len(arr)-2,-1,-1):\\n            arr[i],me = me,max(me,arr[i])\\n            \\n        return arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def replaceElements(self, arr):\\n    \\n        me,arr[-1] = arr[-1],-1\\n        \\n        for i in range(len(arr)-2,-1,-1):\\n            arr[i],me = me,max(me,arr[i])\\n            \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648596,
                "title": "java-easy-to-understand-linear-scanning-from-end-to-beginning",
                "content": "I know it is a very straightforward problem, but still I would like to share my solution in case it might be useful to anyone. I wish you all good luck and have fun.\\n\\n    public int[] replaceElements(int[] arr) {\\n              \\n        int max = -1; // All elements in the input range are positive. Otherwise, it can be modified slightly\\n        \\n        for (int i = arr.length - 1; i >= 0; i--)\\n        {\\n            int temp = arr[i];\\n            arr[i] = max; \\n            max = Math.max(max, temp);\\n        }\\n        return arr;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I know it is a very straightforward problem, but still I would like to share my solution in case it might be useful to anyone. I wish you all good luck and have fun.\\n\\n    public int[] replaceElements(int[] arr) {\\n              \\n        int max = -1; // All elements in the input range are positive. Otherwise, it can be modified slightly\\n        \\n        for (int i = arr.length - 1; i >= 0; i--)\\n        {\\n            int temp = arr[i];\\n            arr[i] = max; \\n            max = Math.max(max, temp);\\n        }\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 478465,
                "title": "python-3-faster-than-99-7-memory-less-than-100",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        out = [-1]\\n        greatest = 0\\n        for num in arr[::-1]:\\n            if greatest < num:\\n                greatest = num\\n            out.append(greatest)\\n        out.pop()\\n        return out[::-1]\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        out = [-1]\\n        greatest = 0\\n        for num in arr[::-1]:\\n            if greatest < num:\\n                greatest = num\\n            out.append(greatest)\\n        out.pop()\\n        return out[::-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2579337,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr)\\n    {\\n        int mx=-1;\\n        for(int i=arr.size()-1;i>=0;i--)\\n        {\\n            int temp=max(mx,arr[i]);\\n            arr[i]=mx;\\n            mx=temp;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr)\\n    {\\n        int mx=-1;\\n        for(int i=arr.size()-1;i>=0;i--)\\n        {\\n            int temp=max(mx,arr[i]);\\n            arr[i]=mx;\\n            mx=temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 612028,
                "title": "java-solution-100-and-100",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int[] result = new int[arr.length];\\n        int maxValue = -1;\\n        for(int x = arr.length-1; x >=0; x--) {\\n        \\tresult[x] = maxValue;\\n        \\tmaxValue = Math.max(arr[x], maxValue);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int[] result = new int[arr.length];\\n        int maxValue = -1;\\n        for(int x = arr.length-1; x >=0; x--) {\\n        \\tresult[x] = maxValue;\\n        \\tmaxValue = Math.max(arr[x], maxValue);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479005,
                "title": "c",
                "content": "```\\npublic int[] ReplaceElements(int[] arr) {\\n\\tvar max = -1;\\n\\tfor (var i = arr.Length - 1; i >= 0; i--) {\\n\\t\\tvar tmp = arr[i];\\n\\t\\tarr[i] = max;\\n\\t\\tif (tmp > max) {\\n\\t\\t\\tmax = tmp;\\n\\t\\t}\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] ReplaceElements(int[] arr) {\\n\\tvar max = -1;\\n\\tfor (var i = arr.Length - 1; i >= 0; i--) {\\n\\t\\tvar tmp = arr[i];\\n\\t\\tarr[i] = max;\\n\\t\\tif (tmp > max) {\\n\\t\\t\\tmax = tmp;\\n\\t\\t}\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 601747,
                "title": "python-super-simple-explanation-must-read",
                "content": "Starting at the end of the array, at each position there are three things to do:\\n\\t\\t1. Hold the value in that position\\n\\t\\t2. Insert maximum number until that position\\n\\t\\t3. Compare \\'hold\\' value with maximum value, the greater is new maximum number.\\n- First maximum number value is -1. \\n- First \\'hold\\' value is value at the end of array\\n\\n```\\n    maxNum = -1\\n\\tfor i in range(len(arr)-1,-1,-1):\\n\\t\\thold = arr[i]\\n\\t\\tarr[i] = maxNum\\n\\t\\tif hold > maxNum:\\n\\t\\t\\tmaxNum = hold\\n\\treturn arr\\n```\\nTime complexity - O(n)\\nSpace complexity - O(1)\\n\\n- amen-Ra",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\n    maxNum = -1\\n\\tfor i in range(len(arr)-1,-1,-1):\\n\\t\\thold = arr[i]\\n\\t\\tarr[i] = maxNum\\n\\t\\tif hold > maxNum:\\n\\t\\t\\tmaxNum = hold\\n\\treturn arr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643620,
                "title": "faster-than-99-31",
                "content": "``` \\nvar replaceElements = function(arr) {\\n    let max = arr[arr.length - 1];\\n    arr[arr.length - 1] = -1;\\n    \\n    for(let i = arr.length - 2; i >= 0; i--) {\\n        let curr = arr[i];\\n        arr[i] = max;\\n        if(curr > max) max = curr;\\n    }\\n    \\n    return arr;\\n};\\n```\\n\\nRuntime: **73** ms, faster than **99.31%** of JavaScript online submissions for Replace Elements with Greatest Element on Right Side.\\nMemory Usage: **45.1** MB, less than **79.20%** of JavaScript online submissions for Replace Elements with Greatest Element on Right Side.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` \\nvar replaceElements = function(arr) {\\n    let max = arr[arr.length - 1];\\n    arr[arr.length - 1] = -1;\\n    \\n    for(let i = arr.length - 2; i >= 0; i--) {\\n        let curr = arr[i];\\n        arr[i] = max;\\n        if(curr > max) max = curr;\\n    }\\n    \\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2366624,
                "title": "with-explanation-comments-time-24-ms-63-84-space-14-6-mb-69-38",
                "content": "**Like it? ->Upvote please!**\\n\\n**Solution 1:**\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        //base case: if there\\'s only one element-> replace it with -1\\n        if(arr.size()==1){\\n            arr[0]=-1;\\n            return arr;\\n        }\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<arr.size();i++){\\n            //initialize the maximum variable with 0 in each step\\n            int max=0;\\n            //loop over the remainder array elements again\\n            for(int j=i+1;j<arr.size();j++)\\n                //get the largest value\\n                if(arr[j]>max)\\n                    max=arr[j];\\n            //replace the current value with the max one\\n            arr[i]=max;\\n        }\\n        \\n        //after that-> replace the last value with -1 & return the array\\n        arr[arr.size()-1]=-1;\\n        return arr;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Solution 2:**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        int maximum=-1;\\n        //loop over the whole array elements\\n        for(int i=arr.size()-1;i>=0;i--){\\n            //store the current value in a temp variable\\n            int temp=arr[i];\\n            //replace the current value with the maximum one & by default, the last element will be -1, as the initial value is it\\'s\\n            arr[i]=maximum;\\n            //get the largest element by comparing\\n            maximum=max(maximum,temp);\\n        }\\n\\n        //return the array elements\\n        return arr;\\n    }\\n};\\n\\'\\'\\'\\n\\n\\n**Like it? ->Upvote please!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        //base case: if there\\'s only one element-> replace it with -1\\n        if(arr.size()==1){\\n            arr[0]=-1;\\n            return arr;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2351429,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        curr_max = arr[-1]\\n        arr[-1] = -1\\n        for i in range(len(arr)-2,-1,-1):\\n            curr = arr[i]\\n            arr[i] = curr_max\\n            if curr>curr_max:\\n                curr_max = curr\\n        return arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        curr_max = arr[-1]\\n        arr[-1] = -1\\n        for i in range(len(arr)-2,-1,-1):\\n            curr = arr[i]\\n            arr[i] = curr_max\\n            if curr>curr_max:\\n                curr_max = curr\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417547,
                "title": "c-easy-solution-variation-of-leader-elements-in-array",
                "content": "```\\n The question is just a variation of problem \" Leaders in an array \". We just have to keep \\n track of maximum element on right side of any element. Traverse the loop from last \\n elelement. We know there is no element on right side of last element so put -1.  And \\n bang you solved the problem. We just need to identify the variation ( easy peasy \\u263A\\uFE0F)\\n ```\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n=arr.size();\\n        int ma=arr[n-1];\\n        arr[n-1]=-1;\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            int c=ma;\\n               ma=max(arr[i],ma);\\n            arr[i]=c;\\n        }\\n        return arr;\\n    }\\n};\\n```\\nPlease upvote if you like !! \\nHAPPY CODING:)",
                "solutionTags": [],
                "code": "```\\n The question is just a variation of problem \" Leaders in an array \". We just have to keep \\n track of maximum element on right side of any element. Traverse the loop from last \\n elelement. We know there is no element on right side of last element so put -1.  And \\n bang you solved the problem. We just need to identify the variation ( easy peasy \\u263A\\uFE0F)\\n ```\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n=arr.size();\\n        int ma=arr[n-1];\\n        arr[n-1]=-1;\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            int c=ma;\\n               ma=max(arr[i],ma);\\n            arr[i]=c;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593302,
                "title": "c-100-memory-one-pass",
                "content": "```C++\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int max_num = -1;\\n        vector<int> res = arr;\\n        for (int i=arr.size()-1; i>=0; i--) {\\n            res[i] = max_num;\\n            max_num = max(max_num, arr[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int max_num = -1;\\n        vector<int> res = arr;\\n        for (int i=arr.size()-1; i>=0; i--) {\\n            res[i] = max_num;\\n            max_num = max(max_num, arr[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869693,
                "title": "12ms-c-using-stack-easy-to-understand",
                "content": "```\\n**Pls Upvote if you like it**\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) \\n\\t{\\n        stack<int> hello ;  // Initialize a stack\\n        vector<int> ans (1,-1) ; // base condition , -1 should be present in array at last position\\n        \\n        hello.push(arr[arr.size()-1]) ; // push last element in stack because it is necessary \\n        for (int i=arr.size()-2; i>=0 ; i--) // traverse it from back\\n        {\\n            ans.push_back(hello.top()) ;\\n            \\n            if (hello.top()<arr[i]) // check maximum element \\n                hello.push(arr[i]) ;  // if found then push it into stack\\n        }\\n        \\n        reverse(ans.begin(),ans.end()) ; // reverse your answer array \\n        return ans ; // here is your solution\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n**Pls Upvote if you like it**\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) \\n\\t{\\n        stack<int> hello ;  // Initialize a stack\\n        vector<int> ans (1,-1) ; // base condition , -1 should be present in array at last position\\n        \\n        hello.push(arr[arr.size()-1]) ; // push last element in stack because it is necessary \\n        for (int i=arr.size()-2; i>=0 ; i--) // traverse it from back\\n        {\\n            ans.push_back(hello.top()) ;\\n            \\n            if (hello.top()<arr[i]) // check maximum element \\n                hello.push(arr[i]) ;  // if found then push it into stack\\n        }\\n        \\n        reverse(ans.begin(),ans.end()) ; // reverse your answer array \\n        return ans ; // here is your solution\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967005,
                "title": "java-and-go-solutions-with-explanation-and-images",
                "content": "# ***Code Is On The Bottom***\\n**If you found this helpful please up vote**\\n\\nThis problems wording is kind of confusing so I decided to try to explain it.\\n\\nI am using the descriptions example, `[17, 18, 5, 4, 6, 1]` for my example because we know that the output should be `[18, 6, 6, 6, 1, -1]`.\\n\\nBefore I start with the example I will explain what the problem is actualy asking us to do. It is asking us to start at the begining character and then check for the greatest character in all the items after it. Then after that to do the second character, find the max value in all the item the follow the second character. They ask us to do this up to one from the end. For the last item they ask us to make that `-1`, ( *Note, they are not asking us to make the last character negative, they are asking to make it exactly `-1`*).\\n\\n# **If you don\\'t understand my example just look at my code or picture**\\n\\n* For the example `[17, 18, 5, 4, 6, 1]` we will start off with the first number, `17`. We have to replace this number with the greatest number that has an index that is greater than its own, `18`.\\n* Then we will go to the next number `18`. The number that is greatest and has a index greater than eighteens is  `6` so replace `18` with `6`.\\n* The next number is `5` the greatest number that has a index greater than `5\\'s` is also `6` so we replace `5` with `6`.\\n* The next number, `4` can also be replaced by `6`.\\n* Now we get to `6`, so we find the greatest number that has a index greater than six\\'s, `1`. So we replace `6` with `1`.\\n* For the last number we have to make it `-1`.\\n\\nNow we end up with the array `[18, 6, 6, 6, 1, -1]`.\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/10273d03-be15-4706-836a-0af03df741ee_1607608209.7424724.png)\\n\\n\\n**Java solution:**\\n```\\npublic int[] replaceElements(int[] arr) {\\n\\tfor (int i = 0; i < arr.length - 1; i++) {\\n\\t\\tint max = 0;\\n\\t\\tfor (int j = i + 1; j < arr.length; j++) {\\n\\t\\t\\tif (arr[j] > max){\\n\\t\\t\\t\\tmax = arr[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tarr[i] = max;\\n\\t}\\n\\tarr[arr.length - 1] = -1;\\n\\treturn arr;\\n}\\n```\\n\\n\\n**Go solution:**\\n\\n```\\nfunc replaceElements(arr []int) []int {\\n\\tfor i := range arr{\\n\\t\\tmax := 0\\n\\t\\tfor j := i + 1; j < len(arr); j++ {\\n\\t\\t\\tif arr[j] > max {\\n\\t\\t\\t\\tmax = arr[j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tarr[i] = max\\n\\t}\\n\\tarr[len(arr) - 1] = -1\\n\\treturn arr\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] replaceElements(int[] arr) {\\n\\tfor (int i = 0; i < arr.length - 1; i++) {\\n\\t\\tint max = 0;\\n\\t\\tfor (int j = i + 1; j < arr.length; j++) {\\n\\t\\t\\tif (arr[j] > max){\\n\\t\\t\\t\\tmax = arr[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tarr[i] = max;\\n\\t}\\n\\tarr[arr.length - 1] = -1;\\n\\treturn arr;\\n}\\n```\n```\\nfunc replaceElements(arr []int) []int {\\n\\tfor i := range arr{\\n\\t\\tmax := 0\\n\\t\\tfor j := i + 1; j < len(arr); j++ {\\n\\t\\t\\tif arr[j] > max {\\n\\t\\t\\t\\tmax = arr[j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tarr[i] = max\\n\\t}\\n\\tarr[len(arr) - 1] = -1\\n\\treturn arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526028,
                "title": "fastest-javascript-solution-w-stack-most-optimal-solution",
                "content": "```\\nconst replaceElements = (arr) => {\\n    let stack = [-1]\\n    for(let i = arr.length-1; i > 0; i--){\\n        if(stack.peak() < arr[i])stack.push(arr[i])\\n        else stack.push(stack.peak())\\n    }\\n    return stack.reverse()\\n};\\nArray.prototype.peak = function(){return this[this.length-1]}\\n```\\nOptimized O(1) Space O(n) Time Solution. (This Solution is Better)\\n```\\nconst replaceElements = (arr) => {\\n    let currMax = arr[arr.length-1]\\n    arr[arr.length-1] = -1\\n    for(let i = arr.length-2; i >= 0; i--){\\n        let curr = arr[i]\\n        arr[i] = currMax\\n        if(curr > currMax)currMax = curr\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst replaceElements = (arr) => {\\n    let stack = [-1]\\n    for(let i = arr.length-1; i > 0; i--){\\n        if(stack.peak() < arr[i])stack.push(arr[i])\\n        else stack.push(stack.peak())\\n    }\\n    return stack.reverse()\\n};\\nArray.prototype.peak = function(){return this[this.length-1]}\\n```\n```\\nconst replaceElements = (arr) => {\\n    let currMax = arr[arr.length-1]\\n    arr[arr.length-1] = -1\\n    for(let i = arr.length-2; i >= 0; i--){\\n        let curr = arr[i]\\n        arr[i] = currMax\\n        if(curr > currMax)currMax = curr\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2071637,
                "title": "python3-o-n-in-place-solution",
                "content": "Although a straight-forwarded solution which most of people could come up with is for each element at ith index : \\n```\\n# For each ith element, find the maximum value beyond its index then assign to it, do so for every element.\\narr[ i ] = max( arr[ i + 1: ] ) \\n```\\nSuch method essentially gives a **O(n^2)** runtime as for each element, it needs to look up all elements at its right side.\\nInstead looking from left to right, we could do it reversly from the end of array, by doing so it only needs a variable to keep the rightmost maximum.\\nUse a variable \"max\" to track the current maximum with initial value -1 ( *as required the last element is set to -1.* )\\n\\n![image](https://assets.leetcode.com/users/images/3a57c8d0-70f0-4845-81ce-7e15b74da15d_1653454837.6219654.png)\\n\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        r_max = -1\\n        for i in range(len(arr)-1, -1, -1):\\n            temp = arr[i]\\n            arr[i] = r_max\\n            if temp > r_max:\\n                r_max = temp\\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\n# For each ith element, find the maximum value beyond its index then assign to it, do so for every element.\\narr[ i ] = max( arr[ i + 1: ] ) \\n```\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        r_max = -1\\n        for i in range(len(arr)-1, -1, -1):\\n            temp = arr[i]\\n            arr[i] = r_max\\n            if temp > r_max:\\n                r_max = temp\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058153,
                "title": "easy-and-simple-python-solution-o-n",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        mx = arr[-1]\\n        arr[-1] = -1\\n        for i in range(len(arr) - 2, -1, -1):\\n            temp = arr[i]\\n            arr[i] = mx\\n            if mx < temp: mx = temp\\n        return arr\\n```\\nfor more such questions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        mx = arr[-1]\\n        arr[-1] = -1\\n        for i in range(len(arr) - 2, -1, -1):\\n            temp = arr[i]\\n            arr[i] = mx\\n            if mx < temp: mx = temp\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852552,
                "title": "java-1ms-o-n-runtime-99-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatest = -1;\\n        for(int i=arr.length-1;i>=0;i--){\\n            int temp = arr[i];\\n            arr[i] = greatest;\\n            greatest = Math.max(temp,greatest);\\n        }\\n        return arr;\\n    }\\n}\\n//Note that we do not take into account the input array when calculating space complexity.\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatest = -1;\\n        for(int i=arr.length-1;i>=0;i--){\\n            int temp = arr[i];\\n            arr[i] = greatest;\\n            greatest = Math.max(temp,greatest);\\n        }\\n        return arr;\\n    }\\n}\\n//Note that we do not take into account the input array when calculating space complexity.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489146,
                "title": "java-easy-to-understand-solution-with-analysis-1ms-better-than-100",
                "content": "Hey everyone,\\n\\nThe problem asks us to update each element in the array to be the greatest of elements to its right.\\nIf we go left to right, we compare the current element to each element to its right. We\\'ll end up with an O(n^2) solution. So, the element on the left is always determined by the elements on the right. Once we reach the largest element on the right, we don\\'t need to go any farther. How can we avoid doing all this extra work?\\n\\nLet\\'s approach the problem from right to left. By going right to left and updating the current element to the biggest seen so far, we handle the problem of doing excess work. In other words, we keep track of the solution so far/build up the solution, a type of memoization.\\n\\nSo, how do we do this? When we reach an element it will always be updated to the greatest element value seen so far. So, we need a variable to keep track of this greatest value, let\\'s call it *greatest*. We know that if the current element is greater than *greatest* we need to update the value of *greatest* to the current element\\'s value. But, how do we compare the the current element with the greatest so far without losing the current element value? We need a temporary variable to store this, let\\'s call it *temp*. So, the logic here is store the element\\'s value as *temp*. Update the element to *greatest*\\'s value. Then, if *temp* is greater than *greatest*, we update *greatest* to *temp*\\'s value.\\n\\n**Algorithm**:\\n\\u2022 Initialize int *greatest* as -1.\\n\\u2022 Iterate decrementally through passed array.\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\u2022 Store current element value as *temp*.\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\u2022 Update the current element with *greatest*.\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\u2022 If the element was greater than *greatest*, update it.\\n\\u2022 Return the array.\\n\\n**Complexity**\\nLet *n* represent the size of array *arr*.\\n\\nWe iterate through *n* only once. So, our time complexity is **O(*n*)**.\\n\\nWe only use 2 variables no matter what the input, and we overwrite the passed array using no extra space. So, space complexity is constant **O(1)**.\\n\\nHope this helps :)\\n\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatest = -1; //Initialize greatest as -1\\n        \\n        //Iterate decrementally through array\\n        for(int i = arr.length-1; i >= 0; i--) {\\n            int temp = arr[i]; //Get current element as temp\\n            arr[i] = greatest; //Update current element with greatest\\n            greatest = Math.max(greatest, temp); //If the element was greater than greatest, update greatest\\n        }\\n        return arr; //Return the array\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatest = -1; //Initialize greatest as -1\\n        \\n        //Iterate decrementally through array\\n        for(int i = arr.length-1; i >= 0; i--) {\\n            int temp = arr[i]; //Get current element as temp\\n            arr[i] = greatest; //Update current element with greatest\\n            greatest = Math.max(greatest, temp); //If the element was greater than greatest, update greatest\\n        }\\n        return arr; //Return the array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658953,
                "title": "js-very-easy-solution-with-o-n",
                "content": "```\\nvar replaceElements = function(arr) {\\n    let currentMax = arr[arr.length - 1];\\n    arr[arr.length - 1] = -1;\\n\\n    for (let i = arr.length - 2; i >= 0; i--) {\\n        if (currentMax > arr[i]) {\\n            arr[i] = currentMax;\\n        } else {\\n            const temp = currentMax;\\n            currentMax = arr[i];\\n            arr[i] = temp;\\n        }\\n    }\\n    \\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar replaceElements = function(arr) {\\n    let currentMax = arr[arr.length - 1];\\n    arr[arr.length - 1] = -1;\\n\\n    for (let i = arr.length - 2; i >= 0; i--) {\\n        if (currentMax > arr[i]) {\\n            arr[i] = currentMax;\\n        } else {\\n            const temp = currentMax;\\n            currentMax = arr[i];\\n            arr[i] = temp;\\n        }\\n    }\\n    \\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 760502,
                "title": "python-o-n-with-comments-explanation-easy-to-understand",
                "content": "Strat:\\n    Iterate through arr, from right to left, while keeping track of the largest element we\\'ve seen. max_so_far starts out at -1, because that\\'s what the last elem\\'s value will be. As we iterate, we compare to current num\\'s value to max_so_far; update as appropiate. \\n\\nStats: O(n) time\\n    Runtime: 112 ms, faster than 76.23% of Python online submissions for Replace Elements with Greatest Element on Right Side.\\n    Memory Usage: 14.3 MB, less than 21.28% of Python online submissions for Replace Elements with Greatest Element on Right Side.\\n\\t\\nHere\\'s the code:\\n\\n\\tclass Solution(object):\\n    def replaceElements(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        length = len(arr)\\n        max_so_far = -1\\n        result = [0] * length\\n        \\n        #iterate through arr, from right to left, one elem at a time\\n        for i in range(length - 1, -1, -1):\\n            #store max_so_far in results & update it\\n            result[i] = max_so_far\\n            max_so_far = max(max_so_far, arr[i])\\n            \\n        return result\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Strat:\\n    Iterate through arr, from right to left, while keeping track of the largest element we\\'ve seen. max_so_far starts out at -1, because that\\'s what the last elem\\'s value will be. As we iterate, we compare to current num\\'s value to max_so_far; update as appropiate. \\n\\nStats: O(n) time\\n    Runtime: 112 ms, faster than 76.23% of Python online submissions for Replace Elements with Greatest Element on Right Side.\\n    Memory Usage: 14.3 MB, less than 21.28% of Python online submissions for Replace Elements with Greatest Element on Right Side.\\n\\t\\nHere\\'s the code:\\n\\n\\tclass Solution(object):\\n    def replaceElements(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        length = len(arr)\\n        max_so_far = -1\\n        result = [0] * length\\n        \\n        #iterate through arr, from right to left, one elem at a time\\n        for i in range(length - 1, -1, -1):\\n            #store max_so_far in results & update it\\n            result[i] = max_so_far\\n            max_so_far = max(max_so_far, arr[i])\\n            \\n        return result\\n",
                "codeTag": "Java"
            },
            {
                "id": 690979,
                "title": "java-simple-looping-from-end",
                "content": "```\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1, n = arr.length;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int tmp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, tmp);\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1, n = arr.length;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int tmp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, tmp);\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 595286,
                "title": "c-5-lines",
                "content": "```\\nint* replaceElements(int* arr, int arrSize, int* returnSize){\\n    *returnSize=arrSize;\\n    for(int i=arrSize-1,tmp=0,max=-1;i>=0;i--){\\n        tmp=arr[i];\\n        arr[i]=max;\\n        max=(max>tmp)?max:tmp;\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* replaceElements(int* arr, int arrSize, int* returnSize){\\n    *returnSize=arrSize;\\n    for(int i=arrSize-1,tmp=0,max=-1;i>=0;i--){\\n        tmp=arr[i];\\n        arr[i]=max;\\n        max=(max>tmp)?max:tmp;\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 500168,
                "title": "simple-javascript-solution-beats-91",
                "content": "Runtime: 76 ms, faster than 91.51% of JavaScript online submissions for Replace Elements with Greatest Element on Right Side.\\nMemory Usage: 37.8 MB, less than 100.00% of JavaScript online submissions for Replace Elements with Greatest Element on Right Side.\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nconst replaceElements = arr => {\\n    let lastMax = -1\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        const val = arr[i]\\n        if (!arr[i + 1]) {\\n            arr[i] = lastMax \\n            lastMax = val\\n        } else {\\n            arr[i] = lastMax\\n            lastMax = Math.max(lastMax, val)\\n        }\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nconst replaceElements = arr => {\\n    let lastMax = -1\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        const val = arr[i]\\n        if (!arr[i + 1]) {\\n            arr[i] = lastMax \\n            lastMax = val\\n        } else {\\n            arr[i] = lastMax\\n            lastMax = Math.max(lastMax, val)\\n        }\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3146616,
                "title": "easy-to-understand-c-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFinding the maximum element towards the right and replacing it to the newly form vector.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n=arr.size();\\n        vector<int>ans(n);\\n        int max=arr[n-1];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(max < arr[i+1])\\n                max=arr[i+1];\\n            ans[i]=max;\\n        }\\n        ans[n-1]=-1;\\n        return ans;\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n=arr.size();\\n        vector<int>ans(n);\\n        int max=arr[n-1];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(max < arr[i+1])\\n                max=arr[i+1];\\n            ans[i]=max;\\n        }\\n        ans[n-1]=-1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141342,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr)\\n    {\\n        int n=arr.size();\\n        vector<int>v(n);\\n        int t=-1;\\n        v[n-1]=-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            v[i]=max(v[i+1],arr[i+1]);\\n        }\\n        return v;\\n        \\n    }\\n};\\n```\\n\\n**please upvote if helpful**\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr)\\n    {\\n        int n=arr.size();\\n        vector<int>v(n);\\n        int t=-1;\\n        v[n-1]=-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            v[i]=max(v[i+1],arr[i+1]);\\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173967,
                "title": "simple-python-solution-with-comments",
                "content": "Start iterating from the end and keep track of the highest number.  Array is replaced in place.\\n\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        \\n        i = len(arr) - 1\\n        \\n        hi = -1\\n        \\n        while i >= 0 :\\n            # Keep track of the \\'would be\\' highest number\\n            temp_hi = max (arr[i], hi)\\n            # Replace the index with the last known highest number\\n            arr[i] = hi\\n            # Replace the last known highest number with the current highest number\\n            hi = temp_hi\\n            i -= 1\\n        \\n        return arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        \\n        i = len(arr) - 1\\n        \\n        hi = -1\\n        \\n        while i >= 0 :\\n            # Keep track of the \\'would be\\' highest number\\n            temp_hi = max (arr[i], hi)\\n            # Replace the index with the last known highest number\\n            arr[i] = hi\\n            # Replace the last known highest number with the current highest number\\n            hi = temp_hi\\n            i -= 1\\n        \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851033,
                "title": "ruby-change-values-in-place-one-pass-over-indices-while-moving-backward",
                "content": "##### Leetcode: 1299. Replace Elements with Greatest Element on Right Side.\\n\\nBecause minimum value of an input array is 1 and -1 is a value for modified array when there is no max elements at the right side, it is easy to solve this task in one loop and one \"storage\" variable that initiated as -1. Just loop the array indexes backward and calculate next maximum based on current value (select maximum value from two values), substituting current value with a current maximum and at the end of an iteration set current maximum equal to the next one.  Change array in place by one pass. \\n\\nRuby code (readable version):\\n```Ruby\\n# Leetcode: 1299. Replace Elements with Greatest Element on Right Side.\\n# https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/\\n# Runtime: 68 ms, faster than 93.44% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# Memory Usage: 12.3 MB, less than 24.59% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# @param {Integer[]} arr\\n# @return {Integer[]}\\ndef replace_elements(arr)\\n    prev = -1\\n    (0...arr.size).reverse_each do |i|\\n        tmp = arr[i]\\n        arr[i] = prev\\n        prev = tmp if tmp > prev        \\n    end\\n    arr\\nend\\n```\\n\\nRuby code (\"concise\" version):\\n```Ruby\\n# Leetcode: 1299. Replace Elements with Greatest Element on Right Side.\\n# https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/\\n# Runtime: 68 ms, faster than 93.44% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# Memory Usage: 11.3 MB, less than 91.80% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# @param {Integer[]} arr\\n# @return {Integer[]}\\ndef replace_elements(arr)\\n    prev = -1\\n    (0...arr.size).reverse_each do |i|\\n        prev, arr[i] = (arr[i] > prev ? arr[i] : prev)  , prev    \\n    end\\n    arr\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1299. Replace Elements with Greatest Element on Right Side.\\n# https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/\\n# Runtime: 68 ms, faster than 93.44% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# Memory Usage: 12.3 MB, less than 24.59% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# @param {Integer[]} arr\\n# @return {Integer[]}\\ndef replace_elements(arr)\\n    prev = -1\\n    (0...arr.size).reverse_each do |i|\\n        tmp = arr[i]\\n        arr[i] = prev\\n        prev = tmp if tmp > prev        \\n    end\\n    arr\\nend\\n```\n```Ruby\\n# Leetcode: 1299. Replace Elements with Greatest Element on Right Side.\\n# https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/\\n# Runtime: 68 ms, faster than 93.44% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# Memory Usage: 11.3 MB, less than 91.80% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# @param {Integer[]} arr\\n# @return {Integer[]}\\ndef replace_elements(arr)\\n    prev = -1\\n    (0...arr.size).reverse_each do |i|\\n        prev, arr[i] = (arr[i] > prev ? arr[i] : prev)  , prev    \\n    end\\n    arr\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 463649,
                "title": "easy-javascript-time-o-n-space-o-1",
                "content": "```\\n\\nconst replaceElements = arr => {\\n  let prev = -1;\\n  for (let i = arr.length - 1; i >= 0; i--) {\\n    let cur = arr[i];\\n    arr[i] = prev;\\n    prev = Math.max(prev, cur);\\n  }\\n  return arr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nconst replaceElements = arr => {\\n  let prev = -1;\\n  for (let i = arr.length - 1; i >= 0; i--) {\\n    let cur = arr[i];\\n    arr[i] = prev;\\n    prev = Math.max(prev, cur);\\n  }\\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463645,
                "title": "python-3-two-lines-72-ms-beats-100-with-explanation-o-n-time-o-1-space",
                "content": "_Explanation:_\\nThe program starts by iterating backwards from the end of list A. It does a pairwise comparison of the value at index i and index i+1 and writes the higher of these two values into index i. After each iteration, we will have ```max(A[i:L])``` stored into A[i]. This allows us to efficiently only do pairwise comparisons to create the final list as opposed to repeatedly calling the ```max``` function on longer and longer sublists. This gives us an O(n) algorithm instead of an O(n\\xB2) algorithm. As an example, the output of the for loop after an input of A = [17,18,5,4,6,1], is A = [18, 18, 6, 6, 6, 1]. Since we want the highest value to the right of each number, we will never include the first number in our answer. The program ends by returning the current list A, without the first number, and after having appended -1 to the end of the list.\\n```\\nclass Solution:\\n    def replaceElements(self, A: List[int]) -> List[int]:\\n        for i in range(len(A)-2,-1,-1): A[i] = max(A[i],A[i+1])\\n        return  A[1:]+[-1]\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```max(A[i:L])```\n```max```",
                "codeTag": "Unknown"
            },
            {
                "id": 3333664,
                "title": "c-o-n-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* replaceElements(int* arr, int arrSize, int* returnSize) {\\n    *returnSize = arrSize;\\n    int* result = malloc(*returnSize * sizeof(int));\\n\\n    int max = -1;\\n    int current;\\n    \\n    for (int i = *returnSize - 1; i >= 0; i--) {\\n        current = arr[i];\\n        result[i] = max;\\n        if (current > max) max = current;\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* replaceElements(int* arr, int arrSize, int* returnSize) {\\n    *returnSize = arrSize;\\n    int* result = malloc(*returnSize * sizeof(int));\\n\\n    int max = -1;\\n    int current;\\n    \\n    for (int i = *returnSize - 1; i >= 0; i--) {\\n        current = arr[i];\\n        result[i] = max;\\n        if (current > max) max = current;\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3296398,
                "title": "simplest-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        int ans[] = new int[arr.length]; \\n        for(int i=arr.length-1 ; i>=0 ; i--){\\n            ans[i] = max;\\n            max = Math.max(max,arr[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        int ans[] = new int[arr.length]; \\n        for(int i=arr.length-1 ; i>=0 ; i--){\\n            ans[i] = max;\\n            max = Math.max(max,arr[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510679,
                "title": "replace-element-with-greatest-element-on-right-side-0-n-time",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int n = arr.length;\\n        int max = arr[n-1];\\n        arr[n-1] = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(arr[i]>=max){\\n                int  temp  = max;\\n                max = arr[i];\\n                arr[i] = temp;\\n            }\\n            else{\\n                arr[i] = max;\\n            }\\n           //upvote if you  like the solution pls!\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int n = arr.length;\\n        int max = arr[n-1];\\n        arr[n-1] = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(arr[i]>=max){\\n                int  temp  = max;\\n                max = arr[i];\\n                arr[i] = temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2443754,
                "title": "java-2-approaches-easy-understanding",
                "content": "**Please upvote if it helps you. It motivates me to work harder.**\\n*if any query, pls comment.*\\n# Naive(Brute-force) Approach\\n```\\nclass Solution {\\n    \\n    //  Time Complexity = O(N*N)\\n    //  Space Complexity = O(1)\\n    \\n    public int[] replaceElements(int[] arr) {\\n        \\n        //  Traversing the array till array length -1\\n        for(int i = 0 ; i < arr.length - 1; i++){\\n            int max = 0;                    \\n            \\n            //  max variable to store the max value to the right of the element\\n            //  traversing the right side of the element i\\n            for(int j = i+1; j < arr.length ; j++ ){\\n                max = Math.max(max,arr[j]);         //  updating the max value each time\\n            }\\n            arr[i] = max;   // updating the element i with the greatest element among the elements to its right\\n        }\\n        arr[arr.length - 1] = -1;       //  Updating the last element with -1 value\\n        \\n        return arr;\\n    }\\n}\\n```\\n# Single Iteration Approach\\n```\\nclass Solution {\\n    \\n    //  Time Complexity = O(N)\\n    //  Space Complexity = O(1)\\n    \\n    public int[] replaceElements(int[] arr) {\\n        \\n        var max = -1;                   //  to store the max value\\n        \\n        //  iterating from right side which is more convenient according to the problem\\n        for (int i = arr.length-1 ; i >= 0 ; --i){   \\n            var temp = arr[i];          //  temp variable to store the array present array value\\n            arr[i] = max;               //  updating the array with max value\\n            if(temp > max)              //  comparison between array value and max value\\n                max = temp;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //  Time Complexity = O(N*N)\\n    //  Space Complexity = O(1)\\n    \\n    public int[] replaceElements(int[] arr) {\\n        \\n        //  Traversing the array till array length -1\\n        for(int i = 0 ; i < arr.length - 1; i++){\\n            int max = 0;                    \\n            \\n            //  max variable to store the max value to the right of the element\\n            //  traversing the right side of the element i\\n            for(int j = i+1; j < arr.length ; j++ ){\\n                max = Math.max(max,arr[j]);         //  updating the max value each time\\n            }\\n            arr[i] = max;   // updating the element i with the greatest element among the elements to its right\\n        }\\n        arr[arr.length - 1] = -1;       //  Updating the last element with -1 value\\n        \\n        return arr;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    //  Time Complexity = O(N)\\n    //  Space Complexity = O(1)\\n    \\n    public int[] replaceElements(int[] arr) {\\n        \\n        var max = -1;                   //  to store the max value\\n        \\n        //  iterating from right side which is more convenient according to the problem\\n        for (int i = arr.length-1 ; i >= 0 ; --i){   \\n            var temp = arr[i];          //  temp variable to store the array present array value\\n            arr[i] = max;               //  updating the array with max value\\n            if(temp > max)              //  comparison between array value and max value\\n                max = temp;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409501,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int mx=-1,n=arr.size();\\n        for(int i=n-1;i>=0;i--){\\n            int a=arr[i];\\n            // mx is the maximum element from the right of arr[i]\\n\\t\\t\\tarr[i]=mx;\\n            mx=max(mx,a);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int mx=-1,n=arr.size();\\n        for(int i=n-1;i>=0;i--){\\n            int a=arr[i];\\n            // mx is the maximum element from the right of arr[i]\\n\\t\\t\\tarr[i]=mx;\\n            mx=max(mx,a);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583372,
                "title": "python-3-o-n-time-o-1-memory",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        curMax = -1\\n        for i in range(len(arr)-1, -1, -1):\\n            arr[i], curMax = curMax, max(arr[i], curMax)\\n        return arr",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        curMax = -1\\n        for i in range(len(arr)-1, -1, -1):\\n            arr[i], curMax = curMax, max(arr[i], curMax)\\n        return arr",
                "codeTag": "Java"
            },
            {
                "id": 1555668,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n           vector<int> sem;\\n     int n=arr.size();\\n        int t;\\n        int m=-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            t=arr[i];\\n            arr[i]=m;\\n            m=max(m,t);   \\n        }\\n         return arr;\\n        }\\n       };",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n           vector<int> sem;\\n     int n=arr.size();\\n        int t;\\n        int m=-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            t=arr[i];\\n            arr[i]=m;\\n            m=max(m,t);   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1363155,
                "title": "simple-js-solution-o-1-space-and-o-n-time",
                "content": "```\\n\\n```/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar replaceElements = function(arr) {\\n    const n = arr.length-1;\\n    let prevMax = arr[n];\\n    arr[n] = -1;\\n    \\n    for(let i = n-1; i>=0; --i) {\\n     const current = arr[i]; \\n     arr[i]=prevMax;\\n     if(current>prevMax) {\\n        prevMax = current;\\n     }          \\n    }\\n    \\n    return arr;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022072,
                "title": "o-n-easy-16ms-golang",
                "content": "```\\nfunc replaceElements(arr []int) []int {\\n    greatest := -1\\n    \\n    for i := len(arr) - 1; i >= 0; i-- {\\n        arr[i], greatest = greatest, max(greatest, arr[i])\\n    }\\n    \\n    return arr\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc replaceElements(arr []int) []int {\\n    greatest := -1\\n    \\n    for i := len(arr) - 1; i >= 0; i-- {\\n        arr[i], greatest = greatest, max(greatest, arr[i])\\n    }\\n    \\n    return arr\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 809822,
                "title": "swift-simple-sweet",
                "content": "```\\nfunc replaceElements(_ arr: [Int]) -> [Int] {\\n\\tlet lastIndex = arr.count - 1\\n\\tvar nums = arr\\n\\tvar curMax = nums[lastIndex]\\n\\n\\tnums[lastIndex] = -1\\n\\tfor i in stride(from: lastIndex - 1, through: 0, by: -1) {\\n\\t\\tlet temp = curMax\\n\\t\\tcurMax = max(curMax, nums[i])\\n\\t\\tnums[i] = temp\\n\\t}\\n\\n\\treturn nums\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc replaceElements(_ arr: [Int]) -> [Int] {\\n\\tlet lastIndex = arr.count - 1\\n\\tvar nums = arr\\n\\tvar curMax = nums[lastIndex]\\n\\n\\tnums[lastIndex] = -1\\n\\tfor i in stride(from: lastIndex - 1, through: 0, by: -1) {\\n\\t\\tlet temp = curMax\\n\\t\\tcurMax = max(curMax, nums[i])\\n\\t\\tnums[i] = temp\\n\\t}\\n\\n\\treturn nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 633511,
                "title": "scala-1-line-scanright",
                "content": "```\\narr.tail.scanRight(-1)(_ max _)\\n```",
                "solutionTags": [],
                "code": "```\\narr.tail.scanRight(-1)(_ max _)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615142,
                "title": "simple-o-n-python-solution-using-list-slicing",
                "content": "Simple O(n) python solution using list slicing:\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        for i in range(0, len(arr)-1):\\n            arr[i] = max(arr[i+1:])\\n        arr[-1] = -1\\n        return arr\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        for i in range(0, len(arr)-1):\\n            arr[i] = max(arr[i+1:])\\n        arr[-1] = -1\\n        return arr\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 514730,
                "title": "c-o-n-solution-easy-to-understand",
                "content": "```\\nvector<int> replaceElements(vector<int>& arr, int m = -1) {\\n\\tfor (int i = arr.size() - 1; i > -1; i--)\\n\\t{\\n\\t\\tint temp = max(arr[i] , m);\\n\\t\\tarr[i] = m;\\n\\t\\tm = temp;\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> replaceElements(vector<int>& arr, int m = -1) {\\n\\tfor (int i = arr.size() - 1; i > -1; i--)\\n\\t{\\n\\t\\tint temp = max(arr[i] , m);\\n\\t\\tarr[i] = m;\\n\\t\\tm = temp;\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481711,
                "title": "javascript-solution",
                "content": "```\\nlet replaceElements = function(arr) {\\n    let maxEle = -1\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        let currentEle = arr[i]\\n        arr[i] = maxEle\\n        if (currentEle > maxEle) { maxEle = currentEle }\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet replaceElements = function(arr) {\\n    let maxEle = -1\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        let currentEle = arr[i]\\n        arr[i] = maxEle\\n        if (currentEle > maxEle) { maxEle = currentEle }\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466005,
                "title": "concise-rust-solution",
                "content": "```rust\\npub fn replace_elements(mut A: Vec<i32>) -> Vec<i32> {\\n\\tlet mut max = -1;\\n\\tfor x in A.iter_mut().rev() {\\n\\t\\tlet t = *x;\\n\\t\\t*x = max;\\n\\t\\tmax = std::cmp::max(max, t);\\n\\t}\\n\\tA\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn replace_elements(mut A: Vec<i32>) -> Vec<i32> {\\n\\tlet mut max = -1;\\n\\tfor x in A.iter_mut().rev() {\\n\\t\\tlet t = *x;\\n\\t\\t*x = max;\\n\\t\\tmax = std::cmp::max(max, t);\\n\\t}\\n\\tA\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463256,
                "title": "o-n-1-liners-python",
                "content": "Sounds like a job for `accumulate(..., max)`.\\n```\\ndef replaceElements(self, arr):\\n    return [*itertools.accumulate([-1] + arr[:0:-1], max)][::-1]\\n```\\nAlternatively a somewhat tricky one:\\n```\\ndef replaceElements(self, arr):\\n    return (b := [-1]).extend(map(max, b, arr[:0:-1])) or b[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef replaceElements(self, arr):\\n    return [*itertools.accumulate([-1] + arr[:0:-1], max)][::-1]\\n```\n```\\ndef replaceElements(self, arr):\\n    return (b := [-1]).extend(map(max, b, arr[:0:-1])) or b[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4019999,
                "title": "brute-force-to-optimal-with-easy-explanation",
                "content": "# Brute force approach\\n\\n---\\n\\n\\n### Intution and approach:\\nSuppose we are standing at an index, starting from index 0.\\n\\n1. We need to find the maximum element to the right of our current position.\\n\\n2. To achieve this, we compare all the elements to the right of our current position.\\n\\n3. After finding the maximum, we replace the element at our current index with this maximum value.\\n\\n4. We then happily jump to the next index and repeat this process until we reach the second to last element (end-1) of the array.\\n\\nFinally, we set the last element to -1 to complete the replacement.\\n\\n### Complexity\\n- Time complexity: O(N)*O(N)\\n For each iteration of the (i<n-1) outer loop,j or the inner loop goes till n \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n No extra space taken\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Optimal soln\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n---\\n\\n### Intution and approach:\\nThe above solution is taking at a lot time to solve our problem.\\nlet\\'s think about a O(N) approach.\\nNow let\\'s stand at the end of the array, we observe that if we keep track of the maximum element our problem would get solved as we are already keeping the track of maximum element to the right of each element.\\n\\n1. Start from the end of the array (the last element). Assume it as the maximum element to the right.\\n\\n2. Move one step backward for each element in the array, comparing it with the maximum element you\\'ve tracked.\\n\\n3. If the current element is greater than or equal to the tracked maximum, update the tracked maximum to the current element. Otherwise, update the current element to the tracked maximum.\\n\\nRepeat this process until you reach the first element.\\n\\nFinally, move each element backward and set the last element to -1.\\n\\n### Complexity\\n- Time complexity: O(N)\\n We iterate through the array only once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n No extra space taken\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> replaceElements(vector<int>& arr) {\\n\\n        /*//brute force sol\\n        int max;\\n        int i=0,j;\\n        int n=arr.size();\\n        int temp;\\n        int ind;\\n        while(i<n-1)\\n        {\\n            max=arr.at(i+1);\\n            for(j=i+1;j<n;j++)\\n            {\\n                if(arr.at(j)>=max)//comparing all elements right to i \\n                {\\n                    ind=j;\\n                    max=arr.at(j);\\n                }\\n            }\\n            arr.at(i)=arr.at(ind); //setting the element at ith index to maximum element which we found above\\n            i++;\\n        }\\n        arr.at(n-1)=-1;\\n        return arr;*/\\n\\n\\n    //Optimal\\n    int n=arr.size();\\n    int i,j;\\n    int max=arr.at(n-1);//assuming the last element is max element,this to compare it with other element so that we can find maximum element each time\\n    for(i=n-1;i>=0;i--)// strating from end till 0\\n    {\\n        if(arr.at(i)>=max)// current element greater than or equal to tracked element\\n        {\\n            max=arr.at(i);// assigning maximum to current element\\n        }\\n        else\\n        {\\n            arr.at(i)=max;// current element NOT >=, assigning current element to maximum\\n        }\\n    }\\n    for(i=0;i<n-1;i++)// move each element backward and set the last element to -1\\n    {\\n        arr.at(i)=arr.at(i+1);\\n    }\\n    arr.at(n-1)=-1;\\n    return arr;\\n}};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> replaceElements(vector<int>& arr) {\\n\\n        /*//brute force sol\\n        int max;\\n        int i=0,j;\\n        int n=arr.size();\\n        int temp;\\n        int ind;\\n        while(i<n-1)\\n        {\\n            max=arr.at(i+1);\\n            for(j=i+1;j<n;j++)\\n            {\\n                if(arr.at(j)>=max)//comparing all elements right to i \\n                {\\n                    ind=j;\\n                    max=arr.at(j);\\n                }\\n            }\\n            arr.at(i)=arr.at(ind); //setting the element at ith index to maximum element which we found above\\n            i++;\\n        }\\n        arr.at(n-1)=-1;\\n        return arr;*/\\n\\n\\n    //Optimal\\n    int n=arr.size();\\n    int i,j;\\n    int max=arr.at(n-1);//assuming the last element is max element,this to compare it with other element so that we can find maximum element each time\\n    for(i=n-1;i>=0;i--)// strating from end till 0\\n    {\\n        if(arr.at(i)>=max)// current element greater than or equal to tracked element\\n        {\\n            max=arr.at(i);// assigning maximum to current element\\n        }\\n        else\\n        {\\n            arr.at(i)=max;// current element NOT >=, assigning current element to maximum\\n        }\\n    }\\n    for(i=0;i<n-1;i++)// move each element backward and set the last element to -1\\n    {\\n        arr.at(i)=arr.at(i+1);\\n    }\\n    arr.at(n-1)=-1;\\n    return arr;\\n}};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624820,
                "title": "easy-beats-92-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to replace each element in the given vector arr with the maximum element to its right. For the last element in arr, it will be replaced with -1 since there are no elements to its right.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code initializes a new vector ans with a size twice that of the given vector nums. It then iterates through each element in nums using the variable i as the index. For each element, it performs the following steps:\\n\\nAssign the current element of nums (nums[i]) to the corresponding index in ans (ans[i]).\\nAssign the same element to the index i + nums.size() in ans. Since nums.size() gives the size of the original vector, this step effectively places the same element at an index that is exactly one full cycle (size of nums) ahead of its original position in ans.\\nRepeat the above steps for all elements in nums until the iteration is complete.\\nAfter the iteration, ans contains all the elements of nums followed by the same elements again, effectively concatenating the original vector with itself.\\n\\nFinally, the ans vector is returned as the result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through each element in nums once, resulting in a time complexity of O(n), where n is the number of elements in the input vector nums.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n), where n is the number of elements in nums. The additional space is required to store the resulting vector ans, which has a size twice that of nums.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int maxx=-1;\\n        for(int i=arr.size()-1;i>=0;i--)\\n        {\\n            \\n            int test= arr[i];\\n            arr[i]=maxx;\\n            if(test>maxx)\\n            maxx=test;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int maxx=-1;\\n        for(int i=arr.size()-1;i>=0;i--)\\n        {\\n            \\n            int test= arr[i];\\n            arr[i]=maxx;\\n            if(test>maxx)\\n            maxx=test;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486898,
                "title": "brute-force-optimal-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Brute Force\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                max = Math.max(max, arr[j]);\\n            }\\n            arr[i]=max;\\n            max=-1;\\n        }\\n        return arr;\\n    }\\n}\\n```\\n# Optimal Code\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        int[] ans = new int[arr.length];\\n        ans[arr.length-1]=max;\\n        for(int i=arr.length-1;i>0;i--){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                ans[i-1]=max;\\n            }else{\\n                ans[i-1]=max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                max = Math.max(max, arr[j]);\\n            }\\n            arr[i]=max;\\n            max=-1;\\n        }\\n        return arr;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        int[] ans = new int[arr.length];\\n        ans[arr.length-1]=max;\\n        for(int i=arr.length-1;i>0;i--){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                ans[i-1]=max;\\n            }else{\\n                ans[i-1]=max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366011,
                "title": "c-easy-approach-with-great-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We have an array of numbers (arr) and we want to replace each element in the array with the greatest element that is to the right of the element.\\n2. Our approach is to traverse the array from right to left and keep track of the maximum element we have seen so far (oldmax) and replace the current element with it.\\n3. After replacing the current element, we update the oldmax to be the new maximum element we have seen so far (which is the current element).\\n4. We return the array after we are done replacing all the elements. */\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int oldmax = -1;\\n        int length = arr.size();\\n        for(int i = length - 1 ; i >=0 ; i--)\\n        {\\n            int newmax = max(oldmax , arr[i]);\\n            arr[i] = oldmax;\\n            oldmax = newmax;\\n        }\\n        return arr;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int oldmax = -1;\\n        int length = arr.size();\\n        for(int i = length - 1 ; i >=0 ; i--)\\n        {\\n            int newmax = max(oldmax , arr[i]);\\n            arr[i] = oldmax;\\n            oldmax = newmax;\\n        }\\n        return arr;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302682,
                "title": "a-simple-python-solution-in-place",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        max=arr[len(arr)-1]\\n        for i in range(len(arr)-1,-1,-1):\\n            if i==len(arr)-1:\\n                arr[i]=-1\\n            else:\\n                temp=arr[i]\\n                arr[i]=max\\n                if max<temp:\\n                    max=temp\\n        return arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        max=arr[len(arr)-1]\\n        for i in range(len(arr)-1,-1,-1):\\n            if i==len(arr)-1:\\n                arr[i]=-1\\n            else:\\n                temp=arr[i]\\n                arr[i]=max\\n                if max<temp:\\n                    max=temp\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228997,
                "title": "java-solution-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int maxx = arr[arr.length-1];\\n        arr[arr.length-1]=-1;\\n        for(int i=arr.length-2;i>=0;i--){\\n            int temp = Math.max(maxx,arr[i]);\\n            arr[i]=maxx;\\n            maxx=temp;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int maxx = arr[arr.length-1];\\n        arr[arr.length-1]=-1;\\n        for(int i=arr.length-2;i>=0;i--){\\n            int temp = Math.max(maxx,arr[i]);\\n            arr[i]=maxx;\\n            maxx=temp;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183849,
                "title": "python-beats-99-94-without-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst of all reverse the array. Initialize ```max_so_far``` to -1\\nThen create an array to store the max element so far we have found.\\nTraverse the reversed array and append the ``` max_so_far``` toe res array. Fianlly reverse the array and return it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        arr = arr[::-1]\\n        res = []\\n        max_so_far = -1\\n        for i in arr:\\n            res.append(max_so_far)\\n            if i>max_so_far:\\n                max_so_far = i\\n\\n\\n        return res[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```max_so_far```\n``` max_so_far```\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        arr = arr[::-1]\\n        res = []\\n        max_so_far = -1\\n        for i in arr:\\n            res.append(max_so_far)\\n            if i>max_so_far:\\n                max_so_far = i\\n\\n\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114827,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>res(arr.size());\\n        int great=arr[arr.size()-1];\\n        res[res.size()-1]=-1;\\n        for(int i=res.size()-2;i>=0;i--){\\n            res[i]=great;\\n            great=max(great,arr[i]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>res(arr.size());\\n        int great=arr[arr.size()-1];\\n        res[res.size()-1]=-1;\\n        for(int i=res.size()-2;i>=0;i--){\\n            res[i]=great;\\n            great=max(great,arr[i]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797050,
                "title": "python3-o-n-simple-to-understand",
                "content": "\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        rev, maximum = arr[::-1], -1\\n\\n        for i in range(len(rev)):\\n            rev[i], maximum = maximum, max(maximum, rev[i])\\n\\n        return rev[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        rev, maximum = arr[::-1], -1\\n\\n        for i in range(len(rev)):\\n            rev[i], maximum = maximum, max(maximum, rev[i])\\n\\n        return rev[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770767,
                "title": "c-o-n-beginner-friendly",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> replaceElements(vector<int> &arr)\\n        {\\n            int m = arr[arr.size() - 1];\\n            arr[arr.size() - 1] = -1;\\n            if (arr.size() == 1) return arr;\\n            \\n            for (int i = arr.size() - 2; i >= 0; i--)\\n            {\\n                int temp = arr[i];\\n                arr[i] = m;\\n                m = max(temp, m);\\n            }\\n            return arr;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> replaceElements(vector<int> &arr)\\n        {\\n            int m = arr[arr.size() - 1];\\n            arr[arr.size() - 1] = -1;\\n            if (arr.size() == 1) return arr;\\n            \\n            for (int i = arr.size() - 2; i >= 0; i--)\\n            {\\n                int temp = arr[i];\\n                arr[i] = m;\\n                m = max(temp, m);\\n            }\\n            return arr;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722192,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> v(n,0);\\n        v[n-1] = -1;\\n        int maxi = arr[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            v[i] = maxi;\\n            maxi = max(maxi,arr[i]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> v(n,0);\\n        v[n-1] = -1;\\n        int maxi = arr[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            v[i] = maxi;\\n            maxi = max(maxi,arr[i]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602091,
                "title": "iterate-and-swap",
                "content": "![image](https://assets.leetcode.com/users/images/c36cb5a5-f105-4f47-a9d9-3ad2a9452bb9_1663693064.2390969.png)\\n\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        maxi = -1\\n        for i in range(len(arr) -1, -1, -1):\\n            arr[i], maxi = maxi, max(arr[i],maxi)\\n        return arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        maxi = -1\\n        for i in range(len(arr) -1, -1, -1):\\n            arr[i], maxi = maxi, max(arr[i],maxi)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551929,
                "title": "simple-o-n-time-and-o-1-space-complexity-solution",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        \\n        int max = -1;        \\n        for(int i=arr.length-1;i>=0;i--){\\n            int element = arr[i];\\n            arr[i]= max;\\n            if(max<element){\\n                max = element ;\\n            }\\n        }\\n        return arr;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        \\n        int max = -1;        \\n        for(int i=arr.length-1;i>=0;i--){\\n            int element = arr[i];\\n            arr[i]= max;\\n            if(max<element){\\n                max = element ;\\n            }\\n        }\\n        return arr;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830191,
                "title": "c-2-approach-left-start-o-n-2-right-start-o-n-7-lines",
                "content": "\\n# Approach 1. start from left\\nFrom the observation from left to right, \\nwe have the following solution.\\n```C++\\nvector<int> replaceElements(vector<int>& arr) {\\n\\tint n = arr.size();\\n\\tint max_val, max_idx = 0;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(i>=max_idx) {\\n\\t\\t\\tmax_val = -1;\\n\\t\\t\\t//figure out max element in the range \\n\\t\\t\\t//from arr[i+1] to arr[n-1]\\n\\t\\t\\tfor(int j=i+1; j<n;j++) {\\n\\t\\t\\t\\tif(arr[j] > max_val) {\\n\\t\\t\\t\\t\\tmax_idx = j;\\n\\t\\t\\t\\t\\tmax_val = arr[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tarr[i] = max_val;            \\n\\t}\\n\\treturn arr;\\n}\\n```\\nThe worst case is descending order array. \\nIt is something like [n-1,n-2,...,9,8,7,6,5,4,3,2,1].\\n\\n\\nIf we can change the return type of API from `vector<int>` into `vector<int>&`, \\nthen the complexity analysis are\\n**Time complexity O(n^2)**\\n**Space complexity O(1)**\\n\\n\\nBecause the max element is always happen in the right side of every \\ncurrent element when you travel from left to right. So we can try to change \\nthe observation from right to left. \\n# Approach 2. start from right \\nFrom the observation from right to left, \\nwe have the following solution.\\n\\n\\n```C++\\nvector<int> replaceElements(vector<int>& arr) {\\n\\tint max_val = -1;\\n\\tfor(int i = arr.size()-1; i>=0;i--) \\n\\t\\tif(arr[i]>max_val) \\n\\t\\t\\tswap(arr[i],max_val);\\n\\t\\telse \\n\\t\\t\\tarr[i] = max_val;\\n\\treturn arr;\\n}\\n```\\n\\n\\nIf we can change the return type of API from `vector<int>` into `vector<int>&`, \\nthen the complexity analysis are\\n\\n**Time complexity O(n)**\\n**Space complexity O(1)**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nvector<int> replaceElements(vector<int>& arr) {\\n\\tint n = arr.size();\\n\\tint max_val, max_idx = 0;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(i>=max_idx) {\\n\\t\\t\\tmax_val = -1;\\n\\t\\t\\t//figure out max element in the range \\n\\t\\t\\t//from arr[i+1] to arr[n-1]\\n\\t\\t\\tfor(int j=i+1; j<n;j++) {\\n\\t\\t\\t\\tif(arr[j] > max_val) {\\n\\t\\t\\t\\t\\tmax_idx = j;\\n\\t\\t\\t\\t\\tmax_val = arr[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tarr[i] = max_val;            \\n\\t}\\n\\treturn arr;\\n}\\n```\n```C++\\nvector<int> replaceElements(vector<int>& arr) {\\n\\tint max_val = -1;\\n\\tfor(int i = arr.size()-1; i>=0;i--) \\n\\t\\tif(arr[i]>max_val) \\n\\t\\t\\tswap(arr[i],max_val);\\n\\t\\telse \\n\\t\\t\\tarr[i] = max_val;\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1793644,
                "title": "kotlin-o-n-straightforward-solution",
                "content": "```kotlin\\nclass Solution {\\n    fun replaceElements(arr: IntArray): IntArray {\\n        var max = -1\\n        \\n        for (i in arr.size - 1 downTo 0) {\\n            val current = arr[i]\\n            arr[i] = max\\n            max = maxOf(current, max)\\n        }\\n        \\n        return arr\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun replaceElements(arr: IntArray): IntArray {\\n        var max = -1\\n        \\n        for (i in arr.size - 1 downTo 0) {\\n            val current = arr[i]\\n            arr[i] = max\\n            max = maxOf(current, max)\\n        }\\n        \\n        return arr\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596649,
                "title": "java-solution-w-explanation-faster-than-99-7",
                "content": "```\\nif(arr.length == 1){arr[0] = -1;return arr;}  //edge case: an only element\\nint max = -1; \\nint curNum = 0; \\n\\nfor(int i = arr.length-1;i >= 0;i--){  \\n\\t//remember the current number and for the last element put -1 in the slot\\n            curNum= arr[i];   \\n\\t//put the greatest element to the right in current slot\\n            arr[i] = max;   \\n\\t//compare current number and the greatest element to the right\\n            max = Math.max(max,curNum);   \\n        }\\nreturn arr;\\n```",
                "solutionTags": [],
                "code": "```\\nif(arr.length == 1){arr[0] = -1;return arr;}  //edge case: an only element\\nint max = -1; \\nint curNum = 0; \\n\\nfor(int i = arr.length-1;i >= 0;i--){  \\n\\t//remember the current number and for the last element put -1 in the slot\\n            curNum= arr[i];   \\n\\t//put the greatest element to the right in current slot\\n            arr[i] = max;   \\n\\t//compare current number and the greatest element to the right\\n            max = Math.max(max,curNum);   \\n        }\\nreturn arr;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1583740,
                "title": "6-lines-easy-java-solution-1ms-99-76-faster",
                "content": "**Upvote if you LIKE** \\uD83D\\uDE42\\nclass Solution {\\n\\n    public int[] replaceElements(int[] arr) {\\n        \\n        int max = -1, temp;\\n        for (int i = arr.length - 1; i >= 0; --i) {\\n            temp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, temp);\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[] replaceElements(int[] arr) {\\n        \\n        int max = -1, temp;\\n        for (int i = arr.length - 1; i >= 0; --i) {\\n            temp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1371359,
                "title": "super-simple-java-100",
                "content": "\\tpublic int[] replaceElements(int[] arr) {\\n\\t\\t\\t\\n\\t\\t\\t// keep track of the max value on the right side\\n\\t\\t\\tint max = arr[arr.length - 1];\\n\\t\\t\\t// iterate backwards, replacing the element at i with the max\\n\\t\\t\\t// update max if the value at index i is greater than max \\n\\t\\t\\tfor (int i = arr.length - 2; i >= 0; i -= 1) {\\n\\t\\t\\t\\tint temp = arr[i];\\n\\t\\t\\t\\tarr[i] = max;\\n\\t\\t\\t\\tmax = Math.max(max, temp);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tarr[arr.length - 1] = -1;\\n\\t\\t\\treturn arr;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic int[] replaceElements(int[] arr) {\\n\\t\\t\\t\\n\\t\\t\\t// keep track of the max value on the right side\\n\\t\\t\\tint max = arr[arr.length - 1];\\n\\t\\t\\t// iterate backwards, replacing the element at i with the max\\n\\t\\t\\t// update max if the value at index i is greater than max \\n\\t\\t\\tfor (int i = arr.length - 2; i >= 0; i -= 1) {\\n\\t\\t\\t\\tint temp = arr[i];\\n\\t\\t\\t\\tarr[i] = max;\\n\\t\\t\\t\\tmax = Math.max(max, temp);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tarr[arr.length - 1] = -1;\\n\\t\\t\\treturn arr;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1359199,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n = arr.size();\\n        int maxv = arr[n-1];\\n\\n        if(n == 0 || n==1)\\n            return {-1};\\n\\n        for(int i=n-2; i>=0; i--){\\n\\n            int temp = arr[i];\\n\\n            arr[i] = maxv;\\n            \\n            if(maxv < temp)\\n                maxv = temp;\\n        }\\n\\n    arr[n-1] = -1;\\n    return arr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n = arr.size();\\n        int maxv = arr[n-1];\\n\\n        if(n == 0 || n==1)\\n            return {-1};\\n\\n        for(int i=n-2; i>=0; i--){\\n\\n            int temp = arr[i];\\n\\n            arr[i] = maxv;\\n            \\n            if(maxv < temp)\\n                maxv = temp;\\n        }\\n\\n    arr[n-1] = -1;\\n    return arr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282572,
                "title": "java-o-n-time-complexity-o-1-space-complexity-beats-100",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int[] ans = new int[arr.length];\\n        ans[arr.length - 1] = -1;\\n        int rightMax = arr[arr.length - 1];\\n        \\n        for(int i = arr.length - 2; i >= 0; i--) {\\n            ans[i] = rightMax;\\n            if(arr[i] > rightMax) {\\n                rightMax = arr[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int[] ans = new int[arr.length];\\n        ans[arr.length - 1] = -1;\\n        int rightMax = arr[arr.length - 1];\\n        \\n        for(int i = arr.length - 2; i >= 0; i--) {\\n            ans[i] = rightMax;\\n            if(arr[i] > rightMax) {\\n                rightMax = arr[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241982,
                "title": "java-easy-100-solution-with-meaningful-variables-and-explanation",
                "content": "```\\n// Read from the back finding the maximum value\\n// We need the previous max because we can\\'t include the current value but we will for the next index\\npublic int[] replaceElements(int[] arr) {\\n\\tint max = -1;\\n\\tint previousMax = 0;\\n\\tfor (int i = arr.length-1; i >= 0; i--) {\\n\\t\\tpreviousMax = max;\\n\\t\\tmax = Math.max(max, arr[i]);\\n\\t\\tarr[i] = previousMax;\\n\\t}\\n\\n\\treturn arr;\\n}",
                "solutionTags": [],
                "code": "```\\n// Read from the back finding the maximum value\\n// We need the previous max because we can\\'t include the current value but we will for the next index\\npublic int[] replaceElements(int[] arr) {\\n\\tint max = -1;\\n\\tint previousMax = 0;\\n\\tfor (int i = arr.length-1; i >= 0; i--) {\\n\\t\\tpreviousMax = max;\\n\\t\\tmax = Math.max(max, arr[i]);\\n\\t\\tarr[i] = previousMax;\\n\\t}\\n\\n\\treturn arr;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1188635,
                "title": "java-easy-solution-beats-99",
                "content": "```\\nclass Solution { \\n    public int[] replaceElements(int[] arr) {\\n        int[] res = new int[arr.length];\\n        int max = Integer.MIN_VALUE;\\n        for (int i = arr.length - 1; i > 0; i--){\\n            max = Math.max(max, arr[i]);\\n            res[i - 1] = max;\\n        }\\n        res[arr.length - 1] = -1;\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution { \\n    public int[] replaceElements(int[] arr) {\\n        int[] res = new int[arr.length];\\n        int max = Integer.MIN_VALUE;\\n        for (int i = arr.length - 1; i > 0; i--){\\n            max = Math.max(max, arr[i]);\\n            res[i - 1] = max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1004144,
                "title": "javascript-o-n-beats-98",
                "content": "```\\n\\nconst replaceElements = arr => {\\n    \\n  let max = arr[arr.length-1];\\n  arr[arr.length-1] = -1;\\n  \\n  for(let i = arr.length-2; i >= 0; i--){\\n    let temp = arr[i]\\n    arr[i] = max;\\n    max = Math.max(max, temp)\\n  }\\n  return arr;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst replaceElements = arr => {\\n    \\n  let max = arr[arr.length-1];\\n  arr[arr.length-1] = -1;\\n  \\n  for(let i = arr.length-2; i >= 0; i--){\\n    let temp = arr[i]\\n    arr[i] = max;\\n    max = Math.max(max, temp)\\n  }\\n  return arr;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955289,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr):\\n        m=-1\\n        for i in range(len(arr)-1,-1,-1):\\n                arr[i],m =m, max(arr[i],m)\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr):\\n        m=-1\\n        for i in range(len(arr)-1,-1,-1):\\n                arr[i],m =m, max(arr[i],m)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885141,
                "title": "c-solution-using-stack-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n     \\n        int n=arr.size();\\n        stack<int> s;\\n        vector<int> ans;\\n        \\n        \\n        s.push(arr[n-1]);\\n        ans.push_back(-1);\\n        for(int i=n-2; i>=0; i--){\\n            ans.push_back(s.top());\\n            if(s.top()<arr[i]){\\n                s.push(arr[i]);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n     \\n        int n=arr.size();\\n        stack<int> s;\\n        vector<int> ans;\\n        \\n        \\n        s.push(arr[n-1]);\\n        ans.push_back(-1);\\n        for(int i=n-2; i>=0; i--){\\n            ans.push_back(s.top());\\n            if(s.top()<arr[i]){\\n                s.push(arr[i]);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835139,
                "title": "typescript-o-n-easy-w-comments",
                "content": "```\\nfunction replaceElements(arr: number[]): number[] {\\n    // current max number we\\'ve seen\\n    let max: number = -1;\\n    // go through the array from the right,\\n    // put in the number representing the max number at that point in arr\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        // store temp\\n        let temp: number = arr[i];\\n        // change current value to current max\\n        arr[i] = max;\\n        // set new max\\n        max = Math.max(max, temp);\\n    }\\n\\n    return arr;\\n}\\n```\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction replaceElements(arr: number[]): number[] {\\n    // current max number we\\'ve seen\\n    let max: number = -1;\\n    // go through the array from the right,\\n    // put in the number representing the max number at that point in arr\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        // store temp\\n        let temp: number = arr[i];\\n        // change current value to current max\\n        arr[i] = max;\\n        // set new max\\n        max = Math.max(max, temp);\\n    }\\n\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 724708,
                "title": "javascript-es6-solution-2-lines",
                "content": "```\\nvar replaceElements = function (arr) {\\n  var len = arr.length;\\n  return arr.map((x, i) =>\\n    i == len - 1 ? -1 : Math.max(...arr.slice(i + 1, len))\\n  );\\n};\\n```\\nThis solution below is faster:\\n\\n```\\nvar replaceElements = function (arr) {\\n  var res = [];\\n  var max = arr[arr.length - 1];\\n  for (let i = arr.length - 1; i >= 0; i--) {\\n    if (i == arr.length - 1) {\\n      res[i] = -1;\\n    } else {\\n      res[i] = max;\\n      max = Math.max(max, arr[i]);\\n    }\\n  }\\n  return res;\\n};\\n```\\n```\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar replaceElements = function (arr) {\\n  var len = arr.length;\\n  return arr.map((x, i) =>\\n    i == len - 1 ? -1 : Math.max(...arr.slice(i + 1, len))\\n  );\\n};\\n```\n```\\nvar replaceElements = function (arr) {\\n  var res = [];\\n  var max = arr[arr.length - 1];\\n  for (let i = arr.length - 1; i >= 0; i--) {\\n    if (i == arr.length - 1) {\\n      res[i] = -1;\\n    } else {\\n      res[i] = max;\\n      max = Math.max(max, arr[i]);\\n    }\\n  }\\n  return res;\\n};\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 656403,
                "title": "java-easy-solution-better-than-100-both-memory-and-runtime",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        for(int i = arr.length - 1; i >= 0; i--) {\\n            int temp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, temp);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        for(int i = arr.length - 1; i >= 0; i--) {\\n            int temp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, temp);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627109,
                "title": "golang-simple-solution",
                "content": "```\\nfunc replaceElements(arr []int) []int {\\n\\tmax := -1\\n\\tfor i := len(arr) - 1; i >= 0; i-- {\\n\\t\\tt := arr[i]\\n\\t\\tarr[i] = max\\n\\t\\tif t > max {\\n\\t\\t\\tmax = t\\n\\t\\t}\\n\\t}\\n\\n\\treturn arr\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc replaceElements(arr []int) []int {\\n\\tmax := -1\\n\\tfor i := len(arr) - 1; i >= 0; i-- {\\n\\t\\tt := arr[i]\\n\\t\\tarr[i] = max\\n\\t\\tif t > max {\\n\\t\\t\\tmax = t\\n\\t\\t}\\n\\t}\\n\\n\\treturn arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 617444,
                "title": "c-3-lines-solution-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        for(int i = (int)arr.size()-1, mx = -1; i >= 0; --i)\\n            mx = max(mx, exchange(arr[i], mx));\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        for(int i = (int)arr.size()-1, mx = -1; i >= 0; --i)\\n            mx = max(mx, exchange(arr[i], mx));\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557377,
                "title": "go-golang-clean-solutions",
                "content": ">Runtime: 148 ms, faster than 24.11% of Go online submissions for Replace Elements with Greatest Element on Right Side.\\nMemory Usage: 5.9 MB, less than 100.00% of Go online submissions for Replace Elements with Greatest Element on Right Side.\\n\\n```go\\nfunc replaceElements(arr []int) []int {\\n    res := make([]int, len(arr))\\n    for i := 0; i < len(arr); i++ {\\n        if i == len(arr) - 1 {\\n            res[i] = -1\\n        } else {\\n            res[i] = helper(arr[i + 1:])\\n        }\\n    }\\n    return res\\n}\\n\\nfunc helper(arr []int) int {\\n    max := 0\\n    for _, v := range arr {\\n        if v > max { max = v }\\n    }\\n    return max\\n}\\n```\\n\\n>Runtime: 12 ms, faster than 95.86% of Go online submissions for Replace Elements with Greatest Element on Right Side.\\nMemory Usage: 6.1 MB, less than 100.00% of Go online submissions for Replace Elements with Greatest Element on Right Side.\\n\\n```go\\nfunc replaceElements(arr []int) []int {\\n    max := -1\\n    for i := len(arr) - 1; i >= 0; i-- {\\n        if arr[i] > max {\\n            max, arr[i] = arr[i], max\\n        } else {\\n            arr[i] = max\\n        }\\n    }\\n    return arr\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc replaceElements(arr []int) []int {\\n    res := make([]int, len(arr))\\n    for i := 0; i < len(arr); i++ {\\n        if i == len(arr) - 1 {\\n            res[i] = -1\\n        } else {\\n            res[i] = helper(arr[i + 1:])\\n        }\\n    }\\n    return res\\n}\\n\\nfunc helper(arr []int) int {\\n    max := 0\\n    for _, v := range arr {\\n        if v > max { max = v }\\n    }\\n    return max\\n}\\n```\n```go\\nfunc replaceElements(arr []int) []int {\\n    max := -1\\n    for i := len(arr) - 1; i >= 0; i-- {\\n        if arr[i] > max {\\n            max, arr[i] = arr[i], max\\n        } else {\\n            arr[i] = max\\n        }\\n    }\\n    return arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 556615,
                "title": "php-solution",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $arr\\n     * @return Integer[]\\n     */\\n    function replaceElements($arr) {\\n        $len = count($arr) - 1;\\n        $max = $arr[$len];\\n        $arr[$len] = -1;\\n        \\n        for($i = $len - 1; $i >= 0; $i--) {\\n            $old_max = $max;\\n            $max = $arr[$i] > $max ? $arr[$i] : $max;   \\n            $arr[$i] = $old_max;\\n        } \\n        \\n        return $arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $arr\\n     * @return Integer[]\\n     */\\n    function replaceElements($arr) {\\n        $len = count($arr) - 1;\\n        $max = $arr[$len];\\n        $arr[$len] = -1;\\n        \\n        for($i = $len - 1; $i >= 0; $i--) {\\n            $old_max = $max;\\n            $max = $arr[$i] > $max ? $arr[$i] : $max;   \\n            $arr[$i] = $old_max;\\n        } \\n        \\n        return $arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554235,
                "title": "java-1ms-faster-than-100-submission-with-explaination",
                "content": "The ideal is to traverse array from the end, and keep hold of max element before current element. At the same time time keep updating the input array.\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = arr[arr.length -1];\\n        for(int i = arr.length - 2; i >=0; i--){\\n            int temp = max;\\n            if(arr[i] > max) max = arr[i];\\n            arr[i] = temp;\\n        }\\n        arr[arr.length - 1] = -1;\\n        return arr;\\n    }\\n}\\n```\\nTime Complexity = O(n)\\nSpace Complexity = O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = arr[arr.length -1];\\n        for(int i = arr.length - 2; i >=0; i--){\\n            int temp = max;\\n            if(arr[i] > max) max = arr[i];\\n            arr[i] = temp;\\n        }\\n        arr[arr.length - 1] = -1;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544817,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        maxn = arr[-1]\\n        for i in range(len(arr)-1,-1, -1):\\n            if maxn < arr[i]:\\n                temp = arr[i]\\n                arr[i] = maxn\\n                maxn = temp\\n            else:\\n                arr[i] = maxn\\n        arr[-1] = -1\\n        return arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        maxn = arr[-1]\\n        for i in range(len(arr)-1,-1, -1):\\n            if maxn < arr[i]:\\n                temp = arr[i]\\n                arr[i] = maxn\\n                maxn = temp\\n            else:\\n                arr[i] = maxn\\n        arr[-1] = -1\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521039,
                "title": "straightforward-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if (arr == null) {\\n            return arr;\\n        }\\n        int max = -1;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            int val = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, val);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if (arr == null) {\\n            return arr;\\n        }\\n        int max = -1;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            int val = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, val);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466057,
                "title": "python-3-simple-fast",
                "content": "#### Step 1:\\n##### scan array from right to left\\n\\n#### Step 2:\\n##### keep track of the max number\\n\\n#### Step 3:\\n##### create a new array with current max number\\n\\n#### Step 4:\\n##### Rinse & Repeat\\n\\n\\n```python\\n# Most Readable\\ndef replaceElements(self, arr: List[int]) -> List[int]:\\n\\tmax_i = -1\\n\\tres = [-1]\\n\\tfor i in arr[::-1]:\\n\\t\\tif i > max_i:\\n\\t\\t\\tmax_i = i\\n\\t\\tres = [max_i] + res\\n\\treturn res[1:]\\n\\t\\n```\\n\\n```python\\n# Super Fast\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        max_i = -1\\n        res = [-1]\\n        for i in arr[::-1]:\\n            if i > max_i:\\n                max_i = i\\n            res += [max_i]\\n        res = res[:-1]\\n        return res[::-1]\\n```",
                "solutionTags": [],
                "code": "```python\\n# Most Readable\\ndef replaceElements(self, arr: List[int]) -> List[int]:\\n\\tmax_i = -1\\n\\tres = [-1]\\n\\tfor i in arr[::-1]:\\n\\t\\tif i > max_i:\\n\\t\\t\\tmax_i = i\\n\\t\\tres = [max_i] + res\\n\\treturn res[1:]\\n\\t\\n```\n```python\\n# Super Fast\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        max_i = -1\\n        res = [-1]\\n        for i in arr[::-1]:\\n            if i > max_i:\\n                max_i = i\\n            res += [max_i]\\n        res = res[:-1]\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463572,
                "title": "python3-backward-scan",
                "content": "Algorithm:\\nInitialize `m` at -1;\\nScan array backward and 1) assign `m` to `arr[i]` and simultaneously update `m` to be `max(m, arr[i])`. \\n\\nImplementation (76ms, 100%): \\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        for i in reversed(range(len(arr))):\\n            arr[i], m = m, max(m, arr[i])\\n        return arr\\n```\\nAnalysis:\\nTime complexity `O(N)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        for i in reversed(range(len(arr))):\\n            arr[i], m = m, max(m, arr[i])\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463353,
                "title": "simple-python-solution-beat-100",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        \\n        maxNum = -1\\n        for i in range(len(arr) - 1, -1, -1):\\n            last = maxNum\\n            maxNum = max(maxNum, arr[i])\\n            arr[i] = last\\n        return arr\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        \\n        maxNum = -1\\n        for i in range(len(arr) - 1, -1, -1):\\n            last = maxNum\\n            maxNum = max(maxNum, arr[i])\\n            arr[i] = last\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463182,
                "title": "easy-solution-in-java",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n=arr.size();\\n        int maxele=arr[n-1];\\n        arr[n-1]=-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int temp=arr[i];\\n            arr[i]=maxele;\\n            maxele=max(maxele,temp);\\n            \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n=arr.size();\\n        int maxele=arr[n-1];\\n        arr[n-1]=-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int temp=arr[i];\\n            arr[i]=maxele;\\n            maxele=max(maxele,temp);\\n            \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685923,
                "title": "c-java-both-simple-and-concise-solutions-100-easy-to-understand-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to traverse the array from right to left, keeping track of the maximum element encountered so far. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The code initializes the maximum value (mx) as the last element of the input array, replaces it with -1.\\n- And then iterates from the second-to-last element to the first element.\\n- At each step, it updates the current maximum (cur) by taking the maximum of the current element and the previous maximum.\\n- The current element is then replaced with the previous maximum, and the process continues until all elements are replaced.\\n# Complexity\\n- Time complexity: $$ O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code : \\n### C++ : \\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = arr.size();\\n        int cur;\\n        int mx = arr[n-1];\\n        arr[n-1] = -1;\\n        for(int i=n-2; i>=0; i--){\\n            cur = max(mx, arr[i]);\\n            arr[i] = mx;\\n            mx = cur;\\n        }\\n        return arr;\\n    }\\n};\\n```\\nNote : The use of `ios_base::sync_with_stdio(false);` `cin.tie(NULL);` reduces the time complexity bit more.\\nFor more info refer this [Link](https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull)\\n### Java :\\n```\\npublic int[] replaceElements(int[] arr) {\\n    for (int i = arr.length - 1, max = -1; i >= 0; --i) {\\n        int tmp = arr[i];\\n        arr[i] = max;\\n        max = Math.max(max, tmp);\\n    }\\n    return arr;\\n}\\n```\\n\\n## More Concise Code : \\n### C++ : \\n```\\nvector<int> replaceElements(vector<int>& A, int mx = -1) {\\n    for (int i = A.size() - 1; i >= 0; --i)\\n        mx = max(mx, exchange(A[i], mx));\\n    return A;\\n}\\n```\\n### Java :\\n```\\npublic int[] replaceElements(int[] A) {\\n    for (int i = A.length - 1, mx = -1; i >= 0; --i)\\n        mx = Math.max(A[i], A[i] = mx);\\n    return A;\\n}\\n```\\n\\n### Happy coding.\\n**Feel free to ask any question in the comment section.**\\n**If you like this solution, Please do upvote this post.**\\n\\n**Tom needs upvote.**\\n![tom up 2.gif](https://assets.leetcode.com/users/images/b072e326-7346-4b1e-80bf-9da9877391c2_1687797330.550179.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = arr.size();\\n        int cur;\\n        int mx = arr[n-1];\\n        arr[n-1] = -1;\\n        for(int i=n-2; i>=0; i--){\\n            cur = max(mx, arr[i]);\\n            arr[i] = mx;\\n            mx = cur;\\n        }\\n        return arr;\\n    }\\n};\\n```\n```\\npublic int[] replaceElements(int[] arr) {\\n    for (int i = arr.length - 1, max = -1; i >= 0; --i) {\\n        int tmp = arr[i];\\n        arr[i] = max;\\n        max = Math.max(max, tmp);\\n    }\\n    return arr;\\n}\\n```\n```\\nvector<int> replaceElements(vector<int>& A, int mx = -1) {\\n    for (int i = A.size() - 1; i >= 0; --i)\\n        mx = max(mx, exchange(A[i], mx));\\n    return A;\\n}\\n```\n```\\npublic int[] replaceElements(int[] A) {\\n    for (int i = A.length - 1, mx = -1; i >= 0; --i)\\n        mx = Math.max(A[i], A[i] = mx);\\n    return A;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679535,
                "title": "java-easy-to-learn-o-n-and-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max=arr[arr.length-1];\\n        arr[arr.length-1]=-1;\\n        for(int i=arr.length-2;i>=0;i--){\\n            int temp=arr[i];\\n            arr[i]=max;\\n            max=Math.max(max,temp);\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max=arr[arr.length-1];\\n        arr[arr.length-1]=-1;\\n        for(int i=arr.length-2;i>=0;i--){\\n            int temp=arr[i];\\n            arr[i]=max;\\n            max=Math.max(max,temp);\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207474,
                "title": "o-n-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* replaceElements(int* arr, int arrSize, int* returnSize){\\n\\n    *returnSize = arrSize;\\n    int max=-1,temp;\\n    \\n\\n    for(int i=arrSize - 1;i >= 0;i--){\\n        if(arr[i]>max)\\n            temp = arr[i];\\n        arr[i]=max;\\n        max = temp;\\n    }\\n\\n\\n    return arr;\\n    \\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* replaceElements(int* arr, int arrSize, int* returnSize){\\n\\n    *returnSize = arrSize;\\n    int max=-1,temp;\\n    \\n\\n    for(int i=arrSize - 1;i >= 0;i--){\\n        if(arr[i]>max)\\n            temp = arr[i];\\n        arr[i]=max;\\n        max = temp;\\n    }\\n\\n\\n    return arr;\\n    \\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3155975,
                "title": "easy-to-understand-o-n-2-solution-java-code",
                "content": "\\n\\n# Bruteforce approach (Java Code)\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if(arr.length==1) {\\n            arr[0] =-1;\\n        }\\n        for(int i =0;i<arr.length;i++) {\\n            int max = -1;\\n            for(int j =i+1;j<arr.length;j++) {\\n                max = Math.max(max,arr[j]);\\n            } \\n            arr[i] = max;\\n        }\\n        return arr;\\n    }\\n}\\n```\\n# Optimised approach (Java Code)\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n      int max = -1;\\n      for(int i = arr.length-1;i>=0;i--) {\\n          int temp = arr[i];\\n          arr[i] = max;\\n          max= Math.max(max,temp);\\n      }\\n      return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if(arr.length==1) {\\n            arr[0] =-1;\\n        }\\n        for(int i =0;i<arr.length;i++) {\\n            int max = -1;\\n            for(int j =i+1;j<arr.length;j++) {\\n                max = Math.max(max,arr[j]);\\n            } \\n            arr[i] = max;\\n        }\\n        return arr;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n      int max = -1;\\n      for(int i = arr.length-1;i>=0;i--) {\\n          int temp = arr[i];\\n          arr[i] = max;\\n          max= Math.max(max,temp);\\n      }\\n      return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793243,
                "title": "easy-golang-solution-simple-go",
                "content": "Please don\\'t forget to upvote the post. \\n\\n```\\nfunc replaceElements(arr []int) []int {\\n    m := -1\\n    for i:=len(arr)-1; i>=0;i-- {\\n        temp := arr[i]\\n        arr[i] = m\\n        if m < temp {\\n            m = temp\\n        }\\n    }\\n    return arr\\n}\\n```\\n\\n\\u270C\\uFE0F",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nfunc replaceElements(arr []int) []int {\\n    m := -1\\n    for i:=len(arr)-1; i>=0;i-- {\\n        temp := arr[i]\\n        arr[i] = m\\n        if m < temp {\\n            m = temp\\n        }\\n    }\\n    return arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2718888,
                "title": "simple-o-n-in-place",
                "content": "\\n\\n# Code\\n```\\nfunc replaceElements(arr []int) []int {\\n   \\n    max := -1\\n    for i := len(arr)-1; i >= 0; i-- {\\n        if arr[i] > max {\\n            arr[i], max = max, arr[i]\\n        } else {\\n            arr[i] = max\\n        }\\n    }\\n    \\n    return arr\\n}\\n\\n// [1, 2, 0, -5, 2] -> [2, 2, 2, 2, -1]\\n// [0] -> [-1]\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc replaceElements(arr []int) []int {\\n   \\n    max := -1\\n    for i := len(arr)-1; i >= 0; i-- {\\n        if arr[i] > max {\\n            arr[i], max = max, arr[i]\\n        } else {\\n            arr[i] = max\\n        }\\n    }\\n    \\n    return arr\\n}\\n\\n// [1, 2, 0, -5, 2] -> [2, 2, 2, 2, -1]\\n// [0] -> [-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643490,
                "title": "20ms-c-beats-81-6-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to take the max on the right so lets take an example \\n\\nInput=[3,2,4,1,2]\\n\\nso the max to the right of the element at index 0 that is 3 is clearly 4\\n\\nand now if we check for the element at index 1 that is 2 then the element is still 4\\nbut we reached this by iterating the entier array so we can reduce this extra work done\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntake a temp array \\n\\nfill it from back with the max \\n\\nnow just fill the ans array with -1 at last index and then taking the value at same index in the temp array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        if(n==1){\\n            arr[0]=-1;\\n            return arr;\\n        }\\n        vector<int> ab(n,-1);\\n        int mx=arr[n-1];\\n        \\n        for(int i=n-1;i>0;i--){\\n            mx=max(mx,arr[i]);\\n            ab[i]=mx;\\n        }\\n        vector<int> ans(n,-1);\\n        ans[n-1]=-1;\\n        for(int i=n-2;i>=0;i--){\\n            ans[i]=ab[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        if(n==1){\\n            arr[0]=-1;\\n            return arr;\\n        }\\n        vector<int> ab(n,-1);\\n        int mx=arr[n-1];\\n        \\n        for(int i=n-1;i>0;i--){\\n            mx=max(mx,arr[i]);\\n            ab[i]=mx;\\n        }\\n        vector<int> ans(n,-1);\\n        ans[n-1]=-1;\\n        for(int i=n-2;i>=0;i--){\\n            ans[i]=ab[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608885,
                "title": "2ms-very-easy-fast-and-simple-java-solution-with-o-n-time-complexity",
                "content": "```\\n//We start from end and update the max until we reach the starting of the array.\\n\\nclass Solution {\\n    public int[] replaceElements(int[] arr) \\n    {\\n        int max = arr[arr.length-1];\\n        int[] otpt = new int[arr.length];\\n        for(int i=arr.length-1;i>=0;i--)\\n        {\\n            otpt[i] = max;\\n            \\n            if(max<arr[i])\\n            {\\n                max = arr[i];\\n            }\\n        }\\n        otpt[arr.length-1] = -1;\\n        return otpt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//We start from end and update the max until we reach the starting of the array.\\n\\nclass Solution {\\n    public int[] replaceElements(int[] arr) \\n    {\\n        int max = arr[arr.length-1];\\n        int[] otpt = new int[arr.length];\\n        for(int i=arr.length-1;i>=0;i--)\\n        {\\n            otpt[i] = max;\\n            \\n            if(max<arr[i])\\n            {\\n                max = arr[i];\\n            }\\n        }\\n        otpt[arr.length-1] = -1;\\n        return otpt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578010,
                "title": "python-simple-solution",
                "content": "Optimised one\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        s = 0\\n        x = 0\\n        y = 0\\n        while x != len(arr)-1:\\n            for i in range(x+1, len(arr)):\\n                if s < arr[i]:\\n                    s = arr[i]\\n                    x = i\\n            for i in range(y, x):\\n                arr[i] = s\\n            s = 0\\n            y = x\\n        arr.pop()\\n        arr.append(-1)\\n        return arr\\n            \\n```\\nUnoptimised solution below , may give TLE\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        for i in range(len(arr)-1):\\n            arr[i] = max(arr[i+1:])\\n        arr[-1] = -1\\n        return arr\\n```\\n![image](https://assets.leetcode.com/users/images/3fce3324-533c-45ab-a5fa-1995a72cc366_1663998889.5267887.png)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        s = 0\\n        x = 0\\n        y = 0\\n        while x != len(arr)-1:\\n            for i in range(x+1, len(arr)):\\n                if s < arr[i]:\\n                    s = arr[i]\\n                    x = i\\n            for i in range(y, x):\\n                arr[i] = s\\n            s = 0\\n            y = x\\n        arr.pop()\\n        arr.append(-1)\\n        return arr\\n            \\n```\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        for i in range(len(arr)-1):\\n            arr[i] = max(arr[i+1:])\\n        arr[-1] = -1\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455043,
                "title": "simple-o-n-solution-1ms-easy-solution",
                "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n     \\n        int max = arr[arr.length-1];\\n        arr[arr.length-1] = -1;    \\n        \\n        for(int i = arr.length-2; i >= 0 ;i--) {\\n            int temp = arr[i];\\n            arr[i] = max;\\n            \\n            if(temp > max)  {\\n                max =temp;\\n            }\\n        }\\n        \\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n     \\n        int max = arr[arr.length-1];\\n        arr[arr.length-1] = -1;    \\n        \\n        for(int i = arr.length-2; i >= 0 ;i--) {\\n            int temp = arr[i];\\n            arr[i] = max;\\n            \\n            if(temp > max)  {\\n                max =temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2395022,
                "title": "python-in-place-simple-execution",
                "content": "Hope you all find it useful.\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        maxright = arr[-1]\\n        for i in range(len(arr) -1,-1,-1):\\n            temp = arr[i]\\n            arr[i] = maxright\\n            if temp > maxright:\\n                maxright = temp\\n        arr[-1] = -1\\n        \\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        maxright = arr[-1]\\n        for i in range(len(arr) -1,-1,-1):\\n            temp = arr[i]\\n            arr[i] = maxright\\n            if temp > maxright:\\n                maxright = temp\\n        arr[-1] = -1\\n        \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366804,
                "title": "simple-c-solution-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        for(int i = 0; i < arr.size() - 1; i++)\\n        {\\n            arr[i] = *max_element(arr.begin() + i + 1, arr.end());\\n        }\\n        arr[arr.size() - 1] = -1;\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        for(int i = 0; i < arr.size() - 1; i++)\\n        {\\n            arr[i] = *max_element(arr.begin() + i + 1, arr.end());\\n        }\\n        arr[arr.size() - 1] = -1;\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188680,
                "title": "java-easy-solutions-with-2-approach-in-best-time-complexity-in-place-method-stack-method",
                "content": "USING STACK\\n```\\nint n=arr.length;\\n        Stack<Integer> s = new Stack<>();\\n        int[] ans = new int[n];\\n        \\n        s.push(arr[n-1]);\\n        ans[n-1] = -1 ;\\n        for(int i=n-2; i>=0; i--){\\n            ans[i] = s.peek();\\n            if(s.peek()<arr[i]){\\n                s.push(arr[i]);\\n            }\\n        }\\n    return ans;\\n```\\n\\nIN-PLACE METHOD : \\n```\\nint n = arr.length;\\n           int max = -1;\\n           int temp = 0 ;\\n           for(int i = n-1 ; i >= 0 ; i-- ){\\n               temp = arr[i];\\n               arr[i] = max;\\n               max = Math.max(temp,max);\\n           }\\n        \\n           return arr;\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nint n=arr.length;\\n        Stack<Integer> s = new Stack<>();\\n        int[] ans = new int[n];\\n        \\n        s.push(arr[n-1]);\\n        ans[n-1] = -1 ;\\n        for(int i=n-2; i>=0; i--){\\n            ans[i] = s.peek();\\n            if(s.peek()<arr[i]){\\n                s.push(arr[i]);\\n            }\\n        }\\n    return ans;\\n```\n```\\nint n = arr.length;\\n           int max = -1;\\n           int temp = 0 ;\\n           for(int i = n-1 ; i >= 0 ; i-- ){\\n               temp = arr[i];\\n               arr[i] = max;\\n               max = Math.max(temp,max);\\n           }\\n        \\n           return arr;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2080041,
                "title": "python3-runtime-133ms-82-42-memory-15-2mb-64-02",
                "content": "Both brute force and optimal solution are mentioned\\n```\\nclass Solution:\\n    def replaceElements(self, array: List[int]) -> List[int]:\\n        return self.optimalSolution(array)\\n\\n    #     O(N) || O(1) 133ms 82.42%\\n    def optimalSolution(self, array):\\n        rightMax = -1\\n        for i in reversed(range(len(array))):\\n            maxVal = max(rightMax, array[i])\\n            array[i] = rightMax\\n            rightMax = maxVal\\n        return array\\n        \\n    # O(n^2) || O(1) TLE\\n    def bruteForce(self, array):\\n        if not array:\\n            return array\\n        \\n        for i in range(len(array)):\\n            maxVal = 0\\n            for j in range(i+1, len(array)):\\n                maxVal = max(maxVal, array[j])\\n            array[i] = maxVal\\n\\n\\n        array[-1] = -1\\n\\n        return array\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, array: List[int]) -> List[int]:\\n        return self.optimalSolution(array)\\n\\n    #     O(N) || O(1) 133ms 82.42%\\n    def optimalSolution(self, array):\\n        rightMax = -1\\n        for i in reversed(range(len(array))):\\n            maxVal = max(rightMax, array[i])\\n            array[i] = rightMax\\n            rightMax = maxVal\\n        return array\\n        \\n    # O(n^2) || O(1) TLE\\n    def bruteForce(self, array):\\n        if not array:\\n            return array\\n        \\n        for i in range(len(array)):\\n            maxVal = 0\\n            for j in range(i+1, len(array)):\\n                maxVal = max(maxVal, array[j])\\n            array[i] = maxVal\\n\\n\\n        array[-1] = -1\\n\\n        return array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074507,
                "title": "o-n-solution-in-cpp-in-constant-space",
                "content": "Here we traverse the array in reverse order and keep track of the largest element till then...\\nWe update each element then based on this largest value...\\n\\n**Pls Upvote this thread if u found the explanation helpful**\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int currMax = arr[arr.size()-1];\\n        arr[arr.size()-1] = -1;\\n        for(int i=arr.size()-2;i>=0;i--) {\\n            if(arr[i]>currMax) {\\n                int x = currMax;\\n                currMax = arr[i];\\n                arr[i] = x;\\n            } else {\\n                arr[i] = currMax;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int currMax = arr[arr.size()-1];\\n        arr[arr.size()-1] = -1;\\n        for(int i=arr.size()-2;i>=0;i--) {\\n            if(arr[i]>currMax) {\\n                int x = currMax;\\n                currMax = arr[i];\\n                arr[i] = x;\\n            } else {\\n                arr[i] = currMax;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981200,
                "title": "easytounderstand-s-1-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n//         O(n*n) && S(1)\\n        // int n=arr.size();\\n        // for(int i=0;i<n-1;i++){\\n        //     arr[i]=*max_element(arr.begin()+i+1,arr.end());   \\n        // }\\n        // arr[n-1]=-1;\\n        // return arr;\\n        \\n//         O(n) && S(n)\\n        // int n=arr.size();\\n        // int large;\\n        // vector<int> a(n,-1);\\n        // large=arr[n-1];\\n        // int k=n-2;\\n        // for(int i=n-2;i>=0;i--){\\n        //     a[k--]=large;\\n        //     large=max(large,arr[i]);\\n        // }\\n        // return a;\\n        \\n//         O(n) && S(1)\\n        int mx=-1;\\n        for(int i=arr.size()-1;i>=0;i--){\\n            int curr=arr[i];\\n            arr[i]=mx;\\n            mx=max(mx,curr);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n//         O(n*n) && S(1)\\n        // int n=arr.size();\\n        // for(int i=0;i<n-1;i++){\\n        //     arr[i]=*max_element(arr.begin()+i+1,arr.end());   \\n        // }\\n        // arr[n-1]=-1;\\n        // return arr;\\n        \\n//         O(n) && S(n)\\n        // int n=arr.size();\\n        // int large;\\n        // vector<int> a(n,-1);\\n        // large=arr[n-1];\\n        // int k=n-2;\\n        // for(int i=n-2;i>=0;i--){\\n        //     a[k--]=large;\\n        //     large=max(large,arr[i]);\\n        // }\\n        // return a;\\n        \\n//         O(n) && S(1)\\n        int mx=-1;\\n        for(int i=arr.size()-1;i>=0;i--){\\n            int curr=arr[i];\\n            arr[i]=mx;\\n            mx=max(mx,curr);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961570,
                "title": "fastest-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) \\n    {\\n        var n=arr.length-1;\\n        var prevHigh=arr[n];\\n        arr[n]=-1;\\n        for(var i=n-1;i>=0;i--)\\n        {\\n            var cur=arr[i];\\n            arr[i]=prevHigh;\\n            if(cur>prevHigh)\\n                prevHigh=cur;\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int[] replaceElements(int[] arr) \\n    {\\n        var n=arr.length-1;\\n        var prevHigh=arr[n];\\n        arr[n]=-1;\\n        for(var i=n-1;i>=0;i--)\\n        {\\n            var cur=arr[i];\\n            arr[i]=prevHigh;\\n            if(cur>prevHigh)\\n                prevHigh=cur;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1893418,
                "title": "java-99-faster-replace-elements-with-greatest-element-on-right",
                "content": "```\\npublic int[] replaceElements(int[] arr) {\\n        int n = arr.length;\\n        int maxVal = -1;\\n        int temp = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n\\t\\t   //store the maxValue temporarily\\n            temp = maxVal;\\n\\t\\t\\t//compute the maxValue with original array value\\n            maxVal = Math.max(arr[i], maxVal);\\n\\t\\t\\t//assign the maxValue now\\n            arr[i] = temp;\\n        }   \\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] replaceElements(int[] arr) {\\n        int n = arr.length;\\n        int maxVal = -1;\\n        int temp = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n\\t\\t   //store the maxValue temporarily\\n            temp = maxVal;\\n\\t\\t\\t//compute the maxValue with original array value\\n            maxVal = Math.max(arr[i], maxVal);\\n\\t\\t\\t//assign the maxValue now\\n            arr[i] = temp;\\n        }   \\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887228,
                "title": "python-beginner-friendly-solution",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        res = [-1] * len(arr)\\n        for i in range(len(arr)-1):\\n            res[i] = max(arr[i+1:])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        res = [-1] * len(arr)\\n        for i in range(len(arr)-1):\\n            res[i] = max(arr[i+1:])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1839512,
                "title": "simple-java-one-traversal-solution",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max=-1;\\n        int n=arr.length;\\n        for(int i=n-1;i>=0;i--){\\n            int t=arr[i];\\n            arr[i]=max;\\n            max=Math.max(t,max);\\n             }\\n         return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max=-1;\\n        int n=arr.length;\\n        for(int i=n-1;i>=0;i--){\\n            int t=arr[i];\\n            arr[i]=max;\\n            max=Math.max(t,max);\\n             }\\n         return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833289,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int len = arr.length;\\n        int max = arr[arr.length - 1];\\n\\n        for (int i = len - 2; i >= 0; i--) {\\n            int temp = arr[i];\\n            arr[i] = max;\\n            if (max < temp) {\\n                max = temp;\\n            }\\n        }\\n\\n        arr[arr.length - 1] = -1;\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int len = arr.length;\\n        int max = arr[arr.length - 1];\\n\\n        for (int i = len - 2; i >= 0; i--) {\\n            int temp = arr[i];\\n            arr[i] = max;\\n            if (max < temp) {\\n                max = temp;\\n            }\\n        }\\n\\n        arr[arr.length - 1] = -1;\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796076,
                "title": "replace-elements-with-greatest-element",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int max_ele=0;\\n            for(int j=i+1; j<arr.size(); j++){\\n               if(arr[j]>max_ele){\\n                   max_ele= arr[j];\\n               }\\n                \\n            }\\n            if(i==arr.size()-1){\\n               ans.push_back(-1);\\n                break;\\n                }\\n            ans.push_back(max_ele);\\n            \\n        }\\n      \\n      return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int max_ele=0;\\n            for(int j=i+1; j<arr.size(); j++){\\n               if(arr[j]>max_ele){\\n                   max_ele= arr[j];\\n               }\\n                \\n            }\\n            if(i==arr.size()-1){\\n               ans.push_back(-1);\\n                break;\\n                }\\n            ans.push_back(max_ele);\\n            \\n        }\\n      \\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792227,
                "title": "easiest-javascript-solution-98-faster",
                "content": "```\\nvar replaceElements = function(arr) {\\n    let j = -1;\\n    \\n    for(let i = arr.length - 1; i >= 0; i--) {\\n        let temp = arr[i];\\n        arr[i] = j;\\n        if(temp > j) {\\n            j = temp;\\n        }\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvar replaceElements = function(arr) {\\n    let j = -1;\\n    \\n    for(let i = arr.length - 1; i >= 0; i--) {\\n        let temp = arr[i];\\n        arr[i] = j;\\n        if(temp > j) {\\n            j = temp;\\n        }\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1723718,
                "title": "easy-to-understand-c-solution-n-newmax-currmax",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n = arr.size();\\n        int currMax = -1;\\n        for(int i=n-1; i>=0; i--){\\n            int newMax = max(currMax,arr[i]); //compare\\n            arr[i] = currMax; //replace the element\\n            currMax = newMax; //update currMax value\\n        }\\n        return arr;\\n    \\n    }\\n};\\n```\\n****Please Upvote if you Like ****\\uD83D\\uDE00",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n = arr.size();\\n        int currMax = -1;\\n        for(int i=n-1; i>=0; i--){\\n            int newMax = max(currMax,arr[i]); //compare\\n            arr[i] = currMax; //replace the element\\n            currMax = newMax; //update currMax value\\n        }\\n        return arr;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668769,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            ans.push_back(*max_element(arr.begin()+i+1,arr.end()));\\n        }\\n        ans.push_back(-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            ans.push_back(*max_element(arr.begin()+i+1,arr.end()));\\n        }\\n        ans.push_back(-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664732,
                "title": "java-simple-1ms",
                "content": "```\\npublic int[] replaceElements(int[] arr) {\\n       int max = -1;\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\tint tmp = arr[i];\\n\\t\\t\\tarr[i] = max;\\n\\t\\t\\tif (tmp > max) {\\n\\t\\t\\t\\tmax = tmp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn arr; \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] replaceElements(int[] arr) {\\n       int max = -1;\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\tint tmp = arr[i];\\n\\t\\t\\tarr[i] = max;\\n\\t\\t\\tif (tmp > max) {\\n\\t\\t\\t\\tmax = tmp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn arr; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640960,
                "title": "simple-c-solution-with-temp-variable-o-n-time-o-1-space",
                "content": "```\\npublic int[] ReplaceElements(int[] arr) {\\n        int max = -1;\\n        for (int i = arr.Length - 1; i >= 0; i--)\\n        {\\n        int temp = max;\\n        if (arr[i] > max)\\n            max = arr[i];\\n        arr[i] = temp;\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] ReplaceElements(int[] arr) {\\n        int max = -1;\\n        for (int i = arr.Length - 1; i >= 0; i--)\\n        {\\n        int temp = max;\\n        if (arr[i] > max)\\n            max = arr[i];\\n        arr[i] = temp;\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580431,
                "title": "python-with-explanation",
                "content": "In this question we need to place the largest to the right value in curr index\\n\\nSteps:\\n1. at first make sanity check: if length is 1 => only `[-1]` is possible\\n2. so far the largest is last ele => attach to var\\n3. idx must be penultimate number.\\n4. traverse till `idx >= 0`\\n5. at first save curr value\\n6. then flip value to largest\\n7. alter: either curr largest or new\\n8. at the end flip value at `idx -1` with -1\\n\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        if len(arr) == 1:\\n            return [-1]\\n        \\n        largest = arr[-1]\\n        idx = len(arr) - 2\\n        while idx >= 0:\\n            temp = arr[idx]\\n            arr[idx] = largest\\n            largest = max(largest, temp)\\n            \\n            idx -= 1\\n        \\n        arr[-1] = -1\\n        return arr\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        if len(arr) == 1:\\n            return [-1]\\n        \\n        largest = arr[-1]\\n        idx = len(arr) - 2\\n        while idx >= 0:\\n            temp = arr[idx]\\n            arr[idx] = largest\\n            largest = max(largest, temp)\\n            \\n            idx -= 1\\n        \\n        arr[-1] = -1\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560449,
                "title": "python-easy-and-intuitive-solution",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        tillmax = arr[len(arr)-1]\\n        \\n        for j in range(len(arr)-2,-1,-1):\\n            tillmax,arr[j] =  max(arr[j],tillmax),tillmax\\n        \\n        arr[len(arr)-1]=-1\\n        \\n        return arr",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        tillmax = arr[len(arr)-1]\\n        \\n        for j in range(len(arr)-2,-1,-1):\\n            tillmax,arr[j] =  max(arr[j],tillmax),tillmax\\n        \\n        arr[len(arr)-1]=-1\\n        \\n        return arr",
                "codeTag": "Java"
            },
            {
                "id": 1491495,
                "title": "python-solution-not-passing-all-test-cases",
                "content": "Can someone tell me why it is not able to pass all test cases ?\\n\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        x = []\\n        if(len(arr) >1):\\n            for i in range(0, len(arr)):\\n                s = max(arr[i:])\\n                x.append(s)\\n            x.append(-1)\\n            return x[1:]\\n        else:\\n            return [-1]",
                "solutionTags": [],
                "code": "Can someone tell me why it is not able to pass all test cases ?\\n\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        x = []\\n        if(len(arr) >1):\\n            for i in range(0, len(arr)):\\n                s = max(arr[i:])\\n                x.append(s)\\n            x.append(-1)\\n            return x[1:]\\n        else:\\n            return [-1]",
                "codeTag": "Java"
            },
            {
                "id": 1380359,
                "title": "easy-solution-faster-than-90-in-o-n",
                "content": "```\\nvar replaceElements = function(arr) {\\n let result = new Array(arr.length)\\n     result[result.length-1]  = -1\\n     for(let i = arr.length-2; i>= 0; i--){\\n         result[i] = Math.max(arr[i+1] , result[i+1])\\n     }\\n \\n    return result\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar replaceElements = function(arr) {\\n let result = new Array(arr.length)\\n     result[result.length-1]  = -1\\n     for(let i = arr.length-2; i>= 0; i--){\\n         result[i] = Math.max(arr[i+1] , result[i+1])\\n     }\\n \\n    return result\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1264189,
                "title": "python-solution-using-list-slicing-and-max-function-takes-99-8-less-space",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        for i in range(len(arr) - 1):\\n            arr[i] = max(arr[i+1:])\\n        arr[-1] = -1\\n        return arr\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        for i in range(len(arr) - 1):\\n            arr[i] = max(arr[i+1:])\\n        arr[-1] = -1\\n        return arr\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263861,
                "title": "two-python-3-solutions",
                "content": "1. If you don\\'t have time, and you don\\'t care about runtime\\n```\\ndef replaceElements(self, nums: List[int]) -> List[int]:\\n\\tfor i in range(0, len(nums)-1):\\n\\t\\tnums[i] = max(nums[i+1:])\\n\\tnums[-1]=-1\\n\\treturn nums\\n```\\n\\n2. If you have time and you care about runtime\\n```\\ndef replaceElements(self, arr: List[int]) -> List[int]:\\n\\tl = len(arr)-1\\n\\tlargest = arr[l]\\n\\tarr[l] = -1\\n\\tl-=1\\n\\n\\twhile l>=0:\\n\\t\\tif arr[l]>largest:\\n\\t\\t\\tarr[l], largest = largest, arr[l]\\n\\t\\telse:\\n\\t\\t\\tarr[l] = largest\\n\\t\\tl-=1\\n\\treturn arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef replaceElements(self, nums: List[int]) -> List[int]:\\n\\tfor i in range(0, len(nums)-1):\\n\\t\\tnums[i] = max(nums[i+1:])\\n\\tnums[-1]=-1\\n\\treturn nums\\n```\n```\\ndef replaceElements(self, arr: List[int]) -> List[int]:\\n\\tl = len(arr)-1\\n\\tlargest = arr[l]\\n\\tarr[l] = -1\\n\\tl-=1\\n\\n\\twhile l>=0:\\n\\t\\tif arr[l]>largest:\\n\\t\\t\\tarr[l], largest = largest, arr[l]\\n\\t\\telse:\\n\\t\\t\\tarr[l] = largest\\n\\t\\tl-=1\\n\\treturn arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1222079,
                "title": "java-code-99-faster-runtime-1ms-o-1-space",
                "content": "# 1299. Replace Elements with Greatest Element on Right Side\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int n=arr.length;\\n        int max=arr[n-1];\\n        int temp=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            temp=max;\\n            if(arr[i]>max)\\n            {\\n                max=arr[i];\\n            }\\n            arr[i]=temp;\\n            \\n        }\\n        arr[n-1]=-1;\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int n=arr.length;\\n        int max=arr[n-1];\\n        int temp=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            temp=max;\\n            if(arr[i]>max)\\n            {\\n                max=arr[i];\\n            }\\n            arr[i]=temp;\\n            \\n        }\\n        arr[n-1]=-1;\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215058,
                "title": "simple-python-solution",
                "content": "```\\nif len(arr)==1:\\n        return [-1]\\n    max=arr[-1]\\n    for i in range(len(arr)-1,-1,-1):\\n        if arr[i]<max:\\n            arr[i]=max\\n        else:\\n            arr[i],max=max,arr[i]\\n    arr[-1]=-1\\n    return arr\\n```",
                "solutionTags": [],
                "code": "```\\nif len(arr)==1:\\n        return [-1]\\n    max=arr[-1]\\n    for i in range(len(arr)-1,-1,-1):\\n        if arr[i]<max:\\n            arr[i]=max\\n        else:\\n            arr[i],max=max,arr[i]\\n    arr[-1]=-1\\n    return arr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1203837,
                "title": "c-easiest-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n=arr.size(); int mx=-1;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int temp=arr[i];\\n            arr[i]=mx;\\n            mx=max(temp,mx);\\n        }\\n        return arr;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n=arr.size(); int mx=-1;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int temp=arr[i];\\n            arr[i]=mx;\\n            mx=max(temp,mx);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1164926,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int len = arr.length;\\n        int [] res = new int [len];\\n        res[len - 1] = -1;\\n        for(int i = len - 1; i > 0; i--){\\n            res[i - 1] = arr[i] > res[i]? arr[i] : res[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int len = arr.length;\\n        int [] res = new int [len];\\n        res[len - 1] = -1;\\n        for(int i = len - 1; i > 0; i--){\\n            res[i - 1] = arr[i] > res[i]? arr[i] : res[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137403,
                "title": "simple-java-solution-beats-99-9",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int maxv = arr[arr.length-1];\\n        arr[arr.length-1] = -1;\\n        for (int i=arr.length-2; i>=0; --i) {\\n            int temp = Math.max(maxv, arr[i]);\\n            arr[i] = maxv;\\n            maxv = temp;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int maxv = arr[arr.length-1];\\n        arr[arr.length-1] = -1;\\n        for (int i=arr.length-2; i>=0; --i) {\\n            int temp = Math.max(maxv, arr[i]);\\n            arr[i] = maxv;\\n            maxv = temp;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107483,
                "title": "easy-java-solution-two-different-ways",
                "content": "# **1 : **\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if(arr.length==1) \\n        {\\n            arr[0]=-1;\\n            return arr;\\n        }\\n\\t\\t int max=-1;\\n        for(int i=arr.length-1 ; i>=0 ; i--)\\n        {\\n            int a = arr[i];\\n            arr[i]=max;\\n            max=Math.max(max,a);\\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n\\n\\n```\\n# **2 : **\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if(arr.length==1) \\n        {\\n            arr[0]=-1;\\n            return arr;\\n        }\\n        int max=0;\\n        for(int i=0 ; i<arr.length ;i++)\\n        {\\n            if(i==arr.length-1)\\n            {\\n                arr[i]=-1;\\n                break;\\n            }\\n            \\n            for(int j=i+1 ; j<arr.length ; j++)\\n            {\\n            if(arr[j]>max)\\n                max=arr[j];\\n            }\\n            arr[i]=max;\\n            max=0;\\n        }\\n        return arr;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if(arr.length==1) \\n        {\\n            arr[0]=-1;\\n            return arr;\\n        }\\n\\t\\t int max=-1;\\n        for(int i=arr.length-1 ; i>=0 ; i--)\\n        {\\n            int a = arr[i];\\n            arr[i]=max;\\n            max=Math.max(max,a);\\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n\\n\\n```\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if(arr.length==1) \\n        {\\n            arr[0]=-1;\\n            return arr;\\n        }\\n        int max=0;\\n        for(int i=0 ; i<arr.length ;i++)\\n        {\\n            if(i==arr.length-1)\\n            {\\n                arr[i]=-1;\\n                break;\\n            }\\n            \\n            for(int j=i+1 ; j<arr.length ; j++)\\n            {\\n            if(arr[j]>max)\\n                max=arr[j];\\n            }\\n            arr[i]=max;\\n            max=0;\\n        }\\n        return arr;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099167,
                "title": "java-right-to-left-1ms-beats-99-89-t-c-o-n-s-c-o-1",
                "content": "\\n    // O(n) O(1)\\n    public int[] replaceElements(int[] arr) {\\n        int len = arr.length, msf = arr[len - 1];\\n\\t\\tint[] ans = new int[len];\\n\\t\\tans[len - 1] = -1;\\n\\t\\tfor (int i = len - 2; i >= 0; i--) {\\n\\t\\t\\tans[i] = msf;\\n\\t\\t\\tif (arr[i] > msf)\\n\\t\\t\\t\\tmsf = arr[i];\\n\\t\\t}\\n\\t\\treturn ans; \\n    }",
                "solutionTags": [],
                "code": "\\n    // O(n) O(1)\\n    public int[] replaceElements(int[] arr) {\\n        int len = arr.length, msf = arr[len - 1];\\n\\t\\tint[] ans = new int[len];\\n\\t\\tans[len - 1] = -1;\\n\\t\\tfor (int i = len - 2; i >= 0; i--) {\\n\\t\\t\\tans[i] = msf;\\n\\t\\t\\tif (arr[i] > msf)\\n\\t\\t\\t\\tmsf = arr[i];\\n\\t\\t}\\n\\t\\treturn ans; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 959751,
                "title": "js-javascript-1-liner",
                "content": "Not very efficient but just for fun:\\n```\\nvar replaceElements = function (arr) {\\n\\treturn arr.reverse().reduce((a, b, i) => a.concat([Math.max(a[i], b)]), [-1]).reverse().slice(1);\\n}\\n```\\nor use the lesser-known `reduceRight` to avoid `reverse`, as well as remove the `slice` to improve speed:\\n```\\nvar replaceElements = function(arr) {\\n    return arr.reduceRight((a, b, i) => i > 0 ? [Math.max(a[0], b)].concat(a) : a, [-1]);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar replaceElements = function (arr) {\\n\\treturn arr.reverse().reduce((a, b, i) => a.concat([Math.max(a[i], b)]), [-1]).reverse().slice(1);\\n}\\n```\n```\\nvar replaceElements = function(arr) {\\n    return arr.reduceRight((a, b, i) => i > 0 ? [Math.max(a[0], b)].concat(a) : a, [-1]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 869683,
                "title": "c-providing-3-soultions-brute-force-one-pass-with-a-vector-one-pass-replace",
                "content": "If you have any question about my code,or thought about the code,please comment below , i will try my best to answer it :)\\n# **O(n^2) brute force**\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int N = arr.size();\\n        vector<int>ans;\\n        for(int i = 0;i<N;i++){\\n            int element = -1;\\n            for(int j = i+1;j<N;j++){\\n                element = max(arr[j],element);\\n            }\\n            ans.push_back(element);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n# **O(n) : One-pass & With a Vector**\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int N = arr.size();\\n        int element = -1;\\n        vector<int>ans(N,-1);\\n        for(int i = N-2;i>=0;i--){\\n            element = max(element,arr[i+1]);\\n            ans[i] = element;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n# **O(n) : One-pass & replace**\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int N = arr.size();\\n        int element = -1;\\n        int temp = 0;\\n        for(int i = N-1;i>=0;i--){\\n            temp = arr[i];\\n            arr[i] = element;\\n            element = max(element,temp);\\n        }\\n        return arr;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int N = arr.size();\\n        vector<int>ans;\\n        for(int i = 0;i<N;i++){\\n            int element = -1;\\n            for(int j = i+1;j<N;j++){\\n                element = max(arr[j],element);\\n            }\\n            ans.push_back(element);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int N = arr.size();\\n        int element = -1;\\n        vector<int>ans(N,-1);\\n        for(int i = N-2;i>=0;i--){\\n            element = max(element,arr[i+1]);\\n            ans[i] = element;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int N = arr.size();\\n        int element = -1;\\n        int temp = 0;\\n        for(int i = N-1;i>=0;i--){\\n            temp = arr[i];\\n            arr[i] = element;\\n            element = max(element,temp);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819806,
                "title": "java-easy-solution",
                "content": "```\\nint rightMax = -1, newMax = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\tnewMax = Math.max(arr[i], rightMax);\\n\\t\\t\\tarr[i] = rightMax;\\n\\t\\t\\trightMax = newMax;\\n\\n\\t\\t}\\n\\t\\treturn arr\\n```",
                "solutionTags": [],
                "code": "```\\nint rightMax = -1, newMax = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\tnewMax = Math.max(arr[i], rightMax);\\n\\t\\t\\tarr[i] = rightMax;\\n\\t\\t\\trightMax = newMax;\\n\\n\\t\\t}\\n\\t\\treturn arr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 819804,
                "title": "java-easy-solution",
                "content": "```\\nint rightMax = -1, newMax = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\tnewMax = Math.max(arr[i], rightMax);\\n\\t\\t\\tarr[i] = rightMax;\\n\\t\\t\\trightMax = newMax;\\n\\n\\t\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nint rightMax = -1, newMax = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\tnewMax = Math.max(arr[i], rightMax);\\n\\t\\t\\tarr[i] = rightMax;\\n\\t\\t\\trightMax = newMax;\\n\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817555,
                "title": "inplace-algorithm-c-easy-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int lastindex = arr.size() - 1;\\n        // get the max number to be the last element a/c to the problem statement\\n        int maxelement = arr[lastindex];\\n        // replace last element with -1 a/c problem statement\\n        arr[lastindex] = -1;\\n        while(lastindex--){\\n            // if the current element is greater than the max element then swap tha values\\n            if(maxelement <= arr[lastindex])\\n                swap(maxelement, arr[lastindex]);\\n            // else use the current value\\n            else\\n                arr[lastindex] = maxelement;\\n            \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int lastindex = arr.size() - 1;\\n        // get the max number to be the last element a/c to the problem statement\\n        int maxelement = arr[lastindex];\\n        // replace last element with -1 a/c problem statement\\n        arr[lastindex] = -1;\\n        while(lastindex--){\\n            // if the current element is greater than the max element then swap tha values\\n            if(maxelement <= arr[lastindex])\\n                swap(maxelement, arr[lastindex]);\\n            // else use the current value\\n            else\\n                arr[lastindex] = maxelement;\\n            \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753425,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    // O(n) time | O(1) space\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        \\n        for (int i = arr.length-1;i>=0;i--) {  \\n            if (i==arr.length-1) {\\n                max = arr[i];\\n                arr[i] = -1;\\n                continue;\\n            } \\n            \\n            int temp = arr[i];\\n            arr[i]   = max;\\n            \\n            if (temp > max) {\\n                max = temp;\\n            }\\n        }\\n        \\n        return arr;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // O(n) time | O(1) space\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        \\n        for (int i = arr.length-1;i>=0;i--) {  \\n            if (i==arr.length-1) {\\n                max = arr[i];\\n                arr[i] = -1;\\n                continue;\\n            } \\n            \\n            int temp = arr[i];\\n            arr[i]   = max;\\n            \\n            if (temp > max) {\\n                max = temp;\\n            }\\n        }\\n        \\n        return arr;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741727,
                "title": "simple-clean-solution",
                "content": "\\'\\'\\'class Solution {\\n    public int[] replaceElements(int[] arr) \\n    {\\n        int top = arr[ arr.length -1 ] ;\\n        arr[ arr.length-1] = -1 ; \\n        \\n        for( int i = arr.length - 2 ; i >= 0 ; i-- )\\n        {\\n        \\t\\tint temp = arr[i] ;\\n        \\t\\tarr[i]   = top ;\\n        \\t\\tif( top < temp )\\n        \\t\\t\\t\\ttop = temp ;\\t\\n        }\\n\\n      return arr ;\\n    }\\n}\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] replaceElements(int[] arr) \\n    {\\n        int top = arr[ arr.length -1 ] ;\\n        arr[ arr.length-1] = -1 ; \\n        \\n        for( int i = arr.length - 2 ; i >= 0 ; i-- )\\n        {\\n        \\t\\tint temp = arr[i] ;\\n        \\t\\tarr[i]   = top ;\\n        \\t\\tif( top < temp )\\n        \\t\\t\\t\\ttop = temp ;\\t\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 715806,
                "title": "python3-faster-than-96-no-need-to-use-max",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        arr = arr[::-1] #reverse the list to make the logic easier\\n        prev = -1 # prev saves the largest value among the previous number. Since the original last number should be replace by -1, we intialize prev as -1.\\n        for i in range(len(arr)):\\n            cur = arr[i] #cur saves the value of the current number\\n            arr[i] = prev # replace the current number with the previous largest number\\n            if cur > prev:\\n                prev = cur #only update the previous largest number if the current number is larger than prev. This is for the next loop\\n            else:\\n                pass\\n        return arr[::-1] # return the list in the original order\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        arr = arr[::-1] #reverse the list to make the logic easier\\n        prev = -1 # prev saves the largest value among the previous number. Since the original last number should be replace by -1, we intialize prev as -1.\\n        for i in range(len(arr)):\\n            cur = arr[i] #cur saves the value of the current number\\n            arr[i] = prev # replace the current number with the previous largest number\\n            if cur > prev:\\n                prev = cur #only update the previous largest number if the current number is larger than prev. This is for the next loop\\n            else:\\n                pass\\n        return arr[::-1] # return the list in the original order\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 708954,
                "title": "swift",
                "content": "```\\n    func replaceElements(_ arr: [Int]) -> [Int] {\\n        var result = [-1]\\n        for i in (1..<arr.count).reversed() {\\n            result.insert(max(result[0], arr[i]), at: 0)\\n        }\\n        return result\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func replaceElements(_ arr: [Int]) -> [Int] {\\n        var result = [-1]\\n        for i in (1..<arr.count).reversed() {\\n            result.insert(max(result[0], arr[i]), at: 0)\\n        }\\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702247,
                "title": "c-python-solutions",
                "content": "C++ solution,\\n```\\nclass Solution {\\npublic:\\n\\tvector<int> replaceElements(vector<int>& arr) {\\n\\t\\tint maxValue = -1;\\n\\n\\t\\tfor (int i = arr.size()-1; i > -1; --i) {\\n\\t\\t\\tint temp = arr[i];\\n\\t\\t\\tarr[i] = maxValue;\\n\\t\\t\\tmaxValue = max(maxValue,temp);\\n\\t\\t}\\n\\n\\t\\treturn arr;\\n\\t}\\n};\\n```\\n\\nPython solution,\\n```\\nclass Solution:\\n\\tdef replaceElements(self, arr):\\n\\t\\tmaxValue = -1\\n\\n\\t\\tfor i in range(len(arr)-1,-1,-1):\\n\\t\\t\\ttemp = arr[i]\\n\\t\\t\\tarr[i] = maxValue\\n\\t\\t\\tmaxValue = max(maxValue,temp)\\n\\n\\t\\treturn arr\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> replaceElements(vector<int>& arr) {\\n\\t\\tint maxValue = -1;\\n\\n\\t\\tfor (int i = arr.size()-1; i > -1; --i) {\\n\\t\\t\\tint temp = arr[i];\\n\\t\\t\\tarr[i] = maxValue;\\n\\t\\t\\tmaxValue = max(maxValue,temp);\\n\\t\\t}\\n\\n\\t\\treturn arr;\\n\\t}\\n};\\n```\n```\\nclass Solution:\\n\\tdef replaceElements(self, arr):\\n\\t\\tmaxValue = -1\\n\\n\\t\\tfor i in range(len(arr)-1,-1,-1):\\n\\t\\t\\ttemp = arr[i]\\n\\t\\t\\tarr[i] = maxValue\\n\\t\\t\\tmaxValue = max(maxValue,temp)\\n\\n\\t\\treturn arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686210,
                "title": "c-80-time-and-space-varies-wildly-with-random-inputs-o-n-time-o-i-space",
                "content": "Starting from the right, nothing much to be said - first value goes stored (into `v`), set the rightmost to `-1`, then you keep storing the maximum value seen so far and replacing:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int lastPos = arr.size() - 1, v = arr[lastPos];\\n        arr[lastPos] = -1;\\n        while (lastPos--) {\\n            if (arr[lastPos] > v) swap(arr[lastPos], v);\\n            else arr[lastPos] = v;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int lastPos = arr.size() - 1, v = arr[lastPos];\\n        arr[lastPos] = -1;\\n        while (lastPos--) {\\n            if (arr[lastPos] > v) swap(arr[lastPos], v);\\n            else arr[lastPos] = v;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592124,
                "title": "python3-faster-than-96-less-than-100",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        for i in range(len(arr))[::-1]:\\n            arr[i], m = m, max(m, arr[i])\\n        return arr",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        for i in range(len(arr))[::-1]:\\n            arr[i], m = m, max(m, arr[i])\\n        return arr",
                "codeTag": "Java"
            },
            {
                "id": 568634,
                "title": "java-100-both-space-and-time",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n     int n = arr.length;\\n     int max = -1;   \\n     for(int i=n-1;i>=0;i--){\\n        int temp = arr[i];\\n        arr[i] = max;\\n        max = Integer.max(max,temp);\\n     }\\n    \\n     return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n     int n = arr.length;\\n     int max = -1;   \\n     for(int i=n-1;i>=0;i--){\\n        int temp = arr[i];\\n        arr[i] = max;\\n        max = Integer.max(max,temp);\\n     }\\n    \\n     return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563665,
                "title": "js-91-o-n-o-1-memory-in-place-easy-clean-with-comments",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar replaceElements = function(arr) {\\n    var len = arr.length;\\n    // Pick the last element as the max element to start.\\n    var maxTillNow = arr[len - 1];\\n    \\n    // Assign the last index\\'s value to be -1.\\n    arr[len - 1] = -1;\\n    \\n    // Go from the last, assign the previous max to the current index value.\\n    for (var i = len - 2; i >= 0; -- i) {\\n        var temp = maxTillNow;\\n        maxTillNow = maxTillNow < arr[i] ? arr[i] : maxTillNow;\\n        arr[i] = temp;\\n    }\\n    \\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar replaceElements = function(arr) {\\n    var len = arr.length;\\n    // Pick the last element as the max element to start.\\n    var maxTillNow = arr[len - 1];\\n    \\n    // Assign the last index\\'s value to be -1.\\n    arr[len - 1] = -1;\\n    \\n    // Go from the last, assign the previous max to the current index value.\\n    for (var i = len - 2; i >= 0; -- i) {\\n        var temp = maxTillNow;\\n        maxTillNow = maxTillNow < arr[i] ? arr[i] : maxTillNow;\\n        arr[i] = temp;\\n    }\\n    \\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559227,
                "title": "easy-java-1-ms-40-9-mb-o-n",
                "content": "Traverse backwards and keep updating the max element\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = arr[arr.length - 1];\\n        arr[arr.length-1] = -1;\\n        int temp;\\n        \\n        for(int i=arr.length-2; i>=0; i--){\\n            if(max < arr[i]){\\n                temp = arr[i];\\n                arr[i] = max;\\n                max = temp;\\n            } else\\n                arr[i] = max;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = arr[arr.length - 1];\\n        arr[arr.length-1] = -1;\\n        int temp;\\n        \\n        for(int i=arr.length-2; i>=0; i--){\\n            if(max < arr[i]){\\n                temp = arr[i];\\n                arr[i] = max;\\n                max = temp;\\n            } else\\n                arr[i] = max;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569721,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1828573,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1834605,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1695789,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1857701,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1691967,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2052243,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2037026,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1894831,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1801920,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1569721,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1828573,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1834605,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1695789,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1857701,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1691967,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2052243,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2037026,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1894831,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1801920,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1994088,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1978817,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1976453,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1966942,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1961999,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1939821,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1898670,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1889892,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1830202,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1822408,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Where Will the Ball Fall",
        "question_content": "<p>You have a 2-D <code>grid</code> of size <code>m x n</code> representing a box, and you have <code>n</code> balls. The box is open on the top and bottom sides.</p>\n\n<p>Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.</p>\n\n<ul>\n\t<li>A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as <code>1</code>.</li>\n\t<li>A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as <code>-1</code>.</li>\n</ul>\n\n<p>We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a &quot;V&quot; shaped pattern between two boards or if a board redirects the ball into either wall of the box.</p>\n\n<p>Return <em>an array </em><code>answer</code><em> of size </em><code>n</code><em> where </em><code>answer[i]</code><em> is the column that the ball falls out of at the bottom after dropping the ball from the </em><code>i<sup>th</sup></code><em> column at the top, or <code>-1</code><em> if the ball gets stuck in the box</em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/26/ball.jpg\" style=\"width: 500px; height: 385px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\n<strong>Output:</strong> [1,-1,-1,-1,-1]\n<strong>Explanation:</strong> This example is shown in the photo.\nBall b0 is dropped at column 0 and falls out of the box at column 1.\nBall b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\nBall b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\nBall b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\nBall b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[-1]]\n<strong>Output:</strong> [-1]\n<strong>Explanation:</strong> The ball gets stuck against the left wall.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\n<strong>Output:</strong> [0,1,2,3,4,-1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> is <code>1</code> or <code>-1</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 988576,
                "title": "java-c-python-solution-with-explanation",
                "content": "# **Explanation**\\nWe drop the ball at `grid[0][i]`\\nand track ball position `i1`, which initlized as `i`.\\n\\nAn observation is that,\\nif the ball wants to move from `i1` to `i2`,\\nwe must have the board direction `grid[j][i1] == grid[j][i2]`\\n<br>\\n\\n# **Complexity**\\nTime `O(mn)`\\nSpace `O(n)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int[] findBall(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            int i1 = i, i2;\\n            for (int j = 0; j < m; ++j) {\\n                i2 = i1 + grid[j][i1];\\n                if (i2 < 0 || i2 >= n || grid[j][i2] != grid[j][i1]) {\\n                    i1 = -1;\\n                    break;\\n                }\\n                i1 = i2;\\n            }\\n            res[i] = i1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> res;\\n        for (int i = 0; i < n; ++i) {\\n            int i1 = i, i2;\\n            for (int j = 0; j < m; ++j) {\\n                i2 = i1 + grid[j][i1];\\n                if (i2 < 0 || i2 >= n || grid[j][i2] != grid[j][i1]) {\\n                    i1 = -1;\\n                    break;\\n                }\\n                i1 = i2;\\n            }\\n            res.push_back(i1);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def findBall(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        def test(i):\\n            for j in xrange(m):\\n                i2 = i + grid[j][i]\\n                if i2 < 0 or i2 >= n or grid[j][i2] != grid[j][i]:\\n                    return -1\\n                i = i2\\n            return i\\n        return map(test, range(n))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int[] findBall(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            int i1 = i, i2;\\n            for (int j = 0; j < m; ++j) {\\n                i2 = i1 + grid[j][i1];\\n                if (i2 < 0 || i2 >= n || grid[j][i2] != grid[j][i1]) {\\n                    i1 = -1;\\n                    break;\\n                }\\n                i1 = i2;\\n            }\\n            res[i] = i1;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> res;\\n        for (int i = 0; i < n; ++i) {\\n            int i1 = i, i2;\\n            for (int j = 0; j < m; ++j) {\\n                i2 = i1 + grid[j][i1];\\n                if (i2 < 0 || i2 >= n || grid[j][i2] != grid[j][i1]) {\\n                    i1 = -1;\\n                    break;\\n                }\\n                i1 = i2;\\n            }\\n            res.push_back(i1);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def findBall(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        def test(i):\\n            for j in xrange(m):\\n                i2 = i + grid[j][i]\\n                if i2 < 0 or i2 >= n or grid[j][i2] != grid[j][i]:\\n                    return -1\\n                i = i2\\n            return i\\n        return map(test, range(n))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 988244,
                "title": "c-easy-solution-dfs",
                "content": "**Idea :**\\nIf current grid p**grid[r][c]** is a **\\\\\\\\** then check it\\'s right column **-> grid[r][c+1]** is same or not  and Go to it\\'s digonal place **-> grid[r+1][c+1]** else return -1 from there\\nand if it is **/** then check it\\'s left column **grid[r][c-1]** is same or not if it same then go **-> grid[r+1][c-1]** else  return -1 from there\\n If You reach last Row return Column Number **<<<------- Do this task for each column** \\n\\n```\\nclass Solution {\\npublic:\\n    bool valid(int rsize,int csize,int r,int c){\\n        if(rsize<=r||csize<=c||c<0||r<0)return false;\\n        return true;\\n    }\\n    int DFS(vector<vector<int>>& grid,int r,int c){\\n        if(r==grid.size())return c;\\n        if(valid(grid.size(),grid[0].size(),r,c)){\\n            if(grid[r][c]==1){\\n                if(valid(grid.size(),grid[0].size(),r,c+1)&&grid[r][c+1]==1){\\n                    return DFS(grid,r+1,c+1);\\n                }\\n            }else{\\n                if(valid(grid.size(),grid[0].size(),r,c-1)&&grid[r][c-1]==-1){\\n                    return DFS(grid,r+1,c-1);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid){\\n        int row = grid.size(),col = grid[0].size();\\n        vector<int>ans(col,0);\\n        for(int c = 0;c<col;c++){\\n            ans[c] = DFS(grid,0,c);\\n        }\\n    return ans;\\n    }\\n};\\n```\\n\\n**Thank You**\\n**Any doubt ask there**\\n**please UpVote**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int rsize,int csize,int r,int c){\\n        if(rsize<=r||csize<=c||c<0||r<0)return false;\\n        return true;\\n    }\\n    int DFS(vector<vector<int>>& grid,int r,int c){\\n        if(r==grid.size())return c;\\n        if(valid(grid.size(),grid[0].size(),r,c)){\\n            if(grid[r][c]==1){\\n                if(valid(grid.size(),grid[0].size(),r,c+1)&&grid[r][c+1]==1){\\n                    return DFS(grid,r+1,c+1);\\n                }\\n            }else{\\n                if(valid(grid.size(),grid[0].size(),r,c-1)&&grid[r][c-1]==-1){\\n                    return DFS(grid,r+1,c-1);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid){\\n        int row = grid.size(),col = grid[0].size();\\n        vector<int>ans(col,0);\\n        for(int c = 0;c<col;c++){\\n            ans[c] = DFS(grid,0,c);\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765290,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/VTvGctn2/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Python",
                    "C",
                    "Go"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/VTvGctn2/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 995242,
                "title": "java-simple-dfs-solution-100-runtime",
                "content": "Logic: \\nIf the current value(i,j) is 1 then the next value in the column(i,j+1) should also be 1. \\nThen, check for next row next col (i+1,j+1)\\n\\nIf the current value(i,j) is -1 then the prev value of the column(i,j-1) should also be -1. \\nThen, check for next row prev col(i+1,j-1)\\n\\nIf any of the condition fail or goes out of bounds that ball won\\'t reach the end.\\n\\n```\\nclass Solution {\\n    public int dfs(int[][] grid, int i, int j){\\n        if(i==grid.length)\\n            return j;\\n        \\n        if(j<0 || j>=grid[0].length)\\n            return -1;\\n        \\n        if(grid[i][j]==1 && j+1<grid[0].length && grid[i][j+1]==1)\\n            return dfs(grid,i+1,j+1);\\n        \\n        else if(grid[i][j]==-1 && j-1>=0 && grid[i][j-1]==-1)\\n            return dfs(grid,i+1,j-1);\\n         \\n        return -1;\\n    }\\n    public int[] findBall(int[][] grid) {\\n        int m = grid[0].length;\\n        int[] ar = new int[m];\\n        \\n        for(int j=0;j<m;j++)\\n            ar[j]=dfs(grid,0,j);\\n        \\n        return ar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int dfs(int[][] grid, int i, int j){\\n        if(i==grid.length)\\n            return j;\\n        \\n        if(j<0 || j>=grid[0].length)\\n            return -1;\\n        \\n        if(grid[i][j]==1 && j+1<grid[0].length && grid[i][j+1]==1)\\n            return dfs(grid,i+1,j+1);\\n        \\n        else if(grid[i][j]==-1 && j-1>=0 && grid[i][j-1]==-1)\\n            return dfs(grid,i+1,j-1);\\n         \\n        return -1;\\n    }\\n    public int[] findBall(int[][] grid) {\\n        int m = grid[0].length;\\n        int[] ar = new int[m];\\n        \\n        for(int j=0;j<m;j++)\\n            ar[j]=dfs(grid,0,j);\\n        \\n        return ar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988210,
                "title": "easy-to-understand-11-line-python3-solution",
                "content": "```\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        nrows = len(grid)\\n        ncols = len(grid[0])\\n        def candrop(i,j):\\n            if i == nrows: return j\\n            if j == ncols-1 and grid[i][j] == 1: return -1\\n            if j == 0 and grid[i][j] == -1: return -1\\n            if grid[i][j] == 1 and grid[i][j+1] == -1: return -1\\n            if grid[i][j] == -1 and grid[i][j-1] == 1: return -1\\n            return candrop(i+1,j+grid[i][j])\\n        \\n        return [candrop(0,j) for j in range(ncols)]\\n```",
                "solutionTags": [],
                "code": "```\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        nrows = len(grid)\\n        ncols = len(grid[0])\\n        def candrop(i,j):\\n            if i == nrows: return j\\n            if j == ncols-1 and grid[i][j] == 1: return -1\\n            if j == 0 and grid[i][j] == -1: return -1\\n            if grid[i][j] == 1 and grid[i][j+1] == -1: return -1\\n            if grid[i][j] == -1 and grid[i][j-1] == 1: return -1\\n            return candrop(i+1,j+grid[i][j])\\n        \\n        return [candrop(0,j) for j in range(ncols)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2764965,
                "title": "c-explained-the-intuition-easy-to-understand",
                "content": "Just think in a recursive way\\n\\n#Forget about the final target\\n#Make smaller targets for each cell\\n#If ball is in any cell in the grid then we only have to solve a **SUBPROBLEM**\\n\\n**SUBPROBLEM**=>\\n**==========**\\n#Smaller target for ball is **to reach the next row**\\n#We just want to somehow figure out solution to reach the next row for any current cell\\n#For any cell we have two scenarios\\n\\t\\t\\t1. If board in currCell [grid[i][j]] is \"RIGHT\" :\\n\\t\\t\\t       =>We can move to next row if board in the rightCell of currCell [grid[i][j + 1]] is also \"RIGHT\" \\n           2.If board in currCell [grid[i][j]] is \"LEFT\" :\\n\\t\\t\\t    =>We can move to next row if board in the leftCell of currCell [grid[i][j - 1]] is also \"LEFT\"\\n\\t  \\n#If we **cannot reach the next row** after evaluating the above conditions\\n    =>ANSWER TO SUBPROBLEM ==> -1 :(\\n\\t\\n#If ball is **able to get into the next row**\\n    =>Now we are closer to out goal to reach bottom row\\n    =>We are in some cell of nextRow depending on above scenarios\\n    =>Now it\\'s again a same \"SUBPROBLEM\" [RECURSION AT IT\\'S BEST :)] but with reduced size\\n    =>ANSWER TO CURRENT SUBPROBLEM => Answer of next subproblem (for a grid cell of next row) \\n#Answer to any subproblem will be the column by which it get\\'s into the next row\\n\\n\\n\\n**#If you can\\'t find a solution to the bigger problem \\n#Just figure out what all you can do at current steps\\n#The next step will be ultimately solved using \"RECURSION\" :) [LIFE PHILOSOPHY]**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>>dp(m + 1, vector<int>(n, -1));\\n        for (int j = 0; j < n; j++) dp[m][j] = j; //Initializing the answer to the bottom case subproblem\\n        //===================================================\\n        for (int i = m - 1; i >= 0; i--) //Move from bottom to top,                        \\n        {                               //as subproblems of next row should be solved before current row\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1) //if board is right\\n                {\\n                    bool isRightCellRight = (j + 1 == n)? false : (grid[i][j + 1] == 1);\\n                    if (isRightCellRight) dp[i][j] = dp[i + 1][j + 1]; \\n                    //if we can reach next row, take the answer from the next row subproblem\\n                }\\n                else if (grid[i][j] == -1) //if board is left\\n                {\\n                    bool isLeftCellLeft = (j - 1 < 0)? false : (grid[i][j - 1] == -1);\\n                    if (isLeftCellLeft) dp[i][j] = dp[i + 1][j - 1];\\n                }\\n            }\\n        }\\n        //=============================================================\\n        return dp[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>>dp(m + 1, vector<int>(n, -1));\\n        for (int j = 0; j < n; j++) dp[m][j] = j; //Initializing the answer to the bottom case subproblem\\n        //===================================================\\n        for (int i = m - 1; i >= 0; i--) //Move from bottom to top,                        \\n        {                               //as subproblems of next row should be solved before current row\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1) //if board is right\\n                {\\n                    bool isRightCellRight = (j + 1 == n)? false : (grid[i][j + 1] == 1);\\n                    if (isRightCellRight) dp[i][j] = dp[i + 1][j + 1]; \\n                    //if we can reach next row, take the answer from the next row subproblem\\n                }\\n                else if (grid[i][j] == -1) //if board is left\\n                {\\n                    bool isLeftCellLeft = (j - 1 < 0)? false : (grid[i][j - 1] == -1);\\n                    if (isLeftCellLeft) dp[i][j] = dp[i + 1][j - 1];\\n                }\\n            }\\n        }\\n        //=============================================================\\n        return dp[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988195,
                "title": "java-python-3-check-the-corresponding-slope-of-its-neighbor-w-brief-explanation-and-analysis",
                "content": "**Q & A**\\nQ1: Can you pls explain how you are finding the next cell. \\nA1: I believe the problem description intentionally gives the hint: slopes of `1` and `-1` for sliding to right and left. Therefore, adding the corresponding displacement, `slope * 1`, to current `column` will get the correct `column` of the next row; Also, the same slope of its neighbor is needed in order to avoid being stuck.\\n\\nQ2: Could you please explain more on the\\n```\\ngrid[r][x] != slope) { // Stuck on the the neighbor?\\n```\\npart?\\nA2:  Ball will tend to fall right (slope = grid[r][x] = 1) or left (slope = grid[r][x] = -1), it need the corresponding neighbor\\'s same tendency (or slope) to fall through, otherwise get stuck. \\ne.g.,\\ngrid[r][x] = 1, ball will tend to fall right and we need to check right neighbor\\'s slope grid[r][x + 1]; If grid[r][x + 1] = 1, then the ball will fall right to the next row at (r + 1, x + 1), otherwise get stuck at (r, x).\\n\\nRewrite the code as following might be helpful to understand:\\n```\\n    public int[] findBall(int[][] grid) {\\n        int n = grid[0].length;\\n        int[] ans = new int[n];\\n        outer:\\n        for (int c = 0, m = grid.length; c < n; ++c) {\\n            int x = c;\\n            for (int r = 0; r < m; ++r) {\\n                int xNeighbor = x + grid[r][x];\\n                // Stuck on the left, right boundaries or on the neighbor? \\n                if (xNeighbor < 0 || xNeighbor >= n || grid[r][x] != grid[r][xNeighbor]) {\\n                    ans[c] = -1;\\n                    continue outer;\\n                }\\n                x = xNeighbor;\\n            }\\n            ans[c] = x; \\n        }\\n        return ans;        \\n    }\\n```\\n**End of Q & A**\\n\\nCheck if the corresponding slope of its neighbor is same: if yes, go to next row, otherwise stuck.\\n```java\\n    public int[] findBall(int[][] grid) {\\n        int n = grid[0].length;\\n        int[] ans = new int[n];\\n        outer:\\n        for (int c = 0, m = grid.length; c < n; ++c) {\\n            int x = c;\\n            for (int r = 0; r < m; ++r) {\\n                int slope = grid[r][x];\\n                x += slope;\\n                if (x < 0 || x >= n || grid[r][x] != slope) { // Stuck on the left, right boundaries or on the neighbor?\\n                    ans[c] = -1;\\n                    continue outer;\\n                }\\n            }\\n            ans[c] = x; \\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = map(len, (grid, grid[0]))\\n        ans = []\\n        for c in range(n):\\n            x = c\\n            for r in range(m):\\n                slope = grid[r][x]\\n                x += grid[r][x]\\n                if x < 0 or x >= n or grid[r][x] != slope:\\n                    ans.append(-1)\\n                    break    \\n            else:        \\n                ans.append(x)\\n        return ans\\n```\\n\\n**Analysis:**\\n\\nTime: O(m * n), space: O(n).",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\ngrid[r][x] != slope) { // Stuck on the the neighbor?\\n```\n```\\n    public int[] findBall(int[][] grid) {\\n        int n = grid[0].length;\\n        int[] ans = new int[n];\\n        outer:\\n        for (int c = 0, m = grid.length; c < n; ++c) {\\n            int x = c;\\n            for (int r = 0; r < m; ++r) {\\n                int xNeighbor = x + grid[r][x];\\n                // Stuck on the left, right boundaries or on the neighbor? \\n                if (xNeighbor < 0 || xNeighbor >= n || grid[r][x] != grid[r][xNeighbor]) {\\n                    ans[c] = -1;\\n                    continue outer;\\n                }\\n                x = xNeighbor;\\n            }\\n            ans[c] = x; \\n        }\\n        return ans;        \\n    }\\n```\n```java\\n    public int[] findBall(int[][] grid) {\\n        int n = grid[0].length;\\n        int[] ans = new int[n];\\n        outer:\\n        for (int c = 0, m = grid.length; c < n; ++c) {\\n            int x = c;\\n            for (int r = 0; r < m; ++r) {\\n                int slope = grid[r][x];\\n                x += slope;\\n                if (x < 0 || x >= n || grid[r][x] != slope) { // Stuck on the left, right boundaries or on the neighbor?\\n                    ans[c] = -1;\\n                    continue outer;\\n                }\\n            }\\n            ans[c] = x; \\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = map(len, (grid, grid[0]))\\n        ans = []\\n        for c in range(n):\\n            x = c\\n            for r in range(m):\\n                slope = grid[r][x]\\n                x += grid[r][x]\\n                if x < 0 or x >= n or grid[r][x] != slope:\\n                    ans.append(-1)\\n                    break    \\n            else:        \\n                ans.append(x)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2765063,
                "title": "python3-o-m-n-simulation-approach",
                "content": "The idea is to simulate what\\'s happening for each ball when dropped at different (0,col). If a ball get out of the box i.e., row==len(grid), we just return the column. if the new column is already out of the box or the next cell doesn\\'t equal to grid[row][col] the ball will get stuck and we just return -1.\\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m,n = len(grid),len(grid[0])\\n        def check(row,col):\\n            ### If a ball get out of the box, return col\\n            if row==m:\\n                return col\\n                \\n            ### note that since grid contains 1 and -1 representing to right and to left, \\n            ### we can just add the grid[row][col] to current collumn to get the new column\\n            new_col = col+grid[row][col]\\n            \\n            ### if the new column is already out of the box \\n            ### or the neighbor cell doesn\\'t equal to grid[row][col] \\n            ### the ball will get stuck and we just return -1\\n            if new_col==n or new_col==-1 or grid[row][new_col]!=grid[row][col]:\\n                return -1\\n            else:\\n                return check(row+1,new_col)\\n        res = []\\n        for i in range(n):\\n            res.append(check(0,i))\\n        return res\\n```\\n\\n**Iterative instead of recursion**\\n```python\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m,n = len(grid),len(grid[0])\\n        res = [-1 for i in range(n)]\\n        \\n        for col in range(n):\\n            curCol = col\\n            for row in range(m):\\n                newCol = curCol + grid[row][curCol]\\n                if newCol==-1 or newCol==n or grid[row][newCol]!=grid[row][curCol]:\\n                    break\\n                curCol = newCol\\n            else:\\n                res[col] = curCol\\n        \\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m,n = len(grid),len(grid[0])\\n        def check(row,col):\\n            ### If a ball get out of the box, return col\\n            if row==m:\\n                return col\\n                \\n            ### note that since grid contains 1 and -1 representing to right and to left, \\n            ### we can just add the grid[row][col] to current collumn to get the new column\\n            new_col = col+grid[row][col]\\n            \\n            ### if the new column is already out of the box \\n            ### or the neighbor cell doesn\\'t equal to grid[row][col] \\n            ### the ball will get stuck and we just return -1\\n            if new_col==n or new_col==-1 or grid[row][new_col]!=grid[row][col]:\\n                return -1\\n            else:\\n                return check(row+1,new_col)\\n        res = []\\n        for i in range(n):\\n            res.append(check(0,i))\\n        return res\\n```\n```python\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m,n = len(grid),len(grid[0])\\n        res = [-1 for i in range(n)]\\n        \\n        for col in range(n):\\n            curCol = col\\n            for row in range(m):\\n                newCol = curCol + grid[row][curCol]\\n                if newCol==-1 or newCol==n or grid[row][newCol]!=grid[row][curCol]:\\n                    break\\n                curCol = newCol\\n            else:\\n                res[col] = curCol\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443268,
                "title": "python-3-dfs-simulation-explanation",
                "content": "### Explanation\\n- Simulate the process\\n\\t- When current board is 1 (right), ball will move to right only if the right neighbor of current position is also 1\\n\\t- When current board is -1 (left), ball will move to left only if the left neighbor of current position is also -1\\n- Repeat above process until the ball drop to bottom or return -1 if it won\\'t\\n- DFS is not necessary, you can implement it using an iterative way instead\\n- Time: `O(m*n)`\\n### Implementation\\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        @cache\\n        def helper(r, c):\\n            if r == m:\\n                return c\\n            elif grid[r][c] == 1 and c+1 < n and grid[r][c+1] == 1:\\n                return helper(r+1, c+1)\\n            elif grid[r][c] == -1 and 0 <= c-1 and grid[r][c-1] == -1:\\n                return helper(r+1, c-1)\\n            else:\\n                return -1\\n            \\n        return [helper(0, j) for j in range(n)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        @cache\\n        def helper(r, c):\\n            if r == m:\\n                return c\\n            elif grid[r][c] == 1 and c+1 < n and grid[r][c+1] == 1:\\n                return helper(r+1, c+1)\\n            elif grid[r][c] == -1 and 0 <= c-1 and grid[r][c-1] == -1:\\n                return helper(r+1, c-1)\\n            else:\\n                return -1\\n            \\n        return [helper(0, j) for j in range(n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988175,
                "title": "c-with-picture-upscaled-grid",
                "content": "> Note: the problem can be solved in a simpler way; here I just wanted to re-use the upscale tactic from [959. Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes/discuss/205674/C%2B%2B-with-picture-DFS-on-upscaled-grid).\\n\\nLike for other similar problems, we upscale our grid to 3x, and paint our lines there. Then, we can do regular DFS for each ball and see if it reaches the bottom.\\n\\nA ball can either go down - if the position is not blocked, left or right. If a ball gets stuck - return -1.\\n\\n![image](https://assets.leetcode.com/users/images/bb7f412f-f368-4e2c-b5c5-dbdb2dba1c3e_1609041793.3970044.png)\\n\\n```cpp\\nvector<pair<int, int>> dir{{1, 0}, {0, -1}, {0, 1}};\\nint drop(int pos, vector<vector<int>> &ug, int m, int n) {\\n    queue<pair<int, int>> q;\\n    q.push({0, pos});\\n    while (!q.empty()) {\\n        auto [i, j] = q.front();\\n        q.pop();\\n        if (i == m - 1)\\n            return j / 3;\\n        ug[i][j] = 1;\\n        for (auto [di, dj] : dir)\\n            if (j + dj >= 0 && j + dj < n && !ug[i + di][j + dj]) {\\n                q.push({i + di, j + dj});\\n                break;\\n            }\\n    }\\n    return -1;\\n}\\nvector<int> findBall(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> ug(m * 3, vector<int>(n * 3));\\n    for (auto i = 0; i < m; ++i)\\n        for (auto j = 0; j < n; ++j) {\\n            ug[i * 3 + 1][j * 3 + 1] = 1;\\n            ug[i * 3][j * 3] = ug[i * 3 + 2][j * 3 + 2] = g[i][j] == 1;\\n            ug[i * 3][j * 3 + 2] = ug[i * 3 + 2][j * 3] = g[i][j] != 1;\\n        }\\n    vector<int> res;\\n    for (auto i = 0; i < n; ++i) {\\n        res.push_back(drop(i * 3 + 1, ug, m * 3, n * 3));\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<pair<int, int>> dir{{1, 0}, {0, -1}, {0, 1}};\\nint drop(int pos, vector<vector<int>> &ug, int m, int n) {\\n    queue<pair<int, int>> q;\\n    q.push({0, pos});\\n    while (!q.empty()) {\\n        auto [i, j] = q.front();\\n        q.pop();\\n        if (i == m - 1)\\n            return j / 3;\\n        ug[i][j] = 1;\\n        for (auto [di, dj] : dir)\\n            if (j + dj >= 0 && j + dj < n && !ug[i + di][j + dj]) {\\n                q.push({i + di, j + dj});\\n                break;\\n            }\\n    }\\n    return -1;\\n}\\nvector<int> findBall(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> ug(m * 3, vector<int>(n * 3));\\n    for (auto i = 0; i < m; ++i)\\n        for (auto j = 0; j < n; ++j) {\\n            ug[i * 3 + 1][j * 3 + 1] = 1;\\n            ug[i * 3][j * 3] = ug[i * 3 + 2][j * 3 + 2] = g[i][j] == 1;\\n            ug[i * 3][j * 3 + 2] = ug[i * 3 + 2][j * 3] = g[i][j] != 1;\\n        }\\n    vector<int> res;\\n    for (auto i = 0; i < n; ++i) {\\n        res.push_back(drop(i * 3 + 1, ug, m * 3, n * 3));\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 988342,
                "title": "c-simple-solution",
                "content": "Suppose there\\'re total n columns, then there\\'re total n balls, dropping from (0, j), j in range of [0, n). For each ball, it starts at position (row = 0, col = j). At current grid grid[row][col], it will decide this ball\\'s next position. If grid[row][col] == 1, this ball\\'s next position will be (row+1, col+1); If grid[row][col] == -1, this ball\\'s next position will be (row+1, col-1). \\nThere\\'re two situations where this ball cannot reach the last row:\\n1. This ball stucks at the wall. which means this ball needs to go to (row+1, col+1), but col+1 >= n; or this ball needs to go to (row+1, col-1), but col - 1 < 0.\\n2. This ball stucks at V shape, which means this grid[row][col] == 1 and grid[row][col+1] == -1; Or grid[row][col] == -1 and grid[row][col-1] == 1.\\n\\nIf this ball stucks, push back -1 into ans and break the while loop; If this ball reaches the last row, push back current col into ans.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> ans;\\n        for (int j = 0; j < n; j++) {\\n            int row = 0, col = j;\\n            while (row < m) {\\n                if (grid[row][col] == 1) {\\n                    if (col+1 >= n || grid[row][col+1] == -1) {\\n                        ans.push_back(-1);\\n                        break;\\n                    }\\n                    col++;\\n                } else if (grid[row][col] == -1) {\\n                    if (col-1 < 0 || grid[row][col-1] == 1) {\\n                        ans.push_back(-1);\\n                        break;\\n                    }\\n                    col--;\\n                }\\n\\t\\t\\t\\trow++;\\n            }\\n            if (row == m) {\\n                ans.push_back(col);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> ans;\\n        for (int j = 0; j < n; j++) {\\n            int row = 0, col = j;\\n            while (row < m) {\\n                if (grid[row][col] == 1) {\\n                    if (col+1 >= n || grid[row][col+1] == -1) {\\n                        ans.push_back(-1);\\n                        break;\\n                    }\\n                    col++;\\n                } else if (grid[row][col] == -1) {\\n                    if (col-1 < 0 || grid[row][col-1] == 1) {\\n                        ans.push_back(-1);\\n                        break;\\n                    }\\n                    col--;\\n                }\\n\\t\\t\\t\\trow++;\\n            }\\n            if (row == m) {\\n                ans.push_back(col);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765248,
                "title": "java-easy-solution-with-explanation-98-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        final int[] result = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            int cy = 0;\\n            int cx = i;\\n            while(cy < m && !isBlocked(grid, cy, cx)) {\\n                cx += grid[cy][cx];\\n                cy += 1;\\n            }\\n\\n            result[i] = cy == m ? cx : -1;\\n        }\\n\\n        return result;\\n    }\\n\\n    private boolean isBlocked(\\n        int[][] grid,\\n        int cy,\\n        int cx\\n    ) {\\n        int n = grid[0].length;\\n        return (grid[cy][cx] == 1 && cx == n - 1) // will hit right wall\\n            || (grid[cy][cx] == -1 && cx == 0)    // will hit left wall\\n            || (grid[cy][cx] == 1 && grid[cy][cx + 1] == -1) // V shape with next\\n            || (grid[cy][cx] == -1 && grid[cy][cx - 1] == 1); // V shape with previous\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        final int[] result = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            int cy = 0;\\n            int cx = i;\\n            while(cy < m && !isBlocked(grid, cy, cx)) {\\n                cx += grid[cy][cx];\\n                cy += 1;\\n            }\\n\\n            result[i] = cy == m ? cx : -1;\\n        }\\n\\n        return result;\\n    }\\n\\n    private boolean isBlocked(\\n        int[][] grid,\\n        int cy,\\n        int cx\\n    ) {\\n        int n = grid[0].length;\\n        return (grid[cy][cx] == 1 && cx == n - 1) // will hit right wall\\n            || (grid[cy][cx] == -1 && cx == 0)    // will hit left wall\\n            || (grid[cy][cx] == 1 && grid[cy][cx + 1] == -1) // V shape with next\\n            || (grid[cy][cx] == -1 && grid[cy][cx - 1] == 1); // V shape with previous\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764927,
                "title": "python-c-java-rust-it-s-all-just-a-simulation-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a simulation approach to move balls down the box. Time complexity is linear (in each dimension): **O(m\\\\*n)**. Space complexity is linear: **O(n)**\\n\\n**Comment.** The key trick of this simulation is the smart use of each cell\\'s value, i.e., (`+1`) or  (`-1`), that provides an increment for\\n* the position of the cell to compare with;\\n* the position of the cell in the next row to move to.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n\\n        m, n = len(grid), len(grid[0])\\n        \\n        # [1] function that simulates m steps\\n        def move_ball(j):\\n            for i in range(m):\\n                k = j + grid[i][j]\\n                if not (0 <= k < n) or (grid[i][k] != grid[i][j]):\\n                    return -1\\n                j = k\\n            return j\\n        \\n        # [2] move n balls from the top to the bottom\\n        return [move_ball(j) for j in range(n)]\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/oGc9ytmr/shared\" frameBorder=\"0\" width=\"800\" height=\"520\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n\\n        m, n = len(grid), len(grid[0])\\n        \\n        # [1] function that simulates m steps\\n        def move_ball(j):\\n            for i in range(m):\\n                k = j + grid[i][j]\\n                if not (0 <= k < n) or (grid[i][k] != grid[i][j]):\\n                    return -1\\n                j = k\\n            return j\\n        \\n        # [2] move n balls from the top to the bottom\\n        return [move_ball(j) for j in range(n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766250,
                "title": "c-dfs-code-with-explanation-1706",
                "content": "Solves [1706: Where Will the Ball Fall ](https://leetcode.com/problems/where-will-the-ball-fall/)\\nIf you find this post helpful, please do upvote! \\u2B06\\uFE0F\\n\\nWe have two choices for the ball: \\n- Ball can move left\\n- Ball can move right\\n\\n1) A ball can move right if the current board and the next board in the grid is like this `\\\\ \\\\`, that is if they are 1.\\n2) A ball can move left if the current board and the previous board in the grid is like this `/ /`, that is if they are -1.\\n\\nNow using this idea run the recursion - If the ball pass through the last row then it retun the final column it is in.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int solve(int i, int j, vector<vector<int>>& grid, int m, int n){\\n\\n        // base condition: if ball passed all rows then, \\n        // ball is out at jth column\\n        if(i == m) return j;\\n        \\n        \\n        /* At a time a ball can move only left or right, not both\\n\\t\\t    so even though we have two choices, only one choise can be executed,\\n\\t\\t\\tso the recursive structure is not exponential but rather linear -> O(M)*/\\n        \\n        // ball can move right if current board and next board are towards right\\n        if(grid[i][j] == 1 && j + 1 < n && grid[i][j + 1] == 1){\\n            return solve(i + 1, j + 1, grid, m, n);\\n        }\\n        \\n        // ball can move left if current board and previous board is towards left\\n        if(grid[i][j] == -1 && j - 1 >= 0 && grid[i][j - 1] == -1){\\n            return solve(i + 1, j - 1, grid, m, n);\\n        }\\n        \\n        // if ball couldn\\'t move left or right, then its trapped\\n        return -1;\\n    }\\n    \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // stores the answer \\n        vector<int> fall(n);\\n        \\n\\t\\t// Find the status of each ball -> O(N)\\n        for(int i = 0; i < n; i++){\\n            fall[i] = solve(0, i, grid, m, n);\\n        }\\n        \\n        return fall;\\n    }\\n};\\n```\\n\\n**Time Complexity: O(M N)\\nSpace Complexity: O(1)**\\n\\n*if auxillary stack space is excluded else SC is O(M).*\\n\\nIf you find this post helpful, please do upvote! \\u2B06\\uFE0F",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int solve(int i, int j, vector<vector<int>>& grid, int m, int n){\\n\\n        // base condition: if ball passed all rows then, \\n        // ball is out at jth column\\n        if(i == m) return j;\\n        \\n        \\n        /* At a time a ball can move only left or right, not both\\n\\t\\t    so even though we have two choices, only one choise can be executed,\\n\\t\\t\\tso the recursive structure is not exponential but rather linear -> O(M)*/\\n        \\n        // ball can move right if current board and next board are towards right\\n        if(grid[i][j] == 1 && j + 1 < n && grid[i][j + 1] == 1){\\n            return solve(i + 1, j + 1, grid, m, n);\\n        }\\n        \\n        // ball can move left if current board and previous board is towards left\\n        if(grid[i][j] == -1 && j - 1 >= 0 && grid[i][j - 1] == -1){\\n            return solve(i + 1, j - 1, grid, m, n);\\n        }\\n        \\n        // if ball couldn\\'t move left or right, then its trapped\\n        return -1;\\n    }\\n    \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // stores the answer \\n        vector<int> fall(n);\\n        \\n\\t\\t// Find the status of each ball -> O(N)\\n        for(int i = 0; i < n; i++){\\n            fall[i] = solve(0, i, grid, m, n);\\n        }\\n        \\n        return fall;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271653,
                "title": "python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**APPROACH**\\n\\n**Let the ball be in ```j``` column and ```i``` row.**, then at next row :\\n* If ```grid[i][j] == 1``` , then ball will move to right column only if ```grid[i][j+1] == 1```. Otherwise it gets struck.\\n* If ```grid[i][j] == -1``` , then ball will move to left column only if ```grid[i][j-1] == -1```. Otherwise it gets struck.\\n\\n***Here is a clear depiction where the ball will be at ```i``` ROW.***\\n\\n*For cases where the ball may reach ```0``` or ```n-1``` column, I have added two additional columns : one in front and other at back, so no extra check statements are required.* \\n\\n![image](https://assets.leetcode.com/users/images/dc40a194-b519-4574-83d4-68493a8d70bb_1657615037.2035635.png)\\n\\n\\n\\n\\n**UPVOTE IF HELPFuuL**\\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        \\n        m,n=len(grid),len(grid[0])\\n        for i in range(m):\\n            grid[i].insert(0,1)\\n            grid[i].append(-1)\\n        res=[]\\n        \\n        for k in range(1,n+1):\\n            i , j = 0 , k\\n            struck = False\\n            while i<m:\\n                if grid[i][j]==1:\\n                    if grid[i][j+1]==1:\\n                        j+=1\\n                    else:\\n                        struck=True\\n                        break\\n                else:\\n                    if grid[i][j-1]==-1:\\n                        j-=1\\n                    else:\\n                        struck=True\\n                        break\\n                i+=1\\n            if struck:\\n                res.append(-1)\\n            else:\\n                res.append(j-1)\\n                \\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/b47eeb75-1993-45ef-a5ee-5fac9544ea02_1657615143.0559897.jpeg)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```j```\n```i```\n```grid[i][j] == 1```\n```grid[i][j+1] == 1```\n```grid[i][j] == -1```\n```grid[i][j-1] == -1```\n```i```\n```0```\n```n-1```\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        \\n        m,n=len(grid),len(grid[0])\\n        for i in range(m):\\n            grid[i].insert(0,1)\\n            grid[i].append(-1)\\n        res=[]\\n        \\n        for k in range(1,n+1):\\n            i , j = 0 , k\\n            struck = False\\n            while i<m:\\n                if grid[i][j]==1:\\n                    if grid[i][j+1]==1:\\n                        j+=1\\n                    else:\\n                        struck=True\\n                        break\\n                else:\\n                    if grid[i][j-1]==-1:\\n                        j-=1\\n                    else:\\n                        struck=True\\n                        break\\n                i+=1\\n            if struck:\\n                res.append(-1)\\n            else:\\n                res.append(j-1)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764917,
                "title": "js-fast-simple-iterative-solution",
                "content": "Runtime74 ms\\nBeats\\n92.79%\\nMemory44.2 MB\\nBeats\\n87.18%\\n\\nThis approach simply follows the ball down from the top for each starting position tried, modifying the column as necessary.\\n### Complexity\\n- Time complexity: O(mn)\\n- Space complexity: O(1)\\n\\n### Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar findBall = function(grid) \\n{\\n    const rows = grid.length, cols = grid[0].length;\\n\\n    const getPosition = function(row, col)\\n    {\\n        if(grid[row][col] === 1)\\n        {\\n            if(col === cols-1 || grid[row][col+1] === -1)\\n                return -1;\\n            return col+1;\\n        }\\n        else\\n        {\\n            if(col === 0 || grid[row][col-1] === 1)\\n                return -1;\\n            return col-1;\\n        }\\n    };\\n\\n    let result = [];\\n    for(let col=0; col<cols; col++)\\n    {\\n        let pos = col;\\n        for(let row=0; row<rows; row++)\\n        {\\n            pos = getPosition(row, pos);\\n            if(pos === -1)\\n                break;\\n        }\\n        result.push(pos);\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar findBall = function(grid) \\n{\\n    const rows = grid.length, cols = grid[0].length;\\n\\n    const getPosition = function(row, col)\\n    {\\n        if(grid[row][col] === 1)\\n        {\\n            if(col === cols-1 || grid[row][col+1] === -1)\\n                return -1;\\n            return col+1;\\n        }\\n        else\\n        {\\n            if(col === 0 || grid[row][col-1] === 1)\\n                return -1;\\n            return col-1;\\n        }\\n    };\\n\\n    let result = [];\\n    for(let col=0; col<cols; col++)\\n    {\\n        let pos = col;\\n        for(let row=0; row<rows; row++)\\n        {\\n            pos = getPosition(row, pos);\\n            if(pos === -1)\\n                break;\\n        }\\n        result.push(pos);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2368248,
                "title": "java-clean-dfs",
                "content": "```\\npublic int[] findBall(int[][] grid) {\\n        int[] results = new int[grid[0].length];\\n        for (int i = 0; i < grid[0].length; i++) {\\n            results[i] = dfs(grid, 0, i);\\n        }\\n\\n        return results;\\n    }\\n\\n    private int dfs(int[][] grid, int row, int column) {\\n        if (row == grid.length)\\n            return column;\\n\\n        if ((grid[row][column] == 1 && (column == grid[0].length - 1 || grid[row][column + 1] == -1)) ||\\n                grid[row][column] == -1 && (column == 0 || grid[row][column - 1] == 1))\\n            return -1;\\n\\n        if (grid[row][column] == 1)\\n            return dfs(grid, row + 1, column + 1);\\n        else\\n            return dfs(grid, row + 1, column - 1);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic int[] findBall(int[][] grid) {\\n        int[] results = new int[grid[0].length];\\n        for (int i = 0; i < grid[0].length; i++) {\\n            results[i] = dfs(grid, 0, i);\\n        }\\n\\n        return results;\\n    }\\n\\n    private int dfs(int[][] grid, int row, int column) {\\n        if (row == grid.length)\\n            return column;\\n\\n        if ((grid[row][column] == 1 && (column == grid[0].length - 1 || grid[row][column + 1] == -1)) ||\\n                grid[row][column] == -1 && (column == 0 || grid[row][column - 1] == 1))\\n            return -1;\\n\\n        if (grid[row][column] == 1)\\n            return dfs(grid, row + 1, column + 1);\\n        else\\n            return dfs(grid, row + 1, column - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2764993,
                "title": "python-3-12-lines-simulation-w-explanation-t-m-85-85",
                "content": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n\\n        m,n = len(grid), len(grid[0])       # comments added nov 1 22 for @flufe (see below)\\n        N, ans = range(n), []\\n                              \\n        for pos in N:                       # for each ball in the top row...                         \\n            for row in grid:                #     for each row....\\n\\n                direction = row[pos]        # +1 to the right, -1 to the left\\n                pos += row[pos]             # move the ball left or right\\n                                    \\n                if (pos not in N or         # if the ball runs into wall or...\\n                    row[pos] != direction): # ... if the ball runs into \\\\/, then...\\n                    ans.append(-1)          # ...start the next ball. Otherwise, ball moves down a row\\n                    break                \\n            else:\\n                ans.append(pos)             # if tha ball does not fail, record its exit position\\n                       \\n        return ans                          # return the list of results\\n```\\n\\n[https://leetcode.com/submissions/detail/785961974/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n\\n        m,n = len(grid), len(grid[0])       # comments added nov 1 22 for @flufe (see below)\\n        N, ans = range(n), []\\n                              \\n        for pos in N:                       # for each ball in the top row...                         \\n            for row in grid:                #     for each row....\\n\\n                direction = row[pos]        # +1 to the right, -1 to the left\\n                pos += row[pos]             # move the ball left or right\\n                                    \\n                if (pos not in N or         # if the ball runs into wall or...\\n                    row[pos] != direction): # ... if the ball runs into \\\\/, then...\\n                    ans.append(-1)          # ...start the next ball. Otherwise, ball moves down a row\\n                    break                \\n            else:\\n                ans.append(pos)             # if tha ball does not fail, record its exit position\\n                       \\n        return ans                          # return the list of results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764910,
                "title": "golang-dfs",
                "content": "```\\nfunc findBall(grid [][]int) []int {\\n    m, n := len(grid), len(grid[0])\\n    output := make([]int, n)\\n    \\n    for i := 0; i < n; i++ {\\n        output[i] = -1\\n        r, c := 0, i\\n        \\n        for r < m {\\n            if grid[r][c] == 1 && c+1 < n && grid[r][c+1] != -1 {\\n                r++\\n                c++\\n            } else if grid[r][c] == -1 && c-1 >= 0 && grid[r][c-1] != 1 {\\n                r++\\n                c--\\n            } else {\\n                break\\n            }\\n        }\\n        \\n        if r == m {\\n            output[i] = c\\n        }\\n    }\\n    return output\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findBall(grid [][]int) []int {\\n    m, n := len(grid), len(grid[0])\\n    output := make([]int, n)\\n    \\n    for i := 0; i < n; i++ {\\n        output[i] = -1\\n        r, c := 0, i\\n        \\n        for r < m {\\n            if grid[r][c] == 1 && c+1 < n && grid[r][c+1] != -1 {\\n                r++\\n                c++\\n            } else if grid[r][c] == -1 && c-1 >= 0 && grid[r][c-1] != 1 {\\n                r++\\n                c--\\n            } else {\\n                break\\n            }\\n        }\\n        \\n        if r == m {\\n            output[i] = c\\n        }\\n    }\\n    return output\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2764944,
                "title": "javascript-easy-to-understand-solution",
                "content": "```javascript\\nvar findBall = function(grid) {\\n    let balls = grid[0].length;\\n    const ans = new Array(balls).fill(-1);\\n    for (let i = 0; i < ans.length; i++) {\\n        ans[i] = dfs(grid, 0, i);\\n    }\\n    return ans;\\n};\\n\\nvar dfs = function(grid, r, c) {\\n    // is stuck in a V\\n    if (\\n        grid[r][c] === 1 && grid[r][c+1] === -1 ||\\n        grid[r][c] === -1 && grid[r][c-1] === 1\\n    ) {\\n        return -1;\\n    }\\n    \\n    // is stuck on left wall\\n    if (grid[r][c] === -1 && c - 1 < 0) {\\n        return -1;\\n    }\\n    // is stuck on right wall\\n    if (grid[r][c] === 1 && c + 1 >= grid[0].length) {\\n        return -1;\\n    }\\n    \\n    // when ball drops to bottom :)\\n    if (r === grid.length - 1) {\\n        // drops to right\\n        if (grid[r][c] === 1) return c + 1;\\n        // drops to left\\n        return c - 1;\\n    }\\n    \\n    // dfs right\\n    if (grid[r][c] === 1) {\\n        return dfs(grid, r + 1, c + 1);\\n    }\\n    //  dfs left\\n    return dfs(grid, r + 1, c - 1);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```javascript\\nvar findBall = function(grid) {\\n    let balls = grid[0].length;\\n    const ans = new Array(balls).fill(-1);\\n    for (let i = 0; i < ans.length; i++) {\\n        ans[i] = dfs(grid, 0, i);\\n    }\\n    return ans;\\n};\\n\\nvar dfs = function(grid, r, c) {\\n    // is stuck in a V\\n    if (\\n        grid[r][c] === 1 && grid[r][c+1] === -1 ||\\n        grid[r][c] === -1 && grid[r][c-1] === 1\\n    ) {\\n        return -1;\\n    }\\n    \\n    // is stuck on left wall\\n    if (grid[r][c] === -1 && c - 1 < 0) {\\n        return -1;\\n    }\\n    // is stuck on right wall\\n    if (grid[r][c] === 1 && c + 1 >= grid[0].length) {\\n        return -1;\\n    }\\n    \\n    // when ball drops to bottom :)\\n    if (r === grid.length - 1) {\\n        // drops to right\\n        if (grid[r][c] === 1) return c + 1;\\n        // drops to left\\n        return c - 1;\\n    }\\n    \\n    // dfs right\\n    if (grid[r][c] === 1) {\\n        return dfs(grid, r + 1, c + 1);\\n    }\\n    //  dfs left\\n    return dfs(grid, r + 1, c - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2764932,
                "title": "swift",
                "content": "```swift\\n//Where Will the Ball Fall\\n//O(n), O(1)\\n    func findBall(_ grid: [[Int]]) -> [Int] {\\n        var res = [Int]()\\n        let rows = grid.endIndex, cols = grid[0].endIndex\\n        next: for i in 0..<cols {\\n            var currRow = 0, currCol = i\\n            while currRow < rows {\\n                if grid[currRow][currCol] == 1 {\\n                    guard currCol + 1 < cols else {\\n                        res.append(-1)\\n                        continue next\\n                    }\\n                    if grid[currRow][currCol+1] == 1 {\\n                        currRow += 1\\n                        currCol += 1\\n                    } else {\\n                        res.append(-1)\\n                        continue next\\n                    }\\n                } else {\\n                    guard currCol-1 >= 0 else {\\n                        res.append(-1)\\n                        continue next\\n                    }\\n                    if grid[currRow][currCol-1] == -1 {\\n                        currRow += 1\\n                        currCol -= 1\\n                    } else {\\n                        res.append(-1)\\n                        continue next\\n                    }\\n                }\\n            }\\n            res.append(currCol)\\n        }\\n        return res\\n    }\\n```",
                "solutionTags": [],
                "code": "```swift\\n//Where Will the Ball Fall\\n//O(n), O(1)\\n    func findBall(_ grid: [[Int]]) -> [Int] {\\n        var res = [Int]()\\n        let rows = grid.endIndex, cols = grid[0].endIndex\\n        next: for i in 0..<cols {\\n            var currRow = 0, currCol = i\\n            while currRow < rows {\\n                if grid[currRow][currCol] == 1 {\\n                    guard currCol + 1 < cols else {\\n                        res.append(-1)\\n                        continue next\\n                    }\\n                    if grid[currRow][currCol+1] == 1 {\\n                        currRow += 1\\n                        currCol += 1\\n                    } else {\\n                        res.append(-1)\\n                        continue next\\n                    }\\n                } else {\\n                    guard currCol-1 >= 0 else {\\n                        res.append(-1)\\n                        continue next\\n                    }\\n                    if grid[currRow][currCol-1] == -1 {\\n                        currRow += 1\\n                        currCol -= 1\\n                    } else {\\n                        res.append(-1)\\n                        continue next\\n                    }\\n                }\\n            }\\n            res.append(currCol)\\n        }\\n        return res\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 988174,
                "title": "a-few-solutions",
                "content": "Perform ball `drop` simulation for each `k`<sup>th</sup> ball.  Each ball is tracked by its row and column, ie. `i` and `j` correspondingly in the input grid `A`.  If we can reach the `M`<sup>th</sup> row, ie. `i == M`, then the ball exits at the `j`<sup>th</sup> column, otherwise the ball got stuck.  The ball is allowed to go left/right if and only if the current cell `i`,`j` and the adjacent cell `i`,`j + A[i][j]` are \"pointing\" in the same direction.  This is expressed as `A[i][j] == A[i][j + A[i][j]]`, ie. we consider each current cell `A[i][j]` as a relative offset from the current `j`<sup>th</sup> column to it\\'s adjacent neighbor which is to-the-left if `A[i][j] == -1` (and thus we update `j = j - 1` for the expression `j += A[i][j]`)  xor is to-the-right if `A[i][j] == 1` (and thus we update `j = j + 1` for the expression `j += A[i][j]`).  An astute observer will notice the iterative solutions update `i` **after** the update to `j` during the simulation because the next `j`<sup>th</sup> column is dependent upon the current `i`<sup>th</sup> row\\'s `j`<sup>th</sup> relative offset `A[i][j]`.\\n\\n**Note:** the most complex and verbose part of this code is the bounds check from `0..N - 1` inclusive for the `j`<sup>th</sup> column and it\\'s adjacent neighbor the `j + A[i][j]`<sup>th</sup> column, which is concisely expressed in Python3 and Kotlin correspondingly as follows:\\n\\n*Python3:* `0 <= j < N and 0 <= j + A[i][j] < N`\\n*Kotlin:* `j in 0..N - 1 && j + A[i][j] in 0..N - 1`\\n\\n\\n`\\uD83D\\uDC46 \\uD83D\\uDC40 `  Notice how redundant this bounds check is in the other 2 languages (Javascript and C++) \\xAF\\\\\\\\_(\\u30C4)_/\\xAF as follows:\\n\\n*Javascript and C++:* `0 <= j && j < N && 0 <= j + A[i][j] && j + A[i][j] < N`\\n\\n---\\n\\n**`\\uD83D\\uDE80 ` \"Concise\" Recursive solutions:** using the first class concept `drop(i = 0, j)` to simulate dropping the `j`<sup>th</sup> ball for each `j` from `0..N - 1` inclusive, ie. if we can drop the `j`<sup>th</sup> ball successfully through the input grid `A`, then return it\\'s corresponding exit column (`-1` if the `j`<sup>th</sup> ball got stuck).\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun findBall(A: Array<IntArray>): IntArray {\\n        var M = A.size\\n        var N = A[0].size\\n        fun drop(i: Int, j: Int): Int {\\n            return if (i == M) j else if (j in 0..N - 1 && j + A[i][j] in 0..N - 1 && A[i][j] == A[i][j + A[i][j]]) drop(i + 1, j + A[i][j]) else -1\\n        }\\n        return IntArray(N) { drop(0, it) }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet findBall = (A, M = A.length, N = A[0].length, drop = (i, j) => i == M ? j : 0 <= j && j < N && 0 <= j + A[i][j] && j + A[i][j] < N && A[i][j] == A[i][j + A[i][j]] ? drop(i + 1, j + A[i][j]) : -1) => [...Array(N).keys()].map(j => drop(0, j));\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findBall(self, A: List[List[int]]) -> List[int]:\\n        ans = []\\n        M = len(A)\\n        N = len(A[0])\\n        drop = lambda i, j: j if i == M else drop(i + 1, j + A[i][j]) if 0 <= j < N and 0 <= j + A[i][j] < N and A[i][j] == A[i][j + A[i][j]] else -1\\n        return [drop(0, j) for j in range(N)]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    VI findBall(VVI& A, VI ans = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun drop = [&](auto i, auto j) {\\n            return i == M ? j : 0 <= j && j < N && 0 <= j + A[i][j] && j + A[i][j] < N && A[i][j] == A[i][j + A[i][j]] ? drop(i + 1, j + A[i][j]) : -1;\\n        };\\n        for (auto j{ 0 }; j < N; ans.push_back(drop(0, j++)));\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n**`\\uD83D\\uDE80 ` \"Verbose\" Recursive solutions:** same idea as above, written verbosely for optimized readability.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun findBall(A: Array<IntArray>): IntArray {\\n        var M = A.size\\n        var N = A[0].size\\n        fun drop(i: Int, j: Int): Int {\\n            if (i == M)\\n                return j\\n            if (j in 0..N - 1 && j + A[i][j] in 0..N - 1 && A[i][j] == A[i][j + A[i][j]])\\n                return drop(i + 1, j + A[i][j])\\n            return -1\\n        }\\n        return IntArray(N) { j -> drop(0, j) }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet findBall = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let drop = (i, j) => {\\n        if (i == M)\\n            return j;\\n        if (0 <= j && j < N && 0 <= j + A[i][j] && j + A[i][j] < N && A[i][j] == A[i][j + A[i][j]])\\n            return drop(i + 1, j + A[i][j]);\\n        return -1;\\n    };\\n    return [...Array(N).keys()].map(j => drop(0, j));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findBall(self, A: List[List[int]]) -> List[int]:\\n        ans = []\\n        M = len(A)\\n        N = len(A[0])\\n        def drop(i, j):\\n            if i == M:\\n                return j\\n            return drop(i + 1, j + A[i][j]) if 0 <= j < N and 0 <= j + A[i][j] < N and A[i][j] == A[i][j + A[i][j]] else -1\\n        return [drop(0, j) for j in range(N)]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    VI findBall(VVI& A, VI ans = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun drop = [&](auto i, auto j) {\\n            if (i == M)\\n                return j;\\n            if (0 <= j && j < N && 0 <= j + A[i][j] && j + A[i][j] < N && A[i][j] == A[i][j + A[i][j]])\\n                return drop(i + 1, j + A[i][j]);\\n            return -1;\\n        };\\n        for (auto j{ 0 }; j < N; ans.push_back(drop(0, j++)));\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n**`\\uD83D\\uDE8C ` Iterative solutions:**  same general idea as above simulations, but in the solutions below, we drop each `k`<sup>th</sup> ball for each `k` from `0..N - 1` inclusive.  Each `k`<sup>th</sup> ball starts it\\'s \"drop\" into `A` at cell `i = 0`,`j = k`.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun findBall(A: Array<IntArray>): IntArray {\\n        var ans = mutableListOf<Int>()\\n        var M = A.size\\n        var N = A[0].size\\n        for (k in 0..N - 1) {\\n            var i = 0\\n            var j = k\\n            while (i < M && j in 0..N - 1 && j + A[i][j] in 0..N - 1 && A[i][j] == A[i][j + A[i][j]]) {\\n                j += A[i][j]; ++i\\n            }\\n            ans.add(if (i == M) j else -1)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet findBall = (A, ans = []) => {\\n    let M = A.length,\\n        N = A[0].length;\\n    for (let k = 0; k < N; ++k) {\\n        let i = 0,\\n            j = k;\\n        while (i < M && 0 <= j && j < N && 0 <= j + A[i][j] && j + A[i][j] < N && A[i][j] == A[i][j + A[i][j]])\\n            j += A[i][j], ++i;\\n        ans.push(i == M ? j : -1);\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findBall(self, A: List[List[int]]) -> List[int]:\\n        ans = []\\n        M = len(A)\\n        N = len(A[0])\\n        for k in range(N):\\n            i = 0\\n            j = k\\n            while i < M and 0 <= j < N and 0 <= j + A[i][j] < N and A[i][j] == A[i][j + A[i][j]]:\\n                j += A[i][j]; i += 1\\n            ans.append(j if i == M else -1)\\n        return ans\\n```\\n\\t\\t\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VI findBall(VVI& A, VI ans = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        for (auto k{ 0 }; k < N; ++k) {\\n            auto i = 0,\\n                 j = k;\\n            while (i < M && 0 <= j && j < N && 0 <= j + A[i][j] && j + A[i][j] < N && A[i][j] == A[i][j + A[i][j]])\\n                j += A[i][j], ++i;\\n            ans.push_back(i == M ? j : -1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findBall(A: Array<IntArray>): IntArray {\\n        var M = A.size\\n        var N = A[0].size\\n        fun drop(i: Int, j: Int): Int {\\n            return if (i == M) j else if (j in 0..N - 1 && j + A[i][j] in 0..N - 1 && A[i][j] == A[i][j + A[i][j]]) drop(i + 1, j + A[i][j]) else -1\\n        }\\n        return IntArray(N) { drop(0, it) }\\n    }\\n}\\n```\n```\\nlet findBall = (A, M = A.length, N = A[0].length, drop = (i, j) => i == M ? j : 0 <= j && j < N && 0 <= j + A[i][j] && j + A[i][j] < N && A[i][j] == A[i][j + A[i][j]] ? drop(i + 1, j + A[i][j]) : -1) => [...Array(N).keys()].map(j => drop(0, j));\\n```\n```\\nclass Solution:\\n    def findBall(self, A: List[List[int]]) -> List[int]:\\n        ans = []\\n        M = len(A)\\n        N = len(A[0])\\n        drop = lambda i, j: j if i == M else drop(i + 1, j + A[i][j]) if 0 <= j < N and 0 <= j + A[i][j] < N and A[i][j] == A[i][j + A[i][j]] else -1\\n        return [drop(0, j) for j in range(N)]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    VI findBall(VVI& A, VI ans = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun drop = [&](auto i, auto j) {\\n            return i == M ? j : 0 <= j && j < N && 0 <= j + A[i][j] && j + A[i][j] < N && A[i][j] == A[i][j + A[i][j]] ? drop(i + 1, j + A[i][j]) : -1;\\n        };\\n        for (auto j{ 0 }; j < N; ans.push_back(drop(0, j++)));\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun findBall(A: Array<IntArray>): IntArray {\\n        var M = A.size\\n        var N = A[0].size\\n        fun drop(i: Int, j: Int): Int {\\n            if (i == M)\\n                return j\\n            if (j in 0..N - 1 && j + A[i][j] in 0..N - 1 && A[i][j] == A[i][j + A[i][j]])\\n                return drop(i + 1, j + A[i][j])\\n            return -1\\n        }\\n        return IntArray(N) { j -> drop(0, j) }\\n    }\\n}\\n```\n```\\nlet findBall = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let drop = (i, j) => {\\n        if (i == M)\\n            return j;\\n        if (0 <= j && j < N && 0 <= j + A[i][j] && j + A[i][j] < N && A[i][j] == A[i][j + A[i][j]])\\n            return drop(i + 1, j + A[i][j]);\\n        return -1;\\n    };\\n    return [...Array(N).keys()].map(j => drop(0, j));\\n};\\n```\n```\\nclass Solution:\\n    def findBall(self, A: List[List[int]]) -> List[int]:\\n        ans = []\\n        M = len(A)\\n        N = len(A[0])\\n        def drop(i, j):\\n            if i == M:\\n                return j\\n            return drop(i + 1, j + A[i][j]) if 0 <= j < N and 0 <= j + A[i][j] < N and A[i][j] == A[i][j + A[i][j]] else -1\\n        return [drop(0, j) for j in range(N)]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    VI findBall(VVI& A, VI ans = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun drop = [&](auto i, auto j) {\\n            if (i == M)\\n                return j;\\n            if (0 <= j && j < N && 0 <= j + A[i][j] && j + A[i][j] < N && A[i][j] == A[i][j + A[i][j]])\\n                return drop(i + 1, j + A[i][j]);\\n            return -1;\\n        };\\n        for (auto j{ 0 }; j < N; ans.push_back(drop(0, j++)));\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun findBall(A: Array<IntArray>): IntArray {\\n        var ans = mutableListOf<Int>()\\n        var M = A.size\\n        var N = A[0].size\\n        for (k in 0..N - 1) {\\n            var i = 0\\n            var j = k\\n            while (i < M && j in 0..N - 1 && j + A[i][j] in 0..N - 1 && A[i][j] == A[i][j + A[i][j]]) {\\n                j += A[i][j]; ++i\\n            }\\n            ans.add(if (i == M) j else -1)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\n```\\nlet findBall = (A, ans = []) => {\\n    let M = A.length,\\n        N = A[0].length;\\n    for (let k = 0; k < N; ++k) {\\n        let i = 0,\\n            j = k;\\n        while (i < M && 0 <= j && j < N && 0 <= j + A[i][j] && j + A[i][j] < N && A[i][j] == A[i][j + A[i][j]])\\n            j += A[i][j], ++i;\\n        ans.push(i == M ? j : -1);\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def findBall(self, A: List[List[int]]) -> List[int]:\\n        ans = []\\n        M = len(A)\\n        N = len(A[0])\\n        for k in range(N):\\n            i = 0\\n            j = k\\n            while i < M and 0 <= j < N and 0 <= j + A[i][j] < N and A[i][j] == A[i][j + A[i][j]]:\\n                j += A[i][j]; i += 1\\n            ans.append(j if i == M else -1)\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VI findBall(VVI& A, VI ans = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        for (auto k{ 0 }; k < N; ++k) {\\n            auto i = 0,\\n                 j = k;\\n            while (i < M && 0 <= j && j < N && 0 <= j + A[i][j] && j + A[i][j] < N && A[i][j] == A[i][j + A[i][j]])\\n                j += A[i][j], ++i;\\n            ans.push_back(i == M ? j : -1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764871,
                "title": "daily-leetcoding-challenge-november-day-1",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/where-will-the-ball-fall/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/where-will-the-ball-fall/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2465816,
                "title": "python-solution-commented",
                "content": "here is a simple explaination\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef findBall(self, grid: List[List[int]]) -> List[int]:\\n\\t\\t\\tn=len(grid[0]) # no of cols\\n\\t\\t\\tm=len(grid) # no of rows\\n\\t\\t\\tres=[-1 for _ in range(n)] # initialise the result array as an array of -1 \\n        \\n\\t\\t\\tfor a in range(n):\\n\\t\\t\\t\\ti=a\\n\\t\\t\\t\\tf=True  # we use f as flag variable, inital value is true but will bw changed to false if and when ball gets trapped \\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tif grid[j][i]==1:\\n\\t\\t\\t\\t\\t\\tif i+1>=n: # this means that the ball has hit the right wall and will not make it through\\n\\t\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tif i+1<n and grid[j][i+1]==-1: # this means that the ball is trapped in a pocket and won\\'t make it through\\n\\t\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tif i-1<0: # this means that the ball has hit the left wall and will not make it through\\n\\t\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tif i-1>=0 and grid[j][i-1]==1:  # this means that the ball is trapped in a pocket and won\\'t make it through\\n\\t\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\ti-=1\\n\\t\\t\\t\\tif flag: # we check the flag variable f to see if the ball was trapped anywhere, true value indicates the ball will make it to the end \\n\\t\\t\\t\\t\\tres[a]=i\\n\\t\\t\\t\\telse : res[a]=-1\\n\\t\\t\\treturn res\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "here is a simple explaination\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef findBall(self, grid: List[List[int]]) -> List[int]:\\n\\t\\t\\tn=len(grid[0]) # no of cols\\n\\t\\t\\tm=len(grid) # no of rows\\n\\t\\t\\tres=[-1 for _ in range(n)] # initialise the result array as an array of -1 \\n        \\n\\t\\t\\tfor a in range(n):\\n\\t\\t\\t\\ti=a\\n\\t\\t\\t\\tf=True  # we use f as flag variable, inital value is true but will bw changed to false if and when ball gets trapped \\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tif grid[j][i]==1:\\n\\t\\t\\t\\t\\t\\tif i+1>=n: # this means that the ball has hit the right wall and will not make it through\\n\\t\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tif i+1<n and grid[j][i+1]==-1: # this means that the ball is trapped in a pocket and won\\'t make it through\\n\\t\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tif i-1<0: # this means that the ball has hit the left wall and will not make it through\\n\\t\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tif i-1>=0 and grid[j][i-1]==1:  # this means that the ball is trapped in a pocket and won\\'t make it through\\n\\t\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\ti-=1\\n\\t\\t\\t\\tif flag: # we check the flag variable f to see if the ball was trapped anywhere, true value indicates the ball will make it to the end \\n\\t\\t\\t\\t\\tres[a]=i\\n\\t\\t\\t\\telse : res[a]=-1\\n\\t\\t\\treturn res\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2251937,
                "title": "c-simple-recursive-function",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid, int i , int j, int n , int m){\\n        if(i>=n)\\n            return j;\\n        \\n        if(grid[i][j]==1){\\n            if(j==m-1 || grid[i][j+1]==-1)\\n                return -1;\\n           \\n            if(grid[i][j+1]==1)\\n                return solve(grid,i+1,j+1,n,m);\\n        }\\n        \\n        if(grid[i][j]==-1){\\n            if(j==0 || grid[i][j-1]==1)\\n                return -1;\\n            \\n            if(grid[i][j-1]==-1)\\n                return solve(grid,i+1,j-1,n,m);\\n        }\\n        \\n        return -1;\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<int> ans;\\n        \\n        for(int i=0;i<m;i++){\\n            int outColumn=solve(grid,0,i,n,m);\\n            ans.push_back(outColumn);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid, int i , int j, int n , int m){\\n        if(i>=n)\\n            return j;\\n        \\n        if(grid[i][j]==1){\\n            if(j==m-1 || grid[i][j+1]==-1)\\n                return -1;\\n           \\n            if(grid[i][j+1]==1)\\n                return solve(grid,i+1,j+1,n,m);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1232012,
                "title": "java-beginner-friendly-detailed-explanation-and-understandable-recursive-approach-for-beginners",
                "content": "So to begin with, let\\'s divide question into three scenarios:\\n\\n1. Ball falls\\n2. Ball gets stuck\\n3. Ball moves through array\\n\\n**Scenario 1**\\nFirst lets see when will will the 1. scenario work, i guess if the ball has reached the end most row, that means it has fallen sucessfully, so, this is our only base case:\\n```\\nif(i==m){\\n           //assign the corresponding coloumn to my answer array\\n\\t\\t   ans[k]=j;\\n\\t\\t   return;\\n        }\\n```\\n\\n**Scenario 2**\\nNow, lets come to 2. scenario, if you think carefully, you would get to learn that ball gets stuck only when:\\n\\n1. Value of arr[i][j]=1 and Right neighbour is wall or Right neighbour is -1 i.e.\\n\\t\\t1->wall OR 1->-1\\n\\t\\t\\n\\t\\t```\\n\\t\\tif(arr[i][j]==1 && (j+1>=n || arr[i][j+1]==-1))\\n            return;\\n\\t\\t```\\n\\n2. Value of arr[i][j]=-1 and Left neighbour is wall or Left neighbour is 1 i.e.\\n\\twall<- -1 OR 1<- -1\\n\\t```\\n\\telse if(arr[i][j]==-1 && (j-1<0 || arr[i][j-1]==1))\\n            return;\\n\\t```\\n\\t\\t\\n**Scenario 3**\\nLastly, ball will move through the array if it escapes the above two scenarios, so it can move in two ways:\\n1. Diagonal Right: when arr[i][j]=1\\n```\\n else if(arr[i][j]==1)\\n            func(arr,i+1,j+1,m,n,ans);\\n```\\n\\n2. Diagonal Left: when arr[i][j]=-1\\n```\\nelse if(arr[i][j]==-1)\\n            func(arr, i+1, j-1,m,n, ans);\\n```\\n\\n**CODE**\\n\\n```\\nclass Solution {\\n    int k=0;\\n    public int[] findBall(int[][] arr) {\\n        \\n        int m=arr.length;\\n        int n=arr[0].length;\\n\\t\\t\\n        //Initialize []ans with -1\\n        int []ans=new int[n];\\n        Arrays.fill(ans, -1);                  \\n        \\n\\t\\t//Step-by-Step iterate through first row of [][]arr\\n        for(int j=0;j<n;j++){\\n            func(arr,0,j,m,n,ans);\\n            k++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void func(int [][]arr, int i, int j, int m, int n, int []ans){\\n        \\n\\t\\t// if i has traversed through last row, that means ball has fallen successfully, hence save ans[k]=jth index of arr[i]\\n        if(i==m){\\n            ans[k]=j;\\n            return;\\n        }\\n\\t\\t\\n        //if 1 is being traversed and its RIGHT neighbour is wall or RIGHT neighbour is -1\\n\\t\\t//ball will get stuck\\n        if(arr[i][j]==1 && (j+1>=n || arr[i][j+1]==-1))\\n            return;\\n\\t\\t\\t\\n        //if -1 is being traversed and its LEFT neighbour is wall or LEFT neighbour is 1\\n\\t\\t//ball will get stuck\\n        else if(arr[i][j]==-1 && (j-1<0 || arr[i][j-1]==1))\\n            return;\\n        \\n\\t\\t// if 1 is being traversed so take me to RIGHT diagonal because 1->\\\\\\n        else if(arr[i][j]==1)\\n            func(arr,i+1,j+1,m,n,ans);\\n        \\n\\t\\t// if -1 is being traversed so take me to LEFT diagonal because -1->/\\n        else if(arr[i][j]==-1)\\n            func(arr, i+1, j-1,m,n, ans);\\n        \\n    }\\n}\\n```\\n\\nHope it helps! :D",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nif(i==m){\\n           //assign the corresponding coloumn to my answer array\\n\\t\\t   ans[k]=j;\\n\\t\\t   return;\\n        }\\n```\n```\\n\\t\\tif(arr[i][j]==1 && (j+1>=n || arr[i][j+1]==-1))\\n            return;\\n\\t\\t```\n```\\n\\telse if(arr[i][j]==-1 && (j-1<0 || arr[i][j-1]==1))\\n            return;\\n\\t```\n```\\n else if(arr[i][j]==1)\\n            func(arr,i+1,j+1,m,n,ans);\\n```\n```\\nelse if(arr[i][j]==-1)\\n            func(arr, i+1, j-1,m,n, ans);\\n```\n```\\nclass Solution {\\n    int k=0;\\n    public int[] findBall(int[][] arr) {\\n        \\n        int m=arr.length;\\n        int n=arr[0].length;\\n\\t\\t\\n        //Initialize []ans with -1\\n        int []ans=new int[n];\\n        Arrays.fill(ans, -1);                  \\n        \\n\\t\\t//Step-by-Step iterate through first row of [][]arr\\n        for(int j=0;j<n;j++){\\n            func(arr,0,j,m,n,ans);\\n            k++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void func(int [][]arr, int i, int j, int m, int n, int []ans){\\n        \\n\\t\\t// if i has traversed through last row, that means ball has fallen successfully, hence save ans[k]=jth index of arr[i]\\n        if(i==m){\\n            ans[k]=j;\\n            return;\\n        }\\n\\t\\t\\n        //if 1 is being traversed and its RIGHT neighbour is wall or RIGHT neighbour is -1\\n\\t\\t//ball will get stuck\\n        if(arr[i][j]==1 && (j+1>=n || arr[i][j+1]==-1))\\n            return;\\n\\t\\t\\t\\n        //if -1 is being traversed and its LEFT neighbour is wall or LEFT neighbour is 1\\n\\t\\t//ball will get stuck\\n        else if(arr[i][j]==-1 && (j-1<0 || arr[i][j-1]==1))\\n            return;\\n        \\n\\t\\t// if 1 is being traversed so take me to RIGHT diagonal because 1->\\\\\\n        else if(arr[i][j]==1)\\n            func(arr,i+1,j+1,m,n,ans);\\n        \\n\\t\\t// if -1 is being traversed so take me to LEFT diagonal because -1->/\\n        else if(arr[i][j]==-1)\\n            func(arr, i+1, j-1,m,n, ans);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989396,
                "title": "java-simulate-straightforward-and-easy-to-understand",
                "content": "***idea***\\nfor each ball in column i, we check if it can fall into next row until the end, the condition is clear, if current cell is 1, we check its right cell, if it\\'s in opposite direction or wall(boundary), it stucked, otherwise, ball move to next row, and its right column, similarly, if current cell is -1, we check its left cell. till the end, we have the current column index of the ball, add it to res.\\n***Time and Space***\\ntime is O(mn), where m is row, n is col, as each ball would go through all rows to fall into bottom\\nspace is O(1) if we dont consider res as space cost\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    public int[] findBall(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int[] res = new int[n];\\n        for(int i=0;i<n;i++){\\n            res[i] = helper(grid,i,0);\\n        }\\n        return res;\\n    }\\n    \\n    int helper(int[][] grid,int col,int row){\\n        while(row<m){\\n            int num = grid[row][col];\\n            if(col+num<0 || col+num>=n || num!=grid[row][col+num])\\n                return -1;\\n            row++;\\n            col = col+num;\\n        }\\n        return col;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    public int[] findBall(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int[] res = new int[n];\\n        for(int i=0;i<n;i++){\\n            res[i] = helper(grid,i,0);\\n        }\\n        return res;\\n    }\\n    \\n    int helper(int[][] grid,int col,int row){\\n        while(row<m){\\n            int num = grid[row][col];\\n            if(col+num<0 || col+num>=n || num!=grid[row][col+num])\\n                return -1;\\n            row++;\\n            col = col+num;\\n        }\\n        return col;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251148,
                "title": "well-explained-intuitive-c-dfs-solution",
                "content": "Every cell of the grid is divided into top and bottom parts.  Algorithm can be devised by mere observation.\\n1. If top =1 this means we are in the upper part of grid[i][j]. \\n\\t*  if grid[i][j]=1 \\n\\t\\t*  We have to go to the bottom part of right cell. If that cell is out of bounds return -1.\\n\\t\\t*  if grid[i][j+1] is not 1 then we cannot go further and are blocked. return -1\\n\\n\\t*  if grid[i][j]=-1 \\n\\t\\t*  We have to go to the bottom part of left cell. If that cell is out of bounds return -1.\\n\\t\\t*  if grid[i][j-1] is not 1 then we cannot go further and are blocked. return -1\\n\\n2. If top =0 this means we are in the lower part of grid[i][j]. In such a case no matter the value of grid[i][j] we need to go down.\\n\\n3. If we reach bottom part of last row then return column number. \\n\\n4. !top means in next function call state will change from top to bottom and vice-versa. \\n\\n```\\nclass Solution {\\npublic:\\n    int util(vector<vector<int>>&grid,bool top,int i,int j)\\n    {   \\n        if(top==0&&i==grid.size()-1)return j;\\n        if(top==1)\\n        {\\n            if(grid[i][j]==1)\\n            {   \\n                if(j+1>=grid[0].size()||grid[i][j+1]==-1)return -1;\\n                return util(grid,!top,i,j+1);\\n            }\\n            else\\n            {\\n                if(j-1<0||grid[i][j-1]==1)return -1;\\n                return util(grid,!top,i,j-1);\\n            }\\n        }\\n        else\\n        {\\n            return util(grid,!top,i+1,j);\\n        }        \\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        vector<int>ans(grid[0].size(),-1);\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            ans[i]=util(grid,true,0,i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote and share if you find the explanation useful.",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int util(vector<vector<int>>&grid,bool top,int i,int j)\\n    {   \\n        if(top==0&&i==grid.size()-1)return j;\\n        if(top==1)\\n        {\\n            if(grid[i][j]==1)\\n            {   \\n                if(j+1>=grid[0].size()||grid[i][j+1]==-1)return -1;\\n                return util(grid,!top,i,j+1);\\n            }\\n            else\\n            {\\n                if(j-1<0||grid[i][j-1]==1)return -1;\\n                return util(grid,!top,i,j-1);\\n            }\\n        }\\n        else\\n        {\\n            return util(grid,!top,i+1,j);\\n        }        \\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        vector<int>ans(grid[0].size(),-1);\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            ans[i]=util(grid,true,0,i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004545,
                "title": "javascript-simple-solution-w-explanation-beats-100-82",
                "content": "***Idea:***\\n\\nIn order to move downward, both the cell the ball enters and the one to the side following the slant must have the same slant. If they do, then the ball will follow the slant, down and over one.\\n\\nAs the cell contents conveniently imply a direction, we can simply use the cell values directly with great efficiency.\\n\\nThe best result for the code below is **72ms / 40.6MB**.\\n\\n` `\\n***Implementation:***\\n\\nWe need to iterate through all the **start** positions and then track the ball as it drops through the **grid** cells, represented by **grid[i][j]**. Since we\\'ll want to use our final value of **j** to update our **ans**, we\\'ll need to define it outside the inner **for** loop to broaden its scope.\\n\\nWe\\'ll need to iterate through the rows (**i**) and at each cell, compare the direction (**dir**) of the cell\\'s slant to that of the cell on the side following the slant. Conveniently, we can use the value of **dir** programmatically to find which cell to check (**grid[i][j+dir]**).\\n\\nIf the two cells match, then the ball moves on to the next row, shifted one cell in the **dir** of the slant. If the cells don\\'t match (which includes **j** going out of bounds) then the ball will not be able to continue downard, so we should set **j = -1** and jump to the end of this loop with **i = m**.\\n\\nOnce the ball reaches the end, we store the current **j** value in our **ans**, before ultimately returning the completed **ans**.\\n\\n` `\\n***Code (Readability):***\\n```\\nvar findBall = function(grid) {\\n    let m = grid.length,\\n        n = grid[0].length,\\n        ans = []\\n    for (let start = 0; start < n; start++) {     // Iterate through the different starting conditions\\n        let j = start\\n        for (let i = 0; i < m; i++) {             // Then iterate downward from grid[i][j]\\n            let dir = grid[i][j]                  // Compare the direction of the current cell to the direction\\n            if (dir === grid[i][j+dir]) j += dir  //   of the cell on the slant side and move that way if matched\\n            else i = m, j = -1                    // Otherwise jump to the loop\\'s end and set j to the fail value\\n        }\\n        ans[start] = j                            // Update the answer\\n    }\\n    return ans                                    // Return the completed answer\\n};\\n```\\n` `\\n***Code (Condensed):***\\n```\\nvar findBall = function(G) {\\n    let m = G.length, n = G[0].length, ans = []\\n    for (let s = 0, j = 0; s < n; ans[s] = j, j = ++s)\\n        for (let i = 0, d = G[0][j]; i < m; d = G[++i]?.[j])\\n            if (d === G[i][j+d]) j += d\\n            else i = m, j = -1\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findBall = function(grid) {\\n    let m = grid.length,\\n        n = grid[0].length,\\n        ans = []\\n    for (let start = 0; start < n; start++) {     // Iterate through the different starting conditions\\n        let j = start\\n        for (let i = 0; i < m; i++) {             // Then iterate downward from grid[i][j]\\n            let dir = grid[i][j]                  // Compare the direction of the current cell to the direction\\n            if (dir === grid[i][j+dir]) j += dir  //   of the cell on the slant side and move that way if matched\\n            else i = m, j = -1                    // Otherwise jump to the loop\\'s end and set j to the fail value\\n        }\\n        ans[start] = j                            // Update the answer\\n    }\\n    return ans                                    // Return the completed answer\\n};\\n```\n```\\nvar findBall = function(G) {\\n    let m = G.length, n = G[0].length, ans = []\\n    for (let s = 0, j = 0; s < n; ans[s] = j, j = ++s)\\n        for (let i = 0, d = G[0][j]; i < m; d = G[++i]?.[j])\\n            if (d === G[i][j+d]) j += d\\n            else i = m, j = -1\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765355,
                "title": "simple-easy-to-understand-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf block is directing ball to right and the immediate right is directing to left => V shape formed .Same if block is directing to left and immediate left has right(1) => V formed. Also if we encounter a wall on any side , ball  will get stuck there.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n- Space complexity: O(1) (ignoring space for ans vector)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\nvector<int> findBall(vector<vector<int>>& vec) {\\n        vector<int> res ;\\n        for(int i =0;i<vec[0].size();i++){\\n\\n            int  x=0,y=i;\\n            bool flag = true;\\n            while(x<vec.size()){\\n\\n                if(vec[x][y]==1){   // if block is directing ball to right\\n                 if (y+1>= vec[0].size() || vec[x][y+1]!=1){ // ball will go down only if immediate right directs right otherwise V shape formed\\n                   flag = false;\\n                   break;       }\\n                 x++,y++;\\n                }\\n\\n                else if(vec[x][y]==-1){  // if block is directing to left\\n                      if (y-1<0 || vec[x][y-1]!=-1){\\n                   flag = false;\\n                   break;       }\\n                 x++,y--;\\n                }\\n\\n            }\\n            if(flag)res.push_back(y);\\n            else\\n                res.push_back(-1);\\n\\n        }\\n           return res;\\n\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int> findBall(vector<vector<int>>& vec) {\\n        vector<int> res ;\\n        for(int i =0;i<vec[0].size();i++){\\n\\n            int  x=0,y=i;\\n            bool flag = true;\\n            while(x<vec.size()){\\n\\n                if(vec[x][y]==1){   // if block is directing ball to right\\n                 if (y+1>= vec[0].size() || vec[x][y+1]!=1){ // ball will go down only if immediate right directs right otherwise V shape formed\\n                   flag = false;\\n                   break;       }\\n                 x++,y++;\\n                }\\n\\n                else if(vec[x][y]==-1){  // if block is directing to left\\n                      if (y-1<0 || vec[x][y-1]!=-1){\\n                   flag = false;\\n                   break;       }\\n                 x++,y--;\\n                }\\n\\n            }\\n            if(flag)res.push_back(y);\\n            else\\n                res.push_back(-1);\\n\\n        }\\n           return res;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2764959,
                "title": "simple-iterative-solution-o-n-m-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> ans(m);\\n\\n        for(int ball=0; ball<m; ball++) {\\n            int i = 0, j = ball, f = 0;\\n            while(i < n) {\\n                if(grid[i][j] == 1) {\\n                    if(j == m - 1 || grid[i][j + 1] == -1) {f = 1; break;}\\n                    i++; j++;\\n                }\\n                else {\\n                    if(j == 0 || grid[i][j - 1] == 1) {f = 1; break;}\\n                    i++; j--;\\n                }\\n            }\\n            ans[ball] = f ? -1 : j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> ans(m);\\n\\n        for(int ball=0; ball<m; ball++) {\\n            int i = 0, j = ball, f = 0;\\n            while(i < n) {\\n                if(grid[i][j] == 1) {\\n                    if(j == m - 1 || grid[i][j + 1] == -1) {f = 1; break;}\\n                    i++; j++;\\n                }\\n                else {\\n                    if(j == 0 || grid[i][j - 1] == 1) {f = 1; break;}\\n                    i++; j--;\\n                }\\n            }\\n            ans[ball] = f ? -1 : j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790868,
                "title": "c-top-down-bottom-up-dp-with-explanation",
                "content": "Logic is same in both top-down and bottom-up, the only difference is in the way of traversing. \\n\\n1 in the grid represents  \\' \\\\ \\'   and -1 in th grid represents  \\' / \\'   .\\n\\nWe can observe ball will get stuck in following 3 cases:\\n\\n* when slope formed by 1 and -1 are forming a V-shaped structure , i.e  \\' \\\\/ \\' \\n* when last row index contains 1 , i.e \\' \\\\| \\'\\n* when first row index contains -1 , i.e  \\' |/ \\'\\n\\nIf the curr grid[r][c] is 1 , check its adjacent left cell if it\\'s 1 , move to the diagonal cell grid [r+1][c+1] else return -1\\n\\nIf the curr grid  is -1 , check if its adjacent right cell if it\\'s -1 , move to diagonal cell grid[r+1][c-1] else return -1\\n\\nwhen r >= row.size() return its column number as ball has left the box.\\n\\n**Bottom - up**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\t\\t\\n        vector<vector<int>>dp(m+1,vector<int>(n,-1));\\n\\t\\t\\n        for(int i = 0;i<n;i++){\\n            dp[m][i] = i;\\n        }\\n\\t\\t\\n        vector<int>res(n,0);\\n\\t\\t\\n        for(int i = m-1 ;i >= 0;i--){\\n\\t\\t\\n            for(int j = n-1;j>=0 ;j--){\\n\\t\\t\\t\\n                if(grid[i][j]==1 && j+1<n && grid[i][j+1] != -1 ){\\n\\t\\t\\t\\t\\n                    dp[i][j] = dp[i+1][j+1];\\n                }\\n                if(grid[i][j] == -1 && j-1>=0 && grid[i][j-1] != 1){\\n\\t\\t\\t\\t\\n                    dp[i][j] = dp[i+1][j-1];\\n                }\\n\\t\\t\\t\\t\\n                res[j] = dp[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Top - down **\\n```\\nclass Solution {\\npublic:\\n    int recursion(vector<vector<int>>&grid, int &m , int &n , vector<vector<int>>&memo,int i , int j){\\n        if(i>=m)return j;\\n        \\n        if(memo[i][j] != -2)return memo[i][j];\\n        \\n        int col = -1;\\n        \\n        if(grid[i][j] == 1 && j + 1 < n && grid[i][j+1] != -1){\\n            \\n            col = recursion(grid,m , n ,memo, i+1, j+1);\\n            \\n        }\\n        if(grid[i][j] == -1 && j-1>=0 && grid[i][j-1] != 1){\\n            \\n            col = recursion(grid,m , n , memo, i+1, j-1);\\n            \\n        } \\n        \\n        return memo[i][j] = col;\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<int>res(n,0);\\n        vector<vector<int>>memo(m,vector<int>(n,-2));\\n        \\n        for(int i = 0;i<n;i++){\\n            \\n            res[i] = recursion(grid,m,n,memo,0,i);\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\t\\t\\n        vector<vector<int>>dp(m+1,vector<int>(n,-1));\\n\\t\\t\\n        for(int i = 0;i<n;i++){\\n            dp[m][i] = i;\\n        }\\n\\t\\t\\n        vector<int>res(n,0);\\n\\t\\t\\n        for(int i = m-1 ;i >= 0;i--){\\n\\t\\t\\n            for(int j = n-1;j>=0 ;j--){\\n\\t\\t\\t\\n                if(grid[i][j]==1 && j+1<n && grid[i][j+1] != -1 ){\\n\\t\\t\\t\\t\\n                    dp[i][j] = dp[i+1][j+1];\\n                }\\n                if(grid[i][j] == -1 && j-1>=0 && grid[i][j-1] != 1){\\n\\t\\t\\t\\t\\n                    dp[i][j] = dp[i+1][j-1];\\n                }\\n\\t\\t\\t\\t\\n                res[j] = dp[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195032,
                "title": "c-simple-code-with-video",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[105][105];\\n    int n,m;\\n    bool isValid(int x, int y){\\n        return (x>=0 && x<n && y>=0 && y<m);\\n    }\\n    \\n    int ok(vector<vector<int>>& grid , int r, int c){\\n        if(r==n) return c;\\n        if(isValid(r,c)){\\n            if(grid[r][c]==1 && isValid(r,c+1) && grid[r][c+1]==1){\\n                if(dp[r+1][c+1]!=-2) return dp[r+1][c+1];\\n                else{\\n                    return dp[r+1][c+1] = ok(grid,r+1,c+1);\\n                }\\n            } \\n            if(grid[r][c]==-1 && isValid(r,c-1) && grid[r][c-1]==-1){\\n                if(dp[r+1][c-1]!=-2) return dp[r+1][c-1];\\n                else{\\n                    return dp[r+1][c-1] = ok(grid,r+1,c-1);\\n                }\\n            } \\n        }\\n        return -1;\\n    }\\n    \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        for(int i=0;i<=101;i++){\\n            for(int j=0;j<=101;j++) dp[i][j]=-2;\\n        }\\n        vector<int>ans(m);\\n        for(int i=0;i<m;i++){\\n            ans[i]=ok(grid,0,i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[105][105];\\n    int n,m;\\n    bool isValid(int x, int y){\\n        return (x>=0 && x<n && y>=0 && y<m);\\n    }\\n    \\n    int ok(vector<vector<int>>& grid , int r, int c){\\n        if(r==n) return c;\\n        if(isValid(r,c)){\\n            if(grid[r][c]==1 && isValid(r,c+1) && grid[r][c+1]==1){\\n                if(dp[r+1][c+1]!=-2) return dp[r+1][c+1];\\n                else{\\n                    return dp[r+1][c+1] = ok(grid,r+1,c+1);\\n                }\\n            } \\n            if(grid[r][c]==-1 && isValid(r,c-1) && grid[r][c-1]==-1){\\n                if(dp[r+1][c-1]!=-2) return dp[r+1][c-1];\\n                else{\\n                    return dp[r+1][c-1] = ok(grid,r+1,c-1);\\n                }\\n            } \\n        }\\n        return -1;\\n    }\\n    \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        for(int i=0;i<=101;i++){\\n            for(int j=0;j<=101;j++) dp[i][j]=-2;\\n        }\\n        vector<int>ans(m);\\n        for(int i=0;i<m;i++){\\n            ans[i]=ok(grid,0,i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989663,
                "title": "python-clear-solution-with-video-explanation",
                "content": "Video with clear visualization and explanation:\\nhttps://youtu.be/HeGDdUvNDNc\\n\\nIntuition: Straight Implementation\\n\\n\\n**Code**\\nInspired by https://leetcode.com/problems/where-will-the-ball-fall/discuss/988156/PythonC%2B%2B-let-the-balls-fall-row-by-row-O(MN)\\n\\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        n_r, n_c = len(grid), len(grid[0])\\n        answer = list(range(n_c))\\n        \\n        for r in range(n_r):\\n            for i in range(n_c):\\n                c = answer[i]\\n                if c == -1: continue\\n                c_nxt = c+grid[r][c]\\n                if c_nxt < 0 or c_nxt >= n_c or grid[r][c_nxt] == -grid[r][c]:\\n                    answer[i] = -1\\n                    continue\\n                answer[i] += grid[r][c]\\n        \\n        return answer\\n```\\n\\nTime: O(m*n) / Space: O(1)\\n\\n\\nFeel free to subscribe to my channel. More LeetCoding videos coming up!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        n_r, n_c = len(grid), len(grid[0])\\n        answer = list(range(n_c))\\n        \\n        for r in range(n_r):\\n            for i in range(n_c):\\n                c = answer[i]\\n                if c == -1: continue\\n                c_nxt = c+grid[r][c]\\n                if c_nxt < 0 or c_nxt >= n_c or grid[r][c_nxt] == -grid[r][c]:\\n                    answer[i] = -1\\n                    continue\\n                answer[i] += grid[r][c]\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988156,
                "title": "python-c-let-the-balls-fall-row-by-row-o-mn",
                "content": "**Idea**\\n\\nWe simply let the balls fall row by row. At each row, we check if each ball gets stuck or not.\\n\\n\\n</br>\\n\\n**Complexity**\\n\\n- Time complexity: `O(MN)`\\n- Space complexity: `O(N)`, or `O(1)` extra\\n\\n</br>\\n\\n**Python**\\n\\n```Python\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        ans = list(range(n))\\n        \\n        for r in range(m):\\n            for i in range(n):\\n                c = ans[i]\\n                if c == -1: continue\\n                # check stuck\\n                nxt_c = c + grid[r][c]\\n                if nxt_c < 0 or nxt_c >= n or grid[r][nxt_c] == -grid[r][c]:\\n                    ans[i] = -1\\n                    continue\\n                ans[i] += grid[r][c]\\n        \\n        return ans\\n```\\n\\n</br>\\n\\n**C++**\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> ans(n);\\n        iota(ans.begin(), ans.end(), 0);\\n        \\n        for (int r = 0; r < m; ++r) {\\n            for (int i = 0; i < n; ++i) {\\n                int c = ans[i];\\n                if (c == -1) continue;\\n                // check stuck\\n                int nxt_c = c + grid[r][c];\\n                if (nxt_c < 0 || nxt_c >= n || grid[r][nxt_c] == -grid[r][c]) {\\n                    ans[i] = -1;\\n                    continue;\\n                }\\n                ans[i] = ans[i] + grid[r][c];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        ans = list(range(n))\\n        \\n        for r in range(m):\\n            for i in range(n):\\n                c = ans[i]\\n                if c == -1: continue\\n                # check stuck\\n                nxt_c = c + grid[r][c]\\n                if nxt_c < 0 or nxt_c >= n or grid[r][nxt_c] == -grid[r][c]:\\n                    ans[i] = -1\\n                    continue\\n                ans[i] += grid[r][c]\\n        \\n        return ans\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> ans(n);\\n        iota(ans.begin(), ans.end(), 0);\\n        \\n        for (int r = 0; r < m; ++r) {\\n            for (int i = 0; i < n; ++i) {\\n                int c = ans[i];\\n                if (c == -1) continue;\\n                // check stuck\\n                int nxt_c = c + grid[r][c];\\n                if (nxt_c < 0 || nxt_c >= n || grid[r][nxt_c] == -grid[r][c]) {\\n                    ans[i] = -1;\\n                    continue;\\n                }\\n                ans[i] = ans[i] + grid[r][c];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716934,
                "title": "most-intuitive-solution-you-will-ever-find-beats-90",
                "content": "# Intuition\\nAt first, it looked tricky to me, but as I broke it down to most simple blocks, I realised it is pretty easy when we think of it as simple dfs calls of going down, right and left with some additional simple if elses!!\\n\\n# Approach\\nWe have three directions to go in.\\n1) **Down** -> if the current block is marked as \\'1\\' we have the flexibilty of going to right. else we can go left.\\n\\n2) **Right** -> If the block we are heading to is marked as \\'1\\' we can only move in this condtion or else the ball will get stuck.\\n\\n3) **Left** -> Similar to right one, try understanding yourself.\\n\\n# Complexity\\n- Time complexity:\\n- O(mn)\\n\\n- Space complexity:\\n  O(n) + recursion stack space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//0->down 1->right 2->left\\nint dfs(vector<vector<int>>& grid, int r, int c, int m, int n,int dir){\\n    //base case at the end\\n    if(r==m) return c;\\n\\n\\n    if(dir==0){                                 //coming from top to down\\n        if(grid[r][c]==1){    //right direct\\n            if(c==n-1) return -1;\\n\\n\\n            else return dfs(grid,r,c+1,m,n,1);\\n        }\\n\\n        else if(grid[r][c]==-1){   //directing to left\\n            if(c==0) return -1;\\n\\n            else return dfs(grid,r,c-1,m,n,2);\\n        }\\n    }\\n\\n    else if(dir==1){             //coming from right to left\\n        //it can either go down, or get stuck. so two conditions.\\n\\n        if(grid[r][c]==-1) return -1;\\n\\n        else if(grid[r][c]==1) return dfs(grid,r+1,c,m,n,0);\\n    }\\n\\n    else if(dir==2){             //coming from left to right\\n        if(grid[r][c]==1) return -1;\\n\\n        else if(grid[r][c]==-1) return dfs(grid,r+1,c,m,n,0);\\n    }\\n    return -1;\\n}\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> ans(n);\\n        for(int col=0;col<n;col++){\\n            ans[col] = dfs(grid, 0, col, m,n,0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//0->down 1->right 2->left\\nint dfs(vector<vector<int>>& grid, int r, int c, int m, int n,int dir){\\n    //base case at the end\\n    if(r==m) return c;\\n\\n\\n    if(dir==0){                                 //coming from top to down\\n        if(grid[r][c]==1){    //right direct\\n            if(c==n-1) return -1;\\n\\n\\n            else return dfs(grid,r,c+1,m,n,1);\\n        }\\n\\n        else if(grid[r][c]==-1){   //directing to left\\n            if(c==0) return -1;\\n\\n            else return dfs(grid,r,c-1,m,n,2);\\n        }\\n    }\\n\\n    else if(dir==1){             //coming from right to left\\n        //it can either go down, or get stuck. so two conditions.\\n\\n        if(grid[r][c]==-1) return -1;\\n\\n        else if(grid[r][c]==1) return dfs(grid,r+1,c,m,n,0);\\n    }\\n\\n    else if(dir==2){             //coming from left to right\\n        if(grid[r][c]==1) return -1;\\n\\n        else if(grid[r][c]==-1) return dfs(grid,r+1,c,m,n,0);\\n    }\\n    return -1;\\n}\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n\\n        vector<int> ans(n);\\n        for(int col=0;col<n;col++){\\n            ans[col] = dfs(grid, 0, col, m,n,0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767563,
                "title": "java-simple-while-loop",
                "content": "The code is readable. A simple while loop is enough.\\nNo need for DFS to pollute the call stack.\\n\\n![image](https://assets.leetcode.com/users/images/1aa39ce6-d0d3-4a8c-a5ca-5a9464302dca_1667320373.7652721.png)\\n\\n\\n```\\nclass Solution {\\n    private int[][] grid;\\n    private int m;\\n    private int n;\\n\\n    public int[] findBall(int[][] grid) {\\n        this.grid = grid;\\n        m = grid.length;\\n        n = grid[0].length;\\n\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            res[i] = calculateExitIndex(i);\\n        }\\n\\n        return res;\\n    }\\n\\n    public int calculateExitIndex(int startingColumn) {\\n        int row = 0;\\n        int column = startingColumn;\\n\\n        while (row < m) {\\n            if (grid[row][column] == 1) {\\n                if (column == n - 1 || grid[row][column + 1] == -1) return -1;\\n                row++;\\n                column++;\\n                continue;\\n            }\\n\\n            if (grid[row][column] == -1) {\\n                if (column == 0 || grid[row][column - 1] == 1) return -1;\\n                row++;\\n                column--;\\n                continue;\\n            }\\n        }\\n\\n        return column;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[][] grid;\\n    private int m;\\n    private int n;\\n\\n    public int[] findBall(int[][] grid) {\\n        this.grid = grid;\\n        m = grid.length;\\n        n = grid[0].length;\\n\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            res[i] = calculateExitIndex(i);\\n        }\\n\\n        return res;\\n    }\\n\\n    public int calculateExitIndex(int startingColumn) {\\n        int row = 0;\\n        int column = startingColumn;\\n\\n        while (row < m) {\\n            if (grid[row][column] == 1) {\\n                if (column == n - 1 || grid[row][column + 1] == -1) return -1;\\n                row++;\\n                column++;\\n                continue;\\n            }\\n\\n            if (grid[row][column] == -1) {\\n                if (column == 0 || grid[row][column - 1] == 1) return -1;\\n                row++;\\n                column--;\\n                continue;\\n            }\\n        }\\n\\n        return column;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765461,
                "title": "easy-python-soluton-o-mxn-comments",
                "content": "Time Complexity  - O(mxn)\\nRuntime - 202ms , \\nMemory  - 14.6MB\\n\\nConcept:\\nIf a ball get out of the box i.e., row==len(grid), we just return the column. if the new column is already out of the box or the next cell doesn\\'t equal to grid[row][col] the ball will get stuck and we just return -1\\n\\n*(Upvote if it was helpful)*\\n\\n```\\nclass Solution:\\ndef findBall(self, grid: List[List[int]]) -> List[int]:\\nm,n = len(grid),len(grid[0])\\ndef check(row,col):\\n### If a ball get out of the box, return col\\nif row==m:\\nreturn col\\n\\n### note that since grid contains 1 and -1 representing to right and to left, \\n### we can just add the grid[row][col] to current collumn to get the new column\\nnew_col = col+grid[row][col]\\n\\n### if the new column is already out of the box \\n### or the neighbor cell doesn\\'t equal to grid[row][col] \\n### the ball will get stuck and we just return -1\\nif new_col==n or new_col==-1 or grid[row][new_col]!=grid[row][col]:\\nreturn -1\\nelse:\\nreturn check(row+1,new_col)\\nres = []\\nfor i in range(n):\\nres.append(check(0,i))\\nreturn res\\n```\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\ndef findBall(self, grid: List[List[int]]) -> List[int]:\\nm,n = len(grid),len(grid[0])\\ndef check(row,col):\\n### If a ball get out of the box, return col\\nif row==m:\\nreturn col\\n\\n### note that since grid contains 1 and -1 representing to right and to left, \\n### we can just add the grid[row][col] to current collumn to get the new column\\nnew_col = col+grid[row][col]\\n\\n### if the new column is already out of the box \\n### or the neighbor cell doesn\\'t equal to grid[row][col] \\n### the ball will get stuck and we just return -1\\nif new_col==n or new_col==-1 or grid[row][new_col]!=grid[row][col]:\\nreturn -1\\nelse:\\nreturn check(row+1,new_col)\\nres = []\\nfor i in range(n):\\nres.append(check(0,i))\\nreturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765220,
                "title": "smart-solution",
                "content": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        lev=0\\n        m=len(grid)\\n        n=len(grid[0])\\n        ans=[-1]*n\\n        for x in range(n):\\n            i=0\\n            j=x\\n            a=grid[i][j]\\n            while(i<m and 0<=j<n):\\n                a=grid[i][j]\\n                if(not 0<=j+a<n):\\n                    break\\n                a2=grid[i][j+a]\\n                if(0<=j+a<n and a*a2>0):\\n                    j+=a\\n                    i+=1\\n                else:\\n                    break\\n            if(i==m and 0<=j<n):\\n                ans[x]=j\\n        return(ans)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        lev=0\\n        m=len(grid)\\n        n=len(grid[0])\\n        ans=[-1]*n\\n        for x in range(n):\\n            i=0\\n            j=x\\n            a=grid[i][j]\\n            while(i<m and 0<=j<n):\\n                a=grid[i][j]\\n                if(not 0<=j+a<n):\\n                    break\\n                a2=grid[i][j+a]\\n                if(0<=j+a<n and a*a2>0):\\n                    j+=a\\n                    i+=1\\n                else:\\n                    break\\n            if(i==m and 0<=j<n):\\n                ans[x]=j\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764942,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n// Upvote If You Like\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(int i,int j,int m,int n,vector<vector<int>> &grid)\\n    {\\n        if(i==m)\\n        {\\n            if(j>=0&&j<n)\\n            {\\n                ans.push_back(j);\\n                return ;\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n                return ;\\n            }\\n        }\\n        if((grid[i][j]==1&&j==n-1)||(grid[i][j]==-1&&j==0))\\n        {\\n            ans.push_back(-1);\\n            return ;\\n        }\\n        if((grid[i][j]==1&&grid[i][j+1]==-1)||(grid[i][j]==-1&&grid[i][j-1]==1))\\n        {\\n            ans.push_back(-1);\\n            return;\\n        }\\n        if(grid[i][j]==1)\\n        {\\n            dfs(i+1,j+1,m,n,grid);\\n        }\\n        else\\n        {\\n            dfs(i+1,j-1,m,n,grid);\\n        }\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int j=0;j<n;j++)\\n        {\\n            dfs(0,j,m,n,grid);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n// Upvote If You Like\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(int i,int j,int m,int n,vector<vector<int>> &grid)\\n    {\\n        if(i==m)\\n        {\\n            if(j>=0&&j<n)\\n            {\\n                ans.push_back(j);\\n                return ;\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n                return ;\\n            }\\n        }\\n        if((grid[i][j]==1&&j==n-1)||(grid[i][j]==-1&&j==0))\\n        {\\n            ans.push_back(-1);\\n            return ;\\n        }\\n        if((grid[i][j]==1&&grid[i][j+1]==-1)||(grid[i][j]==-1&&grid[i][j-1]==1))\\n        {\\n            ans.push_back(-1);\\n            return;\\n        }\\n        if(grid[i][j]==1)\\n        {\\n            dfs(i+1,j+1,m,n,grid);\\n        }\\n        else\\n        {\\n            dfs(i+1,j-1,m,n,grid);\\n        }\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int j=0;j<n;j++)\\n        {\\n            dfs(0,j,m,n,grid);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749548,
                "title": "js-simple-solution",
                "content": "var findBall = function(grid) {\\n    let arr = [];\\n    let colLength = grid.length;\\n    let rowLength = grid[0].length ;\\n    let tmpRow = 0\\n    while(tmpRow < rowLength){\\n        let pos = tmpRow;\\n        let tmpCol = 0;\\n        while(tmpCol < colLength){\\n            let check = checkCell(grid[tmpCol], pos);\\n            if(check === 0){\\n                pos = -1;\\n                break;\\n            }\\n            pos += check;\\n            tmpCol++;\\n        }\\n        arr.push(pos);\\n        tmpRow++\\n    }\\n    return arr;\\n};\\n\\nvar checkCell = function(row, index){\\n    \\n    if(row[index] === 1 && index+1 < row.length && row[index+1] === 1){\\n        return 1\\n    }\\n     if(row[index] === -1 && index-1 >= 0 && row[index-1] === -1){\\n        return -1\\n    }\\n    return 0\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var findBall = function(grid) {\\n    let arr = [];\\n    let colLength = grid.length;\\n    let rowLength = grid[0].length ;\\n    let tmpRow = 0\\n    while(tmpRow < rowLength){\\n        let pos = tmpRow;\\n        let tmpCol = 0;\\n        while(tmpCol < colLength){\\n            let check = checkCell(grid[tmpCol], pos);\\n            if(check === 0){\\n                pos = -1;\\n                break;\\n            }\\n            pos += check;\\n            tmpCol++;\\n        }\\n        arr.push(pos);\\n        tmpRow++\\n    }\\n    return arr;\\n};\\n\\nvar checkCell = function(row, index){\\n    \\n    if(row[index] === 1 && index+1 < row.length && row[index+1] === 1){\\n        return 1\\n    }\\n     if(row[index] === -1 && index-1 >= 0 && row[index-1] === -1){\\n        return -1\\n    }\\n    return 0\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2254418,
                "title": "c-dfs-tc-o-n-m-sc-o-m",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<int>>& grid,int i,int j,int row,int col){\\n            \\n        if(grid[i][j]==1){\\n            if(j+1 == col || grid[i][j+1]==-1) return -1;\\n            \\n            if(i+1<row && j+1<col) return dfs(grid,i+1,j+1,row,col);\\n        }\\n        \\n        if(grid[i][j]==-1){\\n            if(j == 0  || grid[i][j-1]==1) return -1;\\n            \\n            if(i+1<row && j>0) return dfs(grid,i+1,j-1,row,col);\\n        }\\n        \\n        return grid[i][j]==1?j+1:j-1;\\n        \\n        \\n    }\\n    \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        \\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        vector<int> ans(col,-1);\\n        \\n        for(int i=0;i<col;i++){\\n            ans[i]=dfs(grid,0,i,row,col);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<int>>& grid,int i,int j,int row,int col){\\n            \\n        if(grid[i][j]==1){\\n            if(j+1 == col || grid[i][j+1]==-1) return -1;\\n            \\n            if(i+1<row && j+1<col) return dfs(grid,i+1,j+1,row,col);\\n        }\\n        \\n        if(grid[i][j]==-1){\\n            if(j == 0  || grid[i][j-1]==1) return -1;\\n            \\n            if(i+1<row && j>0) return dfs(grid,i+1,j-1,row,col);\\n        }\\n        \\n        return grid[i][j]==1?j+1:j-1;\\n        \\n        \\n    }\\n    \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        \\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        vector<int> ans(col,-1);\\n        \\n        for(int i=0;i<col;i++){\\n            ans[i]=dfs(grid,0,i,row,col);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234238,
                "title": "simple-c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n         vector<int> findBall(vector<vector<int>>& grid) \\n        {    \\n        int row = grid.size(), col = grid[0].size();\\n        vector<int>result;\\n\\t\\tfor(int i = 0;i<col;i++)\\n\\t\\tresult[i] = -1;\\n        \\n        if(row == 1 and col == 1)\\n            return result;\\n        \\n        for(int i = 0; i<col; i++)\\n        {\\n            int r = 0, c = i;\\n            \\n            while(r>=0 and c>=0 and r<row and c<col)\\n            {\\n                if(grid[r][c] == 1)\\n                {\\n                    if(c+1<col and grid[r][c+1] == -1)\\n                        break;\\n                    \\n                    c++;\\n                }\\n                else\\n                {\\n                    if(c-1>=0 and grid[r][c-1] == 1)\\n                            break;\\n                    \\n                    c--;\\n                }\\n                \\n                r++;\\n            }\\n            \\n            if(r == row)\\n               result[i] = c;\\n        }\\n        \\n        return result;   \\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n         vector<int> findBall(vector<vector<int>>& grid) \\n        {    \\n        int row = grid.size(), col = grid[0].size();\\n        vector<int>result;\\n\\t\\tfor(int i = 0;i<col;i++)\\n\\t\\tresult[i] = -1;\\n        \\n        if(row == 1 and col == 1)\\n            return result;\\n        \\n        for(int i = 0; i<col; i++)\\n        {\\n            int r = 0, c = i;\\n            \\n            while(r>=0 and c>=0 and r<row and c<col)\\n            {\\n                if(grid[r][c] == 1)\\n                {\\n                    if(c+1<col and grid[r][c+1] == -1)\\n                        break;\\n                    \\n                    c++;\\n                }\\n                else\\n                {\\n                    if(c-1>=0 and grid[r][c-1] == 1)\\n                            break;\\n                    \\n                    c--;\\n                }\\n                \\n                r++;\\n            }\\n            \\n            if(r == row)\\n               result[i] = c;\\n        }\\n        \\n        return result;   \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767852,
                "title": "c-recursion-dfs-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j, vector<vector<int>>& grid){\\n        if(i >= grid.size())\\n        {\\n            return j;\\n        }\\n        //left to right\\n        if(grid[i][j] == 1 && j+1<grid[0].size() && grid[i][j+1] == 1){\\n            return dfs(i+1,j+1,grid);\\n        }\\n        //right to left\\n        else if(grid[i][j] == -1 && j-1>=0 && grid[i][j-1] == -1){\\n            return dfs(i+1,j-1,grid);\\n        }\\n        else if(grid[i][j] == 1 && j+1 >= grid[0].size())\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return -1;\\n        }\\n        \\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<int> ans(col);\\n        for(int j=0;j<col;j++){\\n            ans[j] = dfs(0,j,grid);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j, vector<vector<int>>& grid){\\n        if(i >= grid.size())\\n        {\\n            return j;\\n        }\\n        //left to right\\n        if(grid[i][j] == 1 && j+1<grid[0].size() && grid[i][j+1] == 1){\\n            return dfs(i+1,j+1,grid);\\n        }\\n        //right to left\\n        else if(grid[i][j] == -1 && j-1>=0 && grid[i][j-1] == -1){\\n            return dfs(i+1,j-1,grid);\\n        }\\n        else if(grid[i][j] == 1 && j+1 >= grid[0].size())\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return -1;\\n        }\\n        \\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<int> ans(col);\\n        for(int j=0;j<col;j++){\\n            ans[j] = dfs(0,j,grid);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767846,
                "title": "java-grid-iteration",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[] ans = new int[n];\\n\\n        for (int col = 0; col < n; col++) {\\n            int curr = col;\\n\\n            for (int row = 0; row < m; row++) {\\n                int next = curr + grid[row][curr];\\n\\n                if (next < 0 || next >= n || grid[row][curr] != grid[row][next]) {\\n                    curr = -1;\\n                    break;\\n                }\\n\\n                curr = next;\\n            }\\n\\n            ans[col] = curr;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[] ans = new int[n];\\n\\n        for (int col = 0; col < n; col++) {\\n            int curr = col;\\n\\n            for (int row = 0; row < m; row++) {\\n                int next = curr + grid[row][curr];\\n\\n                if (next < 0 || next >= n || grid[row][curr] != grid[row][next]) {\\n                    curr = -1;\\n                    break;\\n                }\\n\\n                curr = next;\\n            }\\n\\n            ans[col] = curr;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766835,
                "title": "c-solution-dfs-explained",
                "content": "**starIf you found this solution helpful please upvote\\u2B50\\n**\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<int>>& grid){\\n        //if i(row) is greater than the size of grid it means we are already out of the grid so we return the respective col\\n        if(i >= grid.size()) return j;\\n        \\n        //to check left to right\\n        //if there are two consecutive 1 present in the grid then only a ball can move downward\\n        if(grid[i][j] == 1 && j+1 < grid[0].size() && grid[i][j+1] == 1)\\n            return dfs(i+1, j+1, grid);\\n        \\n        //to check right to left\\n        //if there are two -1 present in the grid then only a ball can move downward\\n        else if(grid[i][j] == -1 && j-1 >= 0 && grid[i][j-1] == -1)\\n            return dfs(i+1, j-1, grid);\\n        \\n        //else the ball will get stuck in the grid\\n        else return -1;\\n    }\\n    \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        //as number of balls are equal to the cols of the given grid so we initiate a vector of size cols\\n        vector<int> ans(cols);\\n        for(int i=0; i<cols; i++){\\n            //for every ball we calculate their col from which they escape the grid\\n            ans[i] = dfs(0, i, grid);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<int>>& grid){\\n        //if i(row) is greater than the size of grid it means we are already out of the grid so we return the respective col\\n        if(i >= grid.size()) return j;\\n        \\n        //to check left to right\\n        //if there are two consecutive 1 present in the grid then only a ball can move downward\\n        if(grid[i][j] == 1 && j+1 < grid[0].size() && grid[i][j+1] == 1)\\n            return dfs(i+1, j+1, grid);\\n        \\n        //to check right to left\\n        //if there are two -1 present in the grid then only a ball can move downward\\n        else if(grid[i][j] == -1 && j-1 >= 0 && grid[i][j-1] == -1)\\n            return dfs(i+1, j-1, grid);\\n        \\n        //else the ball will get stuck in the grid\\n        else return -1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2766786,
                "title": "november-potd-day-1-eazy-understanding-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        \\n        int r=grid.size();\\n        int c=grid[0].size();\\n        vector<int> ans(c,0);  //initiallizing a vector of size as column and value 0\\n        for(int k=0;k<c;++k){       //loop for each ball starting from 0 -> c-1\\n            int ball=k;\\n            bool flag=0;\\n            for(int i =0;i<r;++i){\\n                \\n                if((grid[i][ball]==1 && ball+1 == c)||(grid[i][ball]==1&&(grid[i][ball+1]==-1))||(grid[i][ball]==-1 && ball-1 ==-1)||(grid[i][ball]==-1 &&grid[i][ball-1]==1)){\\n                    ans[k]=-1;\\n                    flag=1;\\n                    break;   // if its a dead end for the ball we need to terminate the loop\\n                    \\n                }else if(grid[i][ball]==1){\\n\\n                ball++;\\n                }else{\\n                    ball--;\\n                }\\n                \\n            }\\n            if(flag==1){    //if the flag is set to 1 that means the ball is set to a dead end we have already set the value of ans of ball\\n                continue;\\n            }else{\\n            ans[k]=ball;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        \\n        int r=grid.size();\\n        int c=grid[0].size();\\n        vector<int> ans(c,0);  //initiallizing a vector of size as column and value 0\\n        for(int k=0;k<c;++k){       //loop for each ball starting from 0 -> c-1\\n            int ball=k;\\n            bool flag=0;\\n            for(int i =0;i<r;++i){\\n                \\n                if((grid[i][ball]==1 && ball+1 == c)||(grid[i][ball]==1&&(grid[i][ball+1]==-1))||(grid[i][ball]==-1 && ball-1 ==-1)||(grid[i][ball]==-1 &&grid[i][ball-1]==1)){\\n                    ans[k]=-1;\\n                    flag=1;\\n                    break;   // if its a dead end for the ball we need to terminate the loop\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2766780,
                "title": "java-solution-easy-faster-than-96-8-1ms-runtime",
                "content": "```java \\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int[] res = new int[grid[0].length];\\n        for(int j=0;j<grid[0].length;j++)\\n        {\\n            res[j]=solve(grid,j);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    private int solve(int[][] grid,int j)\\n    {\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            if(j<grid[0].length-1 && grid[i][j]==1 && grid[i][j+1]==1){\\n                j++;\\n            } \\n            else if(j>0 && grid[i][j]==-1 && grid[i][j-1]==-1){\\n                j--;\\n            }\\n            else\\n                return -1;\\n        }\\n        return j;\\n    }\\n}",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "class Solution {\\n    public int[] findBall(int[][] grid) {\\n        int[] res = new int[grid[0].length];\\n        for(int j=0;j<grid[0].length;j++)\\n        {\\n            res[j]=solve(grid,j);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2766148,
                "title": "rust-two-one-liners-bonus-solution-with-comments",
                "content": "One-liner challenge accepted! :D Just to be clear, what I mean by a one-liner in this context is a solution with no statements. This is a simulation-based solution, so we update the ball postions by iterating over the rows to update the position for each row. First exclude all the cases where the ball is stuck:\\n\\n1. It is already stuck.\\n2. The ball is in the first column and the cell leads left.\\n3. The ball is in the last column and the cell leads right.\\n4. The cell leads in a direction that is opposite to the adjacent cell in that direction.\\n\\nWith these cases out of the way, we can update the position of the ball according to the direction of the cell.\\n\\nFor the first one-liner, we make use of `Option`s to encode when the ball is stuck with `None`. And we use `wrapping_add` together with `!0` as the `usize` equivalent of `-1` to simplify the detection of when the ball falls outside the grid:\\n\\n```\\nimpl Solution {\\n    pub fn find_ball(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        (0..grid[0].len()).map(|col| (0..grid.len()).fold(Some(col), |col_opt, row|\\n            col_opt.and_then(|col| match col.wrapping_add(if grid[row][col] == 1 { 1 } else { !0 }) {\\n                next_col if next_col >= grid[0].len() => None,\\n                next_col if grid[row][col] != grid[row][next_col] => None,\\n                next_col => Some(next_col)\\n            }\\n        )).map_or(-1, |col| col as i32)).collect()\\n    }\\n}\\n```\\n\\nFor the second one-liner, we evaluate the conditions above in a more straight-forward manner, and process all balls before moving on to the next row:\\n\\n```\\nimpl Solution {\\n    pub fn find_ball(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        grid.iter().fold((0..grid[0].len() as i32).collect::<Vec<_>>(), |positions, row| {\\n            positions.into_iter().map(|col| {\\n                if col == -1 || (col == 0 && row[0] == -1) || (col as usize == grid[0].len() - 1 && row[col as usize] == 1)\\n                    || (row[col as usize] != row[((col + row[col as usize]) as usize)]) {\\n                    -1\\n                } else {\\n                    col + row[((col + row[col as usize]) as usize)]    \\n                }\\n            }).collect()\\n        })\\n    }\\n}\\n```\\n\\nI made another experiment as well, which was a nice exercise, albeit not that concise. :) Instead of encoding the state as the current column of each ball, we encode it as the ball that currently occupies a specific column. We use a windowed iterator (created with `scan`) with 1 and -1 prepended and appended, respectively, to facilitate the treatment of the boundary conditions. With this approach, we can use a straight-forward `match` to update the position of the ball currently present in the corresponding column, if any. At the end, we have to recode to state to the requested output format.\\n\\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn find_ball(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        let n = grid[0].len();\\n       grid.iter().fold((0..n as i32).collect::<Vec<_>>(), |prev_balls, row| {\\n            row.iter().copied().chain(once(-1)).skip(1).enumerate().scan((1, row[0]), |(prev, curr), (col, next)| {\\n                let rez = Some((col, *prev, *curr, next));\\n                *prev = *curr;\\n                *curr = next;\\n                rez\\n            }).fold(vec![-1; n], |mut next_balls, (col, prev, curr, next)| {\\n                match (prev_balls[col], prev, curr, next) {\\n                    (-1, _, _, _) => (),\\n                    (ball, _, 1, 1) => next_balls[col + 1] = ball,\\n                    (ball, -1, -1, _) => next_balls[col - 1] = ball,\\n                    _ => (),\\n                }\\n                next_balls\\n            })\\n        }).into_iter().enumerate().fold(vec![-1; n], |mut positions, (position, ball)| {\\n            if ball >= 0 {\\n                positions[ball as usize] = position as i32;\\n            }\\n            positions\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_ball(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        (0..grid[0].len()).map(|col| (0..grid.len()).fold(Some(col), |col_opt, row|\\n            col_opt.and_then(|col| match col.wrapping_add(if grid[row][col] == 1 { 1 } else { !0 }) {\\n                next_col if next_col >= grid[0].len() => None,\\n                next_col if grid[row][col] != grid[row][next_col] => None,\\n                next_col => Some(next_col)\\n            }\\n        )).map_or(-1, |col| col as i32)).collect()\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn find_ball(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        grid.iter().fold((0..grid[0].len() as i32).collect::<Vec<_>>(), |positions, row| {\\n            positions.into_iter().map(|col| {\\n                if col == -1 || (col == 0 && row[0] == -1) || (col as usize == grid[0].len() - 1 && row[col as usize] == 1)\\n                    || (row[col as usize] != row[((col + row[col as usize]) as usize)]) {\\n                    -1\\n                } else {\\n                    col + row[((col + row[col as usize]) as usize)]    \\n                }\\n            }).collect()\\n        })\\n    }\\n}\\n```\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn find_ball(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        let n = grid[0].len();\\n       grid.iter().fold((0..n as i32).collect::<Vec<_>>(), |prev_balls, row| {\\n            row.iter().copied().chain(once(-1)).skip(1).enumerate().scan((1, row[0]), |(prev, curr), (col, next)| {\\n                let rez = Some((col, *prev, *curr, next));\\n                *prev = *curr;\\n                *curr = next;\\n                rez\\n            }).fold(vec![-1; n], |mut next_balls, (col, prev, curr, next)| {\\n                match (prev_balls[col], prev, curr, next) {\\n                    (-1, _, _, _) => (),\\n                    (ball, _, 1, 1) => next_balls[col + 1] = ball,\\n                    (ball, -1, -1, _) => next_balls[col - 1] = ball,\\n                    _ => (),\\n                }\\n                next_balls\\n            })\\n        }).into_iter().enumerate().fold(vec![-1; n], |mut positions, (position, ball)| {\\n            if ball >= 0 {\\n                positions[ball as usize] = position as i32;\\n            }\\n            positions\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2766058,
                "title": "go-solution",
                "content": "```\\nfunc walk(grid [][]int, x, y int) int {\\n\\tif y == len(grid) {\\n\\t\\treturn x\\n\\t}\\n\\tif grid[y][x] == 1 {\\n\\t\\tif x == len(grid[y])-1 || grid[y][x+1] == -1 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\treturn walk(grid, x+1, y+1)\\n\\t}\\n\\tif x == 0 || grid[y][x-1] == 1 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn walk(grid, x-1, y+1)\\n}\\n\\nfunc findBall(grid [][]int) []int {\\n\\tvar (\\n\\t\\tanswer = make([]int, len(grid[0]))\\n\\t)\\n\\tfor i := 0; i < len(answer); i++ {\\n\\t\\tanswer[i] = walk(grid, i, 0)\\n\\t}\\n\\treturn answer\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc walk(grid [][]int, x, y int) int {\\n\\tif y == len(grid) {\\n\\t\\treturn x\\n\\t}\\n\\tif grid[y][x] == 1 {\\n\\t\\tif x == len(grid[y])-1 || grid[y][x+1] == -1 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\treturn walk(grid, x+1, y+1)\\n\\t}\\n\\tif x == 0 || grid[y][x-1] == 1 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn walk(grid, x-1, y+1)\\n}\\n\\nfunc findBall(grid [][]int) []int {\\n\\tvar (\\n\\t\\tanswer = make([]int, len(grid[0]))\\n\\t)\\n\\tfor i := 0; i < len(answer); i++ {\\n\\t\\tanswer[i] = walk(grid, i, 0)\\n\\t}\\n\\treturn answer\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765666,
                "title": "diagonal-traversal-c-dfs-kind-approach",
                "content": "We iterate over each ball, and drop it from the `ith ` cell on top. Now, we simulate the game, and try to find the next cell basis on the direction of the current cell direction.\\n\\nBall moves to the next diagonal cell -\\n1. If direction = 1, that means the cell next to it should be available for move otherwise ball will be blocked.\\n2. if direction = -1, then previous cell should be available for movement else, ball is blocked.\\n3. if during traversal we encounter the case where the direction of current and next/previous cell is of opposite direction, then ball is stuck in V shape. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = (int)grid[0].size();\\n        \\n        auto getValue = [&](const auto &curCell) {\\n            return grid[curCell.first][curCell.second];\\n        };\\n        \\n        auto isValidCell = [&] (const auto &curCell) {\\n            int u = curCell.first;\\n            int v = curCell.second;\\n            return (u >= 0 && v >= 0 && u < n && v < m);\\n        };\\n        \\n        auto isBallBlocked = [&] (const auto &cell, const int &dir) {\\n            bool isBlocked = false;\\n            pair<int, int> nextCell = {cell.first, dir == 1? cell.second + 1: cell.second - 1};\\n            if (!isValidCell(nextCell) || getValue(nextCell) == -dir) {\\n                    isBlocked = true;\\n            }\\n            return isBlocked;\\n        };\\n        \\n        vector<int> result(m, -1);\\n        //dropping ball from each of the column in the table\\n        for (int i = 0; i < m; ++i) {\\n            pair<int, int> curCell = {0, i};\\n            int curDir = getValue(curCell);\\n            \\n            while (isValidCell(curCell) && !isBallBlocked(curCell, curDir)) {\\n                curCell = {curCell.first + 1, curDir == 1? curCell.second + 1: curCell.second - 1};\\n                curDir = isValidCell(curCell) ? getValue(curCell): 1;\\n            }\\n            \\n            if (curCell.first == n) {\\n                result[i] = curCell.second;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = (int)grid[0].size();\\n        \\n        auto getValue = [&](const auto &curCell) {\\n            return grid[curCell.first][curCell.second];\\n        };\\n        \\n        auto isValidCell = [&] (const auto &curCell) {\\n            int u = curCell.first;\\n            int v = curCell.second;\\n            return (u >= 0 && v >= 0 && u < n && v < m);\\n        };\\n        \\n        auto isBallBlocked = [&] (const auto &cell, const int &dir) {\\n            bool isBlocked = false;\\n            pair<int, int> nextCell = {cell.first, dir == 1? cell.second + 1: cell.second - 1};\\n            if (!isValidCell(nextCell) || getValue(nextCell) == -dir) {\\n                    isBlocked = true;\\n            }\\n            return isBlocked;\\n        };\\n        \\n        vector<int> result(m, -1);\\n        //dropping ball from each of the column in the table\\n        for (int i = 0; i < m; ++i) {\\n            pair<int, int> curCell = {0, i};\\n            int curDir = getValue(curCell);\\n            \\n            while (isValidCell(curCell) && !isBallBlocked(curCell, curDir)) {\\n                curCell = {curCell.first + 1, curDir == 1? curCell.second + 1: curCell.second - 1};\\n                curDir = isValidCell(curCell) ? getValue(curCell): 1;\\n            }\\n            \\n            if (curCell.first == n) {\\n                result[i] = curCell.second;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765574,
                "title": "java-solutions-with-comments-dfs-with-memoization-easy-to-understand",
                "content": "* DFS (Accepted, 100.00% Faster)\\n\\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int[] exitColumns = new int[grid[0].length];\\n        \\n        for(int col=0; col<grid[0].length; col++) {\\n            exitColumns[col] = dfs(grid, 0, col);\\n        }\\n        \\n        return exitColumns;\\n    }\\n    \\n    private int dfs(int[][] grid, int row, int col) {\\n        \\n        // ball dropped out of box or hit wall of the box\\n        if(row > grid.length || col < 0 || col >= grid[0].length) {\\n            return -1;\\n        }\\n        \\n        // ball reach at the end of the box\\n        if(row == grid.length) {\\n            return col;\\n        }\\n        \\n        // find \"V\" shaped pattern\\n        if(grid[row][col] == 1) {\\n            if (col < grid[0].length-1 && grid[row][col] != grid[row][col+1]) {\\n                return -1;\\n            }\\n        } else {\\n            if (col > 0 && grid[row][col-1] != grid[row][col]) {\\n                return -1;\\n            }\\n        }\\n               \\n        //if grid[row][col] = 1, redirect ball to the right o/w left \\n        col += grid[row][col];\\n        \\n        //recure till box dropped out of box or get stuck in V shap or at wall boundary\\n        return dfs(grid, row+1, col); \\n    }\\n}\\n```\\n\\n* With Memoization \\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int[] exitColumns = new int[grid[0].length];\\n        \\n        //Memoization in 5 steps\\n        \\n        // #1 : take an array to store results \\n        int[][] memo = new int[grid.length+2][grid[0].length+2];\\n        \\n        // #2 : initialize it with -1\\n        Arrays.stream(memo).forEach(arr -> Arrays.fill(arr, -1));\\n        \\n        for(int col=0; col<grid[0].length; col++) {\\n            exitColumns[col] = dfs(grid, 0, col, memo); // #3 : pass memo to recursive function\\n        }\\n        \\n        return exitColumns;\\n    }\\n    \\n    private int dfs(int[][] grid, int row, int col, int[][] memo) {\\n        \\n        // ball dropped out of box or hit wall of the box\\n        if(row > grid.length || col < 0 || col >= grid[0].length) {\\n            return -1;\\n        }\\n        \\n        // ball reach at the end of the box\\n        if(row == grid.length) {\\n            return col;\\n        }\\n        \\n        // find \"V\" shaped pattern\\n        if(grid[row][col] == 1) {\\n            if (col < grid[0].length-1 && grid[row][col] != grid[row][col+1]) {\\n                return -1;\\n            }\\n        } else {\\n            if (col > 0 && grid[row][col-1] != grid[row][col]) {\\n                return -1;\\n            }\\n        }\\n              \\n        //if grid[row][col] = 1, redirect ball to the right o/w left \\n        col += grid[row][col];\\n        \\n        // #4 : return result if already stored in memo to avoid recomputaion\\n        if(memo[row+1][col+1] != -1) {\\n            return memo[row+1][col+1];\\n        }\\n        \\n        //recure till box dropped out of box or get stuck in V shap or at wall boundary\\n        return memo[row+1][col+1] = dfs(grid, row+1, col, memo); // #5 : store result & return it\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int[] exitColumns = new int[grid[0].length];\\n        \\n        for(int col=0; col<grid[0].length; col++) {\\n            exitColumns[col] = dfs(grid, 0, col);\\n        }\\n        \\n        return exitColumns;\\n    }\\n    \\n    private int dfs(int[][] grid, int row, int col) {\\n        \\n        // ball dropped out of box or hit wall of the box\\n        if(row > grid.length || col < 0 || col >= grid[0].length) {\\n            return -1;\\n        }\\n        \\n        // ball reach at the end of the box\\n        if(row == grid.length) {\\n            return col;\\n        }\\n        \\n        // find \"V\" shaped pattern\\n        if(grid[row][col] == 1) {\\n            if (col < grid[0].length-1 && grid[row][col] != grid[row][col+1]) {\\n                return -1;\\n            }\\n        } else {\\n            if (col > 0 && grid[row][col-1] != grid[row][col]) {\\n                return -1;\\n            }\\n        }\\n               \\n        //if grid[row][col] = 1, redirect ball to the right o/w left \\n        col += grid[row][col];\\n        \\n        //recure till box dropped out of box or get stuck in V shap or at wall boundary\\n        return dfs(grid, row+1, col); \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int[] exitColumns = new int[grid[0].length];\\n        \\n        //Memoization in 5 steps\\n        \\n        // #1 : take an array to store results \\n        int[][] memo = new int[grid.length+2][grid[0].length+2];\\n        \\n        // #2 : initialize it with -1\\n        Arrays.stream(memo).forEach(arr -> Arrays.fill(arr, -1));\\n        \\n        for(int col=0; col<grid[0].length; col++) {\\n            exitColumns[col] = dfs(grid, 0, col, memo); // #3 : pass memo to recursive function\\n        }\\n        \\n        return exitColumns;\\n    }\\n    \\n    private int dfs(int[][] grid, int row, int col, int[][] memo) {\\n        \\n        // ball dropped out of box or hit wall of the box\\n        if(row > grid.length || col < 0 || col >= grid[0].length) {\\n            return -1;\\n        }\\n        \\n        // ball reach at the end of the box\\n        if(row == grid.length) {\\n            return col;\\n        }\\n        \\n        // find \"V\" shaped pattern\\n        if(grid[row][col] == 1) {\\n            if (col < grid[0].length-1 && grid[row][col] != grid[row][col+1]) {\\n                return -1;\\n            }\\n        } else {\\n            if (col > 0 && grid[row][col-1] != grid[row][col]) {\\n                return -1;\\n            }\\n        }\\n              \\n        //if grid[row][col] = 1, redirect ball to the right o/w left \\n        col += grid[row][col];\\n        \\n        // #4 : return result if already stored in memo to avoid recomputaion\\n        if(memo[row+1][col+1] != -1) {\\n            return memo[row+1][col+1];\\n        }\\n        \\n        //recure till box dropped out of box or get stuck in V shap or at wall boundary\\n        return memo[row+1][col+1] = dfs(grid, row+1, col, memo); // #5 : store result & return it\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765457,
                "title": "cpp-dfs-matrix",
                "content": "```\\nclass Solution {\\npublic:\\n    // if the value of (i,j) -> 1 (means we are moving to the right direc) , so (i,j+1) value must be similar(1) => then move further in right direc(i+1,j+1)\\n    \\n     // if the value of (i,j) -> -1 (means we are moving to the left direc) , so (i,j-1) value must be similar(-1) => then move further in left direc(i+1,j-1)\\n    \\n    // and in btw if we reach the last col we got our answer ...\\n    // O.W. return -1\\n    \\n    int solve(int i, int j, int m, int n,vector<vector<int>>& grid)\\n    {\\n        if(i == m)           // if we reach the last row(i.e. -> m) => return the current col \\n            return j;        \\n        \\n        if(grid[i][j] == 1 && j+1 < n && grid[i][j] == grid[i][j+1])  \\n                                                    // moving towards the right direction \\n            return solve(i+1,j+1,m,n,grid);\\n        \\n        else if(grid[i][j] == -1 && j-1 >= 0 && grid[i][j] == grid[i][j-1])  // moving towards the left direction \\n            return solve(i+1,j-1,m,n,grid);\\n        \\n        return -1;\\n    }\\n    \\n    vector<int> findBall(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<int > res(n,0);\\n        \\n        for(int j=0; j<n; j++)\\n        {\\n            res[j] = solve(0,j,m,n,grid);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // if the value of (i,j) -> 1 (means we are moving to the right direc) , so (i,j+1) value must be similar(1) => then move further in right direc(i+1,j+1)\\n    \\n     // if the value of (i,j) -> -1 (means we are moving to the left direc) , so (i,j-1) value must be similar(-1) => then move further in left direc(i+1,j-1)\\n    \\n    // and in btw if we reach the last col we got our answer ...\\n    // O.W. return -1\\n    \\n    int solve(int i, int j, int m, int n,vector<vector<int>>& grid)\\n    {\\n        if(i == m)           // if we reach the last row(i.e. -> m) => return the current col \\n            return j;        \\n        \\n        if(grid[i][j] == 1 && j+1 < n && grid[i][j] == grid[i][j+1])  \\n                                                    // moving towards the right direction \\n            return solve(i+1,j+1,m,n,grid);\\n        \\n        else if(grid[i][j] == -1 && j-1 >= 0 && grid[i][j] == grid[i][j-1])  // moving towards the left direction \\n            return solve(i+1,j-1,m,n,grid);\\n        \\n        return -1;\\n    }\\n    \\n    vector<int> findBall(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<int > res(n,0);\\n        \\n        for(int j=0; j<n; j++)\\n        {\\n            res[j] = solve(0,j,m,n,grid);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765452,
                "title": "93-94-faster-most-optimal-w-complete-explanation-c-easy-to-understand",
                "content": "## Where Will the Ball Fall - MOST OPTIMAL SOLUTION w/ COMPLETE EXPLANATION ||  \\u2705[ C++ ] \\u2705|| EASY TO UNDERSTAND || \\n\\n*Please upvote if you like it. Upvote costs nothing* \\uD83D\\uDE0E\\n\\n### EXPLANATION:\\n![image](https://assets.leetcode.com/users/images/ddfc46ea-3bbd-4be6-ba50-bd0262f59757_1667280623.9965203.png)\\n![image](https://assets.leetcode.com/users/images/7af20529-bcc2-4ebd-9a9c-57a0c1bc33f9_1667280663.5865903.png)\\n![image](https://assets.leetcode.com/users/images/c3d092cb-d072-4f61-be8d-833ef7b0bfb8_1667280700.6527362.png)\\n![image](https://assets.leetcode.com/users/images/fe196afa-8301-4ad5-8aeb-33dd92a179f2_1667280716.0740366.png)\\n\\n##### **Time Complexity : O(M X N)**-----> For each ball traversing array\\n##### **Space Complexity : O(N)**  ---->Costant space\\n##\\n### **</>CODE :**\\n### \\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> findBall(vector<vector<int>> &grid)\\n    {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<int> ans(col, -1);\\n        for (int j = 0; j < col; j++)\\n        {\\n            int ballPosition = j;\\n            int i = 0;\\n            while (i < row)\\n            {\\n                if (grid[i][ballPosition] == 1)\\n                {\\n                    if (ballPosition + 1 == col) // WALL BLOCK CONDITION  Case IV\\n                    {\\n                        break;\\n                    }\\n                    else if (grid[i][ballPosition + 1] == -1) // ADJACENT COLUMN CONDITION  Case I\\n                    {\\n                        break;\\n                    }\\n                    ballPosition++; // ball moves to right\\n                }\\n                else\\n                {\\n                    if (ballPosition - 1 < 0) // WALL BLOCK CONDITION  Case III\\n                    {\\n                        break;\\n                    }\\n                    else if (grid[i][ballPosition - 1] == 1) // ADJACENT COLUMN CONDITION  Case II\\n                    {\\n                        break;\\n                    }\\n                    ballPosition--; // ball moves to left\\n                }\\n                i++;\\n            }\\n            if (i == row)\\n            {\\n                ans[j] = ballPosition;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/18869958-84a2-4749-8598-62fd1fe15366_1667281221.5670905.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> findBall(vector<vector<int>> &grid)\\n    {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<int> ans(col, -1);\\n        for (int j = 0; j < col; j++)\\n        {\\n            int ballPosition = j;\\n            int i = 0;\\n            while (i < row)\\n            {\\n                if (grid[i][ballPosition] == 1)\\n                {\\n                    if (ballPosition + 1 == col) // WALL BLOCK CONDITION  Case IV\\n                    {\\n                        break;\\n                    }\\n                    else if (grid[i][ballPosition + 1] == -1) // ADJACENT COLUMN CONDITION  Case I\\n                    {\\n                        break;\\n                    }\\n                    ballPosition++; // ball moves to right\\n                }\\n                else\\n                {\\n                    if (ballPosition - 1 < 0) // WALL BLOCK CONDITION  Case III\\n                    {\\n                        break;\\n                    }\\n                    else if (grid[i][ballPosition - 1] == 1) // ADJACENT COLUMN CONDITION  Case II\\n                    {\\n                        break;\\n                    }\\n                    ballPosition--; // ball moves to left\\n                }\\n                i++;\\n            }\\n            if (i == row)\\n            {\\n                ans[j] = ballPosition;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765168,
                "title": "explained-python-solution-bfs",
                "content": "**Time:O(NM)**\\nKeep an array (output) to store the current position of the balls.\\n**Cases:**\\n1.  If the current position (pos) of ball is -1 in the output array, then it means ball is already stuck.\\n2.  if the pos == 0 and grid[row][pos] == -1 it means we can\\'t move further so update the output array to -1.\\n3.  Similarly if the pos == N and grid[row][pos] == 1 it means we can\\'t move further so update the output array to -1.\\n4.  Else update the output[pos] by comparing grid[row][pos] by the adjacent column and if the sum of both column values != 0 then update the pos\\n5.  Else set output[pos] = -1\\n\\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        N = len(grid[0])-1\\n        output = list(range(N+1))\\n        for i in range(len(grid)):\\n            for index,pos in enumerate(output):\\n                if pos == -1 :\\n                    continue\\n                if ((pos == 0 and grid[i][pos]==-1) or\\n                    (pos == N and grid[i][pos] == 1)):\\n                    output[index] = -1\\n                elif grid[i][pos] == 1 and grid[i][pos]+grid[i][pos+1]!=0:\\n                    output[index]+=1\\n                elif grid[i][pos] == -1 and grid[i][pos]+grid[i][pos-1] !=0:\\n                    output[index]-=1\\n                else:\\n                    output[index] = -1\\n        return output\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        N = len(grid[0])-1\\n        output = list(range(N+1))\\n        for i in range(len(grid)):\\n            for index,pos in enumerate(output):\\n                if pos == -1 :\\n                    continue\\n                if ((pos == 0 and grid[i][pos]==-1) or\\n                    (pos == N and grid[i][pos] == 1)):\\n                    output[index] = -1\\n                elif grid[i][pos] == 1 and grid[i][pos]+grid[i][pos+1]!=0:\\n                    output[index]+=1\\n                elif grid[i][pos] == -1 and grid[i][pos]+grid[i][pos-1] !=0:\\n                    output[index]-=1\\n                else:\\n                    output[index] = -1\\n        return output\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704089,
                "title": "js-simulation-solution",
                "content": "```\\nvar findBall = function(grid) {\\n    let results=[]\\n    for(let i=0;i<grid[0].length;i++){\\n        let stop=false\\n        let l=0\\n        let c=i\\n        let start=grid[l][c]\\n        while(l<grid.length&&!stop){\\n\\t\\t\\t\\tlet positive=true\\n\\t\\t\\t\\tif(start===-1){\\n\\t\\t\\t\\t\\t\\tpositive=false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(grid[l][c]===1&&grid[l][c+1]===-1||grid[l][c]===-1&&grid[l][c-1]===1){\\n\\t\\t\\t\\t\\t\\tstop=true\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tl++\\n\\t\\t\\t\\tif(positive){\\n\\t\\t\\t\\t\\t\\tc++\\n\\t\\t\\t\\t\\t\\tif(l<grid.length){\\n\\t\\t\\t\\t\\t\\t\\t\\tstart=grid[l][c]\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tc--\\n\\t\\t\\t\\t\\t\\tif(l<grid.length){\\n\\t\\t\\t\\t\\t\\t\\t\\tstart=grid[l][c]\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (c<0||c>=grid[0].length){\\n\\t\\t\\t\\t\\t\\tstop=true\\n\\t\\t\\t\\t}\\n        }\\n        if(stop){\\n            results.push(-1)\\n        }else{\\n            results.push(c)\\n        }\\n    }\\n    return results\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findBall = function(grid) {\\n    let results=[]\\n    for(let i=0;i<grid[0].length;i++){\\n        let stop=false\\n        let l=0\\n        let c=i\\n        let start=grid[l][c]\\n        while(l<grid.length&&!stop){\\n\\t\\t\\t\\tlet positive=true\\n\\t\\t\\t\\tif(start===-1){\\n\\t\\t\\t\\t\\t\\tpositive=false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(grid[l][c]===1&&grid[l][c+1]===-1||grid[l][c]===-1&&grid[l][c-1]===1){\\n\\t\\t\\t\\t\\t\\tstop=true\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tl++\\n\\t\\t\\t\\tif(positive){\\n\\t\\t\\t\\t\\t\\tc++\\n\\t\\t\\t\\t\\t\\tif(l<grid.length){\\n\\t\\t\\t\\t\\t\\t\\t\\tstart=grid[l][c]\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tc--\\n\\t\\t\\t\\t\\t\\tif(l<grid.length){\\n\\t\\t\\t\\t\\t\\t\\t\\tstart=grid[l][c]\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (c<0||c>=grid[0].length){\\n\\t\\t\\t\\t\\t\\tstop=true\\n\\t\\t\\t\\t}\\n        }\\n        if(stop){\\n            results.push(-1)\\n        }else{\\n            results.push(c)\\n        }\\n    }\\n    return results\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692297,
                "title": "swift-simulation-dynamic-programming",
                "content": "```\\n\\nclass Solution {\\n    func findBall(_ grid: [[Int]]) -> [Int] {\\n        guard !grid.isEmpty else { return [] }\\n        let columns = grid[0].count\\n        var result: [Int] = .init(repeating: -1, count: columns)\\n        \\n        ballsLoop: for startColumn in stride(from: 0, to: columns, by: 1) {\\n            var column = startColumn\\n            for row in stride(from: 0, to: grid.count, by: 1) {\\n                guard let element = grid[row][safe: column],\\n                let adjacentElement = grid[row][safe: column + element] else {\\n                    continue ballsLoop \\n                }\\n                if element + adjacentElement == 0 {\\n                    continue ballsLoop\\n                }\\n                column += element\\n            }\\n            result[startColumn] = column\\n        }\\n        return result\\n    }\\n}\\n\\nextension Collection {\\n    subscript(safe index: Index) -> Element? {\\n        indices.contains(index) ? self[index] : nil\\n    }\\n}\\n```\\n\\nDP approach:\\n```\\n\\nclass Solution {\\n    func findBall(_ grid: [[Int]]) -> [Int] {\\n        guard !grid.isEmpty else { return [] }\\n        let columns = grid[0].count\\n        var result: [Int] = []\\n        var dp: [[Int]] = .init(repeating: .init(repeating: -1, count: columns), count: grid.count + 1)\\n        \\n        for row in stride(from: dp.count - 1, to: -1, by: -1) {\\n            for column in stride(from: 0, to: columns, by: 1) {\\n                if row == dp.count - 1 {\\n                    dp[row][column] = column\\n                    continue\\n                }\\n                \\n                let nextColumn = column + grid[row][column]\\n                if let value = dp[row + 1][safe: nextColumn], grid[row][safe: nextColumn] == grid[row][column] {\\n                    dp[row][column] = value\\n                }\\n                if row == 0 {\\n                    result.append(dp[row][column])\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\nextension Collection {\\n    subscript(safe index: Index) -> Element? {\\n        indices.contains(index) ? self[index] : nil\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n\\nclass Solution {\\n    func findBall(_ grid: [[Int]]) -> [Int] {\\n        guard !grid.isEmpty else { return [] }\\n        let columns = grid[0].count\\n        var result: [Int] = .init(repeating: -1, count: columns)\\n        \\n        ballsLoop: for startColumn in stride(from: 0, to: columns, by: 1) {\\n            var column = startColumn\\n            for row in stride(from: 0, to: grid.count, by: 1) {\\n                guard let element = grid[row][safe: column],\\n                let adjacentElement = grid[row][safe: column + element] else {\\n                    continue ballsLoop \\n                }\\n                if element + adjacentElement == 0 {\\n                    continue ballsLoop\\n                }\\n                column += element\\n            }\\n            result[startColumn] = column\\n        }\\n        return result\\n    }\\n}\\n\\nextension Collection {\\n    subscript(safe index: Index) -> Element? {\\n        indices.contains(index) ? self[index] : nil\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    func findBall(_ grid: [[Int]]) -> [Int] {\\n        guard !grid.isEmpty else { return [] }\\n        let columns = grid[0].count\\n        var result: [Int] = []\\n        var dp: [[Int]] = .init(repeating: .init(repeating: -1, count: columns), count: grid.count + 1)\\n        \\n        for row in stride(from: dp.count - 1, to: -1, by: -1) {\\n            for column in stride(from: 0, to: columns, by: 1) {\\n                if row == dp.count - 1 {\\n                    dp[row][column] = column\\n                    continue\\n                }\\n                \\n                let nextColumn = column + grid[row][column]\\n                if let value = dp[row + 1][safe: nextColumn], grid[row][safe: nextColumn] == grid[row][column] {\\n                    dp[row][column] = value\\n                }\\n                if row == 0 {\\n                    result.append(dp[row][column])\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\nextension Collection {\\n    subscript(safe index: Index) -> Element? {\\n        indices.contains(index) ? self[index] : nil\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556379,
                "title": "c-dfs-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int gen(int i, int j, vector<vector<int>>& grid){\\n        \\n        if(i==grid.size()){\\n            return j;\\n        }\\n        \\n        if(grid[i][j]==1 && j+1<grid[0].size() && grid[i][j+1]==1){\\n            return gen(i+1, j+1, grid); // Left ti Right Case\\n        }\\n        else if(grid[i][j]==-1 && j-1>=0 && grid[i][j-1]==-1){\\n            return gen(i+1, j-1, grid); // Right ti Left Case\\n        }\\n        else if(grid[i][j]==1 && j+1==grid[0].size()){\\n            return -1; // Right Wall Case\\n        }\\n        else{\\n            return -1; // Left Wall Case\\n        }\\n        \\n    }\\n    \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<int> ans(col,-1);\\n        \\n        for(int i=0; i<col; i++){\\n            ans[i] = gen(0, i, grid);\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int gen(int i, int j, vector<vector<int>>& grid){\\n        \\n        if(i==grid.size()){\\n            return j;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2333610,
                "title": "java-dfs-solution-with-comments-1-ms",
                "content": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] ans = new int[n];\\n        \\n        for(int j=0;j<n;j++)\\n            ans[j] = checkBallFallsOut(grid, 0, j, m, n);\\n        return ans;\\n    }\\n    \\n    private int checkBallFallsOut(int[][] grid, int i, int j, int m, int n){\\n        if(i<0 || j<0 || i>m || j>=n)\\n            return -1;\\n        \\n\\t\\t//If we have reached to end of the rows then return column.\\n        if(i==m)\\n            return j;\\n        \\n        if(grid[i][j]==-1){\\n\\t\\t\\t//Check for V shape.\\n            if(j>0 && grid[i][j-1] == 1)\\n                return -1;\\n            return checkBallFallsOut(grid, i+1, j-1, m, n);\\n        }\\n        else{\\n\\t\\t\\t//Check for V Shape.\\n            if(j<n-1 && grid[i][j+1] == -1)\\n                return -1;\\n            return checkBallFallsOut(grid, i+1, j+1, m, n);\\n        }\\n    }\\n}\\n\\n***** PLEASE UPVOTE IF YOU LIKE THE SOLUTION*****\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] ans = new int[n];\\n        \\n        for(int j=0;j<n;j++)\\n            ans[j] = checkBallFallsOut(grid, 0, j, m, n);\\n        return ans;\\n    }\\n    \\n    private int checkBallFallsOut(int[][] grid, int i, int j, int m, int n){\\n        if(i<0 || j<0 || i>m || j>=n)\\n            return -1;\\n        \\n\\t\\t//If we have reached to end of the rows then return column.\\n        if(i==m)\\n            return j;\\n        \\n        if(grid[i][j]==-1){\\n\\t\\t\\t//Check for V shape.\\n            if(j>0 && grid[i][j-1] == 1)\\n                return -1;\\n            return checkBallFallsOut(grid, i+1, j-1, m, n);\\n        }\\n        else{\\n\\t\\t\\t//Check for V Shape.\\n            if(j<n-1 && grid[i][j+1] == -1)\\n                return -1;\\n            return checkBallFallsOut(grid, i+1, j+1, m, n);\\n        }\\n    }\\n}\\n\\n***** PLEASE UPVOTE IF YOU LIKE THE SOLUTION*****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241750,
                "title": "where-will-the-ball-fall-c-iterative-solution-easy",
                "content": "```\\nvector<int> findBall(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<int>res(col);\\n        for (int i = 0; i < col; ++i) {\\n            int currRow = 0, currCol = i;\\n            while (currRow < row) {\\n\\n                if (grid[currRow][currCol] == 1&&currCol + 1 < col && grid[currRow][currCol + 1] == 1){\\n\\t\\t\\t\\t\\t// We go to the right if the current value and the value to the right are both equal to 1.\\n\\t\\t\\t\\t\\t// i.e  \\'\\\\ \\\\\\'\\n                    currCol++; currRow++;\\n                } \\n                else if (grid[currRow][currCol]==-1 &&currCol - 1 >= 0&&grid[currRow][currCol-1]== -1){\\n\\t\\t\\t\\t\\t //We go to the left if the current value and the value to the left are both equal to -1.\\n\\t\\t\\t\\t\\t //i.e \\' / /\\'\\n                    currCol--; currRow++;\\n                } \\n                else {\\n\\t\\t\\t\\t// the ball is stuck because there is no other way to move. \\n\\t\\t\\t\\t//i.e \\\\/\\n                    break; \\n                }\\n            }\\n            res[i] = currRow == row ? currCol : -1;\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```\\nvector<int> findBall(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<int>res(col);\\n        for (int i = 0; i < col; ++i) {\\n            int currRow = 0, currCol = i;\\n            while (currRow < row) {\\n\\n                if (grid[currRow][currCol] == 1&&currCol + 1 < col && grid[currRow][currCol + 1] == 1){\\n\\t\\t\\t\\t\\t// We go to the right if the current value and the value to the right are both equal to 1.\\n\\t\\t\\t\\t\\t// i.e  \\'\\\\ \\\\\\'\\n                    currCol++; currRow++;\\n                } \\n                else if (grid[currRow][currCol]==-1 &&currCol - 1 >= 0&&grid[currRow][currCol-1]== -1){\\n\\t\\t\\t\\t\\t //We go to the left if the current value and the value to the left are both equal to -1.\\n\\t\\t\\t\\t\\t //i.e \\' / /\\'\\n                    currCol--; currRow++;\\n                } \\n                else {\\n\\t\\t\\t\\t// the ball is stuck because there is no other way to move. \\n\\t\\t\\t\\t//i.e \\\\/\\n                    break; \\n                }\\n            }\\n            res[i] = currRow == row ? currCol : -1;\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2202187,
                "title": "full-explanation-with-comments-c-solution-iterative-space-optimized-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        if (m==1)\\n            return {-1};\\n        \\n        // 2 vectors to store position of balls (b0,b1,b2...)\\n        // index in both represents the column number in that particular row\\n        // value in both represents the ball numer that has managed to rach that column \\n        // curr - to store the current position of ball number\\n        // next - to calculate next position of ball number\\n        vector<int> curr(m,-1),next(m,-1);\\n        \\n        // currently each ball starts at it\\'s index\\n        for (int i=0; i<m; i++)\\n        {\\n            curr[i]=i;\\n        }\\n        \\n        // iterate through each row and each time calculate the next values based on the current values \\n        for (int i=0; i<n; i++)\\n        {\\n            // if we get 2 consecutive 1, ball will go right side (increase it\\'s index in next)\\n            // if we get 2 consecutive -1, ball will go left side (decrease it\\'s index in next)\\n            \\n            // check for first 2 columns\\n            if (grid[i][0]==1 && grid[i][1]==1)\\n            {\\n                next[1]=curr[0];\\n            }\\n            \\n            if (grid[i][0]==-1 && grid[i][1]==-1)\\n            {\\n                next[0]=curr[1];\\n            }\\n            \\n            // check for rest of the colums\\n            for (int j=1; j<m-1; j++)\\n            {\\n                if (grid[i][j]==1 && grid[i][j+1]==1)\\n                {\\n                    next[j+1]=curr[j];\\n                }\\n                \\n                if (grid[i][j]==-1 && grid[i][j+1]==-1)\\n                {\\n                    next[j]=curr[j+1];\\n                }\\n            }\\n            \\n            // curr will become next for next row\\n            curr = next;\\n            \\n            // for last row, we have next vector containing ball numbers (value) in the respective columns (index)\\n            if (i==n-1)\\n                break;\\n            \\n            // initialise next to -1 again \\n            for (int i=0; i<m; i++)\\n            {\\n                next[i]=-1;\\n            }\\n        }\\n        \\n        // we need to return vector having whose value represents column and index represents the ball number\\n        vector <int> ans (m,-1);\\n        \\n        for (int i=0; i<m; i++)\\n        {\\n            if (next[i]!=-1)\\n                ans[next[i]]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nI hope it helped... please upvote if it did :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        if (m==1)\\n            return {-1};\\n        \\n        // 2 vectors to store position of balls (b0,b1,b2...)\\n        // index in both represents the column number in that particular row\\n        // value in both represents the ball numer that has managed to rach that column \\n        // curr - to store the current position of ball number\\n        // next - to calculate next position of ball number\\n        vector<int> curr(m,-1),next(m,-1);\\n        \\n        // currently each ball starts at it\\'s index\\n        for (int i=0; i<m; i++)\\n        {\\n            curr[i]=i;\\n        }\\n        \\n        // iterate through each row and each time calculate the next values based on the current values \\n        for (int i=0; i<n; i++)\\n        {\\n            // if we get 2 consecutive 1, ball will go right side (increase it\\'s index in next)\\n            // if we get 2 consecutive -1, ball will go left side (decrease it\\'s index in next)\\n            \\n            // check for first 2 columns\\n            if (grid[i][0]==1 && grid[i][1]==1)\\n            {\\n                next[1]=curr[0];\\n            }\\n            \\n            if (grid[i][0]==-1 && grid[i][1]==-1)\\n            {\\n                next[0]=curr[1];\\n            }\\n            \\n            // check for rest of the colums\\n            for (int j=1; j<m-1; j++)\\n            {\\n                if (grid[i][j]==1 && grid[i][j+1]==1)\\n                {\\n                    next[j+1]=curr[j];\\n                }\\n                \\n                if (grid[i][j]==-1 && grid[i][j+1]==-1)\\n                {\\n                    next[j]=curr[j+1];\\n                }\\n            }\\n            \\n            // curr will become next for next row\\n            curr = next;\\n            \\n            // for last row, we have next vector containing ball numbers (value) in the respective columns (index)\\n            if (i==n-1)\\n                break;\\n            \\n            // initialise next to -1 again \\n            for (int i=0; i<m; i++)\\n            {\\n                next[i]=-1;\\n            }\\n        }\\n        \\n        // we need to return vector having whose value represents column and index represents the ball number\\n        vector <int> ans (m,-1);\\n        \\n        for (int i=0; i<m; i++)\\n        {\\n            if (next[i]!=-1)\\n                ans[next[i]]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496210,
                "title": "easy-dfs-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector <int> ans;\\n    void dfs(vector<vector<int>>&grid,int i,int j)\\n    {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        //Condition where ball reaches the end;\\n        if(i>=row)\\n        {\\n           ans.push_back(j);\\n           return;\\n        }\\n        \\n        //check for left diagonal movement\\n        if(grid[i][j]==1)\\n        {\\n            if(j==col-1||grid[i][j+1]==-1)\\n            {\\n                ans.push_back(-1);\\n                return;\\n            }\\n        }\\n        \\n        //check for right diagonal movement\\n        if(grid[i][j]==-1)\\n        {\\n            if(j==0||grid[i][j-1]==1)\\n            {\\n                ans.push_back(-1);\\n                return;\\n            }\\n        }\\n        \\n        //recursive dfs;\\n        dfs(grid,i+1,j+grid[i][j]);\\n    }\\n    \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        \\n        //running dfs on all elements in the first row\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            dfs(grid,0,i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> ans;\\n    void dfs(vector<vector<int>>&grid,int i,int j)\\n    {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        //Condition where ball reaches the end;\\n        if(i>=row)\\n        {\\n           ans.push_back(j);\\n           return;\\n        }\\n        \\n        //check for left diagonal movement\\n        if(grid[i][j]==1)\\n        {\\n            if(j==col-1||grid[i][j+1]==-1)\\n            {\\n                ans.push_back(-1);\\n                return;\\n            }\\n        }\\n        \\n        //check for right diagonal movement\\n        if(grid[i][j]==-1)\\n        {\\n            if(j==0||grid[i][j-1]==1)\\n            {\\n                ans.push_back(-1);\\n                return;\\n            }\\n        }\\n        \\n        //recursive dfs;\\n        dfs(grid,i+1,j+grid[i][j]);\\n    }\\n    \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        \\n        //running dfs on all elements in the first row\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            dfs(grid,0,i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374141,
                "title": "simple-c-solution-faster-than-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int col, int row){\\n        if(grid[row][col] == -1){\\n            if(col == 0){\\n                return -1;\\n            }\\n            if(grid[row][col-1] == 1){\\n                return -1;\\n            }\\n            if(row+1 == grid.size()){\\n                return col - 1;\\n            }\\n            return dfs(grid, col - 1, row + 1);\\n        }\\n        if(grid[row][col] == 1){\\n            if(col == grid[0].size() - 1){\\n                return -1;\\n            }\\n            if(grid[row][col+1] == -1){\\n                return -1;\\n            }\\n            if(row+1 == grid.size()){\\n                return col + 1;\\n            }\\n            return dfs(grid, col + 1, row + 1);\\n        }\\n        \\n        return -1;\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        vector<int>ans;\\n        for(int i = 0; i < n; i++){\\n            ans.push_back(dfs(grid, i, 0));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int col, int row){\\n        if(grid[row][col] == -1){\\n            if(col == 0){\\n                return -1;\\n            }\\n            if(grid[row][col-1] == 1){\\n                return -1;\\n            }\\n            if(row+1 == grid.size()){\\n                return col - 1;\\n            }\\n            return dfs(grid, col - 1, row + 1);\\n        }\\n        if(grid[row][col] == 1){\\n            if(col == grid[0].size() - 1){\\n                return -1;\\n            }\\n            if(grid[row][col+1] == -1){\\n                return -1;\\n            }\\n            if(row+1 == grid.size()){\\n                return col + 1;\\n            }\\n            return dfs(grid, col + 1, row + 1);\\n        }\\n        \\n        return -1;\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        vector<int>ans;\\n        for(int i = 0; i < n; i++){\\n            ans.push_back(dfs(grid, i, 0));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035414,
                "title": "python3-simple-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        \\n        N = len(grid)\\n        M = len(grid[0])\\n        answer = [[-2]*M for _ in range(N+1)]\\n        \\n        for i in range(M):\\n            answer[N][i] = i\\n    \\n        def find_end(i,j):\\n            if answer[i][j] == -2:\\n                if j < M-1 and grid[i][j] == 1 and grid[i][j+1] == 1:\\n                    answer[i][j] = find_end(i+1,j+1)\\n                elif j > 0 and grid[i][j] == -1 and grid[i][j-1] == -1:\\n                    answer[i][j] = find_end(i+1,j-1)\\n                else:\\n                    answer[i][j] = -1\\n            return answer[i][j]\\n            \\n        for j in range(M):\\n            find_end(0,j)\\n            \\n        return answer[0]\\n```\\n\\nIf ```answer[i][j]``` is -2, then its value has not been computed. If it is -1, then the bottom is not reachable. Otherwise its value will be the final column the ball reaches.\\n\\nAt each step, if the ball can move, find_end is recursively called on the next square it falls on. Otherwsie the ball is stuck and we set its value to -1. \\n\\nTo make the base case easier, for when the end is reached, a row is added to the bottom of answer indicating the corresponding column.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        \\n        N = len(grid)\\n        M = len(grid[0])\\n        answer = [[-2]*M for _ in range(N+1)]\\n        \\n        for i in range(M):\\n            answer[N][i] = i\\n    \\n        def find_end(i,j):\\n            if answer[i][j] == -2:\\n                if j < M-1 and grid[i][j] == 1 and grid[i][j+1] == 1:\\n                    answer[i][j] = find_end(i+1,j+1)\\n                elif j > 0 and grid[i][j] == -1 and grid[i][j-1] == -1:\\n                    answer[i][j] = find_end(i+1,j-1)\\n                else:\\n                    answer[i][j] = -1\\n            return answer[i][j]\\n            \\n        for j in range(M):\\n            find_end(0,j)\\n            \\n        return answer[0]\\n```\n```answer[i][j]```",
                "codeTag": "Java"
            },
            {
                "id": 3922596,
                "title": "beats-99-depth-first-search-solution-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ball;\\n    void dfs(int i, int j, int idx, vector<vector<int>> &grid){\\n        if(i == grid.size()){\\n            if(j >= 0 && j < grid[0].size()){\\n                ball[idx] = j;\\n            }\\n            return;\\n        }\\n        if(grid[i][j] == 1){\\n            if(j == grid[0].size() - 1 || grid[i][j+1] == -1) return;\\n            else{\\n                dfs(i+1, j+1, idx, grid);\\n            }\\n        }\\n        else if(grid[i][j] == -1){\\n            if(j == 0 || grid[i][j-1] == 1) return;\\n            else{\\n                dfs(i+1, j-1, idx, grid);\\n            }\\n        }\\n    } \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n = grid[0].size(); \\n        ball = vector<int> (n, -1);\\n        for(int i = 0; i<n; i++){\\n            dfs(0, i, i, grid);\\n        }\\n        return ball;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ball;\\n    void dfs(int i, int j, int idx, vector<vector<int>> &grid){\\n        if(i == grid.size()){\\n            if(j >= 0 && j < grid[0].size()){\\n                ball[idx] = j;\\n            }\\n            return;\\n        }\\n        if(grid[i][j] == 1){\\n            if(j == grid[0].size() - 1 || grid[i][j+1] == -1) return;\\n            else{\\n                dfs(i+1, j+1, idx, grid);\\n            }\\n        }\\n        else if(grid[i][j] == -1){\\n            if(j == 0 || grid[i][j-1] == 1) return;\\n            else{\\n                dfs(i+1, j-1, idx, grid);\\n            }\\n        }\\n    } \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n = grid[0].size(); \\n        ball = vector<int> (n, -1);\\n        for(int i = 0; i<n; i++){\\n            dfs(0, i, i, grid);\\n        }\\n        return ball;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087813,
                "title": "kotlin-dfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun findBall(grid: Array<IntArray>): IntArray {\\n        val ans = IntArray(grid[0].size) { 0 }\\n        \\n        fun dfs(i: Int, j: Int): Int {\\n            if (i == grid.size) return j\\n            val J = j + grid[i][j]\\n            if (J !in grid[0].indices || grid[i][j] != grid[i][J]) return -1\\n            return dfs(i + 1, J)\\n        }\\n\\n        for (i in 0 until grid[0].size) ans[i] = dfs(0, i)\\n\\n        return ans\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    fun findBall(grid: Array<IntArray>): IntArray {\\n        val ans = IntArray(grid[0].size) { 0 }\\n        \\n        fun dfs(i: Int, j: Int): Int {\\n            if (i == grid.size) return j\\n            val J = j + grid[i][j]\\n            if (J !in grid[0].indices || grid[i][j] != grid[i][J]) return -1\\n            return dfs(i + 1, J)\\n        }\\n\\n        for (i in 0 until grid[0].size) ans[i] = dfs(0, i)\\n\\n        return ans\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050191,
                "title": "python-straightforward-solution-time-complexity-o-mn",
                "content": "https://leetcode.com/submissions/detail/878014740/  \\nRuntime: **197 ms**, faster than 89.81% of Python3 online submissions for Where Will the Ball Fall.  \\nMemory Usage: 14.2 MB, less than 98.85% of Python3 online submissions for Where Will the Ball Fall.  \\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        falls, nrow, ncol = [], len(grid), len(grid[0]) \\n        for j in range(ncol): ## initial column position\\n            is_stuck = False \\n            for i in range(nrow):\\n                if grid[i][j]==1 and j<ncol-1 and grid[i][j+1]==1:\\n                    j += 1\\n                elif grid[i][j]==-1 and j>0 and grid[i][j-1]==-1:\\n                    j -= 1\\n                else:\\n                    is_stuck = True\\n                    falls.append(-1)\\n                    break\\n            if not is_stuck: falls.append(j)\\n        return falls\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        falls, nrow, ncol = [], len(grid), len(grid[0]) \\n        for j in range(ncol): ## initial column position\\n            is_stuck = False \\n            for i in range(nrow):\\n                if grid[i][j]==1 and j<ncol-1 and grid[i][j+1]==1:\\n                    j += 1\\n                elif grid[i][j]==-1 and j>0 and grid[i][j-1]==-1:\\n                    j -= 1\\n                else:\\n                    is_stuck = True\\n                    falls.append(-1)\\n                    break\\n            if not is_stuck: falls.append(j)\\n        return falls\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011036,
                "title": "short-simple-efficient-easy-to-understand-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the values for the diagonals to figure out where the ball moves after each row. Value of 1 means ball moves over 1 column. Value of -1 means the ball moves backward 1 column.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain an array for the index location of each ball and iterate over each row of the grid and update the location of each ball. Use the value in the grid to determine which direction the ball falls in. \\n\\nAdditionally check for a \"hole\" where the ball gets stuck between two diagonals or between a diagonal and a wall. Do this by using the direction of the diagonal in the cell the ball is in to figure out which cell is the neighbor that might trap the ball. If the values in these two cells sums to zero, it means the ball is trapped and you can set the position of that ball to -1. \\n\\nContinue this process all the way through the last row. \\n\\n[Super Quick Video Explanation <3 min](https://youtu.be/-RDPsvkJX2A)\\nhttps://youtu.be/-RDPsvkJX2A \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(MN)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(MN)$$ Grid of size MN plus array of size N\\n# Code\\n```\\nclass Solution(object):\\n    # determine whether the ball has fallen into a hole\\n    def nextPosition(self, row, j, max):\\n        if (j == -1): \\n            return -1 # stuck in hold\\n        else:\\n            direction = row[j] # current direction ball is falling\\n            neighborpos = j + direction # neighbor in the direction ball is falling\\n            # if at wall set neighbor to opposite of current direction\\n            neighborval = -direction if (neighborpos < 0 or neighborpos > max) else row[neighborpos]\\n            if (direction + neighborval == 0): # stuck at wall or in hole\\n                return -1\\n            else:\\n                return neighborpos\\n        \\n\\n    def findBall(self, grid):\\n        rows = len(grid)\\n        balls = len(grid[0])\\n        positions = [i for i in range(balls)]\\n        for i in range(rows):\\n            positions = [(self.nextPosition(grid[i], j, balls-1)) for j in positions]\\n        return positions\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    # determine whether the ball has fallen into a hole\\n    def nextPosition(self, row, j, max):\\n        if (j == -1): \\n            return -1 # stuck in hold\\n        else:\\n            direction = row[j] # current direction ball is falling\\n            neighborpos = j + direction # neighbor in the direction ball is falling\\n            # if at wall set neighbor to opposite of current direction\\n            neighborval = -direction if (neighborpos < 0 or neighborpos > max) else row[neighborpos]\\n            if (direction + neighborval == 0): # stuck at wall or in hole\\n                return -1\\n            else:\\n                return neighborpos\\n        \\n\\n    def findBall(self, grid):\\n        rows = len(grid)\\n        balls = len(grid[0])\\n        positions = [i for i in range(balls)]\\n        for i in range(rows):\\n            positions = [(self.nextPosition(grid[i], j, balls-1)) for j in positions]\\n        return positions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768541,
                "title": "simple-python-iterative-solution-faster-than-99",
                "content": "This solution is much simpler than other solutions because:\\n* It looks at each ball separately\\n* It is iterative, and not recursive (and hence allowing us to be more efficient than 99% of solutions)\\n\\nFor each ball, we start from the top of the grid and look at the direction where the ball is going to go.\\n\\nIf the ball hits the sides of the grid (i.e. ```col + direction < 0``` or ```col + direction >= width```) or it gets stuck (i.e. ```grid[row][col] + grid[row][col + direction] == 0```), then we return -1.\\n\\nOtherwise, we allow the ball to continue down the grid till it reaches the bottom, where we return the col.\\n\\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n\\t\\theight = len(grid)\\n\\t\\twidth = len(grid[0])\\n\\t\\n\\t\\tdef _getFallColumn(self, grid: List[List[int]], col: int) -> int:\\n\\t\\t\\trow = 0\\n\\n\\t\\t\\twhile row < height:\\n\\t\\t\\t\\tdirection = grid[row][col]\\n\\t\\t\\t\\tif col + direction < 0 or col + direction >= width or grid[row][col] + grid[row][col + direction] == 0:\\n\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\t\\trow += 1\\n\\t\\t\\t\\tcol += direction\\n\\n\\t\\t\\treturn col          \\n\\t\\n        return [_getFallColumn(grid, col) for col in range(width)]\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```col + direction < 0```\n```col + direction >= width```\n```grid[row][col] + grid[row][col + direction] == 0```\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n\\t\\theight = len(grid)\\n\\t\\twidth = len(grid[0])\\n\\t\\n\\t\\tdef _getFallColumn(self, grid: List[List[int]], col: int) -> int:\\n\\t\\t\\trow = 0\\n\\n\\t\\t\\twhile row < height:\\n\\t\\t\\t\\tdirection = grid[row][col]\\n\\t\\t\\t\\tif col + direction < 0 or col + direction >= width or grid[row][col] + grid[row][col + direction] == 0:\\n\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\t\\trow += 1\\n\\t\\t\\t\\tcol += direction\\n\\n\\t\\t\\treturn col          \\n\\t\\n        return [_getFallColumn(grid, col) for col in range(width)]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2768386,
                "title": "detailed-explanation-using-dfs-java-1ms",
                "content": "This problem was asked in \\uD83D\\uDD25 **Google** \\uD83D\\uDD25 interview.\\n\\n# Overview:\\nFirst you have to take pen and paper. Then try to visualize what is happening. \\n\\nFor example 1 there is a reference drawing that looks like this:\\n```\\ngrid = \\n[ \\n  [ 1, 1, 1,-1,-1],\\n  [ 1, 1, 1,-1,-1],\\n  [-1,-1,-1, 1, 1],\\n  [ 1, 1, 1, 1,-1],\\n  [-1,-1,-1,-1,-1]\\n]\\n```\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/65cf7f4e-b367-4e17-b7a9-946a0e1bf616_1667335054.032698.png\" width=\"600\"/>\\n</p>\\nSame way try to visualize for Example 3:\\n\\n```\\ngrid = \\n[\\n  [ 1, 1, 1, 1, 1, 1],\\n  [-1,-1,-1,-1,-1,-1],\\n  [ 1, 1, 1, 1, 1, 1],\\n  [-1,-1,-1,-1,-1,-1]\\n]\\n```\\n\\nFor this input the visualization should look like this:\\n<p align=\"center\">\\n\\t<img src=\"https://assets.leetcode.com/users/images/4e1c97e0-56d9-45c0-b6bc-fd5a3350737c_1667335768.2461417.png\" width=\"400\"/>\\n</p>\\n\\n\\nSo, the first thing you have to understand is that you will be checking for each ball one by one. When a ball is in a cell (let cell 0,0), it should look for it\\'s right and left cell to take decisions.\\n\\nIf the current cell value is 1 then it should check it\\'s right cell and vice versa. The base case is when the ball reaches the end of row. I am keeping a global variable (as memoization object) where I store the final result in **balls[]** array. To avoid unnecessary calculations, the **balls[currentBallNo]** is checked if it has value > -1.\\n\\nThis is an easy problem once you get the hint. Here\\'s my code:   \\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\n\\n<img src=\"https://assets.leetcode.com/users/images/77a8d905-0482-41c8-9bb6-75402444798c_1667334633.0513756.png\" width=\"800\"/>\\n\\n```\\nclass Solution {\\n    int[][] grid;\\n    int[] balls;\\n    int ROW, COL;\\n    public int[] findBall(int[][] grid) {\\n        this.balls = new int[grid[0].length];\\n        Arrays.fill(balls, -1);\\n        this.grid = grid;\\n        ROW = grid.length;\\n        COL = grid[0].length;\\n        for(int ball=0; ball<balls.length; ball++){\\n            // System.out.println(\"Checking for ball: \"+ ball);\\n            dfs(0, ball, ball);\\n        }\\n        return balls;\\n    }\\n    private void dfs(int i, int j, int ballNo){\\n        if(balls[ballNo]>-1)\\n            return;\\n        if(i==ROW){\\n            balls[ballNo] = j;\\n            return;\\n        }\\n        if(isBound(i,j)){\\n            if(grid[i][j]==1 && j<COL-1 && grid[i][j]==grid[i][j+1]){\\n                dfs(i+1, j+1, ballNo);\\n            }\\n            else if(grid[i][j]==-1 && j>0 && grid[i][j]==grid[i][j-1])\\n                dfs(i+1, j-1, ballNo);\\n        }\\n    }\\n    \\n    private boolean isBound(int i, int j){\\n        return (i>=0 && i<ROW && j>=0 && j<COL);\\n    }\\n}\\n```\\n\\n**Please give upvote  \\uD83D\\uDC4D  if this was helpful !**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\ngrid = \\n[ \\n  [ 1, 1, 1,-1,-1],\\n  [ 1, 1, 1,-1,-1],\\n  [-1,-1,-1, 1, 1],\\n  [ 1, 1, 1, 1,-1],\\n  [-1,-1,-1,-1,-1]\\n]\\n```\n```\\ngrid = \\n[\\n  [ 1, 1, 1, 1, 1, 1],\\n  [-1,-1,-1,-1,-1,-1],\\n  [ 1, 1, 1, 1, 1, 1],\\n  [-1,-1,-1,-1,-1,-1]\\n]\\n```\n```\\nclass Solution {\\n    int[][] grid;\\n    int[] balls;\\n    int ROW, COL;\\n    public int[] findBall(int[][] grid) {\\n        this.balls = new int[grid[0].length];\\n        Arrays.fill(balls, -1);\\n        this.grid = grid;\\n        ROW = grid.length;\\n        COL = grid[0].length;\\n        for(int ball=0; ball<balls.length; ball++){\\n            // System.out.println(\"Checking for ball: \"+ ball);\\n            dfs(0, ball, ball);\\n        }\\n        return balls;\\n    }\\n    private void dfs(int i, int j, int ballNo){\\n        if(balls[ballNo]>-1)\\n            return;\\n        if(i==ROW){\\n            balls[ballNo] = j;\\n            return;\\n        }\\n        if(isBound(i,j)){\\n            if(grid[i][j]==1 && j<COL-1 && grid[i][j]==grid[i][j+1]){\\n                dfs(i+1, j+1, ballNo);\\n            }\\n            else if(grid[i][j]==-1 && j>0 && grid[i][j]==grid[i][j-1])\\n                dfs(i+1, j-1, ballNo);\\n        }\\n    }\\n    \\n    private boolean isBound(int i, int j){\\n        return (i>=0 && i<ROW && j>=0 && j<COL);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768184,
                "title": "c-solution-recursive-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a simulation problem, something like the path finding problem. This will help you to think of a recursive solution considering all possible paths.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a variable that helps you to keep track of the ball number(which column the ball is entering). Iterate for all the balls.\\n\\nNow, for each ball we need to find an exit point or trap point. So as we move into the recursive function, if our current cell has a 1, it means \\'\\\\\\' and a -1 means \\'/\\'. So, getting a 1 would lead us to the (i+1,j+1) cell while the -1 would lead us to (i+1,j-1). So, accordingly we use the recursive calls.\\n\\nBASE CASES/EDGE CASES:\\nthe ball falls out(i >= m>) -> return the column number.\\n\\nelse for all other cases -> return -1.\\nThese cases include:\\n1) V formation -> grid[i][j] == 1 && grid[i][j+1] == -1 and Vice-Versa.\\n2) Edge blocks -> grid[i][j] == 1 and j+1 >= n and Vice-Versa.\\n\\nStore the answers in a vector and return the vector as solution.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIf a recursive soln is considered, the auxiliary stack space would be O(M). Memoization takes O(M*N).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>& grid,int m,int n,vector<vector<int>> &dp)\\n    {\\n        if(i >= m) return j;\\n\\n        if(dp[i][j] != -1) return dp[i][j]; \\n\\n        if(grid[i][j] == 1 && j+1 < n && grid[i][j+1] == 1)\\n        return dp[i][j] = solve(i+1,j+1,grid,m,n,dp);\\n\\n        if(grid[i][j] == -1 && j-1 >= 0 && grid[i][j-1] == -1)\\n        return dp[i] [j] = solve(i+1,j-1,grid,m,n,dp);  \\n\\n        return dp[i][j] = -1;\\n    }\\n     \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int ball_no;\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n\\n        vector<vector<int>> dp(rows,vector<int>(cols,-1));\\n\\n        vector<int> ans(cols);\\n        for(ball_no = 0; ball_no < cols ; ball_no++)\\n        {\\n            ans[ball_no] = solve(0,ball_no,grid,rows,cols,dp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>& grid,int m,int n,vector<vector<int>> &dp)\\n    {\\n        if(i >= m) return j;\\n\\n        if(dp[i][j] != -1) return dp[i][j]; \\n\\n        if(grid[i][j] == 1 && j+1 < n && grid[i][j+1] == 1)\\n        return dp[i][j] = solve(i+1,j+1,grid,m,n,dp);\\n\\n        if(grid[i][j] == -1 && j-1 >= 0 && grid[i][j-1] == -1)\\n        return dp[i] [j] = solve(i+1,j-1,grid,m,n,dp);  \\n\\n        return dp[i][j] = -1;\\n    }\\n     \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int ball_no;\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n\\n        vector<vector<int>> dp(rows,vector<int>(cols,-1));\\n\\n        vector<int> ans(cols);\\n        for(ball_no = 0; ball_no < cols ; ball_no++)\\n        {\\n            ans[ball_no] = solve(0,ball_no,grid,rows,cols,dp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768181,
                "title": "100-faster-in-java",
                "content": "# Intuition\\nMy first intuition was to do it with bruitforce and I was able to solve 62/64 test cases using that. Then I came across the iterative approach witht he intent to inculcate it in my brute force approach. But while solving these, I did have a context that questions can usually be solved using dfs. Using the corner I used in iterative solution, I formed base cases for dfs and ran it through.\\n\\n# Approach\\nThe idea is to create a next value of J, put it through all the corner case constraints, and if it passes those, move it to the next row it can go into. we dont need to create and return the new j for base case i == grid.length because it being equal to grid.length means it is already out of matric and the new J was sent to this call.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n\\n        int[] result = new int[grid[0].length];\\n\\n        for(int i=0; i<result.length; i++){\\n            result[i] = dfs(0,i,grid);\\n        }\\n        return result;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid){\\n\\n        if(i == grid.length){\\n            return j;\\n        }\\n\\n        int newj = j + grid[i][j];\\n\\n        if(newj<0 || newj>=grid[0].length || grid[i][j] != grid[i][newj]){\\n            return -1;\\n        }\\n\\n        \\n\\n       \\n        return dfs(i+1,newj,grid);   \\n       \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n\\n        int[] result = new int[grid[0].length];\\n\\n        for(int i=0; i<result.length; i++){\\n            result[i] = dfs(0,i,grid);\\n        }\\n        return result;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid){\\n\\n        if(i == grid.length){\\n            return j;\\n        }\\n\\n        int newj = j + grid[i][j];\\n\\n        if(newj<0 || newj>=grid[0].length || grid[i][j] != grid[i][newj]){\\n            return -1;\\n        }\\n\\n        \\n\\n       \\n        return dfs(i+1,newj,grid);   \\n       \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767870,
                "title": "c-simple-dfs",
                "content": "The constraints are lenient so we can simply simulate the whole process for each ball to get the answer.\\n\\n```\\nclass Solution {\\n    int m,n;\\n    \\n    int endingColumnOfBall(int r,int c,vector<vector<int>>& grid)\\n    {\\n\\t\\t/*\\n\\t\\tConsidering the current cell at row r and column c\\n\\t\\t\\n\\t\\tThe ball gets stuck in two scenarios for each case of right and left directed board:\\n\\t\\t\\n\\t\\tFor right directed board (grid[r][c]==1) :-\\n\\t\\tIt gets stuck if there is a wall on right ( c==n-1) or a left directed board on right (grid[r][c+1]==-1)\\n\\t\\t\\n\\t\\tSimilarly for left directed board (grid[r][c]==-1):-\\n\\t\\tIt gets stuck if there is a wall on left ( c==0) or a right directed board on left (grid[r][c-1]==1)\\n\\t\\t*/\\n        if(grid[r][c]==1 && (c==n-1||grid[r][c+1]==-1) || grid[r][c]==-1 && (c==0||grid[r][c-1]==1))\\n            return -1;\\n\\t\\t\\n\\t\\t/*If ball reaches last row without getting stuck then following the direction of grid[r][c]\\n\\t\\tfor current column will give the final column\\n\\t\\t\\n\\t\\tWe can just add the value of grid[r][c] to c to do that\\n\\t\\tas for right direction column will become c+1\\n\\t\\tand for left , it will become c-1\\n\\t\\t*/\\n        if(r+1==m)\\n            return c+grid[r][c];\\n        \\n\\t\\t//Otherwise we can just recursively traverse further \\n\\t\\t//Ball goes down so r -> r+1\\n\\t\\t//and c -> c + grid[r][c] to follow board direction\\n        return endingColumnOfBall(r+1,c+grid[r][c],grid);\\n    }\\n    \\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        vector<int> ans(n);\\n        \\n\\t\\t//Tracing the path of the ball starting from each column and finding the last column it ends up in else returning -1 if it gets stuck\\n        for(int i=0;i<n;++i)\\n            ans[i] = endingColumnOfBall(0,i,grid);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity** **: O(m*n)** \\nFor each of the columns we may travel only as long as the ball doesn\\'t fall out of it , i.e , fall through all rows at max , so O(m) operations for each of the n columns\\n\\n**Space Complexity: O(n)**\\nFor the space taken by the ans vector excluding recursive stack space\\n\\nIf we also take into consideration the recursive stack space then **Space Complexity : O(max(m,n))**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int m,n;\\n    \\n    int endingColumnOfBall(int r,int c,vector<vector<int>>& grid)\\n    {\\n\\t\\t/*\\n\\t\\tConsidering the current cell at row r and column c\\n\\t\\t\\n\\t\\tThe ball gets stuck in two scenarios for each case of right and left directed board:\\n\\t\\t\\n\\t\\tFor right directed board (grid[r][c]==1) :-\\n\\t\\tIt gets stuck if there is a wall on right ( c==n-1) or a left directed board on right (grid[r][c+1]==-1)\\n\\t\\t\\n\\t\\tSimilarly for left directed board (grid[r][c]==-1):-\\n\\t\\tIt gets stuck if there is a wall on left ( c==0) or a right directed board on left (grid[r][c-1]==1)\\n\\t\\t*/\\n        if(grid[r][c]==1 && (c==n-1||grid[r][c+1]==-1) || grid[r][c]==-1 && (c==0||grid[r][c-1]==1))\\n            return -1;\\n\\t\\t\\n\\t\\t/*If ball reaches last row without getting stuck then following the direction of grid[r][c]\\n\\t\\tfor current column will give the final column\\n\\t\\t\\n\\t\\tWe can just add the value of grid[r][c] to c to do that\\n\\t\\tas for right direction column will become c+1\\n\\t\\tand for left , it will become c-1\\n\\t\\t*/\\n        if(r+1==m)\\n            return c+grid[r][c];\\n        \\n\\t\\t//Otherwise we can just recursively traverse further \\n\\t\\t//Ball goes down so r -> r+1\\n\\t\\t//and c -> c + grid[r][c] to follow board direction\\n        return endingColumnOfBall(r+1,c+grid[r][c],grid);\\n    }\\n    \\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        vector<int> ans(n);\\n        \\n\\t\\t//Tracing the path of the ball starting from each column and finding the last column it ends up in else returning -1 if it gets stuck\\n        for(int i=0;i<n;++i)\\n            ans[i] = endingColumnOfBall(0,i,grid);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767414,
                "title": "python-recursive-answer-with-complexity",
                "content": "- Time: O(MN)\\n- Space: O(M)\\n\\n```python\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        def col_get_out(row, col):\\n            # get out\\n            if row == m:\\n                return col\\n            # if grid[row][col] == -1, then go left\\n            # if grid[row][col] == 1, then go right\\n            new_col = col + grid[row][col]\\n            # stuck\\n            if (\\n                new_col == -1 # stuck at left\\n                or new_col == n # stuck at right\\n                or grid[row][new_col] != grid[row][col] # stcuk at \\\\/\\n            ):\\n                return -1\\n            return col_get_out(row + 1, new_col) # go down\\n        answer = []\\n        for c in range(n):\\n            answer.append(col_get_out(0, c))\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        def col_get_out(row, col):\\n            # get out\\n            if row == m:\\n                return col\\n            # if grid[row][col] == -1, then go left\\n            # if grid[row][col] == 1, then go right\\n            new_col = col + grid[row][col]\\n            # stuck\\n            if (\\n                new_col == -1 # stuck at left\\n                or new_col == n # stuck at right\\n                or grid[row][new_col] != grid[row][col] # stcuk at \\\\/\\n            ):\\n                return -1\\n            return col_get_out(row + 1, new_col) # go down\\n        answer = []\\n        for c in range(n):\\n            answer.append(col_get_out(0, c))\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767227,
                "title": "simple-java-solution-matrix-5ms",
                "content": "```\\nIF YOU LIKE THE SOLUTION SO PLEASE UPVOTE IT\\n```\\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        \\n        int row=grid.length;\\n        int col=grid[0].length;\\n        \\n        int ans[]=new int[col];\\n        \\n        for(int i=0;i<col;i++){\\n            \\n            int j=0,k=i;\\n            boolean check=false;\\n            \\n            while(j<row && k<col){\\n                if(grid[j][k]==1){\\n                    if((k<col-1 && grid[j][k+1]==-1)  || (k==col-1 && grid[j][k]==1)){\\n                        check=true;\\n                        break;\\n                    }\\n                    k++;\\n                    j++;\\n                }\\n                else if(grid[j][k]==-1){\\n                    if((k>0 && grid[j][k-1]==1) || (k==0 && grid[j][k]==-1)){\\n                        check=true;\\n                        break;\\n                    }\\n                    j++;\\n                    k--;\\n                }\\n            }\\n            if(j==row && check==false){\\n                ans[i]=k;\\n            }\\n            else{\\n                ans[i]=-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nIF YOU LIKE THE SOLUTION SO PLEASE UPVOTE IT\\n```\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        \\n        int row=grid.length;\\n        int col=grid[0].length;\\n        \\n        int ans[]=new int[col];\\n        \\n        for(int i=0;i<col;i++){\\n            \\n            int j=0,k=i;\\n            boolean check=false;\\n            \\n            while(j<row && k<col){\\n                if(grid[j][k]==1){\\n                    if((k<col-1 && grid[j][k+1]==-1)  || (k==col-1 && grid[j][k]==1)){\\n                        check=true;\\n                        break;\\n                    }\\n                    k++;\\n                    j++;\\n                }\\n                else if(grid[j][k]==-1){\\n                    if((k>0 && grid[j][k-1]==1) || (k==0 && grid[j][k]==-1)){\\n                        check=true;\\n                        break;\\n                    }\\n                    j++;\\n                    k--;\\n                }\\n            }\\n            if(j==row && check==false){\\n                ans[i]=k;\\n            }\\n            else{\\n                ans[i]=-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766557,
                "title": "1706-where-will-the-ball-fall-recursive-solution-in-c-fully-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int fB(int i,int j,vector<vector<int>> &grid)   //Helper function to find where each ball ends its journey\\n    {\\n        if(i==grid.size()-1)                       //if the ball is at (n-1)th row \\n        {\\n            if(j<grid[0].size()-1&&grid[i][j]==1&&grid[i][j+1]!=-1)        //Checking condition can ball collide with a wall?\\n                return j+1;                                                                //Also checking for v-shape formation\\n            else if(j>0&&grid[i][j]==-1&&grid[i][j-1]!=1)                      //Same condition if grid[i][j]=-1\\n                return j-1;                        \\n            else\\n                return -1;\\n        }\\n        if(i<0||i>=grid.size()||j<0||j>=grid[0].size())                           //if ball collides with walls on the left or right side\\n            return -1;\\n        if(j+1<grid[0].size()&&grid[i][j]==1&&grid[i][j+1]==-1)     //Checking v-shape formation\\n            return -1;\\n        if(j>0&&grid[i][j]==-1&&grid[i][j-1]==1)                         //Checking v-shape formation\\n            return -1; \\n        int ans{0};\\n        if(grid[i][j]==1)                         //If there is a  \\'\\\\\\' board at index (i,j)\\n        {\\n            ans=fB(i+1,j+1,grid);              //Get answer if the ball falls from (i+1,j+1) index,recursive call\\n            if(ans==-1)                          //As you got -1 as ans from the  (i+1,j+1) index means there is no way ball can \\n                return ans;                     //come out of any column\\n        }\\n        if(grid[i][j]==-1)                   //if there is a \\'/\\' board at index (i,j)\\n        {\\n            ans=fB(i+1,j-1,grid);        //Get answer if the ball falls from (i+1,j-1) index,recursive call\\n            if(ans==-1)                       //As you got -1 as ans from the  (i+1,j-11) index means there is no way ball can \\n                return -1;                      //come out of any column\\n        }\\n        return ans;                 //return the column ball comes out of\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        vector<int> res(grid[0].size(),0);             //vector to store where each ball ends it journey\\n        for(int i=0;i<grid[0].size();i++)                 //A ball being thrown from each column\\n        {\\n            res[i]=fB(0,i,grid);                  //Starting index of ith ball being (0,i)\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int fB(int i,int j,vector<vector<int>> &grid)   //Helper function to find where each ball ends its journey\\n    {\\n        if(i==grid.size()-1)                       //if the ball is at (n-1)th row \\n        {\\n            if(j<grid[0].size()-1&&grid[i][j]==1&&grid[i][j+1]!=-1)        //Checking condition can ball collide with a wall?\\n                return j+1;                                                                //Also checking for v-shape formation\\n            else if(j>0&&grid[i][j]==-1&&grid[i][j-1]!=1)                      //Same condition if grid[i][j]=-1\\n                return j-1;                        \\n            else\\n                return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2766447,
                "title": "javascript-recursive-beats-96-solutions",
                "content": "```\\nvar findBall = function(grid) {\\n    let m = grid.length;\\n    const n = grid[0].length;\\n    \\n    const answer = [...Array(n)].fill(-1);\\n    \\n    const moveBall = (index, row, col) => {\\n        if (row === m) {\\n            answer[index] = col;\\n            return true;\\n        }\\n        \\n        if (row >= m || col < 0 || col >= n) {\\n            return false;\\n        }\\n        \\n        const dir = grid[row][col];\\n        const next = [];\\n        \\n        switch(dir) {\\n            case 1: {\\n                const next = grid[row]?.[col + 1];\\n                if (next === 1) {\\n                    moveBall(index, row + 1, col + 1);\\n                }\\n                break;\\n            }\\n                \\n            case -1: {\\n                const next = grid[row]?.[col - 1];\\n                if (next === -1) {\\n                    moveBall(index, row + 1, col - 1);\\n                }\\n                break;\\n            }\\n        }\\n    }\\n    \\n    for(let i = 0; i < n; i++) {\\n        moveBall(i, 0, i);\\n    }\\n    \\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar findBall = function(grid) {\\n    let m = grid.length;\\n    const n = grid[0].length;\\n    \\n    const answer = [...Array(n)].fill(-1);\\n    \\n    const moveBall = (index, row, col) => {\\n        if (row === m) {\\n            answer[index] = col;\\n            return true;\\n        }\\n        \\n        if (row >= m || col < 0 || col >= n) {\\n            return false;\\n        }\\n        \\n        const dir = grid[row][col];\\n        const next = [];\\n        \\n        switch(dir) {\\n            case 1: {\\n                const next = grid[row]?.[col + 1];\\n                if (next === 1) {\\n                    moveBall(index, row + 1, col + 1);\\n                }\\n                break;\\n            }\\n                \\n            case -1: {\\n                const next = grid[row]?.[col - 1];\\n                if (next === -1) {\\n                    moveBall(index, row + 1, col - 1);\\n                }\\n                break;\\n            }\\n        }\\n    }\\n    \\n    for(let i = 0; i < n; i++) {\\n        moveBall(i, 0, i);\\n    }\\n    \\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2766191,
                "title": "dfs-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<vector<int>>& grid , int row , int col , int r , int c , vector<int> &ans , int column){\\n        if(r==row){\\n            if(c<col && c>=0 ){\\n                ans[column]=c;\\n            }\\n            return ;\\n        }\\n        int x = grid[r][c];\\n        if(x==-1){\\n            if(c-1 >=0){\\n                if(grid[r][c-1]==-1){\\n                    dfs(grid , row , col , r+1 , c-1 , ans , column);\\n                }\\n            }\\n        }\\n        else{\\n            if(c+1 < col){\\n                if(grid[r][c+1]==1){\\n                    dfs(grid , row , col , r+1 , c+1 , ans , column);\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<int> ans(col , -1);\\n        for(int i=0 ; i<col ; i++){\\n            dfs(grid , row , col , 0 , i , ans , i );\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<vector<int>>& grid , int row , int col , int r , int c , vector<int> &ans , int column){\\n        if(r==row){\\n            if(c<col && c>=0 ){\\n                ans[column]=c;\\n            }\\n            return ;\\n        }\\n        int x = grid[r][c];\\n        if(x==-1){\\n            if(c-1 >=0){\\n                if(grid[r][c-1]==-1){\\n                    dfs(grid , row , col , r+1 , c-1 , ans , column);\\n                }\\n            }\\n        }\\n        else{\\n            if(c+1 < col){\\n                if(grid[r][c+1]==1){\\n                    dfs(grid , row , col , r+1 , c+1 , ans , column);\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<int> ans(col , -1);\\n        for(int i=0 ; i<col ; i++){\\n            dfs(grid , row , col , 0 , i , ans , i );\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766107,
                "title": "c-simple-iterative-solution",
                "content": "```\\nvector<int> findBall(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<int>ans;\\n        \\n        for(int k=0;k<m;k++){\\n            \\n            int i = 0;\\n            int j = k;\\n            \\n            while(i < n){\\n                \\n                if(grid[i][j] == 1 && j < m-1 && grid[i][j+1] == 1){\\n                    i++;\\n                    j++;\\n                }\\n                else if(grid[i][j] == -1 && j > 0 && grid[i][j-1] == -1){\\n                    i++;\\n                    j--;\\n                }\\n                else{\\n                    break;\\n                }                \\n            }\\n            \\n            if(i == n){\\n                ans.push_back(j);\\n            }\\n            else ans.push_back(-1);\\n            \\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nvector<int> findBall(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<int>ans;\\n        \\n        for(int k=0;k<m;k++){\\n            \\n            int i = 0;\\n            int j = k;\\n            \\n            while(i < n){\\n                \\n                if(grid[i][j] == 1 && j < m-1 && grid[i][j+1] == 1){\\n                    i++;\\n                    j++;\\n                }\\n                else if(grid[i][j] == -1 && j > 0 && grid[i][j-1] == -1){\\n                    i++;\\n                    j--;\\n                }\\n                else{\\n                    break;\\n                }                \\n            }\\n            \\n            if(i == n){\\n                ans.push_back(j);\\n            }\\n            else ans.push_back(-1);\\n            \\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2766073,
                "title": "c-simple-iterative-solution-beginner",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        vector<int> ret;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for(int j=0; j<c; j++){\\n            int x = 0;\\n            int y = j;\\n            while(1){\\n                if(x==r){//if ball goes out of the box\\n                    ret.push_back(y);\\n                    break;\\n                }\\n                if(grid[x][y] == 1){\\n                    if(y+1 == c || grid[x][y+1] == -1){//if ball goes outside the right wall/col-N or V pattern\\n                        ret.push_back(-1);\\n                        break;\\n                    }\\n                    x = x+1;\\n                    y = y+1;\\n                    continue;\\n                }\\n                else{//if ball goes outside the left wall/col-0 or V pattern\\n                    if(y-1 < 0 || grid[x][y-1] == 1){\\n                        ret.push_back(-1);\\n                        break;\\n                    }\\n                    x = x+1;\\n                    y = y-1;\\n                    continue;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\nPlease feel free to suggest better solution/optimizations. Just a simple approach.",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        vector<int> ret;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for(int j=0; j<c; j++){\\n            int x = 0;\\n            int y = j;\\n            while(1){\\n                if(x==r){//if ball goes out of the box\\n                    ret.push_back(y);\\n                    break;\\n                }\\n                if(grid[x][y] == 1){\\n                    if(y+1 == c || grid[x][y+1] == -1){//if ball goes outside the right wall/col-N or V pattern\\n                        ret.push_back(-1);\\n                        break;\\n                    }\\n                    x = x+1;\\n                    y = y+1;\\n                    continue;\\n                }\\n                else{//if ball goes outside the left wall/col-0 or V pattern\\n                    if(y-1 < 0 || grid[x][y-1] == 1){\\n                        ret.push_back(-1);\\n                        break;\\n                    }\\n                    x = x+1;\\n                    y = y-1;\\n                    continue;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766040,
                "title": "c-simple-simulation-o-m-n",
                "content": "```\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n\\t\\t// Dimensions of the grid.\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<int> ans;\\n\\t\\t\\n\\t\\t// Base case of only 1 column.\\n        if (n == 1) {\\n            ans.push_back(-1);\\n            return ans;\\n        }\\n\\t\\t\\n\\t\\t// Checking path of each ball and determining its next position.\\n\\t\\t// Returing the final column value.\\n        for (int i = 0; i < n; ++i)\\n        {\\n            bool flag = true;\\n            int r = 0, c = i;\\n            while (r < m) {\\n                if (grid[r][c] == 1 && c < n - 1 && grid[r][c] == grid[r][c + 1]) c++;\\n                else if (grid[r][c] == -1 && c > 0 && grid[r][c] == grid[r][c - 1]) c--;\\n                else {\\n                    ans.push_back(-1);\\n                    flag = false;\\n                    break;\\n                }\\n                r++;\\n            }\\n            if (flag) ans.push_back(c);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n\\t\\t// Dimensions of the grid.\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<int> ans;\\n\\t\\t\\n\\t\\t// Base case of only 1 column.\\n        if (n == 1) {\\n            ans.push_back(-1);\\n            return ans;\\n        }\\n\\t\\t\\n\\t\\t// Checking path of each ball and determining its next position.\\n\\t\\t// Returing the final column value.\\n        for (int i = 0; i < n; ++i)\\n        {\\n            bool flag = true;\\n            int r = 0, c = i;\\n            while (r < m) {\\n                if (grid[r][c] == 1 && c < n - 1 && grid[r][c] == grid[r][c + 1]) c++;\\n                else if (grid[r][c] == -1 && c > 0 && grid[r][c] == grid[r][c - 1]) c--;\\n                else {\\n                    ans.push_back(-1);\\n                    flag = false;\\n                    break;\\n                }\\n                r++;\\n            }\\n            if (flag) ans.push_back(c);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2765965,
                "title": "1706-where-will-the-ball-fall-leetcode-daily-challenge-nov-1-dynamic-programming",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector<int> dp(n);\\n        vector<int> ans(n, -1);\\n\\n        iota(begin(dp), end(dp), 0);\\n\\n        for (int i = 0; i < m; ++i) {\\n          vector<int> newDp(n, -1);\\n          for (int j = 0; j < n; ++j) {\\n            if (j + grid[i][j] < 0 || j + grid[i][j] == n)\\n              continue;\\n            if (grid[i][j] == 1 && grid[i][j + 1] == -1 ||\\n                grid[i][j] == -1 && grid[i][j - 1] == 1)\\n              continue;\\n            newDp[j + grid[i][j]] = dp[j];\\n          }\\n          dp = move(newDp);\\n        }\\n\\n        for (int i = 0; i < n; ++i)\\n          if (dp[i] != -1)\\n            ans[dp[i]] = i;\\n\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector<int> dp(n);\\n        vector<int> ans(n, -1);\\n\\n        iota(begin(dp), end(dp), 0);\\n\\n        for (int i = 0; i < m; ++i) {\\n          vector<int> newDp(n, -1);\\n          for (int j = 0; j < n; ++j) {\\n            if (j + grid[i][j] < 0 || j + grid[i][j] == n)\\n              continue;\\n            if (grid[i][j] == 1 && grid[i][j + 1] == -1 ||\\n                grid[i][j] == -1 && grid[i][j - 1] == 1)\\n              continue;\\n            newDp[j + grid[i][j]] = dp[j];\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2765699,
                "title": "c-easy-solution-with-explanation-in-comments-using-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\nint m , n ;\\n\\n   int SolveByMemo(vector<vector<int>>& grid , int row , int col ,vector<vector<int>> &dp)\\n   {\\n       // Base Case : If We have came out of grid we return its column\\n          if(row == m)\\n           return col;\\n\\n        // IF We Have already visited for particular cell  we returned its stored ans\\n           if(dp[row][col] != -4)\\n           return dp[row][col];\\n        \\n        // If we are at leftmost column\\n           if(col == 0)\\n           {\\n               // IF cell redirects to left from leftmost cell we the ball gets stuck\\n               if(grid[row][col] == -1)\\n               return dp[row][col] = -1;\\n                \\n              // If Cell redirects to right from leftmost we check for the next cell\\n               else\\n               {\\n                // if next cell redirects back to current cell the ball gets stuck\\n                  if(grid[row][col+1] == -1 )\\n                  return dp[row][col] = -1;\\n            // else we can go to next right column of next row\\n                  return dp[row][col] = SolveByMemo(grid , row+1 , col+1 , dp);\\n               }\\n\\n           }\\n\\n        // If we are at rightmost column\\n           if(col == n-1)\\n           {\\n // IF cell redirects to right from rightmost cell we the ball gets stuck\\n               if(grid[row][col] == 1)\\n               return dp[row][col] = -1;\\n             // If Cell redirects to right from leftmost we check for the next cell\\n               \\n               else\\n               {\\n            // if prev cell redirects back to current cell the ball gets stuck\\n                  if(grid[row][col-1] == 1 )\\n                  return dp[row][col] = -1;\\n            // else we can go to next left column of next row\\n                  return dp[row][col] = SolveByMemo(grid , row+1 , col-1 , dp);\\n               }\\n           }\\n\\n           // iF Current cell redirects to right \\n           if(grid[row][col] == 1)\\n           {\\n            // if right cell redirects to left , the ball is stuck \\n             if(grid[row][col+1] == -1)\\n             return dp[row][col] = -1;\\n              // else we can go to next right column of next row\\n             return dp[row][col] = SolveByMemo(grid , row+1 , col+1 , dp);\\n           }\\n           // iF Current cell redirects to left\\n           else\\n           {\\n            // if left cell redirects to right , the ball is stuck \\n             if(grid[row][col-1] == 1)\\n             return dp[row][col] = -1;\\n\\n            // else we can go to next left column of next row\\n             return dp[row][col] = SolveByMemo(grid , row+1 , col-1 , dp);\\n           }\\n           return -1;\\n   }\\n\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n         \\n\\n        m = grid.size();\\n        n = grid[0].size();\\n\\n\\n        //if there is only one  column irrespective of no. of  rows the ball will stuck \\n         if(n == 1)\\n         return {-1};\\n\\n\\n        vector<int> ans(n , -1);\\n\\n        vector<vector<int>> dp(m , vector<int> (n , -4) ); \\n      \\n      for(int i = 0 ; i< n; i++)\\n      {\\n          // We check for each ball one by one each \\n        ans[i] =  SolveByMemo(grid , 0 , i, dp);\\n      } \\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\nint m , n ;\\n\\n   int SolveByMemo(vector<vector<int>>& grid , int row , int col ,vector<vector<int>> &dp)\\n   {\\n       // Base Case : If We have came out of grid we return its column\\n          if(row == m)\\n           return col;\\n\\n        // IF We Have already visited for particular cell  we returned its stored ans\\n           if(dp[row][col] != -4)\\n           return dp[row][col];\\n        \\n        // If we are at leftmost column\\n           if(col == 0)\\n           {\\n               // IF cell redirects to left from leftmost cell we the ball gets stuck\\n               if(grid[row][col] == -1)\\n               return dp[row][col] = -1;\\n                \\n              // If Cell redirects to right from leftmost we check for the next cell\\n               else\\n               {\\n                // if next cell redirects back to current cell the ball gets stuck\\n                  if(grid[row][col+1] == -1 )\\n                  return dp[row][col] = -1;\\n            // else we can go to next right column of next row\\n                  return dp[row][col] = SolveByMemo(grid , row+1 , col+1 , dp);\\n               }\\n\\n           }\\n\\n        // If we are at rightmost column\\n           if(col == n-1)\\n           {\\n // IF cell redirects to right from rightmost cell we the ball gets stuck\\n               if(grid[row][col] == 1)\\n               return dp[row][col] = -1;\\n             // If Cell redirects to right from leftmost we check for the next cell\\n               \\n               else\\n               {\\n            // if prev cell redirects back to current cell the ball gets stuck\\n                  if(grid[row][col-1] == 1 )\\n                  return dp[row][col] = -1;\\n            // else we can go to next left column of next row\\n                  return dp[row][col] = SolveByMemo(grid , row+1 , col-1 , dp);\\n               }\\n           }\\n\\n           // iF Current cell redirects to right \\n           if(grid[row][col] == 1)\\n           {\\n            // if right cell redirects to left , the ball is stuck \\n             if(grid[row][col+1] == -1)\\n             return dp[row][col] = -1;\\n              // else we can go to next right column of next row\\n             return dp[row][col] = SolveByMemo(grid , row+1 , col+1 , dp);\\n           }\\n           // iF Current cell redirects to left\\n           else\\n           {\\n            // if left cell redirects to right , the ball is stuck \\n             if(grid[row][col-1] == 1)\\n             return dp[row][col] = -1;\\n\\n            // else we can go to next left column of next row\\n             return dp[row][col] = SolveByMemo(grid , row+1 , col-1 , dp);\\n           }\\n           return -1;\\n   }\\n\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n         \\n\\n        m = grid.size();\\n        n = grid[0].size();\\n\\n\\n        //if there is only one  column irrespective of no. of  rows the ball will stuck \\n         if(n == 1)\\n         return {-1};\\n\\n\\n        vector<int> ans(n , -1);\\n\\n        vector<vector<int>> dp(m , vector<int> (n , -4) ); \\n      \\n      for(int i = 0 ; i< n; i++)\\n      {\\n          // We check for each ball one by one each \\n        ans[i] =  SolveByMemo(grid , 0 , i, dp);\\n      } \\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765670,
                "title": "java-where-will-the-ball-fall-simulation-bfs",
                "content": "```\\nclass Solution {\\n    \\n    \\n    class BallInfo {\\n        int col; // from which column.\\n        int x,y; // determines currentPosition.\\n        \\n        public BallInfo(int col,int x,int y) {\\n            this.col = col;\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    \\n    public int[] findBall(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Queue<BallInfo> q = new LinkedList<>();\\n        int ans[] = new int[m];\\n        int idx=0;\\n        \\n        for(int i=0;i<m;i++) {\\n            q.offer(new BallInfo(i,0,i));         \\n        }\\n        \\n        while(!q.isEmpty()) {\\n            \\n            BallInfo cb = q.poll();\\n            // reached end of row.\\n            if(cb.x>=n) {\\n                ans[cb.col] = cb.y;\\n                continue;\\n            }\\n\\t\\t\\tif(cb.x<0 || cb.y>=m || cb.y<0) { // current ball is outOFBounds already.\\n                continue;\\n            }\\n            \\n            int nextX = cb.x;\\n            int nextY = (grid[cb.x][cb.y]==1?cb.y+1:cb.y-1);\\n            \\n            // struck condition.\\n            if(nextX<0 || nextY>=m || nextY<0 || grid[nextX][nextY]+grid[cb.x][cb.y]==0) {\\n                ans[cb.col] = -1;\\n                continue;\\n            }\\n            \\n            if(grid[cb.x][cb.y]==1) {\\n                q.offer(new BallInfo(cb.col,cb.x+1,cb.y+1));\\n            } else {\\n                q.offer(new BallInfo(cb.col,cb.x+1,cb.y-1));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n*Please Upvote if you found my solution useful. Thanks :)*\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    class BallInfo {\\n        int col; // from which column.\\n        int x,y; // determines currentPosition.\\n        \\n        public BallInfo(int col,int x,int y) {\\n            this.col = col;\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    \\n    public int[] findBall(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Queue<BallInfo> q = new LinkedList<>();\\n        int ans[] = new int[m];\\n        int idx=0;\\n        \\n        for(int i=0;i<m;i++) {\\n            q.offer(new BallInfo(i,0,i));         \\n        }\\n        \\n        while(!q.isEmpty()) {\\n            \\n            BallInfo cb = q.poll();\\n            // reached end of row.\\n            if(cb.x>=n) {\\n                ans[cb.col] = cb.y;\\n                continue;\\n            }\\n\\t\\t\\tif(cb.x<0 || cb.y>=m || cb.y<0) { // current ball is outOFBounds already.\\n                continue;\\n            }\\n            \\n            int nextX = cb.x;\\n            int nextY = (grid[cb.x][cb.y]==1?cb.y+1:cb.y-1);\\n            \\n            // struck condition.\\n            if(nextX<0 || nextY>=m || nextY<0 || grid[nextX][nextY]+grid[cb.x][cb.y]==0) {\\n                ans[cb.col] = -1;\\n                continue;\\n            }\\n            \\n            if(grid[cb.x][cb.y]==1) {\\n                q.offer(new BallInfo(cb.col,cb.x+1,cb.y+1));\\n            } else {\\n                q.offer(new BallInfo(cb.col,cb.x+1,cb.y-1));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765594,
                "title": "easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    \\n    int findBallDropColumn(int row, int col, vector<vector<int>>& grid) {\\n        // base case; ball reached the last row\\n        if (row == n) return col;\\n        int nextColumn = col + grid[row][col];\\n        if (nextColumn < 0 || nextColumn > m - 1 ||\\n            grid[row][col] != grid[row][nextColumn]) {\\n            return -1;\\n        }\\n        return findBallDropColumn(row + 1, nextColumn, grid);\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<int> ans;\\n        for(int i=0;i<m;i++){\\n            int f=findBallDropColumn(0,i,grid);\\n            ans.push_back(f);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    \\n    int findBallDropColumn(int row, int col, vector<vector<int>>& grid) {\\n        // base case; ball reached the last row\\n        if (row == n) return col;\\n        int nextColumn = col + grid[row][col];\\n        if (nextColumn < 0 || nextColumn > m - 1 ||\\n            grid[row][col] != grid[row][nextColumn]) {\\n            return -1;\\n        }\\n        return findBallDropColumn(row + 1, nextColumn, grid);\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<int> ans;\\n        for(int i=0;i<m;i++){\\n            int f=findBallDropColumn(0,i,grid);\\n            ans.push_back(f);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765580,
                "title": "java-beginner-solution-faster-than-100-with-fun-comments",
                "content": "```\\nclass Solution {\\n    private int helper(int i, int j, int[][] grid){\\n        \\n        if(j<0 || j>=grid[0].length) return -1; //if stuck at the corner condition\\n        if(i == grid.length) return j; //if reached the end return the column no.\\n        \\n        int dir = grid[i][j]; //get direction\\\\\\n        \\n        //check if we have an opening to slide our balls in right direction\\n        if(dir == 1 && j+1 < grid[0].length && grid[i][j+1] != -1){ \\n            return helper(i+1,j+1,grid); //if yes slide in the ball and continue\\n        }\\n        \\n        //check if we have an opening to slide our balls in left direction\\n        if(dir == -1 && j-1 >= 0 && grid[i][j-1] != 1){\\n            return helper(i+1,j-1,grid); //if yes slide in the ball and continue\\n        }\\n        return -1; //if we can\\'t slide our balls in return -1 as the ball is stuck in the middle.\\n        \\n    }\\n    \\n    public int[] findBall(int[][] grid) {\\n        int ans[] = new int[grid[0].length]; //building ans\\n        for (int i = 0; i < grid[0].length;i++){ //start sliding one ball from each column.\\n            ans[i] = helper(0,i,grid);\\n        }\\n        return ans; //return ans.\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private int helper(int i, int j, int[][] grid){\\n        \\n        if(j<0 || j>=grid[0].length) return -1; //if stuck at the corner condition\\n        if(i == grid.length) return j; //if reached the end return the column no.\\n        \\n        int dir = grid[i][j]; //get direction\\\\\\n        \\n        //check if we have an opening to slide our balls in right direction\\n        if(dir == 1 && j+1 < grid[0].length && grid[i][j+1] != -1){ \\n            return helper(i+1,j+1,grid); //if yes slide in the ball and continue\\n        }\\n        \\n        //check if we have an opening to slide our balls in left direction\\n        if(dir == -1 && j-1 >= 0 && grid[i][j-1] != 1){\\n            return helper(i+1,j-1,grid); //if yes slide in the ball and continue\\n        }\\n        return -1; //if we can\\'t slide our balls in return -1 as the ball is stuck in the middle.\\n        \\n    }\\n    \\n    public int[] findBall(int[][] grid) {\\n        int ans[] = new int[grid[0].length]; //building ans\\n        for (int i = 0; i < grid[0].length;i++){ //start sliding one ball from each column.\\n            ans[i] = helper(0,i,grid);\\n        }\\n        return ans; //return ans.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764887,
                "title": "c-easy-solution-faster-than-95-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int R, C;\\n    int dfs(vector<vector<int>>& grid, int r, int c, int from) {\\n        if (r == R) return c;\\n        if (c == C or c < 0) return -1;\\n        if (from == 0) {\\n            if (grid[r][c] == 1) return dfs(grid, r, c+1, 1);\\n            else return dfs(grid, r, c-1, 3);\\n        } else if (from == 1) {\\n            if (grid[r][c] == 1) return dfs(grid, r+1, c, 0);\\n            else return -1;\\n        } else {\\n            if (grid[r][c] == 1) return -1;            \\n\\t\\t\\telse return dfs(grid, r+1, c, 0);\\n        }\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        R = grid.size();\\n        C = grid[0].size();\\n        vector<int> ans;\\n        for (int i=0; i<C; i++) {\\n            auto r = dfs(grid, 0, i, 0);\\n            ans.push_back(r);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int R, C;\\n    int dfs(vector<vector<int>>& grid, int r, int c, int from) {\\n        if (r == R) return c;\\n        if (c == C or c < 0) return -1;\\n        if (from == 0) {\\n            if (grid[r][c] == 1) return dfs(grid, r, c+1, 1);\\n            else return dfs(grid, r, c-1, 3);\\n        } else if (from == 1) {\\n            if (grid[r][c] == 1) return dfs(grid, r+1, c, 0);\\n            else return -1;\\n        } else {\\n            if (grid[r][c] == 1) return -1;            \\n\\t\\t\\telse return dfs(grid, r+1, c, 0);\\n        }\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        R = grid.size();\\n        C = grid[0].size();\\n        vector<int> ans;\\n        for (int i=0; i<C; i++) {\\n            auto r = dfs(grid, 0, i, 0);\\n            ans.push_back(r);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739365,
                "title": "python-bottom-up-dp-approach",
                "content": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        dp = [[i for i in range(COLS)] for _ in range(ROWS + 1)]\\n        \\n        for r in range(ROWS - 1, -1, -1):\\n            for c in range(COLS):\\n                nc = c + grid[r][c]\\n                if nc < 0 or nc == COLS or grid[r][nc] != grid[r][c]:\\n                    dp[r][c] = -1\\n                else:\\n                    dp[r][c] = dp[r + 1][nc]\\n        \\n        return dp[0]\\n        \\n        # TIME: O(M*N)\\n        # SPACE: O(M*N)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        dp = [[i for i in range(COLS)] for _ in range(ROWS + 1)]\\n        \\n        for r in range(ROWS - 1, -1, -1):\\n            for c in range(COLS):\\n                nc = c + grid[r][c]\\n                if nc < 0 or nc == COLS or grid[r][nc] != grid[r][c]:\\n                    dp[r][c] = -1\\n                else:\\n                    dp[r][c] = dp[r + 1][nc]\\n        \\n        return dp[0]\\n        \\n        # TIME: O(M*N)\\n        # SPACE: O(M*N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727428,
                "title": "javascript-clean-simple-simulated-drop-100",
                "content": "```\\nconst findBall = grid => {\\n  const balls = []\\n  for (let i = 0; i < grid[0].length; i++) {\\n    balls.push(simulateBall(i))\\n  }\\n  return balls\\n  \\n  function simulateBall(idx) {\\n    for (let i = 0; i < grid.length; i++) {\\n      const level = grid[i]\\n      if (isValley(idx, level)) return -1\\n      else idx += level[idx]\\n      if (isOutOfBounds(idx)) return -1\\n    }\\n    return idx\\n  }\\n  \\n  function isOutOfBounds(idx) {\\n    return idx < 0 || idx >= grid[0].length\\n  }\\n  \\n  function isValley(idx, level) {\\n    return (level[idx] === 1 && level[idx + 1] === -1) || \\n      (level[idx] === -1 && level[idx - 1] === 1)\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findBall = grid => {\\n  const balls = []\\n  for (let i = 0; i < grid[0].length; i++) {\\n    balls.push(simulateBall(i))\\n  }\\n  return balls\\n  \\n  function simulateBall(idx) {\\n    for (let i = 0; i < grid.length; i++) {\\n      const level = grid[i]\\n      if (isValley(idx, level)) return -1\\n      else idx += level[idx]\\n      if (isOutOfBounds(idx)) return -1\\n    }\\n    return idx\\n  }\\n  \\n  function isOutOfBounds(idx) {\\n    return idx < 0 || idx >= grid[0].length\\n  }\\n  \\n  function isValley(idx, level) {\\n    return (level[idx] === 1 && level[idx + 1] === -1) || \\n      (level[idx] === -1 && level[idx - 1] === 1)\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2639014,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] findBall(int[][] g) {\\n        int k=g.length,p=g[0].length;\\n        int a[]=new int[p];\\n        for(int i=0;i<p;i++)\\n        {\\n            int m=i,l=0;\\n            for(int j=0;j<k;j++)\\n            {\\n                l=m+g[j][m];\\n                if(l<0 || l>=p || g[j][m] != g[j][l])\\n                {\\n                    m=-1;\\n                    break;\\n                }\\n                m=l;\\n            }\\n            a[i]=m;\\n        }\\n        return a;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] findBall(int[][] g) {\\n        int k=g.length,p=g[0].length;\\n        int a[]=new int[p];\\n        for(int i=0;i<p;i++)\\n        {\\n            int m=i,l=0;\\n            for(int j=0;j<k;j++)\\n            {\\n                l=m+g[j][m];\\n                if(l<0 || l>=p || g[j][m] != g[j][l])\\n                {\\n                    m=-1;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2605483,
                "title": "java-dp-solution-beats-100-self-documented-code",
                "content": "\\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int landedSpots[] = new int[grid[0].length];\\n        Arrays.fill(landedSpots, -1);\\n        \\n        for (int column = 0; column < grid[0].length; column++) {\\n            int columnLandedIn = ballFall(grid, 0, column);\\n            \\n            if (columnLandedIn != -1) landedSpots[column] = columnLandedIn;\\n        }\\n        return landedSpots;\\n    }\\n    \\n    public int ballFall(int[][] grid, int row, int column) {\\n        if (row == grid.length) return column;\\n        \\n        int cellDirection = grid[row][column];\\n        int directionCellColumn = column+cellDirection;\\n        \\n        if (directionCellColumn < 0 || directionCellColumn > grid[row].length - 1) return -1;\\n        if (grid[row][directionCellColumn] != cellDirection) return -1;\\n        \\n        return ballFall(grid, row + 1, directionCellColumn);\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/11354832-e00c-4c76-b85f-17a911d7a94c_1663762573.6559026.png)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int landedSpots[] = new int[grid[0].length];\\n        Arrays.fill(landedSpots, -1);\\n        \\n        for (int column = 0; column < grid[0].length; column++) {\\n            int columnLandedIn = ballFall(grid, 0, column);\\n            \\n            if (columnLandedIn != -1) landedSpots[column] = columnLandedIn;\\n        }\\n        return landedSpots;\\n    }\\n    \\n    public int ballFall(int[][] grid, int row, int column) {\\n        if (row == grid.length) return column;\\n        \\n        int cellDirection = grid[row][column];\\n        int directionCellColumn = column+cellDirection;\\n        \\n        if (directionCellColumn < 0 || directionCellColumn > grid[row].length - 1) return -1;\\n        if (grid[row][directionCellColumn] != cellDirection) return -1;\\n        \\n        return ballFall(grid, row + 1, directionCellColumn);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530718,
                "title": "very-simple-memoization-dfs-solution",
                "content": "```\\nclass Solution {\\n    Integer memo[][],m,n;\\n    public int[] findBall(int[][] grid) {\\n        m=grid.length; n=grid[0].length; memo = new Integer[m][n];\\n        int i,ar[]=new int[n];\\n        for(i=0;i<n;i++) ar[i]=go(grid,i,0);\\n        return ar;\\n    }\\n    int go(int[][] grid, int i, int j){\\n        if(j==m) return i;\\n        if(memo[j][i]!=null) return memo[j][i];\\n        if(grid[j][i]==1){\\n            if((i+1)==n || grid[j][i+1]==-1) return -1;\\n            else return memo[j][i]=go(grid,i+1,j+1);\\n        }else{\\n            if((i-1)==-1 || grid[j][i-1]==1) return -1;\\n            else return memo[j][i]=go(grid,i-1,j+1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer memo[][],m,n;\\n    public int[] findBall(int[][] grid) {\\n        m=grid.length; n=grid[0].length; memo = new Integer[m][n];\\n        int i,ar[]=new int[n];\\n        for(i=0;i<n;i++) ar[i]=go(grid,i,0);\\n        return ar;\\n    }\\n    int go(int[][] grid, int i, int j){\\n        if(j==m) return i;\\n        if(memo[j][i]!=null) return memo[j][i];\\n        if(grid[j][i]==1){\\n            if((i+1)==n || grid[j][i+1]==-1) return -1;\\n            else return memo[j][i]=go(grid,i+1,j+1);\\n        }else{\\n            if((i-1)==-1 || grid[j][i-1]==1) return -1;\\n            else return memo[j][i]=go(grid,i-1,j+1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475430,
                "title": "python-dynamic-programming-row-iteration-o-n-space-o-mn-time",
                "content": "Let `m = len(grid), n = len(grid[0])`\\nIntuition: \\n* We can track the position of the balls. Initially, all balls are of positions `[0..n]`.\\n* Without loss of generality, let ball `i` has position `pi` in `[-1..n]`\\n* If the ball is not stuck, the update is straightforward: if `row[pi] == 1` then `pi = pi + 1`, otherwise `pi = pi -1`.\\n* There can be only 4 case where balls get stuck:\\n\\t* If it is on the left of the row (`pi = 0`) and `row[pi] == -1`. \\n\\t* If it is on the right of the row (`pi = 0`) and `row[pi] == +1`. \\n\\t* If it is in the middle of the row `row[pi] = 1` and `row[pi+1] = -1`\\n\\t* If it is in the middle of the row `row[pi] = -1` and `row[pi-1] = 1`.\\n\\nGiven this, the iteration is as follow:\\n* We skip the ones that already stuck.\\n* We update the ball position if it not stuck.\\n\\nFor the space, we have to maintain the array `pos`, which will be `O(n)`\\nSince we iterate each row, and in each row we go through all `pos` elements, the time is `O(mn)`\\n\\n```python\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        # 1. the ball can arrive at this row, or not.\\n        # 2. keep track of the previous loc ball\\'s id so that we know how to update it.\\n        pos = list(range(len(grid[0])))\\n        for row in grid:\\n            for i, p in enumerate(pos):\\n                if p == -1:\\n                    continue\\n                if p == 0 and (row[p] == -1 or p == len(row) - 1):\\n                    pos[i] = -1\\n                    continue\\n                if p == len(row) - 1 and (row[p] == 1 or p == 0):\\n                    pos[i] = -1\\n                    continue\\n                else:\\n                    if row[p] == 1:\\n                        if row[p + 1] == -1:\\n                            pos[i] = -1\\n                        else:\\n                            pos[i] = p + 1\\n                    else:\\n                        if row[p-1] == 1:\\n                            pos[i] = -1\\n                        else:\\n                            pos[i] = p - 1\\n        return pos\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        # 1. the ball can arrive at this row, or not.\\n        # 2. keep track of the previous loc ball\\'s id so that we know how to update it.\\n        pos = list(range(len(grid[0])))\\n        for row in grid:\\n            for i, p in enumerate(pos):\\n                if p == -1:\\n                    continue\\n                if p == 0 and (row[p] == -1 or p == len(row) - 1):\\n                    pos[i] = -1\\n                    continue\\n                if p == len(row) - 1 and (row[p] == 1 or p == 0):\\n                    pos[i] = -1\\n                    continue\\n                else:\\n                    if row[p] == 1:\\n                        if row[p + 1] == -1:\\n                            pos[i] = -1\\n                        else:\\n                            pos[i] = p + 1\\n                    else:\\n                        if row[p-1] == 1:\\n                            pos[i] = -1\\n                        else:\\n                            pos[i] = p - 1\\n        return pos\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384913,
                "title": "python-simple-easy-to-understand",
                "content": "\\nSimple recursion for each column in our grid to simulate with 3 base cases\\n\\t1. if current row == len(grid), we\\'ve reached the bottom. Return the current col\\n\\t2. If current cell value is 1, check if cell to the right is -1, or if we\\'re out of bounds. If so, ball is stuck. Return -1\\n\\t3. If current cell value is -1, check if cell to the left is 1, or if we\\'re out of bounds, Return -1 if true\\n\\nWhen traversing, row is always incremented by 1, but col depends on the current cell value. Fortunately, we can just do `c + grid[r][c]` for the next col.\\n\\t\\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        ROWS = len(grid)\\n        COLS = len(grid[0]) \\n        res = [-1 for _ in range(COLS)]\\n        \\n        def dfs(r, c):\\n            if r == ROWS: return c\\n            if grid[r][c] == 1 and (c + 1 >= COLS or grid[r][c+1] == -1):\\n                return -1\\n            elif grid[r][c] == -1 and (c - 1 < 0 or grid[r][c-1] == 1):\\n                return -1\\n            \\n            return dfs(r + 1, c + grid[r][c])\\n        \\n        for i in range(COLS):\\n            res[i] = dfs(0, i)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        ROWS = len(grid)\\n        COLS = len(grid[0]) \\n        res = [-1 for _ in range(COLS)]\\n        \\n        def dfs(r, c):\\n            if r == ROWS: return c\\n            if grid[r][c] == 1 and (c + 1 >= COLS or grid[r][c+1] == -1):\\n                return -1\\n            elif grid[r][c] == -1 and (c - 1 < 0 or grid[r][c-1] == 1):\\n                return -1\\n            \\n            return dfs(r + 1, c + grid[r][c])\\n        \\n        for i in range(COLS):\\n            res[i] = dfs(0, i)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370457,
                "title": "python-my-soln-easiest-to-understand",
                "content": "class Solution:\\n\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        def dfs(i,j):\\n            if i == m: return j \\n            \\n            if j == n-1 and grid[i][j] == 1: return -1 \\n            \\n            if j == 0 and grid[i][j] == -1: return -1 \\n            \\n            if grid[i][j] == 1 and grid[i][j+1] == -1: return -1 \\n            \\n            if grid[i][j] == -1 and grid[i][j-1] == 1: return -1\\n            \\n            \\n            return dfs(i+1,j+grid[i][j]) \\n        \\n        \\n        ans = []\\n        for idx in range(n):\\n            val = dfs(0, idx)\\n            ans.append(val)\\n            \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        def dfs(i,j):\\n            if i == m: return j \\n            \\n            if j == n-1 and grid[i][j] == 1: return -1 \\n            \\n            if j == 0 and grid[i][j] == -1: return -1 \\n            \\n            if grid[i][j] == 1 and grid[i][j+1] == -1: return -1 \\n            \\n            if grid[i][j] == -1 and grid[i][j-1] == 1: return -1\\n            \\n            \\n            return dfs(i+1,j+grid[i][j]) \\n        \\n        \\n        ans = []\\n        for idx in range(n):\\n            val = dfs(0, idx)\\n            ans.append(val)\\n            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2367255,
                "title": "1706-python",
                "content": "\\tclass Solution:\\n\\t\\tdef findBall(self, grid: List[List[int]]) -> List[int]:\\n\\t\\t\\tr = len(grid)\\n\\t\\t\\tc = len(grid[0])\\n\\t\\t\\tres = []\\n\\t\\t\\tdef fallsin(i,j):\\n\\t\\t\\t\\tif i == r:\\n\\t\\t\\t\\t\\tres.append(j) \\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif grid[i][j] == 1 and j+1 < c and grid[i][j+1] == 1:\\n\\t\\t\\t\\t\\tfallsin(i+1,j+1)\\n\\n\\t\\t\\t\\telif grid[i][j] == -1 and j-1 >= 0 and grid[i][j-1] == -1:\\n\\t\\t\\t\\t\\tfallsin(i+1,j-1)\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\tfor i in range(c):\\n\\t\\t\\t\\tfallsin(0,i)\\n\\t\\t\\treturn (res)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef findBall(self, grid: List[List[int]]) -> List[int]:\\n\\t\\t\\tr = len(grid)\\n\\t\\t\\tc = len(grid[0])\\n\\t\\t\\tres = []\\n\\t\\t\\tdef fallsin(i,j):\\n\\t\\t\\t\\tif i == r:\\n\\t\\t\\t\\t\\tres.append(j) \\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif grid[i][j] == 1 and j+1 < c and grid[i][j+1] == 1:\\n\\t\\t\\t\\t\\tfallsin(i+1,j+1)\\n\\n\\t\\t\\t\\telif grid[i][j] == -1 and j-1 >= 0 and grid[i][j-1] == -1:\\n\\t\\t\\t\\t\\tfallsin(i+1,j-1)\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\tfor i in range(c):\\n\\t\\t\\t\\tfallsin(0,i)\\n\\t\\t\\treturn (res)",
                "codeTag": "Java"
            },
            {
                "id": 2357268,
                "title": "beautiful-java-solution-o-mn-time-o-n-space",
                "content": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int n = grid[0].length;\\n        int[] result = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            result[i] = falling(i, grid);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int falling(int pos, int[][] grid) {\\n        for (int r = 0; r < grid.length; r++) {\\n            int c = pos;\\n            if (grid[r][c] == 1 && (c >= grid[0].length-1 || grid[r][c+1] == -1)) {\\n                return -1;\\n            }\\n            if (grid[r][c] == -1 && (c <= 0 || grid[r][c-1] == 1)) {\\n                return -1;\\n            }\\n            pos += grid[r][c];\\n        }\\n        return pos;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int n = grid[0].length;\\n        int[] result = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            result[i] = falling(i, grid);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int falling(int pos, int[][] grid) {\\n        for (int r = 0; r < grid.length; r++) {\\n            int c = pos;\\n            if (grid[r][c] == 1 && (c >= grid[0].length-1 || grid[r][c+1] == -1)) {\\n                return -1;\\n            }\\n            if (grid[r][c] == -1 && (c <= 0 || grid[r][c-1] == 1)) {\\n                return -1;\\n            }\\n            pos += grid[r][c];\\n        }\\n        return pos;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329014,
                "title": "c-two-approaches-dp",
                "content": "class Solution {\\npublic:\\n    \\n    // METHOD 1 : Nested Forloops\\n    \\n    vector<int> findBall(vector<vector<int>>& mat) {\\n        int n = mat.size() , m = mat[0].size();\\n        vector<int> ans(m,-1);\\n        \\n        for(int j = 0; j < m; j++){\\n            \\n            int r = 0, c = j;\\n            while(r < n){\\n                if(mat[r][c] == 1){\\n                    if(c == m-1 || mat[r][c+1] == -1)\\n                        break;\\n                    else {\\n                        r++;  c++;\\n                    }\\n                }\\n                else{\\n                    if(c == 0 || mat[r][c-1] == 1)\\n                        break;\\n                    else {\\n                        r++;  c--;\\n                    }\\n                }\\n            }\\n            if(r == n)\\n                ans[j] = c;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    \\n    // METHOD 2 : DYNAMIC PROGRAMMING\\n    \\n    vector<vector<int>> dp;\\n    int fun(int r, int c,vector<vector<int>>& mat){\\n        if(r == mat.size())\\n            return c;\\n        if(dp[r][c] != -1)\\n            return dp[r][c];\\n        \\n        \\n        int ans = -1;\\n        if(mat[r][c] == 1){\\n            \\n            if(c == mat[0].size()-1 || mat[r][c+1] == -1)\\n                ans = -1;\\n            else \\n                ans = fun(r+1, c+1, mat);\\n        }\\n        else{\\n            \\n            if(c == 0 || mat[r][c-1] == 1)\\n                ans = -1;\\n            else \\n                ans = fun(r+1, c-1, mat);\\n        }\\n        \\n        return dp[r][c] = ans;\\n    }\\n    \\n    vector<int> findBall(vector<vector<int>>& mat) {\\n        \\n        int n = mat.size() , m = mat[0].size();\\n        \\n        dp = vector<vector<int>>(n,vector<int>(m, -1));\\n        \\n        vector<int> ans(m);\\n        for(int i = 0; i < m; i++){\\n            ans[i] = fun(0,i,mat);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // METHOD 1 : Nested Forloops\\n    \\n    vector<int> findBall(vector<vector<int>>& mat) {\\n        int n = mat.size() , m = mat[0].size();\\n        vector<int> ans(m,-1);\\n        \\n        for(int j = 0; j < m; j++){\\n            \\n            int r = 0, c = j;\\n            while(r < n){\\n                if(mat[r][c] == 1){\\n                    if(c == m-1 || mat[r][c+1] == -1)\\n                        break;\\n                    else {\\n                        r++;  c++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2313006,
                "title": "pyhton-simple-easy-sol-with-explanation",
                "content": "#### Please upvote if you find the code Helpful !!!\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef findBall(self, grid: List[List[int]]) -> List[int]:\\n\\n\\t\\t\\tr = len(grid)\\n\\t\\t\\tc = len(grid[0])\\n\\t\\t\\tres = []\\n\\n\\n\\t\\t\\tfor k in range(c):\\n\\t\\t\\t\\ti = 0\\n\\t\\t\\t\\tj = k\\n\\n\\t\\t\\t\\twhile i < r:\\n\\n\\t\\t\\t\\t\\t# checking if ball fall one level down towards right \\n\\t\\t\\t\\t\\tif grid[i][j] == 1 and j < c-1 and grid[i][j+1] == 1:\\n\\t\\t\\t\\t\\t\\ti = i+1\\n\\t\\t\\t\\t\\t\\tj =j+1\\n\\t\\t\\t\\t\\t# checking if ball fall one level down towards left \\n\\t\\t\\t\\t\\telif grid[i][j] == -1 and j > 0 and grid[i][j-1] == -1:\\n\\t\\t\\t\\t\\t\\ti = i+1\\n\\t\\t\\t\\t\\t\\tj = j-1\\n\\t\\t\\t\\t\\t# ball got stuck\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\tif i == r:\\n\\t\\t\\t\\t\\tres.append(j)\\n\\n\\t\\t\\treturn res\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "#### Please upvote if you find the code Helpful !!!\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef findBall(self, grid: List[List[int]]) -> List[int]:\\n\\n\\t\\t\\tr = len(grid)\\n\\t\\t\\tc = len(grid[0])\\n\\t\\t\\tres = []\\n\\n\\n\\t\\t\\tfor k in range(c):\\n\\t\\t\\t\\ti = 0\\n\\t\\t\\t\\tj = k\\n\\n\\t\\t\\t\\twhile i < r:\\n\\n\\t\\t\\t\\t\\t# checking if ball fall one level down towards right \\n\\t\\t\\t\\t\\tif grid[i][j] == 1 and j < c-1 and grid[i][j+1] == 1:\\n\\t\\t\\t\\t\\t\\ti = i+1\\n\\t\\t\\t\\t\\t\\tj =j+1\\n\\t\\t\\t\\t\\t# checking if ball fall one level down towards left \\n\\t\\t\\t\\t\\telif grid[i][j] == -1 and j > 0 and grid[i][j-1] == -1:\\n\\t\\t\\t\\t\\t\\ti = i+1\\n\\t\\t\\t\\t\\t\\tj = j-1\\n\\t\\t\\t\\t\\t# ball got stuck\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\tif i == r:\\n\\t\\t\\t\\t\\tres.append(j)\\n\\n\\t\\t\\treturn res\\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2308358,
                "title": "recursion-memoization",
                "content": "I think the only makes this problem intersting is the numbere of check at any point we have.\\n\\n1. OUT OF BOUND\\n2. At any index if we have 1 means we have \"\\\\ \"   so to make it \"V\" we need -1 at just next index(j+1).\\n3. At any index we have -1 means we have \"/\" so to make it \"V\" we need 1 at prev index (j-1).\\n4. At (i  == 0 and j == 0 ) or (i ==0  and j==m-1) we dont move the boundary. \\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int solve(int i ,int j , int n , int m ,vector<vector<int>>& grid )\\n    {\\n        if( i < 0 || j < 0 || j >= m || i>=n )\\n            return -1;\\n        \\n         int dir= grid[i][j];\\n        \\n        if(j==0 && dir==-1)\\n        {\\n            return -1;\\n        }\\n        \\n        if(j==grid[0].size()-1 && dir==1)\\n        {\\n            return  -1;\\n        }\\n        \\n        if((j > 0 && grid[i][j-1] == 1) && dir == -1)\\n        {\\n            return  -1;\\n        }\\n        \\n        if(( j+1 < grid[0].size() && grid[i][j+1] == -1 ) && dir == 1)\\n        {\\n            return  -1;\\n        }\\n        \\n        if(i == n-1)\\n            return dp[i][j] = j + grid[i][j];\\n        \\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(grid[i][j] == 1)\\n        {\\n           \\n            return dp[i][j] = solve(i+1,j+1,n,m,grid);\\n        }\\n           \\n        else\\n        {   \\n            return dp[i][j] = solve(i+1,j-1,n,m,grid);\\n        } \\n        \\n    }\\n    \\n    \\n    vector<int> findBall(vector<vector<int>>& grid) \\n    {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        \\n        vector<int>v(m,-1);\\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0 ; i<m ; i++)\\n        {\\n            v[i] = solve(0,i,n,m,grid);\\n        }\\n        \\n        return v;\\n        \\n    }\\n};\\n```\\nI think my code without memoization was giving similar result.\\n![image](https://assets.leetcode.com/users/images/34ccecf8-adc5-4636-bf16-bcff57700fa8_1658314615.8044007.png)\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int solve(int i ,int j , int n , int m ,vector<vector<int>>& grid )\\n    {\\n        if( i < 0 || j < 0 || j >= m || i>=n )\\n            return -1;\\n        \\n         int dir= grid[i][j];\\n        \\n        if(j==0 && dir==-1)\\n        {\\n            return -1;\\n        }\\n        \\n        if(j==grid[0].size()-1 && dir==1)\\n        {\\n            return  -1;\\n        }\\n        \\n        if((j > 0 && grid[i][j-1] == 1) && dir == -1)\\n        {\\n            return  -1;\\n        }\\n        \\n        if(( j+1 < grid[0].size() && grid[i][j+1] == -1 ) && dir == 1)\\n        {\\n            return  -1;\\n        }\\n        \\n        if(i == n-1)\\n            return dp[i][j] = j + grid[i][j];\\n        \\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(grid[i][j] == 1)\\n        {\\n           \\n            return dp[i][j] = solve(i+1,j+1,n,m,grid);\\n        }\\n           \\n        else\\n        {   \\n            return dp[i][j] = solve(i+1,j-1,n,m,grid);\\n        } \\n        \\n    }\\n    \\n    \\n    vector<int> findBall(vector<vector<int>>& grid) \\n    {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        \\n        vector<int>v(m,-1);\\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0 ; i<m ; i++)\\n        {\\n            v[i] = solve(0,i,n,m,grid);\\n        }\\n        \\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267064,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        res = []\\n        \\n        for idx in range(n):\\n            i, j = 0, idx\\n            while i < m:\\n                if grid[i][j] == 1 and j < n-1 and grid[i][j+1] == 1:\\n                    i, j = i+1, j+1\\n                elif grid[i][j] == -1 and j > 0 and grid[i][j-1] == -1:\\n                    i, j = i+1, j-1\\n                else:\\n                    res.append(-1)\\n                    break\\n            if i == m:\\n                res.append(j)\\n        return res\\n            \\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        res = []\\n        \\n        for idx in range(n):\\n            i, j = 0, idx\\n            while i < m:\\n                if grid[i][j] == 1 and j < n-1 and grid[i][j+1] == 1:\\n                    i, j = i+1, j+1\\n                elif grid[i][j] == -1 and j > 0 and grid[i][j-1] == -1:\\n                    i, j = i+1, j-1\\n                else:\\n                    res.append(-1)\\n                    break\\n            if i == m:\\n                res.append(j)\\n        return res\\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249552,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    int[][] dp;\\n    public int[] findBall(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        dp=new int[m][n];\\n        for(int[] arr:dp)\\n            Arrays.fill(arr,-2);\\n        int answer[]=new int[n];\\n        for(int col=0;col<n;col++)\\n            answer[col]=fallDown(grid,0,col,m,n);\\n        return answer;\\n    }\\n    int fallDown(int[][] grid,int row,int col,int m,int n) {\\n        if(row==m)\\n            return col;\\n        if(dp[row][col]!=-2)\\n            return dp[row][col];\\n        int curr=grid[row][col];\\n        if((curr==1&&(col==n-1||grid[row][col+1]==-1))||\\n           curr==-1&&(col==0||grid[row][col-1]==1))\\n            return dp[row][col]=-1;\\n        return dp[row][col]=fallDown(grid,row+1,col+curr,m,n);\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    int[][] dp;\\n    public int[] findBall(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        dp=new int[m][n];\\n        for(int[] arr:dp)\\n            Arrays.fill(arr,-2);\\n        int answer[]=new int[n];\\n        for(int col=0;col<n;col++)\\n            answer[col]=fallDown(grid,0,col,m,n);\\n        return answer;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2190453,
                "title": "python-faster-than-90-solution",
                "content": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        def dfs(i, j):\\n            # Check wall bounds\\n            if j < 0 or j >= n:\\n                return -1\\n            if i == m:\\n                return j\\n            \\n            cur = grid[i][j]\\n            # Check for V\\n            if j+cur>=n or grid[i][j+cur] == -cur:\\n                return -1\\n\\n            else:\\n                return dfs(i+1,j+cur)\\n        \\n        return [dfs(0,j) for j in range(n)]\\n            \\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        def dfs(i, j):\\n            # Check wall bounds\\n            if j < 0 or j >= n:\\n                return -1\\n            if i == m:\\n                return j\\n            \\n            cur = grid[i][j]\\n            # Check for V\\n            if j+cur>=n or grid[i][j+cur] == -cur:\\n                return -1\\n\\n            else:\\n                return dfs(i+1,j+cur)\\n        \\n        return [dfs(0,j) for j in range(n)]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057923,
                "title": "javascript-recursive-simple-dfs",
                "content": "```\\nvar findBall = function(grid) { \\n    function dfs(row, col) {\\n        if (row === grid.length) return col;\\n        let dir = grid[row][col];\\n        if (dir === 1 && grid[row][col + 1] === 1) return dfs(row + 1, col + 1);\\n        if (dir === -1 && grid[row][col - 1] === -1) return dfs(row + 1, col - 1);\\n        return -1;\\n    }\\n    const output = [];\\n    for (let i = 0; i < grid[0].length; i++) output.push(dfs(0, i));\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findBall = function(grid) { \\n    function dfs(row, col) {\\n        if (row === grid.length) return col;\\n        let dir = grid[row][col];\\n        if (dir === 1 && grid[row][col + 1] === 1) return dfs(row + 1, col + 1);\\n        if (dir === -1 && grid[row][col - 1] === -1) return dfs(row + 1, col - 1);\\n        return -1;\\n    }\\n    const output = [];\\n    for (let i = 0; i < grid[0].length; i++) output.push(dfs(0, i));\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1684741,
                "title": "java-python-easy-dfs-solution-with-images-o-1-space",
                "content": "* For every cell, check whether it leads to right cell of left cell\\n* Check the V condition\\n* If cell is 1 and cell to its right is also 1, go ahead to its diagnol cell, Otherwise return -1 because its a V condition\\n* Same for -1 cell\\n* If cell leads to wall, return -1 \\n\\n**Basic Representation**\\n* 1 --> Cell leading to right\\n* -1 --> Cell leading to left\\n\\n\\n![image](https://assets.leetcode.com/users/images/fa949c16-fe9b-4f8f-9d93-a28f4225ea5b_1641976048.4178941.png)\\n\\n\\n**V CONDITION**\\n```\\nIf currentCell[i][j] == 1 and currentCell[i][j + 1] == -1:\\n\\treturn -1\\n```\\n\\n![image](https://assets.leetcode.com/users/images/13c14fa7-3dcf-40c5-a7cb-c0da8099574a_1641975939.7363236.png)\\n\\n**Right Wall Condition**\\n```\\nif currentCell[i][j] == 1:\\n\\tif j + 1 >= columnlength:\\n\\t\\treturn -1\\n```\\n**Left Wall Condition**\\n```\\nif currentCell[i][j] == -1:\\n\\tif j - 1 < 0:\\n\\t\\treturn -1\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b7ace148-3015-4083-9ddb-5da0e0f0a79f_1641976298.4034832.png)\\n\\n**Valid Move**\\n\\n![image](https://assets.leetcode.com/users/images/e3b9b7bd-3173-4205-880a-3c21b9a88805_1641976334.8126934.png)\\n\\n# JAVA\\n```\\nclass Solution {   \\n    public int[] findBall(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[] ans = new int[m];\\n        for (int j = 0; j < m; j ++){\\n            ans[j] = dfs(grid, 0, j, n, m);\\n        }\\n        return ans;\\n    }\\n    public int dfs(int[][] arr, int i, int j, int n, int m){\\n            while (i < n && j < m && i > -1 && j > -1){\\n                if (arr[i][j] == 1){\\n                    if (j + 1 < m && arr[i][j + 1] == 1){\\n                        i += 1;\\n                        j += 1;\\n                    }\\n                    else{\\n                        return -1;\\n                    }\\n                }\\n                else{\\n                    if (j - 1 > -1 && arr[i][j - 1] == -1){\\n                        i += 1;\\n                        j -= 1;\\n                    }\\n                    else{\\n                        return -1;\\n                    }\\n                }\\n            }\\n            return j;\\n        }\\n}\\n```\\n# PYTHON\\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        n, m = len(grid),len(grid[0])\\n        ans = []\\n        def dfs(arr, i, j, n, m):\\n            while i < n and j < m and i > -1 and j > -1:\\n                if arr[i][j] == 1:\\n                    if j + 1 < m and arr[i][j + 1] == 1:\\n                        i += 1\\n                        j += 1\\n                    else:\\n                        return -1\\n                else:\\n                    if j - 1 > -1 and arr[i][j - 1] == -1:\\n                        i += 1\\n                        j -= 1\\n                    else:\\n                        return -1\\n            return j\\n                    \\n        for j in range(m):\\n            ans.append(dfs(grid, 0, j, n, m))\\n        return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nIf currentCell[i][j] == 1 and currentCell[i][j + 1] == -1:\\n\\treturn -1\\n```\n```\\nif currentCell[i][j] == 1:\\n\\tif j + 1 >= columnlength:\\n\\t\\treturn -1\\n```\n```\\nif currentCell[i][j] == -1:\\n\\tif j - 1 < 0:\\n\\t\\treturn -1\\n```\n```\\nclass Solution {   \\n    public int[] findBall(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[] ans = new int[m];\\n        for (int j = 0; j < m; j ++){\\n            ans[j] = dfs(grid, 0, j, n, m);\\n        }\\n        return ans;\\n    }\\n    public int dfs(int[][] arr, int i, int j, int n, int m){\\n            while (i < n && j < m && i > -1 && j > -1){\\n                if (arr[i][j] == 1){\\n                    if (j + 1 < m && arr[i][j + 1] == 1){\\n                        i += 1;\\n                        j += 1;\\n                    }\\n                    else{\\n                        return -1;\\n                    }\\n                }\\n                else{\\n                    if (j - 1 > -1 && arr[i][j - 1] == -1){\\n                        i += 1;\\n                        j -= 1;\\n                    }\\n                    else{\\n                        return -1;\\n                    }\\n                }\\n            }\\n            return j;\\n        }\\n}\\n```\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        n, m = len(grid),len(grid[0])\\n        ans = []\\n        def dfs(arr, i, j, n, m):\\n            while i < n and j < m and i > -1 and j > -1:\\n                if arr[i][j] == 1:\\n                    if j + 1 < m and arr[i][j + 1] == 1:\\n                        i += 1\\n                        j += 1\\n                    else:\\n                        return -1\\n                else:\\n                    if j - 1 > -1 and arr[i][j - 1] == -1:\\n                        i += 1\\n                        j -= 1\\n                    else:\\n                        return -1\\n            return j\\n                    \\n        for j in range(m):\\n            ans.append(dfs(grid, 0, j, n, m))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596821,
                "title": "simple-dfs-without-dp",
                "content": "\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int ans[]=new int[grid[0].length];\\n        for(int i=0;i<grid[0].length;i++){\\n            ans[i]=dfs(0,i,grid);\\n        }\\n        return ans;\\n    }\\n    \\n    public int dfs(int x,int y,int [][]grid){\\n        if(x==grid.length){\\n            return y;\\n        }\\n        if(grid[x][y]==1){\\n            if(y==grid[0].length-1 || grid[x][y+1]==-1){\\n                return -1;\\n            }else{\\n                return dfs(x+1,y+1,grid);\\n            }                      \\n        }\\n        else{\\n            if(y==0 || grid[x][y-1]==1){\\n                return -1;\\n            }else{\\n                return dfs(x+1,y-1,grid);\\n            }\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int[] findBall(int[][] grid) {\\n        int ans[]=new int[grid[0].length];\\n        for(int i=0;i<grid[0].length;i++){\\n            ans[i]=dfs(0,i,grid);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1497899,
                "title": "simple-java-dfs",
                "content": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int m = grid[0].length;\\n        int[] res = new int[m];\\n        for (int i = 0; i < m; i++) {\\n            res[i] = fall(grid, 0, i);\\n        }\\n        return res;\\n    }\\n    int fall(int[][] grid, int x, int y) {\\n        if (x == grid.length) {\\n            return y;\\n        }\\n        if (stuck(x, y, grid)) {\\n            return -1;\\n        }\\n        return fall(grid, x + 1, y + grid[x][y]);\\n    }\\n    boolean stuck(int x, int y, int[][] grid) {\\n        if (y == 0 && grid[x][y] == -1 || \\n            y == grid[0].length - 1 && grid[x][y] == 1 ||\\n            grid[x][y] == 1 && grid[x][y + 1] == -1 || \\n            grid[x][y] == -1 && grid[x][y - 1] == 1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int m = grid[0].length;\\n        int[] res = new int[m];\\n        for (int i = 0; i < m; i++) {\\n            res[i] = fall(grid, 0, i);\\n        }\\n        return res;\\n    }\\n    int fall(int[][] grid, int x, int y) {\\n        if (x == grid.length) {\\n            return y;\\n        }\\n        if (stuck(x, y, grid)) {\\n            return -1;\\n        }\\n        return fall(grid, x + 1, y + grid[x][y]);\\n    }\\n    boolean stuck(int x, int y, int[][] grid) {\\n        if (y == 0 && grid[x][y] == -1 || \\n            y == grid[0].length - 1 && grid[x][y] == 1 ||\\n            grid[x][y] == 1 && grid[x][y + 1] == -1 || \\n            grid[x][y] == -1 && grid[x][y - 1] == 1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430995,
                "title": "c-dfs",
                "content": "```\\n\\n```public:\\n    vector<int>res;\\n    void dfs(vector<vector<int>>&grid,int i,int j,int n,int m)\\n    {\\n        if(i==n)\\n        {\\n            res.push_back(j);\\n            return ;\\n        }\\n        if(grid[i][j]==1)\\n        {\\n            if(j+1==m||grid[i][j+1]==-1)\\n            {\\n                res.push_back(-1);\\n                return ;\\n            }\\n            dfs(grid,i+1,j+1,n,m);\\n        }\\n         if(grid[i][j]==-1)\\n        {\\n            if(j==0||grid[i][j-1]==1)\\n            {\\n                res.push_back(-1);\\n                return ;\\n            }\\n            dfs(grid,i+1,j-1,n,m);\\n        }\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n            dfs(grid,0,j,n,m);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1298193,
                "title": "easy-to-understand-java-solution-0ms-100-faster",
                "content": "```\\n\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] result = new int[n];\\n        \\n\\t\\t//we run findResult() for every ball (column).\\n        for(int i=0;i<n;i++){\\n            findResult(grid,i,m,n,result);\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    public void findResult(int[][] grid, int index, int m, int n, int[] result){\\n        \\n        int row=0;\\n        int column=index;\\n        \\n        while(row < m && column < n){\\n            if(grid[row][column] == 1){ \\n                if(column+1 < n){ // check to avoid index out of bound\\n                    if(grid[row][column+1] == -1){ \\n\\t\\t\\t\\t\\t// In case of right span, presence of left span in next cell will prevent the ball to come down.\\n\\t\\t\\t\\t\\t// So, mark the result as -1. \\n                        result[index]=-1;\\n                        return;\\n                    }\\n\\t\\t\\t\\t\\t//moving diagonally down towards right.\\n                    row++;\\n                    column++;\\n                } else{ \\n\\t\\t\\t\\t//This is covering an edge case where we reach at index=n and right span is present instead of left span.\\n\\t\\t\\t\\t//Left span is needed for the ball to come out. \\n                    result[index]=-1;\\n                    return;\\n                }\\n            } else if(grid[row][column] == -1){\\n                if(column-1 >= 0){\\n                    if(grid[row][column-1] == 1){ \\n\\t\\t\\t\\t\\t// In case of left span, presence of right span in next cell will prevent the ball to come down.\\n\\t\\t\\t\\t\\t// So, mark the result as -1. \\n                        result[index]=-1;\\n                        return;\\n                    }\\n\\t\\t\\t\\t\\t//moving diagonally down towards left.\\n                    row++;\\n                    column--;\\n                } else{\\n\\t\\t\\t\\t   //This is covering an edge case where we reach at index=0 and left span is present instead of right span. \\n\\t\\t\\t\\t   //Right span is needed for the ball to come out. \\n                    result[index]=-1;\\n                    return;\\n                }\\n            }\\n            \\n        }\\n        \\n        //we have reached till this point, it means ball will come out.\\n\\t\\t//just need to assign the column index.\\n        result[index]=column;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] result = new int[n];\\n        \\n\\t\\t//we run findResult() for every ball (column).\\n        for(int i=0;i<n;i++){\\n            findResult(grid,i,m,n,result);\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    public void findResult(int[][] grid, int index, int m, int n, int[] result){\\n        \\n        int row=0;\\n        int column=index;\\n        \\n        while(row < m && column < n){\\n            if(grid[row][column] == 1){ \\n                if(column+1 < n){ // check to avoid index out of bound\\n                    if(grid[row][column+1] == -1){ \\n\\t\\t\\t\\t\\t// In case of right span, presence of left span in next cell will prevent the ball to come down.\\n\\t\\t\\t\\t\\t// So, mark the result as -1. \\n                        result[index]=-1;\\n                        return;\\n                    }\\n\\t\\t\\t\\t\\t//moving diagonally down towards right.\\n                    row++;\\n                    column++;\\n                } else{ \\n\\t\\t\\t\\t//This is covering an edge case where we reach at index=n and right span is present instead of left span.\\n\\t\\t\\t\\t//Left span is needed for the ball to come out. \\n                    result[index]=-1;\\n                    return;\\n                }\\n            } else if(grid[row][column] == -1){\\n                if(column-1 >= 0){\\n                    if(grid[row][column-1] == 1){ \\n\\t\\t\\t\\t\\t// In case of left span, presence of right span in next cell will prevent the ball to come down.\\n\\t\\t\\t\\t\\t// So, mark the result as -1. \\n                        result[index]=-1;\\n                        return;\\n                    }\\n\\t\\t\\t\\t\\t//moving diagonally down towards left.\\n                    row++;\\n                    column--;\\n                } else{\\n\\t\\t\\t\\t   //This is covering an edge case where we reach at index=0 and left span is present instead of right span. \\n\\t\\t\\t\\t   //Right span is needed for the ball to come out. \\n                    result[index]=-1;\\n                    return;\\n                }\\n            }\\n            \\n        }\\n        \\n        //we have reached till this point, it means ball will come out.\\n\\t\\t//just need to assign the column index.\\n        result[index]=column;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085435,
                "title": "100-simple-idiomatic-go-solution",
                "content": "```\\nfunc findBall(grid [][]int) []int {\\n\\tm, n := len(grid), len(grid[0])\\n\\tresult := make([]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tpos := i\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tdir := grid[j][pos]\\n\\t\\t\\tif nextPos := pos + dir; nextPos < 0 || nextPos >= n || grid[j][nextPos] == -dir {\\n\\t\\t\\t\\tpos = -1\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tpos += dir\\n\\t\\t}\\n\\t\\tresult[i] = pos\\n\\t}\\n\\n\\treturn result\\n}\\n```\\n\\nTime complexity: O(n*m)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findBall(grid [][]int) []int {\\n\\tm, n := len(grid), len(grid[0])\\n\\tresult := make([]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tpos := i\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tdir := grid[j][pos]\\n\\t\\t\\tif nextPos := pos + dir; nextPos < 0 || nextPos >= n || grid[j][nextPos] == -dir {\\n\\t\\t\\t\\tpos = -1\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tpos += dir\\n\\t\\t}\\n\\t\\tresult[i] = pos\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1013113,
                "title": "c-dfs-solution-20ms-faster-than-100-submissions",
                "content": "Each ball starts from row 0\\n\\'\\\\\\\\/ \\' or \\'/\\\\\\\\\\' causes the ball to get stuck.\\n\\'/ /\\' or \\'\\\\ \\\\\\' makes it come down\\nSo if we reach row+1 it means we are not stuck anywhere. So return the corresponding column\\n```\\nclass Solution {\\npublic:\\n    bool  isvalid(int r,int c,int m,int n) \\n    {\\n        if(r>=m || r<0 || c>=n || c<0) \\n            return false;\\n        return true;\\n    }\\n    \\n    int dfs(vector<vector<int>>& grid,int row,int col , int m,int n) {\\n        if(row == m) \\n            return col;\\n        if(isvalid(row,col,m,n))\\n        {\\n            if(grid[row][col]==1) {\\n                if(isvalid(row,col+1,m,n) && grid[row][col+1]==1)  \\n                {\\n                    return dfs(grid,row+1,col+1,m,n);\\n                }\\n            }\\n            else {\\n                if(isvalid(row,col-1,m,n) && grid[row][col-1]==-1) \\n                {\\n                    return dfs(grid,row+1,col-1,m,n);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> result (n,1);\\n            for(int j=0;j<n;j++) {\\n                result[j] = dfs(grid,0,j,m,n);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool  isvalid(int r,int c,int m,int n) \\n    {\\n        if(r>=m || r<0 || c>=n || c<0) \\n            return false;\\n        return true;\\n    }\\n    \\n    int dfs(vector<vector<int>>& grid,int row,int col , int m,int n) {\\n        if(row == m) \\n            return col;\\n        if(isvalid(row,col,m,n))\\n        {\\n            if(grid[row][col]==1) {\\n                if(isvalid(row,col+1,m,n) && grid[row][col+1]==1)  \\n                {\\n                    return dfs(grid,row+1,col+1,m,n);\\n                }\\n            }\\n            else {\\n                if(isvalid(row,col-1,m,n) && grid[row][col-1]==-1) \\n                {\\n                    return dfs(grid,row+1,col-1,m,n);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> result (n,1);\\n            for(int j=0;j<n;j++) {\\n                result[j] = dfs(grid,0,j,m,n);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001162,
                "title": "java-dfs-100",
                "content": "At first it really seems to be a hard problem (at least to me). But you get down with pen paper, it\\'s actually not that hard. Just follow as the problem says.\\n\\n**1** means you can only go diagonal right i.e. `G[r+1][c+1]`,\\n**0** means you can only go diagonal left i.e. `G[r+1][c-1]`, \\nbut with the condition that you can go diagonal right /left if and only if the `G[r+1][c+1]`/`G[r+1][c-1]` values are the same as of `G[r][c]`. \\n\\nNow what about the termination condition, that should be if we go outside of our grid column wise boundary` c<0 || c>=C` then we should return **-1**, \\nAnother case would be if we reached the last row then we should return the **c** where we ended which denote where that came out.\\n\\n```\\n    private int find(int G[][], int r, int c, int R, int C){\\n        if(c<0 || c>=C)\\n            return -1;\\n        if(r>=R)\\n            return c;\\n        if(c<C-1 && G[r][c] == 1 && G[r][c] == G[r][c+1])\\n            return find(G, r+1, c+1, R, C);\\n        else if (c>0 && G[r][c] == -1 && G[r][c] == G[r][c-1])\\n            return find(G, r+1, c-1, R, C);\\n        else\\n            return -1;\\n    }\\n    public int[] findBall(int[][] G) {        \\n        int res[] = new int[G[0].length];\\n        for(int i=0;i<G[0].length;i++){\\n            res[i] = find(G, 0, i, G.length, G[0].length);\\n        }\\n        return res;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    private int find(int G[][], int r, int c, int R, int C){\\n        if(c<0 || c>=C)\\n            return -1;\\n        if(r>=R)\\n            return c;\\n        if(c<C-1 && G[r][c] == 1 && G[r][c] == G[r][c+1])\\n            return find(G, r+1, c+1, R, C);\\n        else if (c>0 && G[r][c] == -1 && G[r][c] == G[r][c-1])\\n            return find(G, r+1, c-1, R, C);\\n        else\\n            return -1;\\n    }\\n    public int[] findBall(int[][] G) {        \\n        int res[] = new int[G[0].length];\\n        for(int i=0;i<G[0].length;i++){\\n            res[i] = find(G, 0, i, G.length, G[0].length);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 996420,
                "title": "c-simplest-solution-accepted",
                "content": "Trick of the problem : We need to take care of the V-shape for each ball, if in the path the ball encounters it then simply return -1 . Else keep updating the ball\\'s column as it continues to fall towards the ground.\\n\\nHow to check V-shape? \\n\\nJust check the condition that if grid[curRow][curCol] != grid[curRow][newCol] that means the ball will strended in the V-shape otherwise it will escape downwards. Note : newCol value should never go out of the grid values.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        int m = grid.size();\\n        vector<int>res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int curCol = i;\\n            for(int j = 0; j < m; j++)\\n            {\\n\\t\\t\\t    //Update the col as follows\\n                int newCol = curCol + grid[j][curCol];\\n\\t\\t\\t\\t// Condition for ball to get stuck forever\\n                if(newCol < 0 || newCol >= n || grid[j][curCol] != grid[j][newCol])\\n                {\\n                    curCol = -1;\\n                    break;\\n                }\\n                curCol = newCol;\\n            }\\n            res.push_back(curCol);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        int m = grid.size();\\n        vector<int>res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int curCol = i;\\n            for(int j = 0; j < m; j++)\\n            {\\n\\t\\t\\t    //Update the col as follows\\n                int newCol = curCol + grid[j][curCol];\\n\\t\\t\\t\\t// Condition for ball to get stuck forever\\n                if(newCol < 0 || newCol >= n || grid[j][curCol] != grid[j][newCol])\\n                {\\n                    curCol = -1;\\n                    break;\\n                }\\n                curCol = newCol;\\n            }\\n            res.push_back(curCol);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988948,
                "title": "java-dfs-faster-than-100-solutions",
                "content": "**Kindly upvote if you find this solution useful**\\n\\n```\\nclass Solution {\\n  final int up = 0;\\n    final int left = 2;\\n    final int right = 3;\\n\\n    public int[] findBall(int[][] grid) {\\n        int n = grid.length;\\n        if (n == 0) return new int[0];\\n        int m = grid[0].length;\\n        int[] ans = new int[m];\\n        for (int col = 0; col < m; col++) {\\n            ans[col] = dfs(0,col,n,m,grid, up);\\n        }\\n        return ans;\\n    }\\n\\n    private int dfs(int row, int col, int n, int m, int[][] grid, int dir) {\\n        if (row == n) return col;\\n        if (row < 0 || row >= n || col < 0 || col >= m) return -1;\\n        int ans;\\n        if (grid[row][col] == 1) {\\n            if (dir == up) ans = dfs(row,col + 1,n, m, grid,left);\\n            else if (dir == left) ans = dfs(row + 1, col, n, m, grid, up);\\n            else return -1;\\n        }\\n        else {\\n            if (dir == up) ans = dfs(row,col - 1,n, m, grid,right);\\n            else if (dir == right) ans = dfs(row + 1, col, n, m, grid, up);\\n            else return -1;\\n        }\\n        return ans;\\n    }   \\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n  final int up = 0;\\n    final int left = 2;\\n    final int right = 3;\\n\\n    public int[] findBall(int[][] grid) {\\n        int n = grid.length;\\n        if (n == 0) return new int[0];\\n        int m = grid[0].length;\\n        int[] ans = new int[m];\\n        for (int col = 0; col < m; col++) {\\n            ans[col] = dfs(0,col,n,m,grid, up);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 988447,
                "title": "python3-simulation",
                "content": "**Algo**\\nFor each ball, we simulate its trajectory following the dynamics and decide where it falls. \\n\\n**Implementation** (196ms, 100%) \\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0]) # dimensions\\n        ans = [-1]*n \\n        for j in range(n): \\n            k = j\\n            for i in range(m):\\n                kk = k + grid[i][k]\\n                if not 0 <= kk < n or grid[i][k] * grid[i][kk] < 0: break\\n                k = kk \\n            else: ans[j] = k # no break \\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(MN)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0]) # dimensions\\n        ans = [-1]*n \\n        for j in range(n): \\n            k = j\\n            for i in range(m):\\n                kk = k + grid[i][k]\\n                if not 0 <= kk < n or grid[i][k] * grid[i][kk] < 0: break\\n                k = kk \\n            else: ans[j] = k # no break \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 988279,
                "title": "java-straightforward",
                "content": "For each ball, neighbour position direction should same as current position direction. Otherwise, the ball will fall in a \"V\".\\nNeighbour position = Current position + direction.\\n\\n```\\npublic int[] findBall(int[][] grid) {\\n\\tint m = grid.length, n = grid[0].length;\\n\\tint[] balls = new int[n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint pos = i;\\n\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\tint nextPos = pos + grid[j][pos];\\n\\t\\t\\tif (nextPos >= n || nextPos < 0 \\n\\t\\t\\t\\t|| grid[j][nextPos] != grid[j][pos]) {\\n\\t\\t\\t\\tpos = -1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpos += grid[j][pos];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tballs[i] = pos;\\n\\t}\\n\\treturn balls;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] findBall(int[][] grid) {\\n\\tint m = grid.length, n = grid[0].length;\\n\\tint[] balls = new int[n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint pos = i;\\n\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\tint nextPos = pos + grid[j][pos];\\n\\t\\t\\tif (nextPos >= n || nextPos < 0 \\n\\t\\t\\t\\t|| grid[j][nextPos] != grid[j][pos]) {\\n\\t\\t\\t\\tpos = -1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpos += grid[j][pos];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tballs[i] = pos;\\n\\t}\\n\\treturn balls;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 988257,
                "title": "c-solution-simplest-youtube-video-hindi",
                "content": "At every cell, you just check one thing : \"The next cell where you are going and your current cell, do they form a \\'V\\' \". If YES, then -1 else move ahead and see which column it falls out\\n```\\n//YouTube : https://www.youtube.com/watch?v=ElWwrlPe0qc\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size();    //rows\\n        int n = grid[0].size(); //columns\\n        vector<int> result;\\n        \\n        for(int ball = 0; ball<n; ball++) {\\n            \\n            int row = 0;\\n            int col = ball;\\n            bool reached = true;\\n            while(row < m && col < n) {\\n                if(grid[row][col] == 1) {\\n                    if(col==n-1 || grid[row][col+1] == -1) {\\n                        reached = false;\\n                        break;\\n                    }\\n                    col++;\\n                } else if(grid[row][col] == -1) {\\n                    if(col==0 || grid[row][col-1] == 1) {\\n                        reached = false;\\n                        break;\\n                    }\\n                    col--;\\n                }\\n                row++;\\n            }\\n            if(reached)\\n                result.push_back(col);\\n            else\\n                result.push_back(-1);\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//YouTube : https://www.youtube.com/watch?v=ElWwrlPe0qc\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m = grid.size();    //rows\\n        int n = grid[0].size(); //columns\\n        vector<int> result;\\n        \\n        for(int ball = 0; ball<n; ball++) {\\n            \\n            int row = 0;\\n            int col = ball;\\n            bool reached = true;\\n            while(row < m && col < n) {\\n                if(grid[row][col] == 1) {\\n                    if(col==n-1 || grid[row][col+1] == -1) {\\n                        reached = false;\\n                        break;\\n                    }\\n                    col++;\\n                } else if(grid[row][col] == -1) {\\n                    if(col==0 || grid[row][col-1] == 1) {\\n                        reached = false;\\n                        break;\\n                    }\\n                    col--;\\n                }\\n                row++;\\n            }\\n            if(reached)\\n                result.push_back(col);\\n            else\\n                result.push_back(-1);\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988212,
                "title": "python-memoization",
                "content": "```\\ndef findBall(self, grid: List[List[int]]) -> List[int]:\\n\\trows = len(grid)\\n\\tcols = len(grid[0])\\n\\n\\t@lru_cache(None)\\n\\tdef falloc(col, row=0):\\n\\t\\tif row == rows: return col\\n\\t\\tnext_col = col + grid[row][col]\\n\\t\\tif 0 <= next_col < cols and grid[row][next_col] != -grid[row][col]:\\n\\t\\t\\treturn falloc(next_col, row+1)\\n\\t\\treturn -1\\n\\n\\treturn [falloc(i) for i in range(cols)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ndef findBall(self, grid: List[List[int]]) -> List[int]:\\n\\trows = len(grid)\\n\\tcols = len(grid[0])\\n\\n\\t@lru_cache(None)\\n\\tdef falloc(col, row=0):\\n\\t\\tif row == rows: return col\\n\\t\\tnext_col = col + grid[row][col]\\n\\t\\tif 0 <= next_col < cols and grid[row][next_col] != -grid[row][col]:\\n\\t\\t\\treturn falloc(next_col, row+1)\\n\\t\\treturn -1\\n\\n\\treturn [falloc(i) for i in range(cols)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 988130,
                "title": "c-o-n-solution-simulation",
                "content": "Just simulate the ball falling logic, if current element is `\\\\`, we need to compare to the next element, otherwise we compare to the previous element, if they are equal,  \\nwe can move the ball to next column(if current element is `\\\\`) otherwise move to the previous element, and then go to the next row.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int cnt = grid[0].size();\\n        int m = grid.size();\\n        vector<int> ans;\\n        for(int i = 0; i < cnt; ++i) {\\n            int start = i;\\n            int f = 0;\\n            for(int j = 0; j < m; ++j) {\\n                int next = start + grid[j][start];\\n                if(next < 0 || next >= cnt) {  // hit the wall.\\n                    f = -1;\\n                    break;\\n                }\\n                if(grid[j][start] ==  grid[j][next]) {   //it is not V shape.\\n                    start = next;\\n                    \\n                }else {\\n                    f = -1; break;   // it is V shape\\n                }\\n            }\\n            if(f == -1) ans.push_back(f);\\n            else ans.push_back(start);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int cnt = grid[0].size();\\n        int m = grid.size();\\n        vector<int> ans;\\n        for(int i = 0; i < cnt; ++i) {\\n            int start = i;\\n            int f = 0;\\n            for(int j = 0; j < m; ++j) {\\n                int next = start + grid[j][start];\\n                if(next < 0 || next >= cnt) {  // hit the wall.\\n                    f = -1;\\n                    break;\\n                }\\n                if(grid[j][start] ==  grid[j][next]) {   //it is not V shape.\\n                    start = next;\\n                    \\n                }else {\\n                    f = -1; break;   // it is V shape\\n                }\\n            }\\n            if(f == -1) ans.push_back(f);\\n            else ans.push_back(start);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661717,
                "title": "easy-peasy-solution-for-the-problem-which-looks-scary-but-actually-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<int>>& grid, int n, int m){\\n        if(i == n) return j;\\n        int nextCol = j + grid[i][j];\\n        if(nextCol < 0 || nextCol >= m || grid[i][j] != grid[i][nextCol]) return -1;\\n        return dfs(i+1,nextCol,grid,n,m);\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int>ans(m);\\n        for(int j=0; j<m; j++){\\n            ans[j] = dfs(0,j,grid,n,m);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<int>>& grid, int n, int m){\\n        if(i == n) return j;\\n        int nextCol = j + grid[i][j];\\n        if(nextCol < 0 || nextCol >= m || grid[i][j] != grid[i][nextCol]) return -1;\\n        return dfs(i+1,nextCol,grid,n,m);\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int>ans(m);\\n        for(int j=0; j<m; j++){\\n            ans[j] = dfs(0,j,grid,n,m);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483808,
                "title": "easy-simple-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int row=grid.length;\\n        int col=grid[0].length;\\n        \\n        int ans[]=new int[col];\\n        for(int j=0;j<col;j++){\\n            int curPos=j;\\n            int nPos=-1;\\n            for(int i=0;i<row;i++){\\n                nPos=curPos+grid[i][curPos];\\n                if(nPos<0 ||nPos>=col || grid[i][curPos]!=grid[i][nPos]){\\n                    curPos=-1;\\n                    break;\\n                }\\n                curPos=nPos;\\n            }\\n            ans[j]=curPos;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int row=grid.length;\\n        int col=grid[0].length;\\n        \\n        int ans[]=new int[col];\\n        for(int j=0;j<col;j++){\\n            int curPos=j;\\n            int nPos=-1;\\n            for(int i=0;i<row;i++){\\n                nPos=curPos+grid[i][curPos];\\n                if(nPos<0 ||nPos>=col || grid[i][curPos]!=grid[i][nPos]){\\n                    curPos=-1;\\n                    break;\\n                }\\n                curPos=nPos;\\n            }\\n            ans[j]=curPos;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419291,
                "title": "c-well-commented",
                "content": "Consider | as wall, / as -1,\\\\ as 1 and . as ball\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        // If number of column is 1 then (if grid[0][0] == 1 then --> |\\\\| ball stuck)\\n        //                               (if grid[0][0] == -1 then --> |/| ball stuck)\\n        // so for any condition ball gets stucked in first cell if m == 1\\n        if(m == 1)\\n        {\\n            return {-1};\\n        }\\n\\n        vector<int> ans(m,-1);\\n\\n        // For each ball fall\\n        for(int j = 0; j < m; j++)\\n        {\\n            int ballStuck = 0;  //flag to stop the check of fall if ball is stuck\\n            int ballRow = 0;    // in which row ball is \\n            int ballCol = j;    // in which column ball is \\n\\n            while(ballStuck == 0 && ballRow != n) //if ball is not stuck and ball is not \\n                                                  // at the end of the box\\n            {\\n                if(grid[ballRow][ballCol] == -1)  \\n                {    \\n                    if(ballCol - 1 < 0)            // Now cell is -1 so ball should go \\n                                                   // left but if column is 0th then\\n                                                   // |./   | ball stuck\\n                    {\\n                        ballStuck = 1;\\n                    }\\n                    else if(grid[ballRow][ballCol-1] == 1)\\n                    // Now if column is not 0th then if previous column is 1 means\\n                    // |\\\\./   | then ball is stuck\\n                    {\\n                        ballStuck = 1;\\n                    }\\n                    else\\n                    // If not any of that then ball will goto left side |  /./ |\\n                    //                                                  | / /  |\\n                    {\\n                        ballCol = ballCol - 1;\\n                        ballRow++;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ballCol + 1 > m-1)\\n                    {\\n                        ballStuck = 1;\\n                    }\\n                    else if(grid[ballRow][ballCol+1] == -1)\\n                    {\\n                        ballStuck = 1;\\n                    }\\n                    else\\n                    {\\n                        ballCol = ballCol + 1;\\n                        ballRow++;\\n                    }\\n                }\\n            }\\n            if(ballStuck == 1)\\n            {\\n                ans[j] = -1;\\n            }\\n            else\\n            {\\n                ans[j] = ballCol;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        // If number of column is 1 then (if grid[0][0] == 1 then --> |\\\\| ball stuck)\\n        //                               (if grid[0][0] == -1 then --> |/| ball stuck)\\n        // so for any condition ball gets stucked in first cell if m == 1\\n        if(m == 1)\\n        {\\n            return {-1};\\n        }\\n\\n        vector<int> ans(m,-1);\\n\\n        // For each ball fall\\n        for(int j = 0; j < m; j++)\\n        {\\n            int ballStuck = 0;  //flag to stop the check of fall if ball is stuck\\n            int ballRow = 0;    // in which row ball is \\n            int ballCol = j;    // in which column ball is \\n\\n            while(ballStuck == 0 && ballRow != n) //if ball is not stuck and ball is not \\n                                                  // at the end of the box\\n            {\\n                if(grid[ballRow][ballCol] == -1)  \\n                {    \\n                    if(ballCol - 1 < 0)            // Now cell is -1 so ball should go \\n                                                   // left but if column is 0th then\\n                                                   // |./   | ball stuck\\n                    {\\n                        ballStuck = 1;\\n                    }\\n                    else if(grid[ballRow][ballCol-1] == 1)\\n                    // Now if column is not 0th then if previous column is 1 means\\n                    // |\\\\./   | then ball is stuck\\n                    {\\n                        ballStuck = 1;\\n                    }\\n                    else\\n                    // If not any of that then ball will goto left side |  /./ |\\n                    //                                                  | / /  |\\n                    {\\n                        ballCol = ballCol - 1;\\n                        ballRow++;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ballCol + 1 > m-1)\\n                    {\\n                        ballStuck = 1;\\n                    }\\n                    else if(grid[ballRow][ballCol+1] == -1)\\n                    {\\n                        ballStuck = 1;\\n                    }\\n                    else\\n                    {\\n                        ballCol = ballCol + 1;\\n                        ballRow++;\\n                    }\\n                }\\n            }\\n            if(ballStuck == 1)\\n            {\\n                ans[j] = -1;\\n            }\\n            else\\n            {\\n                ans[j] = ballCol;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226520,
                "title": "javascript-dfs-simple",
                "content": "# Code\\n```\\n// O(m*n)\\nvar findBall = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    const go = (i, j) => {\\n        if (i === m) return j; // reached the end!\\n\\n        if (grid[i][j] === 1) {\\n            j++; // we need to go right ->\\n            if (j >= n || grid[i][j] === -1) {\\n                return -1; // blocked!\\n            }\\n        } else {\\n            j--; // we need to go left <-\\n            if (j < 0 || grid[i][j] === 1) {\\n                return -1; // blocked!\\n            }\\n        }\\n        return go(i + 1, j)\\n    }\\n\\n    const arr = [];\\n    for (let j = 0; j < n; j++) {\\n        arr.push(go(0, j));\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(m*n)\\nvar findBall = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    const go = (i, j) => {\\n        if (i === m) return j; // reached the end!\\n\\n        if (grid[i][j] === 1) {\\n            j++; // we need to go right ->\\n            if (j >= n || grid[i][j] === -1) {\\n                return -1; // blocked!\\n            }\\n        } else {\\n            j--; // we need to go left <-\\n            if (j < 0 || grid[i][j] === 1) {\\n                return -1; // blocked!\\n            }\\n        }\\n        return go(i + 1, j)\\n    }\\n\\n    const arr = [];\\n    for (let j = 0; j < n; j++) {\\n        arr.push(go(0, j));\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3127816,
                "title": "java-easy-to-understand-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n//     public int[] findBall(int[][] grid) {\\n//         int n=grid.length;\\n//         int m=grid[0].length;\\n//         int[] ans = new int[n];\\n//         for(int j=0; j<m; j++){\\n//             int cpos=j;\\n//             int npos=-1;\\n\\n//             for(int i=0; i<n; i++){\\n//                 npos=cpos+grid[i][cpos];  //1->right, -1->left\\n\\n//                 if(npos<0 || npos>=m || grid[i][cpos]!=grid[i][npos]){\\n//                     cpos=-1;\\n//                     break;\\n//                 }\\n//                 cpos=npos;\\n//             }\\n//             ans[j]=cpos;\\n//         }\\n//         return ans;\\n//     }\\n// }\\n\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n\\n        int[] result = new int[grid[0].length];\\n\\n        for(int i=0; i<result.length; i++){\\n            result[i] = dfs(0,i,grid);\\n        }\\n        return result;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid){\\n\\n        if(i == grid.length){\\n            return j;\\n        }\\n\\n        int newj = j + grid[i][j];\\n\\n        if(newj<0 || newj>=grid[0].length || grid[i][j] != grid[i][newj]){\\n            return -1;\\n        }\\n\\n        \\n\\n       \\n        return dfs(i+1,newj,grid);   \\n       \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n// class Solution {\\n//     public int[] findBall(int[][] grid) {\\n//         int n=grid.length;\\n//         int m=grid[0].length;\\n//         int[] ans = new int[n];\\n//         for(int j=0; j<m; j++){\\n//             int cpos=j;\\n//             int npos=-1;\\n\\n//             for(int i=0; i<n; i++){\\n//                 npos=cpos+grid[i][cpos];  //1->right, -1->left\\n\\n//                 if(npos<0 || npos>=m || grid[i][cpos]!=grid[i][npos]){\\n//                     cpos=-1;\\n//                     break;\\n//                 }\\n//                 cpos=npos;\\n//             }\\n//             ans[j]=cpos;\\n//         }\\n//         return ans;\\n//     }\\n// }\\n\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n\\n        int[] result = new int[grid[0].length];\\n\\n        for(int i=0; i<result.length; i++){\\n            result[i] = dfs(0,i,grid);\\n        }\\n        return result;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid){\\n\\n        if(i == grid.length){\\n            return j;\\n        }\\n\\n        int newj = j + grid[i][j];\\n\\n        if(newj<0 || newj>=grid[0].length || grid[i][j] != grid[i][newj]){\\n            return -1;\\n        }\\n\\n        \\n\\n       \\n        return dfs(i+1,newj,grid);   \\n       \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037263,
                "title": "dfs-simple-approach-1ms-faster-not-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n\\n        int[] result = new int[grid[0].length];\\n\\n        for(int i=0; i<result.length; i++){\\n            result[i] = dfs(0,i,grid);\\n        }\\n        return result;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid){\\n\\n        if(i == grid.length){\\n            return j;\\n        }\\n\\n        int newj = j + grid[i][j];\\n\\n        if(newj<0 || newj>=grid[0].length || grid[i][j] != grid[i][newj]){\\n            return -1;\\n        }\\n       \\n        return dfs(i+1,newj,grid);   \\n       \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n\\n        int[] result = new int[grid[0].length];\\n\\n        for(int i=0; i<result.length; i++){\\n            result[i] = dfs(0,i,grid);\\n        }\\n        return result;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid){\\n\\n        if(i == grid.length){\\n            return j;\\n        }\\n\\n        int newj = j + grid[i][j];\\n\\n        if(newj<0 || newj>=grid[0].length || grid[i][j] != grid[i][newj]){\\n            return -1;\\n        }\\n       \\n        return dfs(i+1,newj,grid);   \\n       \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988343,
                "title": "c-o-n-m-simulation",
                "content": "```C++\\nclass Solution {\\npublic:\\n    #define printf(...) empty_printf(__VA_ARGS__)\\n    #define empty_printf(...)    \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        //pos(row,col), up ball/down ball   \\n        //cell_status: \"\\\\\"  \"/\"\\n        //up ball in \"\\\\\": if row,col+1 == \"/\" ->Ball Stop\\n        //up ball in \"\\\\\": if row,col+1 == \"\\\\\" ->Go ball down & go pos(row,col+1)\\n        //down ball in \"\\\\\":  -> Go ball up & go pos(row+1,col)\\n        \\n        //up ball in \"/\": if row,col+\\uFF11 == \"\\\\\" ->Ball Stop\\n        //up ball in \"/\": if row,col+1 == \"/\" ->Go ball down & go pos(row,col-1)\\n        //down ball in \"\\\\\":  -> Go ball up & go pos(row+1,col)\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> v = vector<vector<int>>(n,vector<int>());\\n        vector<int> ans = vector<int>(n,0);\\n        for(int i = 0; i<n;i++) {\\n            v[i] = {0,i,1};\\n\\t\\t\\t//[0] : row\\n\\t\\t\\t//[1] : col\\n\\t\\t\\t//[2] 1 is ball up, 0 is ball down\\n\\t\\t\\t/* For example, \\n\\t\\tup-> o /\\n\\t\\t\\t  /\\n\\t\\t\\t /  o<-- down\\n\\t\\t\\t \\n\\t\\t  \\\\    o <-- up\\n\\t\\t   \\\\\\t  \\ndown->  o    \\\\ \\n\\t\\t\\t \\n\\t\\t\\t*/\\n\\t\\t\\t\\n            ans[i] = i;\\n        }\\n        \\n        \\n        for(int i = 0; i<n;i++) {\\n            vector<int>& o = v[i];\\n            while(true) {\\n                if(grid[o[0]][o[1]] == 1) {\\n                    if(o[2]==1) {\\n                        if(o[1]+1>=n) {\\n                            ans[i] = -1;\\n                            break;\\n                        }else if(grid[o[0]][o[1]+1]==-1){\\n                            ans[i] = -1;\\n                            break;\\n                        }else{\\n                            o[1]=o[1]+1;\\n                            o[2]=-1;//ball go down\\n                        } \\n                        printf(\"i=%d, (r,c)=(%d,%d,%d) up1/down-1\\\\n\",i,o[0],o[1],o[2]);\\n                    } else {//o[2]==0\\n                        o[2]=1;\\n                        o[0]=o[0]+1;\\n                        if(o[0]>=m) {\\n                            ans[i] = o[1];\\n                            break;\\n                        }\\n                        printf(\"i=%d, (r,c)=(%d,%d,%d) up1/down-1\\\\n\",i,o[0],o[1],o[2]);\\n                    }\\n                } else {\\n                    //grid[o[0]][o[1]] == -1\\n                    if(o[2]==1) {\\n                        if(o[1]-1<0) {\\n                            ans[i] = -1;\\n                            break;\\n                        }else if(grid[o[0]][o[1]-1]==1){\\n                            ans[i] = -1;\\n                            break;\\n                        }else{\\n                            o[1]=o[1]-1;\\n                            o[2]=-1;//ball go down\\n                        }  \\n                        printf(\"i=%d, (r,c)=(%d,%d,%d) up1/down-1\\\\n\",i,o[0],o[1],o[2]);\\n                    } else {\\n                        o[2]=1;\\n                        o[0]=o[0]+1;\\n                        if(o[0]>=m) {\\n                            ans[i] = o[1];\\n                            break;\\n                        } \\n                        printf(\"i=%d, (r,c)=(%d,%d,%d) up1/down-1\\\\n\",i,o[0],o[1],o[2]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    #define printf(...) empty_printf(__VA_ARGS__)\\n    #define empty_printf(...)    \\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        //pos(row,col), up ball/down ball   \\n        //cell_status: \"\\\\\"  \"/\"\\n        //up ball in \"\\\\\": if row,col+1 == \"/\" ->Ball Stop\\n        //up ball in \"\\\\\": if row,col+1 == \"\\\\\" ->Go ball down & go pos(row,col+1)\\n        //down ball in \"\\\\\":  -> Go ball up & go pos(row+1,col)\\n        \\n        //up ball in \"/\": if row,col+\\uFF11 == \"\\\\\" ->Ball Stop\\n        //up ball in \"/\": if row,col+1 == \"/\" ->Go ball down & go pos(row,col-1)\\n        //down ball in \"\\\\\":  -> Go ball up & go pos(row+1,col)\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> v = vector<vector<int>>(n,vector<int>());\\n        vector<int> ans = vector<int>(n,0);\\n        for(int i = 0; i<n;i++) {\\n            v[i] = {0,i,1};\\n\\t\\t\\t//[0] : row\\n\\t\\t\\t//[1] : col\\n\\t\\t\\t//[2] 1 is ball up, 0 is ball down\\n\\t\\t\\t/* For example, \\n\\t\\tup-> o /\\n\\t\\t\\t  /\\n\\t\\t\\t /  o<-- down\\n\\t\\t\\t \\n\\t\\t  \\\\    o <-- up\\n\\t\\t   \\\\\\t  \\ndown->  o    \\\\ \\n\\t\\t\\t \\n\\t\\t\\t*/\\n\\t\\t\\t\\n            ans[i] = i;\\n        }\\n        \\n        \\n        for(int i = 0; i<n;i++) {\\n            vector<int>& o = v[i];\\n            while(true) {\\n                if(grid[o[0]][o[1]] == 1) {\\n                    if(o[2]==1) {\\n                        if(o[1]+1>=n) {\\n                            ans[i] = -1;\\n                            break;\\n                        }else if(grid[o[0]][o[1]+1]==-1){\\n                            ans[i] = -1;\\n                            break;\\n                        }else{\\n                            o[1]=o[1]+1;\\n                            o[2]=-1;//ball go down\\n                        } \\n                        printf(\"i=%d, (r,c)=(%d,%d,%d) up1/down-1\\\\n\",i,o[0],o[1],o[2]);\\n                    } else {//o[2]==0\\n                        o[2]=1;\\n                        o[0]=o[0]+1;\\n                        if(o[0]>=m) {\\n                            ans[i] = o[1];\\n                            break;\\n                        }\\n                        printf(\"i=%d, (r,c)=(%d,%d,%d) up1/down-1\\\\n\",i,o[0],o[1],o[2]);\\n                    }\\n                } else {\\n                    //grid[o[0]][o[1]] == -1\\n                    if(o[2]==1) {\\n                        if(o[1]-1<0) {\\n                            ans[i] = -1;\\n                            break;\\n                        }else if(grid[o[0]][o[1]-1]==1){\\n                            ans[i] = -1;\\n                            break;\\n                        }else{\\n                            o[1]=o[1]-1;\\n                            o[2]=-1;//ball go down\\n                        }  \\n                        printf(\"i=%d, (r,c)=(%d,%d,%d) up1/down-1\\\\n\",i,o[0],o[1],o[2]);\\n                    } else {\\n                        o[2]=1;\\n                        o[0]=o[0]+1;\\n                        if(o[0]>=m) {\\n                            ans[i] = o[1];\\n                            break;\\n                        } \\n                        printf(\"i=%d, (r,c)=(%d,%d,%d) up1/down-1\\\\n\",i,o[0],o[1],o[2]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971428,
                "title": "straight-forward-approach-intuitive-and-helper-for-beginners",
                "content": "# Intuition\\nProblem is pretty straight forward, just follow what question is asking.\\n\\n# Approach\\nFor every column, will start with coordinates row=0,col=col.\\nThen we will follow the problem that is if grid[i][j]==1 then we will\\nincrease col=col+1 and if grid[i][j]==-1 then we will decrease col=col-1, in both the cases we will increase row=row+1.\\nThis entire process will happen in a while loop. We just need to check for the stopping condition ie either we encounter opposite sign in grid or we encounter wall.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<int>ans(n,-1);\\n        int x,y;\\n        for(int i=0;i<n;i++){\\n            x=0,y=i;\\n            while(x<m && y>=0 && y<n){\\n                if(grid[x][y]==1){\\n                    if(y+1==n || grid[x][y+1]==-1)break;\\n                    x+=1,y+=1;\\n                }\\n                else{\\n                    if(y-1<0 || grid[x][y-1]==1)break;\\n                    x+=1,y-=1;\\n                }\\n            }\\n            if(x==m)ans[i]=y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<int>ans(n,-1);\\n        int x,y;\\n        for(int i=0;i<n;i++){\\n            x=0,y=i;\\n            while(x<m && y>=0 && y<n){\\n                if(grid[x][y]==1){\\n                    if(y+1==n || grid[x][y+1]==-1)break;\\n                    x+=1,y+=1;\\n                }\\n                else{\\n                    if(y-1<0 || grid[x][y-1]==1)break;\\n                    x+=1,y-=1;\\n                }\\n            }\\n            if(x==m)ans[i]=y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943296,
                "title": "leetcode-official-dynamic-programming-approach-optimized-o-n-sc-o-n-2-tc",
                "content": "### LeetCode Official Dynamic Programming Approach\\nThis is the LeetCode Official Solution:\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/?orderBy=most_votes\\nYou will find The DP Approach Description in the Second Approach in the LeetCode Solution, Please read it so you can then understand my optimization for the approach.\\n\\n### My Dynamic Programming Approach Optimization\\nInstead of using 2-dimensional array size ***M\\u22C5N***,\\nWe used only two 1-dimensional arrays size ***N*** `memo` & `prevMemo`,\\nwhere we save the previous values of `memo` into `prevMemo` ,\\nthen We get the desired new values out of `grid`, We put them into `memo` and we repeat the whole process until we return `memo` containing the desired answer. \\n\\n\\n### Complexity\\n- Time complexity: O(M.N)\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nvector<int> findBall(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<int> memo(n);\\n    vector<int> prevMemo(n);\\n\\n    for (int col = 0; col < n; col++) {\\n        memo[col] = col;\\n    }\\n    for (int row = m - 1; row >= 0; row--) {\\n        for (int col = 0; col < n; col++) {\\n            int nextCol = col + grid[row][col];\\n            if (nextCol < 0 || nextCol > n - 1 || grid[row][col] != grid[row][nextCol]) {\\n                prevMemo[col] = -1;\\n            } else {\\n                prevMemo[col] = memo[nextCol];\\n            }\\n        }\\n        swap(memo, prevMemo);\\n    }\\n    return memo;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvector<int> findBall(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<int> memo(n);\\n    vector<int> prevMemo(n);\\n\\n    for (int col = 0; col < n; col++) {\\n        memo[col] = col;\\n    }\\n    for (int row = m - 1; row >= 0; row--) {\\n        for (int col = 0; col < n; col++) {\\n            int nextCol = col + grid[row][col];\\n            if (nextCol < 0 || nextCol > n - 1 || grid[row][col] != grid[row][nextCol]) {\\n                prevMemo[col] = -1;\\n            } else {\\n                prevMemo[col] = memo[nextCol];\\n            }\\n        }\\n        swap(memo, prevMemo);\\n    }\\n    return memo;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2857119,
                "title": "java-clear-and-concise-simulation-0-ms-o-m-n-runtime",
                "content": "```\\nThis approach boils down to the four major flows as per the below logic. \\n\\n1. If the ball is in the leftmost column with the cell redirecting to the left (-1), its STUCK\\n2. If the ball is in the rightmost column with the cell redirecting to the right (1), its STUCK\\n3. If the ball is in a cell which redirects to the right (1) and the cell to its right does not (-1), its STUCK\\n4. If the ball is in a cell which redirects to the left (-1) and the cell to its left does not (1), its STUCK\\n\\n\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int[] result = new int[grid[0].length];\\n        int lastRow = grid.length-1;\\n        int lastCol = grid[0].length-1;\\n        \\n        for(int i=0; i<grid[0].length; i++) {\\n            int ballStartRow = 0;\\n            int ballStartCol = i;\\n            \\n\\t\\t\\t// Drop the ball one by one\\n            result[i] = dropBall(grid, ballStartRow, ballStartCol, lastRow, lastCol); \\n        }\\n        return result;\\n    }\\n    \\n    public int dropBall(int[][] grid, int ballRow, int ballCol, int lastRow, int lastCol) {\\n  \\n        // Loop until the ball reaches the bottom\\n        while(ballRow <= lastRow) {\\n            int cell = grid[ballRow][ballCol];\\n            \\n            // Leftmost cell\\n            if ((ballCol == 0 && cell == -1)) {\\n                return -1;\\n            }\\n            \\n            // Rightmost cell\\n            if (ballCol == lastCol && cell == 1) {\\n                return -1;\\n            }\\n            \\n\\t\\t\\t// Cell redirects to the RIGHT\\n            if (cell == 1) {\\n                // Cell and Right Cell redirects equally. Roll Right.\\n                if (grid[ballRow][ballCol] == grid[ballRow][ballCol+1]) {\\n                    ballCol++;\\n                } \\n                else {\\n                    return -1;\\n                }\\n            } \\n            \\n\\t\\t\\t// Cell redirects to the LEFT\\n            if (cell == -1) {\\n\\t\\t\\t\\t// Cell and Left Cell redirects equally. Roll Left.\\n                if (grid[ballRow][ballCol] == grid[ballRow][ballCol-1]) {\\n                    ballCol--;\\n                } \\n                else {\\n                    return -1;\\n                }\\n            }\\n            \\n            // drop ball one level\\n            ballRow++;\\n        }\\n        \\n        // return the col it went out of\\n        return ballCol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nThis approach boils down to the four major flows as per the below logic. \\n\\n1. If the ball is in the leftmost column with the cell redirecting to the left (-1), its STUCK\\n2. If the ball is in the rightmost column with the cell redirecting to the right (1), its STUCK\\n3. If the ball is in a cell which redirects to the right (1) and the cell to its right does not (-1), its STUCK\\n4. If the ball is in a cell which redirects to the left (-1) and the cell to its left does not (1), its STUCK\\n\\n\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int[] result = new int[grid[0].length];\\n        int lastRow = grid.length-1;\\n        int lastCol = grid[0].length-1;\\n        \\n        for(int i=0; i<grid[0].length; i++) {\\n            int ballStartRow = 0;\\n            int ballStartCol = i;\\n            \\n\\t\\t\\t// Drop the ball one by one\\n            result[i] = dropBall(grid, ballStartRow, ballStartCol, lastRow, lastCol); \\n        }\\n        return result;\\n    }\\n    \\n    public int dropBall(int[][] grid, int ballRow, int ballCol, int lastRow, int lastCol) {\\n  \\n        // Loop until the ball reaches the bottom\\n        while(ballRow <= lastRow) {\\n            int cell = grid[ballRow][ballCol];\\n            \\n            // Leftmost cell\\n            if ((ballCol == 0 && cell == -1)) {\\n                return -1;\\n            }\\n            \\n            // Rightmost cell\\n            if (ballCol == lastCol && cell == 1) {\\n                return -1;\\n            }\\n            \\n\\t\\t\\t// Cell redirects to the RIGHT\\n            if (cell == 1) {\\n                // Cell and Right Cell redirects equally. Roll Right.\\n                if (grid[ballRow][ballCol] == grid[ballRow][ballCol+1]) {\\n                    ballCol++;\\n                } \\n                else {\\n                    return -1;\\n                }\\n            } \\n            \\n\\t\\t\\t// Cell redirects to the LEFT\\n            if (cell == -1) {\\n\\t\\t\\t\\t// Cell and Left Cell redirects equally. Roll Left.\\n                if (grid[ballRow][ballCol] == grid[ballRow][ballCol-1]) {\\n                    ballCol--;\\n                } \\n                else {\\n                    return -1;\\n                }\\n            }\\n            \\n            // drop ball one level\\n            ballRow++;\\n        }\\n        \\n        // return the col it went out of\\n        return ballCol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822826,
                "title": "where-will-the-ball-fall",
                "content": "class Solution {\\n  public int[] findBall(int[][] grid) {\\n    final int m = grid.length;\\n    final int n = grid[0].length;\\n    // dp[i] := status of i-th column\\n    // -1 := empty, 0 := b0, 1 := b1, ...\\n    int[] dp = new int[n];\\n    // ans[i] := i-th ball\\'s final position\\n    int[] ans = new int[n];\\n    Arrays.fill(ans, -1);\\n\\n    for (int i = 0; i < n; ++i)\\n      dp[i] = i;\\n\\n    for (int i = 0; i < m; ++i) {\\n      int[] newDp = new int[n];\\n      Arrays.fill(newDp, -1);\\n      for (int j = 0; j < n; ++j) {\\n        // Out of bound\\n        if (j + grid[i][j] < 0 || j + grid[i][j] == n)\\n          continue;\\n        // Stuck\\n        if (grid[i][j] == 1 && grid[i][j + 1] == -1 || grid[i][j] == -1 && grid[i][j - 1] == 1)\\n          continue;\\n        newDp[j + grid[i][j]] = dp[j];\\n      }\\n      dp = newDp;\\n    }\\n\\n    for (int i = 0; i < n; ++i)\\n      if (dp[i] != -1)\\n        ans[dp[i]] = i;\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n  public int[] findBall(int[][] grid) {\\n    final int m = grid.length;\\n    final int n = grid[0].length;\\n    // dp[i] := status of i-th column\\n    // -1 := empty, 0 := b0, 1 := b1, ...\\n    int[] dp = new int[n];\\n    // ans[i] := i-th ball\\'s final position\\n    int[] ans = new int[n];\\n    Arrays.fill(ans, -1);\\n\\n    for (int i = 0; i < n; ++i)\\n      dp[i] = i;\\n\\n    for (int i = 0; i < m; ++i) {\\n      int[] newDp = new int[n];\\n      Arrays.fill(newDp, -1);\\n      for (int j = 0; j < n; ++j) {\\n        // Out of bound\\n        if (j + grid[i][j] < 0 || j + grid[i][j] == n)\\n          continue;\\n        // Stuck\\n        if (grid[i][j] == 1 && grid[i][j + 1] == -1 || grid[i][j] == -1 && grid[i][j - 1] == 1)\\n          continue;\\n        newDp[j + grid[i][j]] = dp[j];\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2786241,
                "title": "python-clean-self-explanatory-code-easy-solution",
                "content": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        answer = []\\n        rows, cols = len(grid), len(grid[0])\\n        def stuck(row,col):\\n            if grid[row][col] == 1 and ((col + 1) >= cols or grid[row][col + 1] == -1):\\n                return True\\n            elif grid[row][col] == -1 and ((col - 1) < 0 or grid[row][col - 1] == 1):\\n                return True\\n            return False\\n        def canReach(row,col):\\n            if row >= rows:\\n                return col\\n            if stuck(row,col):\\n                return -1\\n            if grid[row][col] == 1:\\n                return canReach(row + 1, col + 1)\\n            else:\\n                return canReach(row + 1, col - 1)\\n \\n        for col in range(cols):\\n            answer.append(canReach(0,col))\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        answer = []\\n        rows, cols = len(grid), len(grid[0])\\n        def stuck(row,col):\\n            if grid[row][col] == 1 and ((col + 1) >= cols or grid[row][col + 1] == -1):\\n                return True\\n            elif grid[row][col] == -1 and ((col - 1) < 0 or grid[row][col - 1] == 1):\\n                return True\\n            return False\\n        def canReach(row,col):\\n            if row >= rows:\\n                return col\\n            if stuck(row,col):\\n                return -1\\n            if grid[row][col] == 1:\\n                return canReach(row + 1, col + 1)\\n            else:\\n                return canReach(row + 1, col - 1)\\n \\n        for col in range(cols):\\n            answer.append(canReach(0,col))\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772487,
                "title": "java-solution-intutive-physics-way",
                "content": "The next step of a ball is depende on the board and balls incoming direction. The ball has 3 direction( go down, go left, go right), the board has 2 direction(1, -1). So put the 6 possible next steps into the hashmap. \\n```\\n  public int[] findBall(int[][] grid) {\\n    HashMap<String, int[]> map = new HashMap<>();\\n    map.put(\"1,0,1\", new int[]{0,1});\\n    map.put(\"0,1,1\", new int[]{1,0});\\n    map.put(\"0,-1,1\", null);\\n    map.put(\"1,0,-1\", new int[]{0,-1});\\n    map.put(\"0,1,-1\", null);\\n    map.put(\"0,-1,-1\", new int[]{1,0});\\n    int dep = grid.length-1;\\n    int[] ans = new int[grid[0].length];\\n    for (int i = 0; i < grid[0].length; i++) {\\n      ans[i] = dfs(0,i,1,0,grid,map,dep, grid[0].length);\\n    }\\n    return ans;\\n  }\\n  \\n  private int dfs(int x, int y,int dx, int dy, int[][] grid, HashMap<String, int[]> map, int dep, int m) {\\n    if (x > dep) {\\n      return y;\\n    }\\n    if (y<0 || y>=m) return -1;\\n    int[] nd =map.get(dx+\",\"+dy+\",\"+grid[x][y]);\\n    if(nd==null){return -1;}\\n    int nx = x+nd[0];\\n    int ny = y+nd[1];\\n    return dfs(nx,ny,nd[0],nd[1],grid,map,dep,m);\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public int[] findBall(int[][] grid) {\\n    HashMap<String, int[]> map = new HashMap<>();\\n    map.put(\"1,0,1\", new int[]{0,1});\\n    map.put(\"0,1,1\", new int[]{1,0});\\n    map.put(\"0,-1,1\", null);\\n    map.put(\"1,0,-1\", new int[]{0,-1});\\n    map.put(\"0,1,-1\", null);\\n    map.put(\"0,-1,-1\", new int[]{1,0});\\n    int dep = grid.length-1;\\n    int[] ans = new int[grid[0].length];\\n    for (int i = 0; i < grid[0].length; i++) {\\n      ans[i] = dfs(0,i,1,0,grid,map,dep, grid[0].length);\\n    }\\n    return ans;\\n  }\\n  \\n  private int dfs(int x, int y,int dx, int dy, int[][] grid, HashMap<String, int[]> map, int dep, int m) {\\n    if (x > dep) {\\n      return y;\\n    }\\n    if (y<0 || y>=m) return -1;\\n    int[] nd =map.get(dx+\",\"+dy+\",\"+grid[x][y]);\\n    if(nd==null){return -1;}\\n    int nx = x+nd[0];\\n    int ny = y+nd[1];\\n    return dfs(nx,ny,nd[0],nd[1],grid,map,dep,m);\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2769127,
                "title": "python-simulation",
                "content": "Like #3, but a bit simpler idea:\\n\\ninstead of rolling, think that the balls are falling down, collide with the \\\\ or / and jump to the opposite side:\\n```\\n1) \\\\->... e.g. \\\\ or /\\n\\n1.1)\\n.\\n\\\\->\\\\\\n   |\\n   .\\n\\n1.2)\\n.\\n\\\\->/ - blocked\\n\\n2) e.g. \\\\ or / ...<-/  \\n\\n2.1)\\n   .\\n/<-/\\n|\\n.\\n\\n2.2)\\n   .\\n\\\\<-/ - blocked\\n\\n3) right edge\\n.\\n\\\\->| - blocked\\n\\n4) left edge\\n   .\\n|<-/ - blocked\\n```\\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:        \\n        ROWS, COLS = len(grid), len(grid[0])\\n        pos = [c for c in range(COLS)]\\n        \\n        for row in range(ROWS):\\n            for col in range(COLS):\\n                if pos[col] >= 0: # when can move down\\n                    if grid[row][pos[col]] == 1: # if can go right e.g. \\\\\\n                        if pos[col] + 1 < COLS and grid[row][pos[col] + 1] == 1: # \\\\\\\\ and right is the same -> move right\\n                            pos[col] += 1\\n                        else:\\n                            pos[col] = -1 # \\\\/ or \\\\| blocked\\n                    elif grid[row][pos[col]] == -1: # if can go left e.g. /\\n                        if pos[col] > 0 and grid[row][pos[col] - 1] == -1: # // and left is the same -> move left\\n                            pos[col] -= 1\\n                        else:\\n                            pos[col] = -1 # \\\\/ or |/ blocked\\n\\n                # if pos[col] >= 0 and grid[row][pos[col]] == 1:\\n                #     if pos[col] + 1 < COLS and grid[row][pos[col] + 1] == 1:\\n                #         pos[col] += 1\\n                #     elif pos[col] + 1 < COLS and grid[row][pos[col] + 1] == -1:\\n                #         pos[col] = -1\\n                #     elif pos[col] + 1 == COLS:\\n                #         pos[col] = -1\\n                # elif pos[col] >= 0 and grid[row][pos[col]] == -1:\\n                #     if pos[col] - 1 >= 0 and grid[row][pos[col] - 1] == -1:\\n                #         pos[col] -= 1\\n                #     elif pos[col] - 1 >= 0 and grid[row][pos[col] - 1] == 1:\\n                #         pos[col] = -1\\n                #     elif pos[col] - 1 == -1:\\n                #         pos[col] = -1\\n\\n        return pos\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\n1) \\\\->... e.g. \\\\ or /\\n\\n1.1)\\n.\\n\\\\->\\\\\\n   |\\n   .\\n\\n1.2)\\n.\\n\\\\->/ - blocked\\n\\n2) e.g. \\\\ or / ...<-/  \\n\\n2.1)\\n   .\\n/<-/\\n|\\n.\\n\\n2.2)\\n   .\\n\\\\<-/ - blocked\\n\\n3) right edge\\n.\\n\\\\->| - blocked\\n\\n4) left edge\\n   .\\n|<-/ - blocked\\n```\n```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:        \\n        ROWS, COLS = len(grid), len(grid[0])\\n        pos = [c for c in range(COLS)]\\n        \\n        for row in range(ROWS):\\n            for col in range(COLS):\\n                if pos[col] >= 0: # when can move down\\n                    if grid[row][pos[col]] == 1: # if can go right e.g. \\\\\\n                        if pos[col] + 1 < COLS and grid[row][pos[col] + 1] == 1: # \\\\\\\\ and right is the same -> move right\\n                            pos[col] += 1\\n                        else:\\n                            pos[col] = -1 # \\\\/ or \\\\| blocked\\n                    elif grid[row][pos[col]] == -1: # if can go left e.g. /\\n                        if pos[col] > 0 and grid[row][pos[col] - 1] == -1: # // and left is the same -> move left\\n                            pos[col] -= 1\\n                        else:\\n                            pos[col] = -1 # \\\\/ or |/ blocked\\n\\n                # if pos[col] >= 0 and grid[row][pos[col]] == 1:\\n                #     if pos[col] + 1 < COLS and grid[row][pos[col] + 1] == 1:\\n                #         pos[col] += 1\\n                #     elif pos[col] + 1 < COLS and grid[row][pos[col] + 1] == -1:\\n                #         pos[col] = -1\\n                #     elif pos[col] + 1 == COLS:\\n                #         pos[col] = -1\\n                # elif pos[col] >= 0 and grid[row][pos[col]] == -1:\\n                #     if pos[col] - 1 >= 0 and grid[row][pos[col] - 1] == -1:\\n                #         pos[col] -= 1\\n                #     elif pos[col] - 1 >= 0 and grid[row][pos[col] - 1] == 1:\\n                #         pos[col] = -1\\n                #     elif pos[col] - 1 == -1:\\n                #         pos[col] = -1\\n\\n        return pos\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768540,
                "title": "kotlin-simple-dfs-recursion",
                "content": "I added some comments in code to explain, but the main idea behind this is that the value at ```grid[m][n]``` will be the change in column when the ball moves, using this we can check if the value at ```grid[m][n+value]``` is the opposite, it can\\'t fall since it will be a dip.\\n\\n\\n```\\nclass Solution {\\n    fun findBall(grid: Array<IntArray>): IntArray {\\n        val result = IntArray(grid[0].size)\\n\\t\\t\\n        for (ball in 0 until grid[0].size) {\\n            fall(grid, ball, 0, ball, result)\\n        }\\n        \\n        return result\\n    }\\n    \\n    private fun fall(\\n        grid: Array<IntArray>,\\n        ball: Int,\\n        row: Int,\\n        col: Int,\\n        result: IntArray\\n    ) {\\n        if (canFallToNextRow(\\n            grid,\\n            row,\\n            col\\n            )\\n        ) {\\n            // if the ball has escaped the grid set the result\\n            if (row == grid.size - 1) {\\n                result[ball] = col + grid[row][col]\\n            } else {\\n                // if not it falls to the next row\\n                // it will move to the col+1 if falling right, shown by 1\\n                // or to col-1 if falling left, shown by -1\\n                // meaning it will move to grid[row+1][col+value]\\n                fall(\\n                    grid,\\n                    ball,\\n                    row+1,\\n                    col + grid[row][col],\\n                    result\\n                )\\n            }\\n        // if it can not fall it is stuck, so -1\\n        } else {\\n            result[ball] = -1\\n        }\\n    }\\n    \\n    \\n    // since the value in grid[m][n] is how the column (n) will be affected\\n    // we can check if a wall will be hit using it\\n    private fun canFallToNextRow(\\n        grid: Array<IntArray>,\\n        row: Int,\\n        col: Int\\n    ) : Boolean {\\n        val move = grid[row][col]\\n        \\n        //if the ball hits a wall or a \\\\/ shape it cannot fall\\n        if (col + move < 0\\n            || col + move >= grid[0].size\\n            || grid[row][col + move] == -move\\n           ) {\\n            return false\\n        } else {\\n            return true\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```grid[m][n]```\n```grid[m][n+value]```\n```\\nclass Solution {\\n    fun findBall(grid: Array<IntArray>): IntArray {\\n        val result = IntArray(grid[0].size)\\n\\t\\t\\n        for (ball in 0 until grid[0].size) {\\n            fall(grid, ball, 0, ball, result)\\n        }\\n        \\n        return result\\n    }\\n    \\n    private fun fall(\\n        grid: Array<IntArray>,\\n        ball: Int,\\n        row: Int,\\n        col: Int,\\n        result: IntArray\\n    ) {\\n        if (canFallToNextRow(\\n            grid,\\n            row,\\n            col\\n            )\\n        ) {\\n            // if the ball has escaped the grid set the result\\n            if (row == grid.size - 1) {\\n                result[ball] = col + grid[row][col]\\n            } else {\\n                // if not it falls to the next row\\n                // it will move to the col+1 if falling right, shown by 1\\n                // or to col-1 if falling left, shown by -1\\n                // meaning it will move to grid[row+1][col+value]\\n                fall(\\n                    grid,\\n                    ball,\\n                    row+1,\\n                    col + grid[row][col],\\n                    result\\n                )\\n            }\\n        // if it can not fall it is stuck, so -1\\n        } else {\\n            result[ball] = -1\\n        }\\n    }\\n    \\n    \\n    // since the value in grid[m][n] is how the column (n) will be affected\\n    // we can check if a wall will be hit using it\\n    private fun canFallToNextRow(\\n        grid: Array<IntArray>,\\n        row: Int,\\n        col: Int\\n    ) : Boolean {\\n        val move = grid[row][col]\\n        \\n        //if the ball hits a wall or a \\\\/ shape it cannot fall\\n        if (col + move < 0\\n            || col + move >= grid[0].size\\n            || grid[row][col + move] == -move\\n           ) {\\n            return false\\n        } else {\\n            return true\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768311,
                "title": "c-easy-to-understand-solution-with-comments",
                "content": "```\\n#define vi vector<int>\\n#define vvi vector<vi>\\nclass Solution {\\npublic:\\n    int helper (vvi &grid, int i, int j, vvi &dp){\\n        if (i >= grid.size()) return j;  //where rows end i.e we have reached our required exit column    \\n        if (i < 0 || j < 0 || j >= grid[0].size ()) return -1;// if ball is outside walls either left or right or above return -1\\n        if (dp[i][j] != -2) return dp [i][j]; // if visited before then return the result\\n        \\n        \\n        if (grid[i][j] == 1){\\n            if (j+1 >= grid[0].size()) return -1; // if ball get stuck to right wall return -1\\n            if (grid[i][j+1] == -1) return -1; // if right column has opposite slope (forming V) return -1\\n            \\n            return dp[i][j] = helper (grid,i+1,j+1,dp); // bring answer by visiting diagonally right column\\n        }\\n        \\n        if (grid[i][j] == -1){\\n            if (j-1 < 0) return -1;  // if ball get stuck to left wall return -1\\n            if (grid[i][j-1] == 1) return -1;  // if left column has opposite slope (forming V) return -1\\n            \\n            return dp[i][j]=helper (grid,i+1,j-1,dp);  // bring answer by visiting diagonally left column\\n        }\\n        \\n        return {};\\n    }\\n\\t\\n\\t\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        vi ans;\\n        vvi dp (grid.size (), vi (grid[0].size (), -2));\\n        \\n        for (int i = 0; i < grid[0].size(); i++){\\n            int res= helper (grid,0,i,dp);\\n            \\n            ans.push_back (res);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n#define vi vector<int>\\n#define vvi vector<vi>\\nclass Solution {\\npublic:\\n    int helper (vvi &grid, int i, int j, vvi &dp){\\n        if (i >= grid.size()) return j;  //where rows end i.e we have reached our required exit column    \\n        if (i < 0 || j < 0 || j >= grid[0].size ()) return -1;// if ball is outside walls either left or right or above return -1\\n        if (dp[i][j] != -2) return dp [i][j]; // if visited before then return the result\\n        \\n        \\n        if (grid[i][j] == 1){\\n            if (j+1 >= grid[0].size()) return -1; // if ball get stuck to right wall return -1\\n            if (grid[i][j+1] == -1) return -1; // if right column has opposite slope (forming V) return -1\\n            \\n            return dp[i][j] = helper (grid,i+1,j+1,dp); // bring answer by visiting diagonally right column\\n        }\\n        \\n        if (grid[i][j] == -1){\\n            if (j-1 < 0) return -1;  // if ball get stuck to left wall return -1\\n            if (grid[i][j-1] == 1) return -1;  // if left column has opposite slope (forming V) return -1\\n            \\n            return dp[i][j]=helper (grid,i+1,j-1,dp);  // bring answer by visiting diagonally left column\\n        }\\n        \\n        return {};\\n    }\\n\\t\\n\\t\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        vi ans;\\n        vvi dp (grid.size (), vi (grid[0].size (), -2));\\n        \\n        for (int i = 0; i < grid[0].size(); i++){\\n            int res= helper (grid,0,i,dp);\\n            \\n            ans.push_back (res);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768183,
                "title": "my-simple-intuitive-well-commented-solution",
                "content": "**C++ CODE:**\\n```\\nclass Solution {\\n    void dfs(vector<vector<int>>& grid, vector<int>& ans, int row, int col){\\n        /**\\n        base cases \\n        1.for left slant, the adjacent cell has right slant or a boundary wall(right)\\n        2. for right slant, the adjacent cell has left slant or a boundary wall(left)\\n        3. Out of the grid\\n        */\\n        \\n        //out of the grid\\n        if(row>grid.size()-1){\\n            ans.push_back(col);\\n            return;\\n        }\\n    \\n        // right slant\\n        // checks if it hits the left boundary, or if it has a left slant in the left adjacent cell\\n        if((grid[row][col]==1 && col==grid[0].size()-1) || (grid[row][col]==1 && col!=grid[0].size()-1 && grid[row][col+1]==-1)){\\n            ans.push_back(-1);\\n            return;\\n        }\\n        // left slant\\n        // checks if it hits the right boundary, or if it has a right slant in the right adjacent cell\\n        if((grid[row][col]==-1 && col==0) || (grid[row][col]==-1 && col!=0 && grid[row][col-1]==1)){\\n            ans.push_back(-1);\\n            return;\\n        }\\n        \\n        //if none of the above condition doesn\\'t meet then we need to proceed to next cell\\n        if(grid[row][col]==1)   // if its a right slant\\n            dfs(grid, ans, row+1, col+1);\\n        else if(grid[row][col]==-1) // if its a left slant\\n            dfs(grid, ans, row+1, col-1);\\n    }\\n    \\n    \\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        vector<int> ans;    //keeps all the answer.\\n        for(int i=0;i<col;++i){\\n            // finding out the outcoming col for each ball\\n            dfs(grid, ans, 0, i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(vector<vector<int>>& grid, vector<int>& ans, int row, int col){\\n        /**\\n        base cases \\n        1.for left slant, the adjacent cell has right slant or a boundary wall(right)\\n        2. for right slant, the adjacent cell has left slant or a boundary wall(left)\\n        3. Out of the grid\\n        */\\n        \\n        //out of the grid\\n        if(row>grid.size()-1){\\n            ans.push_back(col);\\n            return;\\n        }\\n    \\n        // right slant\\n        // checks if it hits the left boundary, or if it has a left slant in the left adjacent cell\\n        if((grid[row][col]==1 && col==grid[0].size()-1) || (grid[row][col]==1 && col!=grid[0].size()-1 && grid[row][col+1]==-1)){\\n            ans.push_back(-1);\\n            return;\\n        }\\n        // left slant\\n        // checks if it hits the right boundary, or if it has a right slant in the right adjacent cell\\n        if((grid[row][col]==-1 && col==0) || (grid[row][col]==-1 && col!=0 && grid[row][col-1]==1)){\\n            ans.push_back(-1);\\n            return;\\n        }\\n        \\n        //if none of the above condition doesn\\'t meet then we need to proceed to next cell\\n        if(grid[row][col]==1)   // if its a right slant\\n            dfs(grid, ans, row+1, col+1);\\n        else if(grid[row][col]==-1) // if its a left slant\\n            dfs(grid, ans, row+1, col-1);\\n    }\\n    \\n    \\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        vector<int> ans;    //keeps all the answer.\\n        for(int i=0;i<col;++i){\\n            // finding out the outcoming col for each ball\\n            dfs(grid, ans, 0, i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768115,
                "title": "c-easy-understanding",
                "content": "Here are some steps that might give you an idea of how this problem can be approached in an easy way.\\n\\n1. As the ball will get stuck only when it encounters a V\\n2. The cases are -\\n\\t\\t\\t1. \\tA \\'-1\\' appears immediately after a \\'1\\' (V formed)\\n\\t\\t\\t2. \\t-1 appears at the beginning of a row (stuck at wall)\\n\\t\\t\\t3. \\t1 appears at the end of a row (stuck at wall)\\n3. Thus, we keep a track of all the Vs in the grid\\n4. We initialize a vector with the initial positions of each ball\\n5. Check for each row\\n\\t\\t\\t1. \\tIf the ball is already stuck, ignore it\\n\\t\\t\\t2. \\tIf the ball arrives at a V, it get stuck\\n\\t\\t\\t3. \\tElse, it changes its column based on the diagonal path\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        // if there is only one column, the ball is going to get stuck\\n        if (grid[0].size() == 1)\\n            return {-1};\\n        \\n        map <pair <int, int>, int > vs;\\n        \\n        // get a list of all the positions where a ball may get stuck (i.e. all the V\\'s in the grid)\\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            for (int j = 0; j < grid[0].size(); j++)\\n            {\\n                if (j == 0)\\n                {\\n                    if (grid[i][j] == -1 or (grid[i][j] == 1 and grid[i][j+1] == -1))\\n                        vs[make_pair(i,j)]++;\\n                    \\n                }\\n                    \\n                else if (j == grid[0].size()-1)\\n                {\\n                    if (grid[i][j] == 1 or (grid[i][j] == -1 and grid[i][j-1] == 1))\\n                        vs[make_pair(i,j)]++;\\n                }\\n                \\n                else if (grid[i][j] == 1 and grid[i][j+1] == -1)\\n                    vs[make_pair(i,j)]++;\\n                \\n                else if (grid[i][j] == -1 and grid[i][j-1] == 1)\\n                    vs[make_pair(i,j)]++;\\n            }\\n        }\\n        \\n        \\n        vector <int> ballcol (grid[0].size());\\n        \\n        for (int i = 0; i < grid[0].size(); i++)\\n            ballcol[i] = i;\\n        \\n        \\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            \\n            for (int j = 0; j < ballcol.size(); j++)\\n            {\\n                \\n                // if a ball is already stuck, ignore it\\n                if (ballcol[j] == -1)\\n                    continue;\\n                \\n                // if a ball is in position of a V, it is stuck\\n                if (vs[make_pair(i, ballcol[j])])\\n                {\\n                    ballcol[j] = -1;\\n                    continue;\\n                }\\n                \\n                // change the column of the ball according to the slope\\n                ballcol[j] += grid[i][ballcol[j]];\\n            }\\n            \\n        }\\n        \\n        return ballcol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        // if there is only one column, the ball is going to get stuck\\n        if (grid[0].size() == 1)\\n            return {-1};\\n        \\n        map <pair <int, int>, int > vs;\\n        \\n        // get a list of all the positions where a ball may get stuck (i.e. all the V\\'s in the grid)\\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            for (int j = 0; j < grid[0].size(); j++)\\n            {\\n                if (j == 0)\\n                {\\n                    if (grid[i][j] == -1 or (grid[i][j] == 1 and grid[i][j+1] == -1))\\n                        vs[make_pair(i,j)]++;\\n                    \\n                }\\n                    \\n                else if (j == grid[0].size()-1)\\n                {\\n                    if (grid[i][j] == 1 or (grid[i][j] == -1 and grid[i][j-1] == 1))\\n                        vs[make_pair(i,j)]++;\\n                }\\n                \\n                else if (grid[i][j] == 1 and grid[i][j+1] == -1)\\n                    vs[make_pair(i,j)]++;\\n                \\n                else if (grid[i][j] == -1 and grid[i][j-1] == 1)\\n                    vs[make_pair(i,j)]++;\\n            }\\n        }\\n        \\n        \\n        vector <int> ballcol (grid[0].size());\\n        \\n        for (int i = 0; i < grid[0].size(); i++)\\n            ballcol[i] = i;\\n        \\n        \\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            \\n            for (int j = 0; j < ballcol.size(); j++)\\n            {\\n                \\n                // if a ball is already stuck, ignore it\\n                if (ballcol[j] == -1)\\n                    continue;\\n                \\n                // if a ball is in position of a V, it is stuck\\n                if (vs[make_pair(i, ballcol[j])])\\n                {\\n                    ballcol[j] = -1;\\n                    continue;\\n                }\\n                \\n                // change the column of the ball according to the slope\\n                ballcol[j] += grid[i][ballcol[j]];\\n            }\\n            \\n        }\\n        \\n        return ballcol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768070,
                "title": "dfs-with-detail-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndfs on each ball and check out whether each ball can go out of the box\\nif it is possible record the column the ball ends up with\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m) for the dfs stack\\n# Code\\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[] res=new int[n];\\n        //dfs on all n balls\\n        for(int i=0;i<n;i++){\\n            dfs(0,i,i,grid,res);\\n        }\\n        return res;\\n    }\\n    //row and col indicate the current position of the ball\\n    //ith indicate which ball it is\\n    //res stores the answer\\n    public void dfs(int row,int col, int ith, int[][] grid,int[] res){\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        //if the ball has gone out of the box\\n        if(row==m){\\n            //if the col is still valid\\n            //res[ith]=col\\n            if(col<n&&col>=0)\\n                res[ith]=col;\\n            //if the col is not valid\\n            //res[ith]=-1\\n            else\\n                res[ith]=-1;\\n            return;\\n        }\\n        //if the ball is still in the box but the ball has been redirect to the wall the the box\\n        //  or if the ball gets stuck by the v shape\\n        //then res[ith]=-1\\n        if(((col<0||col>=n)&&row<m)||\\n        (col+1<n&&grid[row][col+1]==-1&&grid[row][col]==1)||\\n        (col>0&&grid[row][col]==-1&&grid[row][col-1]==1)){\\n            res[ith]=-1;\\n            return;\\n        }\\n        //if the ball is redirected to the right\\n        //  go down one row and go toward right by 1 unit and dfs on the new location of the ball\\n        if(grid[row][col]==1)\\n            dfs(row+1,col+1,ith,grid,res);\\n        //if the ball is redirected to the left\\n        // go down one row and go toward left by 1 unit and dfs on the new location of the ball\\n        else\\n            dfs(row+1,col-1,ith,grid,res);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[] res=new int[n];\\n        //dfs on all n balls\\n        for(int i=0;i<n;i++){\\n            dfs(0,i,i,grid,res);\\n        }\\n        return res;\\n    }\\n    //row and col indicate the current position of the ball\\n    //ith indicate which ball it is\\n    //res stores the answer\\n    public void dfs(int row,int col, int ith, int[][] grid,int[] res){\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        //if the ball has gone out of the box\\n        if(row==m){\\n            //if the col is still valid\\n            //res[ith]=col\\n            if(col<n&&col>=0)\\n                res[ith]=col;\\n            //if the col is not valid\\n            //res[ith]=-1\\n            else\\n                res[ith]=-1;\\n            return;\\n        }\\n        //if the ball is still in the box but the ball has been redirect to the wall the the box\\n        //  or if the ball gets stuck by the v shape\\n        //then res[ith]=-1\\n        if(((col<0||col>=n)&&row<m)||\\n        (col+1<n&&grid[row][col+1]==-1&&grid[row][col]==1)||\\n        (col>0&&grid[row][col]==-1&&grid[row][col-1]==1)){\\n            res[ith]=-1;\\n            return;\\n        }\\n        //if the ball is redirected to the right\\n        //  go down one row and go toward right by 1 unit and dfs on the new location of the ball\\n        if(grid[row][col]==1)\\n            dfs(row+1,col+1,ith,grid,res);\\n        //if the ball is redirected to the left\\n        // go down one row and go toward left by 1 unit and dfs on the new location of the ball\\n        else\\n            dfs(row+1,col-1,ith,grid,res);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767830,
                "title": "recursive-and-iterative",
                "content": "\\n### Recursive\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        if (grid.empty() || grid[0].empty()) {\\n            return {};\\n        }\\n        \\n        int R = grid.size(), C = grid[0].size();        \\n        vector<int> res(C, 0);\\n        function<int(int,int)> dfs = [&](int r, int c) {\\n            // if current is the last row, we know the ball falls out of the bottom.\\n            if (r == R) {\\n                return c;\\n            }\\n            \\n            // 1  ->\\n            // -1 <-\\n            int nextCol = c + grid[r][c];\\n            \\n            // only in the same direction\\n            // grid[r][c] != grid[r][nextCol] means \\n            if (nextCol < 0 || nextCol >= C || grid[r][c] != grid[r][nextCol]) {\\n                return -1;\\n            }\\n            return dfs(r + 1, nextCol);\\n        };\\n        \\n        for (int c = 0; c < C; c++) {\\n            res[c] = dfs(0, c);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\n### Iterative\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        if (grid.empty() || grid[0].empty()) {\\n            return {};\\n        }\\n        \\n        int R = grid.size(), C = grid[0].size();\\n        vector<int> res(C);\\n        \\n        // for each col, we traverse from first row to last row\\n        for (int c = 0; c < C; c++) {\\n            int curCol = c;\\n            for (int r = 0; r < R; r++) {                \\n                int nextCol = curCol + grid[r][curCol];\\n                if (nextCol < 0 || nextCol >= C || grid[r][curCol] != grid[r][nextCol]) {\\n                    res[c] = -1;\\n                    break;\\n                }                \\n                // now, balls[c] will fall into nextCol\\n                res[c] = nextCol;\\n                curCol = nextCol;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        if (grid.empty() || grid[0].empty()) {\\n            return {};\\n        }\\n        \\n        int R = grid.size(), C = grid[0].size();        \\n        vector<int> res(C, 0);\\n        function<int(int,int)> dfs = [&](int r, int c) {\\n            // if current is the last row, we know the ball falls out of the bottom.\\n            if (r == R) {\\n                return c;\\n            }\\n            \\n            // 1  ->\\n            // -1 <-\\n            int nextCol = c + grid[r][c];\\n            \\n            // only in the same direction\\n            // grid[r][c] != grid[r][nextCol] means \\n            if (nextCol < 0 || nextCol >= C || grid[r][c] != grid[r][nextCol]) {\\n                return -1;\\n            }\\n            return dfs(r + 1, nextCol);\\n        };\\n        \\n        for (int c = 0; c < C; c++) {\\n            res[c] = dfs(0, c);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        if (grid.empty() || grid[0].empty()) {\\n            return {};\\n        }\\n        \\n        int R = grid.size(), C = grid[0].size();\\n        vector<int> res(C);\\n        \\n        // for each col, we traverse from first row to last row\\n        for (int c = 0; c < C; c++) {\\n            int curCol = c;\\n            for (int r = 0; r < R; r++) {                \\n                int nextCol = curCol + grid[r][curCol];\\n                if (nextCol < 0 || nextCol >= C || grid[r][curCol] != grid[r][nextCol]) {\\n                    res[c] = -1;\\n                    break;\\n                }                \\n                // now, balls[c] will fall into nextCol\\n                res[c] = nextCol;\\n                curCol = nextCol;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767778,
                "title": "python3-easy-approach-simulate-each-ball-s-trajectory",
                "content": "My approach to solving this problem is by simulating the trajectory of each ball.\\nAnd if the path is not valid, then the inner loop break, otherwise we update the answer with `res[j] = pos` in the else clause after `for` syntax.\\n\\n``` \\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        \\n        res = [-1] * n\\n        for j in range(n):\\n            pos = j\\n            i = 0\\n            for i in range(m):\\n            # while i < m:\\n                sep = grid[i][pos]  # means seperator\\n                if sep == 1 and (pos == n - 1 or grid[i][pos + 1] == -1) \\\\\\n                    or sep == -1 and (pos == 0 or grid[i][pos - 1] == 1): # NOT VALID\\n                    break\\n                else:   # VALID\\n                    if sep == 1:\\n                        pos += 1\\n                    else:\\n                        pos -= 1\\n                i += 1\\n            else:\\n                # The for loop finished without break!\\n                res[j] = pos\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        \\n        res = [-1] * n\\n        for j in range(n):\\n            pos = j\\n            i = 0\\n            for i in range(m):\\n            # while i < m:\\n                sep = grid[i][pos]  # means seperator\\n                if sep == 1 and (pos == n - 1 or grid[i][pos + 1] == -1) \\\\\\n                    or sep == -1 and (pos == 0 or grid[i][pos - 1] == 1): # NOT VALID\\n                    break\\n                else:   # VALID\\n                    if sep == 1:\\n                        pos += 1\\n                    else:\\n                        pos -= 1\\n                i += 1\\n            else:\\n                # The for loop finished without break!\\n                res[j] = pos\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767753,
                "title": "1ms-runtime-using-dfs-java",
                "content": "class Solution {\\n    public int[] findBall(int[][] grid) {\\n        \\n        int col=grid[0].length;\\n        int arr[]=new int[col];\\n        for(int i=0;i<col;i++){\\n            arr[i]=dfs(0,i,grid);\\n        }\\n        return arr;\\n    }\\n    \\n    \\n    int dfs(int i,int j, int[][] grid){\\n        if(i>=grid.length){\\n            return j;\\n        }\\n        \\n        if(grid[i][j]==1 && j+1<grid[0].length && grid[i][j+1]==1){\\n            return dfs(i+1,j+1,grid);\\n        }\\n        else if(grid[i][j]==-1 && j-1>=0 && grid[i][j-1]==-1){\\n            return dfs(i+1,j-1,grid);\\n        }else if(grid[i][j]==1 && j+1>=grid.length){\\n            return -1;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int[] findBall(int[][] grid) {\\n        \\n        int col=grid[0].length;\\n        int arr[]=new int[col];\\n        for(int i=0;i<col;i++){\\n            arr[i]=dfs(0,i,grid);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2767634,
                "title": "java-easy-to-understand-two-solutions",
                "content": "# Solution 1\\nWe will check for every column to fill up our ans array.\\n\\nOn traversing we have two conditions:\\n1.  If our current board is 1 (right slanting), then we will check if it is not the last board or if its next board is not a -1 (Making a \\'V\\' shape).\\n2.  If our current board is -1 (left slanting), then we will check if it is not the first board or if its previous board is not a 1 (Making a \\'V\\' shape).\\n\\nIf any of the above conditions meet, we return a -1.\\n\\nBy the end if we don\\'t encounter any such conditions, we will return the last index of our column.\\n\\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int[] ans = new int[c];\\n        \\n        for (int i = 0; i < c; i++) \\n            ans[i] = canReachEnd(grid, r, c, i);\\n        \\n        return ans;\\n    }\\n    \\n    public int canReachEnd(int[][] grid, int r, int c, int curr) {\\n        int i = 0, j = curr;\\n        \\n        while (i < r && j < c) {\\n            if (grid[i][j] == 1) {\\n                if (j == c - 1 || grid[i][j + 1] == -1)\\n                    return -1; \\n                \\n                j++; // grid[i][j + 1] = 1\\n            } else {\\n                if (j == 0 || grid[i][j - 1] == 1) \\n                    return -1;\\n                \\n                j--; // grid[i][j - 1] = -1\\n            }\\n    \\n            i++; // Going to next row\\n        }\\n        \\n        return j;\\n    }\\n}\\n```\\n\\n# Solution 2\\nWe will check for every column to fill up our ans array.\\n\\nOn traversing, we will check for the next column the ball has to travel. To do that we add up the current board value to our j (column) and come up with the following conditions:\\n1. If the nextJ is less than 0, then that means we are at the first column and its value is -1 (left slanting).\\n2. If the nextJ is greater than c - 1, then that means we are at the last column and its value is 1 (right slanting).\\n3. If the current value of grid is not equal to the next column\\'s value in the SAME row\\n\\nIf any of the above conditions meet, we return a -1.\\n\\nBy the end if we don\\'t encounter any such conditions, we will return the last index of our column.\\n\\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int[] ans = new int[c];\\n        \\n        for (int i = 0; i < c; i++) \\n            ans[i] = canReachEnd(grid, r, c, i);\\n        \\n        return ans;\\n    }\\n    \\n    public int canReachEnd(int[][] grid, int r, int c, int curr) {\\n        int i = 0, j = curr;\\n        \\n        while (i < r && j < c) {\\n            int nextJ = j + grid[i][j]; \\n            \\n            if (nextJ < 0 || nextJ > c - 1 || grid[i][j] != grid[i][nextJ]) \\n                return -1; \\n                \\n            j = nextJ; // Going to next column\\n            i++; // Going to next row\\n        }\\n        \\n        return j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int[] ans = new int[c];\\n        \\n        for (int i = 0; i < c; i++) \\n            ans[i] = canReachEnd(grid, r, c, i);\\n        \\n        return ans;\\n    }\\n    \\n    public int canReachEnd(int[][] grid, int r, int c, int curr) {\\n        int i = 0, j = curr;\\n        \\n        while (i < r && j < c) {\\n            if (grid[i][j] == 1) {\\n                if (j == c - 1 || grid[i][j + 1] == -1)\\n                    return -1; \\n                \\n                j++; // grid[i][j + 1] = 1\\n            } else {\\n                if (j == 0 || grid[i][j - 1] == 1) \\n                    return -1;\\n                \\n                j--; // grid[i][j - 1] = -1\\n            }\\n    \\n            i++; // Going to next row\\n        }\\n        \\n        return j;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int[] ans = new int[c];\\n        \\n        for (int i = 0; i < c; i++) \\n            ans[i] = canReachEnd(grid, r, c, i);\\n        \\n        return ans;\\n    }\\n    \\n    public int canReachEnd(int[][] grid, int r, int c, int curr) {\\n        int i = 0, j = curr;\\n        \\n        while (i < r && j < c) {\\n            int nextJ = j + grid[i][j]; \\n            \\n            if (nextJ < 0 || nextJ > c - 1 || grid[i][j] != grid[i][nextJ]) \\n                return -1; \\n                \\n            j = nextJ; // Going to next column\\n            i++; // Going to next row\\n        }\\n        \\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767505,
                "title": "c-wihtout-dfs-bfs",
                "content": "**Please upvote if you like this solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n       \\n        int row=grid.size(),col=grid[0].size();\\n         vector<int> ans(col);\\n        for(int j=0;j<col;j++){\\n            int curr_col = j;\\n            int next_col=-1;\\n            for(int i=0;i<row;i++){\\n                next_col = curr_col+grid[i][curr_col];\\n                if(next_col<0 || next_col>=col || grid[i][curr_col]!= grid[i][next_col]) {\\n                    curr_col=-1;\\n                    break;\\n                }\\n                curr_col = next_col;\\n            }\\n           ans[j]=curr_col;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n       \\n        int row=grid.size(),col=grid[0].size();\\n         vector<int> ans(col);\\n        for(int j=0;j<col;j++){\\n            int curr_col = j;\\n            int next_col=-1;\\n            for(int i=0;i<row;i++){\\n                next_col = curr_col+grid[i][curr_col];\\n                if(next_col<0 || next_col>=col || grid[i][curr_col]!= grid[i][next_col]) {\\n                    curr_col=-1;\\n                    break;\\n                }\\n                curr_col = next_col;\\n            }\\n           ans[j]=curr_col;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767127,
                "title": "c-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/009dc4aa-33a9-4001-b06f-23f1411a5024_1667313539.9373624.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/009dc4aa-33a9-4001-b06f-23f1411a5024_1667313539.9373624.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2766692,
                "title": "java-easy-solution-simulation-iterative",
                "content": "### Easy Solution | Simulation | Iterative [Java]\\n\\n*Time* = O(m * n)\\n*Space* = O(1)\\n\\n```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[] ans = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int r = 0, c = i;\\n            \\n            while (r < m) {\\n                int currentCell = grid[r][c];\\n                c += currentCell;\\n                \\n                if (c < 0 || c >= n || grid[r][c] != currentCell) {\\n                    c = -1;\\n                    break;\\n                }\\n                \\n                r++;\\n            }\\n            \\n            ans[i] = c;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findBall(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[] ans = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int r = 0, c = i;\\n            \\n            while (r < m) {\\n                int currentCell = grid[r][c];\\n                c += currentCell;\\n                \\n                if (c < 0 || c >= n || grid[r][c] != currentCell) {\\n                    c = -1;\\n                    break;\\n                }\\n                \\n                r++;\\n            }\\n            \\n            ans[i] = c;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766597,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid) ; m = len(grid[0])\\n        ans = []\\n        for col in range(m):\\n            x = 0 ; y = col\\n            ok = 1 \\n            while 1:\\n                if x==n: break \\n                if grid[x][y]==1:\\n                    if y==m-1 or grid[x][y+1]==-1:\\n                        ok = 0 \\n                        break \\n                    x += 1 \\n                    y += 1 \\n                else:\\n                    if y==0 or grid[x][y-1]==1:\\n                        ok = 0 \\n                        break \\n                    x += 1 \\n                    y -= 1 \\n            if ok:\\n                ans.append(y)    \\n            else:\\n                ans.append(-1)\\n        return ans\\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid) ; m = len(grid[0])\\n        ans = []\\n        for col in range(m):\\n            x = 0 ; y = col\\n            ok = 1 \\n            while 1:\\n                if x==n: break \\n                if grid[x][y]==1:\\n                    if y==m-1 or grid[x][y+1]==-1:\\n                        ok = 0 \\n                        break \\n                    x += 1 \\n                    y += 1 \\n                else:\\n                    if y==0 or grid[x][y-1]==1:\\n                        ok = 0 \\n                        break \\n                    x += 1 \\n                    y -= 1 \\n            if ok:\\n                ans.append(y)    \\n            else:\\n                ans.append(-1)\\n        return ans\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766426,
                "title": "java-iterative",
                "content": "Runtime: 2 ms, faster than 73.77% of Java online submissions for Where Will the Ball Fall.\\nMemory Usage: 43.5 MB, less than 91.76% of Java online submissions for Where Will the Ball Fall.\\n```\\nclass Solution {\\n  public int[] findBall(int[][] grid) {\\n    int ans[] = new int[grid[0].length], tmp[] = new int[grid[0].length];\\n    for(int i = 0; ++i != ans.length;) ans[i] = i;\\n      \\n    for(int[] l : grid){\\n      Arrays.fill(tmp, -1);\\n      \\n      for(int i = 0; i != tmp.length; i++)\\n        if(l[i] == 1) {if(i != 0 && l[i-1] == 1) tmp[i] = ans[i-1];}\\n        else if(i != tmp.length - 1 && l[i+1] == -1) tmp[i] = ans[i+1];\\n        \\n      int k[] = ans;\\n      ans = tmp;\\n      tmp = k;\\n    }  \\n    \\n    Arrays.fill(tmp, -1);\\n    for(int i = 0; i != tmp.length; i++)\\n      if(ans[i] != -1) tmp[ans[i]] = i;\\n    \\n    return tmp;  \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int[] findBall(int[][] grid) {\\n    int ans[] = new int[grid[0].length], tmp[] = new int[grid[0].length];\\n    for(int i = 0; ++i != ans.length;) ans[i] = i;\\n      \\n    for(int[] l : grid){\\n      Arrays.fill(tmp, -1);\\n      \\n      for(int i = 0; i != tmp.length; i++)\\n        if(l[i] == 1) {if(i != 0 && l[i-1] == 1) tmp[i] = ans[i-1];}\\n        else if(i != tmp.length - 1 && l[i+1] == -1) tmp[i] = ans[i+1];\\n        \\n      int k[] = ans;\\n      ans = tmp;\\n      tmp = k;\\n    }  \\n    \\n    Arrays.fill(tmp, -1);\\n    for(int i = 0; i != tmp.length; i++)\\n      if(ans[i] != -1) tmp[ans[i]] = i;\\n    \\n    return tmp;  \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766387,
                "title": "easy-solution-c-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int i=0,j=0,row=grid.size(),column=grid[0].size();\\n        bool flag = true;\\n        vector<int> result(column,-1);\\n        for(int k=0;k<column;k++){\\n            i = 0; j = k,flag=true;\\n            while(flag){\\n                if(i>=row || j>=column){\\n                    result[k] = j;\\n                    break;\\n                }\\n                if(grid[i][j]==1){\\n                    if(j+1 == column || grid[i][j+1]==-1) break;\\n                    else{\\n                        i++;\\n                        j++;\\n                    }\\n                }else{\\n                    if(j==0 || grid[i][j-1]==1) break;\\n                    else{\\n                        i++;\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        int i=0,j=0,row=grid.size(),column=grid[0].size();\\n        bool flag = true;\\n        vector<int> result(column,-1);\\n        for(int k=0;k<column;k++){\\n            i = 0; j = k,flag=true;\\n            while(flag){\\n                if(i>=row || j>=column){\\n                    result[k] = j;\\n                    break;\\n                }\\n                if(grid[i][j]==1){\\n                    if(j+1 == column || grid[i][j+1]==-1) break;\\n                    else{\\n                        i++;\\n                        j++;\\n                    }\\n                }else{\\n                    if(j==0 || grid[i][j-1]==1) break;\\n                    else{\\n                        i++;\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766347,
                "title": "ruby-solution",
                "content": "If the current cell is 1, it is necessary to check the right column and it should be 1, too.\\n\\nIf the current cell is -1, it is necessary to check the left column and it should be -1, too.\\n\\nIf any of these conditions is satisfied, it is necessary to check the next row by using the next col for the current cell. If not, the loop can be broke immediately.\\n\\n```ruby\\n# @param {Integer[][]} grid\\n# @return {Integer[]}\\ndef find_ball(grid)\\n\\n  total_col = grid.first.size\\n  \\n  0.upto(total_col - 1).map do |index_col|\\n\\n    grid.each do |row|\\n      if row[index_col] == 1 && row[index_col + 1] == 1\\n        index_col += 1\\n      elsif row[index_col] == -1 && row[index_col - 1] == -1 && index_col > 0\\n        index_col -= 1\\n      else\\n        index_col = -1\\n        break\\n      end\\n    end\\n\\n    index_col\\n  end\\n  \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[][]} grid\\n# @return {Integer[]}\\ndef find_ball(grid)\\n\\n  total_col = grid.first.size\\n  \\n  0.upto(total_col - 1).map do |index_col|\\n\\n    grid.each do |row|\\n      if row[index_col] == 1 && row[index_col + 1] == 1\\n        index_col += 1\\n      elsif row[index_col] == -1 && row[index_col - 1] == -1 && index_col > 0\\n        index_col -= 1\\n      else\\n        index_col = -1\\n        break\\n      end\\n    end\\n\\n    index_col\\n  end\\n  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2766331,
                "title": "dfs-dp-beginners-approach-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101]; \\n    int helper(int i,int j,int n,int m,vector<vector<int>> &grid)\\n    {\\n        if(i>=n) return j+1; // If i==n we reached the end. So return column number\\n        if(dp[i][j]!=0) return dp[i][j]; // If we have already found a path then retrun\\n        if(grid[i][j]==1)\\n        {\\n            if(j+1>=m || grid[i][j+1] ==-1){\\n                return -1; // For the right wall and V shape\\n            }\\n            else{\\n                return dp[i][j]=helper(i+1,j+1,n,m,grid); //We go from ij to i+1j+1 if grid[i][j] = 1\\n            }\\n        }\\n        else if(grid[i][j]==-1){\\n            if(j-1<0 || grid[i][j-1]==1){\\n                return -1; // For left wall and V shape\\n            }\\n            else{\\n                return dp[i][j]=helper(i+1,j-1,n,m,grid);\\n            }\\n        }\\n        return dp[i][j];\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        vector<int> ans(grid[0].size());\\n        // Use DFS from every column of a 1st row\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            int k = (helper(0,i,grid.size(),grid[0].size(),grid));\\n            ans[i] = (k>0?k-1:k); //As DP has 0 as a default value to control the dispute I am  returning j+1 i.e for 0 column it will return 1 hence to control this we are using this line.\\n// This is done just for the ease i didnt want to populate dp with -2 or anyother number. hence had to do this.   \\n        }\\n        return ans;\\n    }\\n};\\n\\n// Over all solution :\\n\\n// ij = 1 ij+1 =-1 j == n\\n// ij = -1 ij-1=-1 || j==0\\n// ij = 1 pass (i+1)(j+1)\\n// ij = -1 pass(i+1)(j-1)\\n// if(i==n-1) return j\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101]; \\n    int helper(int i,int j,int n,int m,vector<vector<int>> &grid)\\n    {\\n        if(i>=n) return j+1; // If i==n we reached the end. So return column number\\n        if(dp[i][j]!=0) return dp[i][j]; // If we have already found a path then retrun\\n        if(grid[i][j]==1)\\n        {\\n            if(j+1>=m || grid[i][j+1] ==-1){\\n                return -1; // For the right wall and V shape\\n            }\\n            else{\\n                return dp[i][j]=helper(i+1,j+1,n,m,grid); //We go from ij to i+1j+1 if grid[i][j] = 1\\n            }\\n        }\\n        else if(grid[i][j]==-1){\\n            if(j-1<0 || grid[i][j-1]==1){\\n                return -1; // For left wall and V shape\\n            }\\n            else{\\n                return dp[i][j]=helper(i+1,j-1,n,m,grid);\\n            }\\n        }\\n        return dp[i][j];\\n    }\\n    vector<int> findBall(vector<vector<int>>& grid) {\\n        vector<int> ans(grid[0].size());\\n        // Use DFS from every column of a 1st row\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            int k = (helper(0,i,grid.size(),grid[0].size(),grid));\\n            ans[i] = (k>0?k-1:k); //As DP has 0 as a default value to control the dispute I am  returning j+1 i.e for 0 column it will return 1 hence to control this we are using this line.\\n// This is done just for the ease i didnt want to populate dp with -2 or anyother number. hence had to do this.   \\n        }\\n        return ans;\\n    }\\n};\\n\\n// Over all solution :\\n\\n// ij = 1 ij+1 =-1 j == n\\n// ij = -1 ij-1=-1 || j==0\\n// ij = 1 pass (i+1)(j+1)\\n// ij = -1 pass(i+1)(j-1)\\n// if(i==n-1) return j\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1666753,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1780315,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1666818,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1865575,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1667337,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1749463,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1666971,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1666635,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 2058735,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 2036684,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1666753,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1780315,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1666818,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1865575,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1667337,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1749463,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1666971,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 1666635,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 2058735,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 2036684,
                "content": [
                    {
                        "username": "Rishin1",
                        "content": "can anyone just explain me the question\\n"
                    },
                    {
                        "username": "Bikkel",
                        "content": "The condition of the problem is not clear or the approach for solving it is not clear?"
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "wtf"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Try to see a pattern of how the balls are moving in the grid !!\n\nAnd how they are moving in relation to grid's cells.\n\nYou will find the intuition for solving this question."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Even though these kind of problems are straightforward and easy to understand. Coding them can be trippy."
                    },
                    {
                        "username": "noahkester",
                        "content": "Passing 61/64 with the dynamic programming approach. Anyone have any clue why its failing just the last few ones?\\n        \\n        int[] dp = new int[m];\\n        for (int c = 0; c < m; c++) {\\n            dp[c] = c;\\n        }\\n        int nc;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                if (dp[c] == -1) {\\n                    continue;\\n                }\\n                nc = dp[c] + grid[r][c];\\n                if (nc >= 0 && nc < m) {\\n                    if (grid[r][c] == grid[r][nc]) {\\n                        dp[c] = nc;\\n                    }\\n                    else {\\n                        dp[c] = -1;\\n                    }\\n\\n                }\\n                else {\\n                    dp[c] = -1;\\n                }\\n            }\\n        }\\n        return dp;\\n\\nINPUT\\n[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nOUTPUT\\n[-1,-1,1,-1,-1,-1,-1,8,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1]\\nEXPECTED\\n[-1,-1,1,-1,-1,-1,-1,10,11,-1,-1,12,13,-1,-1,-1,-1,-1,17,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nSo close :("
                    },
                    {
                        "username": "tanhungp",
                        "content": "A bit late to the party. When you update your current collumn, you have to use the current column position. cur_col += grid[row][cur_col]. I got the same wrong answer as you and that\\'s how I solved it."
                    },
                    {
                        "username": "sbusenba",
                        "content": " getting the exact same failure from my solution in javascript, with identical output, so we must have the same thing wrong:\\n\\nvar findBall = function(grid) {\\n    noOfColumns = grid[0].length;\\n    height = grid.length\\n    let endLocations = []\\n    for (let i =0;i<noOfColumns;i++){\\n        let ballLocation = i;\\n        let ballStuck = false;\\n        for (let j=0;j<height;j++){\\n            if (ballStuck === false){ \\n                switch (grid[j][i]){\\n                    case 1:\\n                        if (ballLocation+1>=noOfColumns){\\n                            //off right side\\n                            ballStuck = true;\\n                        } else if (grid[j][ballLocation+1]==-1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation+=1;\\n                        }\\n                    break;\\n                    case -1:\\n                        if (ballLocation-1<0){\\n                            //off left side\\n                            ballStuck = true;\\n                        }else if (grid[j][ballLocation-1]==1){\\n                            //stuck in V\\n                            ballStuck = true;\\n                        } else {\\n                            ballLocation-=1;\\n                        }\\n                    break;\\n                    default:\\n                    break;\\n                }\\n            }\\n        }\\n        if (ballStuck){\\n            endLocations.push(-1)\\n        } else{\\n            endLocations.push(ballLocation)\\n        }\\n    }\\n    return endLocations;\\n};"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Hint \nWhat if there were only the top row? Which balls will get stuck? Which balls will move and to which cell?\nDetermine this information and use it for the next row. \n\nHere's the [solution](https://leetcode.com/problems/where-will-the-ball-fall/solutions/3023710/fast-iterative-o-m-x-n-solution-in-c-easy-to-understand/) if you need more help."
                    },
                    {
                        "username": "souravraj6051",
                        "content": "I think leetcode official buddy explained very nicely\\n\\n\\nhttps://leetcode.com/problems/where-will-the-ball-fall/solutions/2634524/where-will-the-ball-fall/"
                    },
                    {
                        "username": "katox96",
                        "content": "Hey What\\'s up. "
                    },
                    {
                        "username": "neozyan",
                        "content": "just trying to think about the question."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "I can\\'t see any ways for balls to fall into the same box. This makes the dynamic programming approach lose its benefits because we need to perform new computations for every ball, and we cannot effectively reuse previous computations"
                    },
                    {
                        "username": "stellarhuman09",
                        "content": "Could multiple balls be in the same cell at the same time?"
                    }
                ]
            },
            {
                "id": 2024900,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\n\nIt's pretty easy when you crack all `5` possible scenarios.\n\n1. `\\ /` or `\\ |` or`| /` should return `-1`.\n2. `\\ \\` and `/ /` will make you progress.\n3. return the column number when `row == grid.size() `"
                    },
                    {
                        "username": "Aaronstone",
                        "content": "[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nthis was 49t test case that was failing\\nY  anyone ?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Basically we simulate a ball falling down through the grid, starting at every spot from grid[0][0] to grid[0][n - 1], and add an answer to our endPoints array that tells us what column the ball dropped out of the grid from. The ball can get stuck in some situations, and in these cases we mark the answer for dropping at that column as -1. Here are some examples:\\n\\n1. The grid[row][col] that the ball is in is marked 1, which means it should move to the right. But the number at grid[row][col + 1] is either -1 OR col + 1 is outside of the bounds of grid[row]. In this case the ball gets stuck and the answer for dropping at the initial starting column is -1.\\n\\n2. The reverse from above: grid[row][col] is -1, so our ball rolls to the left. However to the left is either a 1, or col - 1 goes outside the bounds of grid[row]. The ball gets stuck in these scenarios so we mark the endpoint for dropping from our starting column as -1.\\n\\nIf the ball can travel from the starting column, and fall out the bottom (Goes through every row from 0 to m - 1, falling out of the bottom when row == m) then we can mark the answer for the starting column as the column that the ball falls out of the bottom from. For example if you drop at column 0 (col == 0), and you get to a point where row == m and col == 3, then we would assign indice 0 in our output array to 3. Output[0] = 3.\\n\\nHopefully this makes what the problem is asking you to do more clear."
                    },
                    {
                        "username": "doksh2",
                        "content": "I get 61/64 test cases but can\\'t find the mistake . I have it wrong for this input `[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n`\\n `class Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        if len(grid[0]) < 1:\\n            return grid\\n        elif len(grid[0]) == 1:\\n            return [-1]\\n\\n        res = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n\\n        print(res[-1])\\n\\n        # for the last row\\n        for c in range(len(grid[0])):\\n            direction = grid[-1][c]\\n            if c == 0:\\n                if direction == -1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c + 1\\n\\n            elif c == len(grid[0]) - 1:\\n                if direction == 1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c - 1\\n\\n            else:\\n                if direction == 1 and grid[-1][c+1] == 1:\\n                    res[-1][c] = c + 1\\n                elif direction == -1 and grid[-1][c-1] == -1:\\n                    res[-1][c] = c - 1\\n                else:\\n                    res[-1][c] = -1\\n\\n        # for the rows before the last row\\n        for r in range(len(grid)-2, -1, -1):\\n            for c in range(len(grid[0])):\\n                direction = grid[r][c]\\n                if c == 0:\\n                    if direction == -1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c+1]\\n\\n                elif c == len(grid[0]) - 1:\\n                    if direction == 1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c-1]\\n\\n                else:\\n                    if direction == 1 and grid[r][c+1] == 1:\\n                        res[r][c] = res[r+1][c+1]\\n                    elif direction == -1 and grid[r][c-1] == -1:\\n                        res[r][c] = res[r+1][c-1]\\n                    else:\\n                        res[r][c] = -1\\n                \\n        print(res)\\n        \\n        return res[0]\\n`\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "can anyone explain this couldn\\'t understand anything thanks:)"
                    },
                    {
                        "username": "MaksimMakarenko1991",
                        "content": "If ball stay at column p after i falling steps, check grid[i][p]. It points to d - next possible falling direction: 1 - to the right, -1 - to the left. The possibility is determined by values of grid[i][p] and grid[i][p+d] "
                    },
                    {
                        "username": "ndanie03",
                        "content": "Can someone help me? This must be a bug...\\n\\nMy function returns the exact answer, but then it continues looping... after the return statement?!\\n\\nHere is my log:\\n\\n ```\\nfunction called\\n{ ball: 0, row: 5, col: 1 }\\n{ ball: 1, row: 1, col: 2 }\\n{ ball: 2, row: 0, col: 2 }\\n{ ball: 3, row: 0, col: 3 }\\n{ ball: 4, row: 1, col: 3 }\\n[ 1, -1, -1, -1, -1 ]\\nfunction called...\\n\\nTypeError: Cannot read properties of undefined (reading \\'0\\')\\nLine 14: Char 38 in solution.ts (findBall)\\n```\\n\\nHere is my code in typescript:\\n\\n```\\nfunction findBall(grid: number[][]): number[] {\\n    const result = [];\\n    const cols = grid.length;\\n    const rows = grid[0].length;\\n\\n    console.log(\"function called\");\\n\\n    for (let ball = 0; ball < cols; ball++) {\\n        let col = ball, row = 0;\\n\\n        for (; row <= rows; row++) {\\n            if (row === rows) break;\\n\\n            const currDir = grid[row][col];\\n            const adjDir = grid[row][col + currDir];\\n\\n            if (currDir + adjDir === 0) break;\\n\\n            col += currDir;\\n\\n            if (col < 0 || col >= cols) break;\\n        }\\n\\n        console.log({ ball, row, col });\\n        result.push(row < rows ? -1 : col);\\n    }\\n    console.log(result);\\n\\n    return result;\\n};\\n```"
                    },
                    {
                        "username": "bhruti1",
                        "content": "hmm... this question seemed hard initially, but afterwards found that this is easy just have to find some patterns. Give it a try. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "sharmasiddharth017",
                        "content": "I think one approach to this question can be considered as finding if a path exists for each cell from first row to (lastrow+1) "
                    },
                    {
                        "username": "Soolmaz",
                        "content": "Seems to be interesting problem, but a little bit confusing in description part"
                    }
                ]
            },
            {
                "id": 2008583,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\n\nIt's pretty easy when you crack all `5` possible scenarios.\n\n1. `\\ /` or `\\ |` or`| /` should return `-1`.\n2. `\\ \\` and `/ /` will make you progress.\n3. return the column number when `row == grid.size() `"
                    },
                    {
                        "username": "Aaronstone",
                        "content": "[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nthis was 49t test case that was failing\\nY  anyone ?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Basically we simulate a ball falling down through the grid, starting at every spot from grid[0][0] to grid[0][n - 1], and add an answer to our endPoints array that tells us what column the ball dropped out of the grid from. The ball can get stuck in some situations, and in these cases we mark the answer for dropping at that column as -1. Here are some examples:\\n\\n1. The grid[row][col] that the ball is in is marked 1, which means it should move to the right. But the number at grid[row][col + 1] is either -1 OR col + 1 is outside of the bounds of grid[row]. In this case the ball gets stuck and the answer for dropping at the initial starting column is -1.\\n\\n2. The reverse from above: grid[row][col] is -1, so our ball rolls to the left. However to the left is either a 1, or col - 1 goes outside the bounds of grid[row]. The ball gets stuck in these scenarios so we mark the endpoint for dropping from our starting column as -1.\\n\\nIf the ball can travel from the starting column, and fall out the bottom (Goes through every row from 0 to m - 1, falling out of the bottom when row == m) then we can mark the answer for the starting column as the column that the ball falls out of the bottom from. For example if you drop at column 0 (col == 0), and you get to a point where row == m and col == 3, then we would assign indice 0 in our output array to 3. Output[0] = 3.\\n\\nHopefully this makes what the problem is asking you to do more clear."
                    },
                    {
                        "username": "doksh2",
                        "content": "I get 61/64 test cases but can\\'t find the mistake . I have it wrong for this input `[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n`\\n `class Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        if len(grid[0]) < 1:\\n            return grid\\n        elif len(grid[0]) == 1:\\n            return [-1]\\n\\n        res = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n\\n        print(res[-1])\\n\\n        # for the last row\\n        for c in range(len(grid[0])):\\n            direction = grid[-1][c]\\n            if c == 0:\\n                if direction == -1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c + 1\\n\\n            elif c == len(grid[0]) - 1:\\n                if direction == 1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c - 1\\n\\n            else:\\n                if direction == 1 and grid[-1][c+1] == 1:\\n                    res[-1][c] = c + 1\\n                elif direction == -1 and grid[-1][c-1] == -1:\\n                    res[-1][c] = c - 1\\n                else:\\n                    res[-1][c] = -1\\n\\n        # for the rows before the last row\\n        for r in range(len(grid)-2, -1, -1):\\n            for c in range(len(grid[0])):\\n                direction = grid[r][c]\\n                if c == 0:\\n                    if direction == -1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c+1]\\n\\n                elif c == len(grid[0]) - 1:\\n                    if direction == 1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c-1]\\n\\n                else:\\n                    if direction == 1 and grid[r][c+1] == 1:\\n                        res[r][c] = res[r+1][c+1]\\n                    elif direction == -1 and grid[r][c-1] == -1:\\n                        res[r][c] = res[r+1][c-1]\\n                    else:\\n                        res[r][c] = -1\\n                \\n        print(res)\\n        \\n        return res[0]\\n`\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "can anyone explain this couldn\\'t understand anything thanks:)"
                    },
                    {
                        "username": "MaksimMakarenko1991",
                        "content": "If ball stay at column p after i falling steps, check grid[i][p]. It points to d - next possible falling direction: 1 - to the right, -1 - to the left. The possibility is determined by values of grid[i][p] and grid[i][p+d] "
                    },
                    {
                        "username": "ndanie03",
                        "content": "Can someone help me? This must be a bug...\\n\\nMy function returns the exact answer, but then it continues looping... after the return statement?!\\n\\nHere is my log:\\n\\n ```\\nfunction called\\n{ ball: 0, row: 5, col: 1 }\\n{ ball: 1, row: 1, col: 2 }\\n{ ball: 2, row: 0, col: 2 }\\n{ ball: 3, row: 0, col: 3 }\\n{ ball: 4, row: 1, col: 3 }\\n[ 1, -1, -1, -1, -1 ]\\nfunction called...\\n\\nTypeError: Cannot read properties of undefined (reading \\'0\\')\\nLine 14: Char 38 in solution.ts (findBall)\\n```\\n\\nHere is my code in typescript:\\n\\n```\\nfunction findBall(grid: number[][]): number[] {\\n    const result = [];\\n    const cols = grid.length;\\n    const rows = grid[0].length;\\n\\n    console.log(\"function called\");\\n\\n    for (let ball = 0; ball < cols; ball++) {\\n        let col = ball, row = 0;\\n\\n        for (; row <= rows; row++) {\\n            if (row === rows) break;\\n\\n            const currDir = grid[row][col];\\n            const adjDir = grid[row][col + currDir];\\n\\n            if (currDir + adjDir === 0) break;\\n\\n            col += currDir;\\n\\n            if (col < 0 || col >= cols) break;\\n        }\\n\\n        console.log({ ball, row, col });\\n        result.push(row < rows ? -1 : col);\\n    }\\n    console.log(result);\\n\\n    return result;\\n};\\n```"
                    },
                    {
                        "username": "bhruti1",
                        "content": "hmm... this question seemed hard initially, but afterwards found that this is easy just have to find some patterns. Give it a try. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "sharmasiddharth017",
                        "content": "I think one approach to this question can be considered as finding if a path exists for each cell from first row to (lastrow+1) "
                    },
                    {
                        "username": "Soolmaz",
                        "content": "Seems to be interesting problem, but a little bit confusing in description part"
                    }
                ]
            },
            {
                "id": 1999121,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\n\nIt's pretty easy when you crack all `5` possible scenarios.\n\n1. `\\ /` or `\\ |` or`| /` should return `-1`.\n2. `\\ \\` and `/ /` will make you progress.\n3. return the column number when `row == grid.size() `"
                    },
                    {
                        "username": "Aaronstone",
                        "content": "[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nthis was 49t test case that was failing\\nY  anyone ?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Basically we simulate a ball falling down through the grid, starting at every spot from grid[0][0] to grid[0][n - 1], and add an answer to our endPoints array that tells us what column the ball dropped out of the grid from. The ball can get stuck in some situations, and in these cases we mark the answer for dropping at that column as -1. Here are some examples:\\n\\n1. The grid[row][col] that the ball is in is marked 1, which means it should move to the right. But the number at grid[row][col + 1] is either -1 OR col + 1 is outside of the bounds of grid[row]. In this case the ball gets stuck and the answer for dropping at the initial starting column is -1.\\n\\n2. The reverse from above: grid[row][col] is -1, so our ball rolls to the left. However to the left is either a 1, or col - 1 goes outside the bounds of grid[row]. The ball gets stuck in these scenarios so we mark the endpoint for dropping from our starting column as -1.\\n\\nIf the ball can travel from the starting column, and fall out the bottom (Goes through every row from 0 to m - 1, falling out of the bottom when row == m) then we can mark the answer for the starting column as the column that the ball falls out of the bottom from. For example if you drop at column 0 (col == 0), and you get to a point where row == m and col == 3, then we would assign indice 0 in our output array to 3. Output[0] = 3.\\n\\nHopefully this makes what the problem is asking you to do more clear."
                    },
                    {
                        "username": "doksh2",
                        "content": "I get 61/64 test cases but can\\'t find the mistake . I have it wrong for this input `[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n`\\n `class Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        if len(grid[0]) < 1:\\n            return grid\\n        elif len(grid[0]) == 1:\\n            return [-1]\\n\\n        res = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n\\n        print(res[-1])\\n\\n        # for the last row\\n        for c in range(len(grid[0])):\\n            direction = grid[-1][c]\\n            if c == 0:\\n                if direction == -1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c + 1\\n\\n            elif c == len(grid[0]) - 1:\\n                if direction == 1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c - 1\\n\\n            else:\\n                if direction == 1 and grid[-1][c+1] == 1:\\n                    res[-1][c] = c + 1\\n                elif direction == -1 and grid[-1][c-1] == -1:\\n                    res[-1][c] = c - 1\\n                else:\\n                    res[-1][c] = -1\\n\\n        # for the rows before the last row\\n        for r in range(len(grid)-2, -1, -1):\\n            for c in range(len(grid[0])):\\n                direction = grid[r][c]\\n                if c == 0:\\n                    if direction == -1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c+1]\\n\\n                elif c == len(grid[0]) - 1:\\n                    if direction == 1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c-1]\\n\\n                else:\\n                    if direction == 1 and grid[r][c+1] == 1:\\n                        res[r][c] = res[r+1][c+1]\\n                    elif direction == -1 and grid[r][c-1] == -1:\\n                        res[r][c] = res[r+1][c-1]\\n                    else:\\n                        res[r][c] = -1\\n                \\n        print(res)\\n        \\n        return res[0]\\n`\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "can anyone explain this couldn\\'t understand anything thanks:)"
                    },
                    {
                        "username": "MaksimMakarenko1991",
                        "content": "If ball stay at column p after i falling steps, check grid[i][p]. It points to d - next possible falling direction: 1 - to the right, -1 - to the left. The possibility is determined by values of grid[i][p] and grid[i][p+d] "
                    },
                    {
                        "username": "ndanie03",
                        "content": "Can someone help me? This must be a bug...\\n\\nMy function returns the exact answer, but then it continues looping... after the return statement?!\\n\\nHere is my log:\\n\\n ```\\nfunction called\\n{ ball: 0, row: 5, col: 1 }\\n{ ball: 1, row: 1, col: 2 }\\n{ ball: 2, row: 0, col: 2 }\\n{ ball: 3, row: 0, col: 3 }\\n{ ball: 4, row: 1, col: 3 }\\n[ 1, -1, -1, -1, -1 ]\\nfunction called...\\n\\nTypeError: Cannot read properties of undefined (reading \\'0\\')\\nLine 14: Char 38 in solution.ts (findBall)\\n```\\n\\nHere is my code in typescript:\\n\\n```\\nfunction findBall(grid: number[][]): number[] {\\n    const result = [];\\n    const cols = grid.length;\\n    const rows = grid[0].length;\\n\\n    console.log(\"function called\");\\n\\n    for (let ball = 0; ball < cols; ball++) {\\n        let col = ball, row = 0;\\n\\n        for (; row <= rows; row++) {\\n            if (row === rows) break;\\n\\n            const currDir = grid[row][col];\\n            const adjDir = grid[row][col + currDir];\\n\\n            if (currDir + adjDir === 0) break;\\n\\n            col += currDir;\\n\\n            if (col < 0 || col >= cols) break;\\n        }\\n\\n        console.log({ ball, row, col });\\n        result.push(row < rows ? -1 : col);\\n    }\\n    console.log(result);\\n\\n    return result;\\n};\\n```"
                    },
                    {
                        "username": "bhruti1",
                        "content": "hmm... this question seemed hard initially, but afterwards found that this is easy just have to find some patterns. Give it a try. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "sharmasiddharth017",
                        "content": "I think one approach to this question can be considered as finding if a path exists for each cell from first row to (lastrow+1) "
                    },
                    {
                        "username": "Soolmaz",
                        "content": "Seems to be interesting problem, but a little bit confusing in description part"
                    }
                ]
            },
            {
                "id": 1962714,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\n\nIt's pretty easy when you crack all `5` possible scenarios.\n\n1. `\\ /` or `\\ |` or`| /` should return `-1`.\n2. `\\ \\` and `/ /` will make you progress.\n3. return the column number when `row == grid.size() `"
                    },
                    {
                        "username": "Aaronstone",
                        "content": "[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nthis was 49t test case that was failing\\nY  anyone ?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Basically we simulate a ball falling down through the grid, starting at every spot from grid[0][0] to grid[0][n - 1], and add an answer to our endPoints array that tells us what column the ball dropped out of the grid from. The ball can get stuck in some situations, and in these cases we mark the answer for dropping at that column as -1. Here are some examples:\\n\\n1. The grid[row][col] that the ball is in is marked 1, which means it should move to the right. But the number at grid[row][col + 1] is either -1 OR col + 1 is outside of the bounds of grid[row]. In this case the ball gets stuck and the answer for dropping at the initial starting column is -1.\\n\\n2. The reverse from above: grid[row][col] is -1, so our ball rolls to the left. However to the left is either a 1, or col - 1 goes outside the bounds of grid[row]. The ball gets stuck in these scenarios so we mark the endpoint for dropping from our starting column as -1.\\n\\nIf the ball can travel from the starting column, and fall out the bottom (Goes through every row from 0 to m - 1, falling out of the bottom when row == m) then we can mark the answer for the starting column as the column that the ball falls out of the bottom from. For example if you drop at column 0 (col == 0), and you get to a point where row == m and col == 3, then we would assign indice 0 in our output array to 3. Output[0] = 3.\\n\\nHopefully this makes what the problem is asking you to do more clear."
                    },
                    {
                        "username": "doksh2",
                        "content": "I get 61/64 test cases but can\\'t find the mistake . I have it wrong for this input `[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n`\\n `class Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        if len(grid[0]) < 1:\\n            return grid\\n        elif len(grid[0]) == 1:\\n            return [-1]\\n\\n        res = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n\\n        print(res[-1])\\n\\n        # for the last row\\n        for c in range(len(grid[0])):\\n            direction = grid[-1][c]\\n            if c == 0:\\n                if direction == -1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c + 1\\n\\n            elif c == len(grid[0]) - 1:\\n                if direction == 1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c - 1\\n\\n            else:\\n                if direction == 1 and grid[-1][c+1] == 1:\\n                    res[-1][c] = c + 1\\n                elif direction == -1 and grid[-1][c-1] == -1:\\n                    res[-1][c] = c - 1\\n                else:\\n                    res[-1][c] = -1\\n\\n        # for the rows before the last row\\n        for r in range(len(grid)-2, -1, -1):\\n            for c in range(len(grid[0])):\\n                direction = grid[r][c]\\n                if c == 0:\\n                    if direction == -1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c+1]\\n\\n                elif c == len(grid[0]) - 1:\\n                    if direction == 1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c-1]\\n\\n                else:\\n                    if direction == 1 and grid[r][c+1] == 1:\\n                        res[r][c] = res[r+1][c+1]\\n                    elif direction == -1 and grid[r][c-1] == -1:\\n                        res[r][c] = res[r+1][c-1]\\n                    else:\\n                        res[r][c] = -1\\n                \\n        print(res)\\n        \\n        return res[0]\\n`\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "can anyone explain this couldn\\'t understand anything thanks:)"
                    },
                    {
                        "username": "MaksimMakarenko1991",
                        "content": "If ball stay at column p after i falling steps, check grid[i][p]. It points to d - next possible falling direction: 1 - to the right, -1 - to the left. The possibility is determined by values of grid[i][p] and grid[i][p+d] "
                    },
                    {
                        "username": "ndanie03",
                        "content": "Can someone help me? This must be a bug...\\n\\nMy function returns the exact answer, but then it continues looping... after the return statement?!\\n\\nHere is my log:\\n\\n ```\\nfunction called\\n{ ball: 0, row: 5, col: 1 }\\n{ ball: 1, row: 1, col: 2 }\\n{ ball: 2, row: 0, col: 2 }\\n{ ball: 3, row: 0, col: 3 }\\n{ ball: 4, row: 1, col: 3 }\\n[ 1, -1, -1, -1, -1 ]\\nfunction called...\\n\\nTypeError: Cannot read properties of undefined (reading \\'0\\')\\nLine 14: Char 38 in solution.ts (findBall)\\n```\\n\\nHere is my code in typescript:\\n\\n```\\nfunction findBall(grid: number[][]): number[] {\\n    const result = [];\\n    const cols = grid.length;\\n    const rows = grid[0].length;\\n\\n    console.log(\"function called\");\\n\\n    for (let ball = 0; ball < cols; ball++) {\\n        let col = ball, row = 0;\\n\\n        for (; row <= rows; row++) {\\n            if (row === rows) break;\\n\\n            const currDir = grid[row][col];\\n            const adjDir = grid[row][col + currDir];\\n\\n            if (currDir + adjDir === 0) break;\\n\\n            col += currDir;\\n\\n            if (col < 0 || col >= cols) break;\\n        }\\n\\n        console.log({ ball, row, col });\\n        result.push(row < rows ? -1 : col);\\n    }\\n    console.log(result);\\n\\n    return result;\\n};\\n```"
                    },
                    {
                        "username": "bhruti1",
                        "content": "hmm... this question seemed hard initially, but afterwards found that this is easy just have to find some patterns. Give it a try. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "sharmasiddharth017",
                        "content": "I think one approach to this question can be considered as finding if a path exists for each cell from first row to (lastrow+1) "
                    },
                    {
                        "username": "Soolmaz",
                        "content": "Seems to be interesting problem, but a little bit confusing in description part"
                    }
                ]
            },
            {
                "id": 1874471,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\n\nIt's pretty easy when you crack all `5` possible scenarios.\n\n1. `\\ /` or `\\ |` or`| /` should return `-1`.\n2. `\\ \\` and `/ /` will make you progress.\n3. return the column number when `row == grid.size() `"
                    },
                    {
                        "username": "Aaronstone",
                        "content": "[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nthis was 49t test case that was failing\\nY  anyone ?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Basically we simulate a ball falling down through the grid, starting at every spot from grid[0][0] to grid[0][n - 1], and add an answer to our endPoints array that tells us what column the ball dropped out of the grid from. The ball can get stuck in some situations, and in these cases we mark the answer for dropping at that column as -1. Here are some examples:\\n\\n1. The grid[row][col] that the ball is in is marked 1, which means it should move to the right. But the number at grid[row][col + 1] is either -1 OR col + 1 is outside of the bounds of grid[row]. In this case the ball gets stuck and the answer for dropping at the initial starting column is -1.\\n\\n2. The reverse from above: grid[row][col] is -1, so our ball rolls to the left. However to the left is either a 1, or col - 1 goes outside the bounds of grid[row]. The ball gets stuck in these scenarios so we mark the endpoint for dropping from our starting column as -1.\\n\\nIf the ball can travel from the starting column, and fall out the bottom (Goes through every row from 0 to m - 1, falling out of the bottom when row == m) then we can mark the answer for the starting column as the column that the ball falls out of the bottom from. For example if you drop at column 0 (col == 0), and you get to a point where row == m and col == 3, then we would assign indice 0 in our output array to 3. Output[0] = 3.\\n\\nHopefully this makes what the problem is asking you to do more clear."
                    },
                    {
                        "username": "doksh2",
                        "content": "I get 61/64 test cases but can\\'t find the mistake . I have it wrong for this input `[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n`\\n `class Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        if len(grid[0]) < 1:\\n            return grid\\n        elif len(grid[0]) == 1:\\n            return [-1]\\n\\n        res = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n\\n        print(res[-1])\\n\\n        # for the last row\\n        for c in range(len(grid[0])):\\n            direction = grid[-1][c]\\n            if c == 0:\\n                if direction == -1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c + 1\\n\\n            elif c == len(grid[0]) - 1:\\n                if direction == 1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c - 1\\n\\n            else:\\n                if direction == 1 and grid[-1][c+1] == 1:\\n                    res[-1][c] = c + 1\\n                elif direction == -1 and grid[-1][c-1] == -1:\\n                    res[-1][c] = c - 1\\n                else:\\n                    res[-1][c] = -1\\n\\n        # for the rows before the last row\\n        for r in range(len(grid)-2, -1, -1):\\n            for c in range(len(grid[0])):\\n                direction = grid[r][c]\\n                if c == 0:\\n                    if direction == -1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c+1]\\n\\n                elif c == len(grid[0]) - 1:\\n                    if direction == 1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c-1]\\n\\n                else:\\n                    if direction == 1 and grid[r][c+1] == 1:\\n                        res[r][c] = res[r+1][c+1]\\n                    elif direction == -1 and grid[r][c-1] == -1:\\n                        res[r][c] = res[r+1][c-1]\\n                    else:\\n                        res[r][c] = -1\\n                \\n        print(res)\\n        \\n        return res[0]\\n`\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "can anyone explain this couldn\\'t understand anything thanks:)"
                    },
                    {
                        "username": "MaksimMakarenko1991",
                        "content": "If ball stay at column p after i falling steps, check grid[i][p]. It points to d - next possible falling direction: 1 - to the right, -1 - to the left. The possibility is determined by values of grid[i][p] and grid[i][p+d] "
                    },
                    {
                        "username": "ndanie03",
                        "content": "Can someone help me? This must be a bug...\\n\\nMy function returns the exact answer, but then it continues looping... after the return statement?!\\n\\nHere is my log:\\n\\n ```\\nfunction called\\n{ ball: 0, row: 5, col: 1 }\\n{ ball: 1, row: 1, col: 2 }\\n{ ball: 2, row: 0, col: 2 }\\n{ ball: 3, row: 0, col: 3 }\\n{ ball: 4, row: 1, col: 3 }\\n[ 1, -1, -1, -1, -1 ]\\nfunction called...\\n\\nTypeError: Cannot read properties of undefined (reading \\'0\\')\\nLine 14: Char 38 in solution.ts (findBall)\\n```\\n\\nHere is my code in typescript:\\n\\n```\\nfunction findBall(grid: number[][]): number[] {\\n    const result = [];\\n    const cols = grid.length;\\n    const rows = grid[0].length;\\n\\n    console.log(\"function called\");\\n\\n    for (let ball = 0; ball < cols; ball++) {\\n        let col = ball, row = 0;\\n\\n        for (; row <= rows; row++) {\\n            if (row === rows) break;\\n\\n            const currDir = grid[row][col];\\n            const adjDir = grid[row][col + currDir];\\n\\n            if (currDir + adjDir === 0) break;\\n\\n            col += currDir;\\n\\n            if (col < 0 || col >= cols) break;\\n        }\\n\\n        console.log({ ball, row, col });\\n        result.push(row < rows ? -1 : col);\\n    }\\n    console.log(result);\\n\\n    return result;\\n};\\n```"
                    },
                    {
                        "username": "bhruti1",
                        "content": "hmm... this question seemed hard initially, but afterwards found that this is easy just have to find some patterns. Give it a try. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "sharmasiddharth017",
                        "content": "I think one approach to this question can be considered as finding if a path exists for each cell from first row to (lastrow+1) "
                    },
                    {
                        "username": "Soolmaz",
                        "content": "Seems to be interesting problem, but a little bit confusing in description part"
                    }
                ]
            },
            {
                "id": 1844541,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\n\nIt's pretty easy when you crack all `5` possible scenarios.\n\n1. `\\ /` or `\\ |` or`| /` should return `-1`.\n2. `\\ \\` and `/ /` will make you progress.\n3. return the column number when `row == grid.size() `"
                    },
                    {
                        "username": "Aaronstone",
                        "content": "[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nthis was 49t test case that was failing\\nY  anyone ?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Basically we simulate a ball falling down through the grid, starting at every spot from grid[0][0] to grid[0][n - 1], and add an answer to our endPoints array that tells us what column the ball dropped out of the grid from. The ball can get stuck in some situations, and in these cases we mark the answer for dropping at that column as -1. Here are some examples:\\n\\n1. The grid[row][col] that the ball is in is marked 1, which means it should move to the right. But the number at grid[row][col + 1] is either -1 OR col + 1 is outside of the bounds of grid[row]. In this case the ball gets stuck and the answer for dropping at the initial starting column is -1.\\n\\n2. The reverse from above: grid[row][col] is -1, so our ball rolls to the left. However to the left is either a 1, or col - 1 goes outside the bounds of grid[row]. The ball gets stuck in these scenarios so we mark the endpoint for dropping from our starting column as -1.\\n\\nIf the ball can travel from the starting column, and fall out the bottom (Goes through every row from 0 to m - 1, falling out of the bottom when row == m) then we can mark the answer for the starting column as the column that the ball falls out of the bottom from. For example if you drop at column 0 (col == 0), and you get to a point where row == m and col == 3, then we would assign indice 0 in our output array to 3. Output[0] = 3.\\n\\nHopefully this makes what the problem is asking you to do more clear."
                    },
                    {
                        "username": "doksh2",
                        "content": "I get 61/64 test cases but can\\'t find the mistake . I have it wrong for this input `[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n`\\n `class Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        if len(grid[0]) < 1:\\n            return grid\\n        elif len(grid[0]) == 1:\\n            return [-1]\\n\\n        res = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n\\n        print(res[-1])\\n\\n        # for the last row\\n        for c in range(len(grid[0])):\\n            direction = grid[-1][c]\\n            if c == 0:\\n                if direction == -1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c + 1\\n\\n            elif c == len(grid[0]) - 1:\\n                if direction == 1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c - 1\\n\\n            else:\\n                if direction == 1 and grid[-1][c+1] == 1:\\n                    res[-1][c] = c + 1\\n                elif direction == -1 and grid[-1][c-1] == -1:\\n                    res[-1][c] = c - 1\\n                else:\\n                    res[-1][c] = -1\\n\\n        # for the rows before the last row\\n        for r in range(len(grid)-2, -1, -1):\\n            for c in range(len(grid[0])):\\n                direction = grid[r][c]\\n                if c == 0:\\n                    if direction == -1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c+1]\\n\\n                elif c == len(grid[0]) - 1:\\n                    if direction == 1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c-1]\\n\\n                else:\\n                    if direction == 1 and grid[r][c+1] == 1:\\n                        res[r][c] = res[r+1][c+1]\\n                    elif direction == -1 and grid[r][c-1] == -1:\\n                        res[r][c] = res[r+1][c-1]\\n                    else:\\n                        res[r][c] = -1\\n                \\n        print(res)\\n        \\n        return res[0]\\n`\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "can anyone explain this couldn\\'t understand anything thanks:)"
                    },
                    {
                        "username": "MaksimMakarenko1991",
                        "content": "If ball stay at column p after i falling steps, check grid[i][p]. It points to d - next possible falling direction: 1 - to the right, -1 - to the left. The possibility is determined by values of grid[i][p] and grid[i][p+d] "
                    },
                    {
                        "username": "ndanie03",
                        "content": "Can someone help me? This must be a bug...\\n\\nMy function returns the exact answer, but then it continues looping... after the return statement?!\\n\\nHere is my log:\\n\\n ```\\nfunction called\\n{ ball: 0, row: 5, col: 1 }\\n{ ball: 1, row: 1, col: 2 }\\n{ ball: 2, row: 0, col: 2 }\\n{ ball: 3, row: 0, col: 3 }\\n{ ball: 4, row: 1, col: 3 }\\n[ 1, -1, -1, -1, -1 ]\\nfunction called...\\n\\nTypeError: Cannot read properties of undefined (reading \\'0\\')\\nLine 14: Char 38 in solution.ts (findBall)\\n```\\n\\nHere is my code in typescript:\\n\\n```\\nfunction findBall(grid: number[][]): number[] {\\n    const result = [];\\n    const cols = grid.length;\\n    const rows = grid[0].length;\\n\\n    console.log(\"function called\");\\n\\n    for (let ball = 0; ball < cols; ball++) {\\n        let col = ball, row = 0;\\n\\n        for (; row <= rows; row++) {\\n            if (row === rows) break;\\n\\n            const currDir = grid[row][col];\\n            const adjDir = grid[row][col + currDir];\\n\\n            if (currDir + adjDir === 0) break;\\n\\n            col += currDir;\\n\\n            if (col < 0 || col >= cols) break;\\n        }\\n\\n        console.log({ ball, row, col });\\n        result.push(row < rows ? -1 : col);\\n    }\\n    console.log(result);\\n\\n    return result;\\n};\\n```"
                    },
                    {
                        "username": "bhruti1",
                        "content": "hmm... this question seemed hard initially, but afterwards found that this is easy just have to find some patterns. Give it a try. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "sharmasiddharth017",
                        "content": "I think one approach to this question can be considered as finding if a path exists for each cell from first row to (lastrow+1) "
                    },
                    {
                        "username": "Soolmaz",
                        "content": "Seems to be interesting problem, but a little bit confusing in description part"
                    }
                ]
            },
            {
                "id": 1833608,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\n\nIt's pretty easy when you crack all `5` possible scenarios.\n\n1. `\\ /` or `\\ |` or`| /` should return `-1`.\n2. `\\ \\` and `/ /` will make you progress.\n3. return the column number when `row == grid.size() `"
                    },
                    {
                        "username": "Aaronstone",
                        "content": "[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nthis was 49t test case that was failing\\nY  anyone ?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Basically we simulate a ball falling down through the grid, starting at every spot from grid[0][0] to grid[0][n - 1], and add an answer to our endPoints array that tells us what column the ball dropped out of the grid from. The ball can get stuck in some situations, and in these cases we mark the answer for dropping at that column as -1. Here are some examples:\\n\\n1. The grid[row][col] that the ball is in is marked 1, which means it should move to the right. But the number at grid[row][col + 1] is either -1 OR col + 1 is outside of the bounds of grid[row]. In this case the ball gets stuck and the answer for dropping at the initial starting column is -1.\\n\\n2. The reverse from above: grid[row][col] is -1, so our ball rolls to the left. However to the left is either a 1, or col - 1 goes outside the bounds of grid[row]. The ball gets stuck in these scenarios so we mark the endpoint for dropping from our starting column as -1.\\n\\nIf the ball can travel from the starting column, and fall out the bottom (Goes through every row from 0 to m - 1, falling out of the bottom when row == m) then we can mark the answer for the starting column as the column that the ball falls out of the bottom from. For example if you drop at column 0 (col == 0), and you get to a point where row == m and col == 3, then we would assign indice 0 in our output array to 3. Output[0] = 3.\\n\\nHopefully this makes what the problem is asking you to do more clear."
                    },
                    {
                        "username": "doksh2",
                        "content": "I get 61/64 test cases but can\\'t find the mistake . I have it wrong for this input `[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n`\\n `class Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        if len(grid[0]) < 1:\\n            return grid\\n        elif len(grid[0]) == 1:\\n            return [-1]\\n\\n        res = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n\\n        print(res[-1])\\n\\n        # for the last row\\n        for c in range(len(grid[0])):\\n            direction = grid[-1][c]\\n            if c == 0:\\n                if direction == -1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c + 1\\n\\n            elif c == len(grid[0]) - 1:\\n                if direction == 1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c - 1\\n\\n            else:\\n                if direction == 1 and grid[-1][c+1] == 1:\\n                    res[-1][c] = c + 1\\n                elif direction == -1 and grid[-1][c-1] == -1:\\n                    res[-1][c] = c - 1\\n                else:\\n                    res[-1][c] = -1\\n\\n        # for the rows before the last row\\n        for r in range(len(grid)-2, -1, -1):\\n            for c in range(len(grid[0])):\\n                direction = grid[r][c]\\n                if c == 0:\\n                    if direction == -1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c+1]\\n\\n                elif c == len(grid[0]) - 1:\\n                    if direction == 1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c-1]\\n\\n                else:\\n                    if direction == 1 and grid[r][c+1] == 1:\\n                        res[r][c] = res[r+1][c+1]\\n                    elif direction == -1 and grid[r][c-1] == -1:\\n                        res[r][c] = res[r+1][c-1]\\n                    else:\\n                        res[r][c] = -1\\n                \\n        print(res)\\n        \\n        return res[0]\\n`\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "can anyone explain this couldn\\'t understand anything thanks:)"
                    },
                    {
                        "username": "MaksimMakarenko1991",
                        "content": "If ball stay at column p after i falling steps, check grid[i][p]. It points to d - next possible falling direction: 1 - to the right, -1 - to the left. The possibility is determined by values of grid[i][p] and grid[i][p+d] "
                    },
                    {
                        "username": "ndanie03",
                        "content": "Can someone help me? This must be a bug...\\n\\nMy function returns the exact answer, but then it continues looping... after the return statement?!\\n\\nHere is my log:\\n\\n ```\\nfunction called\\n{ ball: 0, row: 5, col: 1 }\\n{ ball: 1, row: 1, col: 2 }\\n{ ball: 2, row: 0, col: 2 }\\n{ ball: 3, row: 0, col: 3 }\\n{ ball: 4, row: 1, col: 3 }\\n[ 1, -1, -1, -1, -1 ]\\nfunction called...\\n\\nTypeError: Cannot read properties of undefined (reading \\'0\\')\\nLine 14: Char 38 in solution.ts (findBall)\\n```\\n\\nHere is my code in typescript:\\n\\n```\\nfunction findBall(grid: number[][]): number[] {\\n    const result = [];\\n    const cols = grid.length;\\n    const rows = grid[0].length;\\n\\n    console.log(\"function called\");\\n\\n    for (let ball = 0; ball < cols; ball++) {\\n        let col = ball, row = 0;\\n\\n        for (; row <= rows; row++) {\\n            if (row === rows) break;\\n\\n            const currDir = grid[row][col];\\n            const adjDir = grid[row][col + currDir];\\n\\n            if (currDir + adjDir === 0) break;\\n\\n            col += currDir;\\n\\n            if (col < 0 || col >= cols) break;\\n        }\\n\\n        console.log({ ball, row, col });\\n        result.push(row < rows ? -1 : col);\\n    }\\n    console.log(result);\\n\\n    return result;\\n};\\n```"
                    },
                    {
                        "username": "bhruti1",
                        "content": "hmm... this question seemed hard initially, but afterwards found that this is easy just have to find some patterns. Give it a try. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "sharmasiddharth017",
                        "content": "I think one approach to this question can be considered as finding if a path exists for each cell from first row to (lastrow+1) "
                    },
                    {
                        "username": "Soolmaz",
                        "content": "Seems to be interesting problem, but a little bit confusing in description part"
                    }
                ]
            },
            {
                "id": 1774466,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\n\nIt's pretty easy when you crack all `5` possible scenarios.\n\n1. `\\ /` or `\\ |` or`| /` should return `-1`.\n2. `\\ \\` and `/ /` will make you progress.\n3. return the column number when `row == grid.size() `"
                    },
                    {
                        "username": "Aaronstone",
                        "content": "[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nthis was 49t test case that was failing\\nY  anyone ?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Basically we simulate a ball falling down through the grid, starting at every spot from grid[0][0] to grid[0][n - 1], and add an answer to our endPoints array that tells us what column the ball dropped out of the grid from. The ball can get stuck in some situations, and in these cases we mark the answer for dropping at that column as -1. Here are some examples:\\n\\n1. The grid[row][col] that the ball is in is marked 1, which means it should move to the right. But the number at grid[row][col + 1] is either -1 OR col + 1 is outside of the bounds of grid[row]. In this case the ball gets stuck and the answer for dropping at the initial starting column is -1.\\n\\n2. The reverse from above: grid[row][col] is -1, so our ball rolls to the left. However to the left is either a 1, or col - 1 goes outside the bounds of grid[row]. The ball gets stuck in these scenarios so we mark the endpoint for dropping from our starting column as -1.\\n\\nIf the ball can travel from the starting column, and fall out the bottom (Goes through every row from 0 to m - 1, falling out of the bottom when row == m) then we can mark the answer for the starting column as the column that the ball falls out of the bottom from. For example if you drop at column 0 (col == 0), and you get to a point where row == m and col == 3, then we would assign indice 0 in our output array to 3. Output[0] = 3.\\n\\nHopefully this makes what the problem is asking you to do more clear."
                    },
                    {
                        "username": "doksh2",
                        "content": "I get 61/64 test cases but can\\'t find the mistake . I have it wrong for this input `[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n`\\n `class Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        if len(grid[0]) < 1:\\n            return grid\\n        elif len(grid[0]) == 1:\\n            return [-1]\\n\\n        res = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n\\n        print(res[-1])\\n\\n        # for the last row\\n        for c in range(len(grid[0])):\\n            direction = grid[-1][c]\\n            if c == 0:\\n                if direction == -1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c + 1\\n\\n            elif c == len(grid[0]) - 1:\\n                if direction == 1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c - 1\\n\\n            else:\\n                if direction == 1 and grid[-1][c+1] == 1:\\n                    res[-1][c] = c + 1\\n                elif direction == -1 and grid[-1][c-1] == -1:\\n                    res[-1][c] = c - 1\\n                else:\\n                    res[-1][c] = -1\\n\\n        # for the rows before the last row\\n        for r in range(len(grid)-2, -1, -1):\\n            for c in range(len(grid[0])):\\n                direction = grid[r][c]\\n                if c == 0:\\n                    if direction == -1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c+1]\\n\\n                elif c == len(grid[0]) - 1:\\n                    if direction == 1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c-1]\\n\\n                else:\\n                    if direction == 1 and grid[r][c+1] == 1:\\n                        res[r][c] = res[r+1][c+1]\\n                    elif direction == -1 and grid[r][c-1] == -1:\\n                        res[r][c] = res[r+1][c-1]\\n                    else:\\n                        res[r][c] = -1\\n                \\n        print(res)\\n        \\n        return res[0]\\n`\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "can anyone explain this couldn\\'t understand anything thanks:)"
                    },
                    {
                        "username": "MaksimMakarenko1991",
                        "content": "If ball stay at column p after i falling steps, check grid[i][p]. It points to d - next possible falling direction: 1 - to the right, -1 - to the left. The possibility is determined by values of grid[i][p] and grid[i][p+d] "
                    },
                    {
                        "username": "ndanie03",
                        "content": "Can someone help me? This must be a bug...\\n\\nMy function returns the exact answer, but then it continues looping... after the return statement?!\\n\\nHere is my log:\\n\\n ```\\nfunction called\\n{ ball: 0, row: 5, col: 1 }\\n{ ball: 1, row: 1, col: 2 }\\n{ ball: 2, row: 0, col: 2 }\\n{ ball: 3, row: 0, col: 3 }\\n{ ball: 4, row: 1, col: 3 }\\n[ 1, -1, -1, -1, -1 ]\\nfunction called...\\n\\nTypeError: Cannot read properties of undefined (reading \\'0\\')\\nLine 14: Char 38 in solution.ts (findBall)\\n```\\n\\nHere is my code in typescript:\\n\\n```\\nfunction findBall(grid: number[][]): number[] {\\n    const result = [];\\n    const cols = grid.length;\\n    const rows = grid[0].length;\\n\\n    console.log(\"function called\");\\n\\n    for (let ball = 0; ball < cols; ball++) {\\n        let col = ball, row = 0;\\n\\n        for (; row <= rows; row++) {\\n            if (row === rows) break;\\n\\n            const currDir = grid[row][col];\\n            const adjDir = grid[row][col + currDir];\\n\\n            if (currDir + adjDir === 0) break;\\n\\n            col += currDir;\\n\\n            if (col < 0 || col >= cols) break;\\n        }\\n\\n        console.log({ ball, row, col });\\n        result.push(row < rows ? -1 : col);\\n    }\\n    console.log(result);\\n\\n    return result;\\n};\\n```"
                    },
                    {
                        "username": "bhruti1",
                        "content": "hmm... this question seemed hard initially, but afterwards found that this is easy just have to find some patterns. Give it a try. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "sharmasiddharth017",
                        "content": "I think one approach to this question can be considered as finding if a path exists for each cell from first row to (lastrow+1) "
                    },
                    {
                        "username": "Soolmaz",
                        "content": "Seems to be interesting problem, but a little bit confusing in description part"
                    }
                ]
            },
            {
                "id": 1758565,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\n\nIt's pretty easy when you crack all `5` possible scenarios.\n\n1. `\\ /` or `\\ |` or`| /` should return `-1`.\n2. `\\ \\` and `/ /` will make you progress.\n3. return the column number when `row == grid.size() `"
                    },
                    {
                        "username": "Aaronstone",
                        "content": "[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nthis was 49t test case that was failing\\nY  anyone ?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Basically we simulate a ball falling down through the grid, starting at every spot from grid[0][0] to grid[0][n - 1], and add an answer to our endPoints array that tells us what column the ball dropped out of the grid from. The ball can get stuck in some situations, and in these cases we mark the answer for dropping at that column as -1. Here are some examples:\\n\\n1. The grid[row][col] that the ball is in is marked 1, which means it should move to the right. But the number at grid[row][col + 1] is either -1 OR col + 1 is outside of the bounds of grid[row]. In this case the ball gets stuck and the answer for dropping at the initial starting column is -1.\\n\\n2. The reverse from above: grid[row][col] is -1, so our ball rolls to the left. However to the left is either a 1, or col - 1 goes outside the bounds of grid[row]. The ball gets stuck in these scenarios so we mark the endpoint for dropping from our starting column as -1.\\n\\nIf the ball can travel from the starting column, and fall out the bottom (Goes through every row from 0 to m - 1, falling out of the bottom when row == m) then we can mark the answer for the starting column as the column that the ball falls out of the bottom from. For example if you drop at column 0 (col == 0), and you get to a point where row == m and col == 3, then we would assign indice 0 in our output array to 3. Output[0] = 3.\\n\\nHopefully this makes what the problem is asking you to do more clear."
                    },
                    {
                        "username": "doksh2",
                        "content": "I get 61/64 test cases but can\\'t find the mistake . I have it wrong for this input `[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n`\\n `class Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        if len(grid[0]) < 1:\\n            return grid\\n        elif len(grid[0]) == 1:\\n            return [-1]\\n\\n        res = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n\\n        print(res[-1])\\n\\n        # for the last row\\n        for c in range(len(grid[0])):\\n            direction = grid[-1][c]\\n            if c == 0:\\n                if direction == -1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c + 1\\n\\n            elif c == len(grid[0]) - 1:\\n                if direction == 1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c - 1\\n\\n            else:\\n                if direction == 1 and grid[-1][c+1] == 1:\\n                    res[-1][c] = c + 1\\n                elif direction == -1 and grid[-1][c-1] == -1:\\n                    res[-1][c] = c - 1\\n                else:\\n                    res[-1][c] = -1\\n\\n        # for the rows before the last row\\n        for r in range(len(grid)-2, -1, -1):\\n            for c in range(len(grid[0])):\\n                direction = grid[r][c]\\n                if c == 0:\\n                    if direction == -1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c+1]\\n\\n                elif c == len(grid[0]) - 1:\\n                    if direction == 1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c-1]\\n\\n                else:\\n                    if direction == 1 and grid[r][c+1] == 1:\\n                        res[r][c] = res[r+1][c+1]\\n                    elif direction == -1 and grid[r][c-1] == -1:\\n                        res[r][c] = res[r+1][c-1]\\n                    else:\\n                        res[r][c] = -1\\n                \\n        print(res)\\n        \\n        return res[0]\\n`\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "can anyone explain this couldn\\'t understand anything thanks:)"
                    },
                    {
                        "username": "MaksimMakarenko1991",
                        "content": "If ball stay at column p after i falling steps, check grid[i][p]. It points to d - next possible falling direction: 1 - to the right, -1 - to the left. The possibility is determined by values of grid[i][p] and grid[i][p+d] "
                    },
                    {
                        "username": "ndanie03",
                        "content": "Can someone help me? This must be a bug...\\n\\nMy function returns the exact answer, but then it continues looping... after the return statement?!\\n\\nHere is my log:\\n\\n ```\\nfunction called\\n{ ball: 0, row: 5, col: 1 }\\n{ ball: 1, row: 1, col: 2 }\\n{ ball: 2, row: 0, col: 2 }\\n{ ball: 3, row: 0, col: 3 }\\n{ ball: 4, row: 1, col: 3 }\\n[ 1, -1, -1, -1, -1 ]\\nfunction called...\\n\\nTypeError: Cannot read properties of undefined (reading \\'0\\')\\nLine 14: Char 38 in solution.ts (findBall)\\n```\\n\\nHere is my code in typescript:\\n\\n```\\nfunction findBall(grid: number[][]): number[] {\\n    const result = [];\\n    const cols = grid.length;\\n    const rows = grid[0].length;\\n\\n    console.log(\"function called\");\\n\\n    for (let ball = 0; ball < cols; ball++) {\\n        let col = ball, row = 0;\\n\\n        for (; row <= rows; row++) {\\n            if (row === rows) break;\\n\\n            const currDir = grid[row][col];\\n            const adjDir = grid[row][col + currDir];\\n\\n            if (currDir + adjDir === 0) break;\\n\\n            col += currDir;\\n\\n            if (col < 0 || col >= cols) break;\\n        }\\n\\n        console.log({ ball, row, col });\\n        result.push(row < rows ? -1 : col);\\n    }\\n    console.log(result);\\n\\n    return result;\\n};\\n```"
                    },
                    {
                        "username": "bhruti1",
                        "content": "hmm... this question seemed hard initially, but afterwards found that this is easy just have to find some patterns. Give it a try. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "sharmasiddharth017",
                        "content": "I think one approach to this question can be considered as finding if a path exists for each cell from first row to (lastrow+1) "
                    },
                    {
                        "username": "Soolmaz",
                        "content": "Seems to be interesting problem, but a little bit confusing in description part"
                    }
                ]
            },
            {
                "id": 1746972,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\n\nIt's pretty easy when you crack all `5` possible scenarios.\n\n1. `\\ /` or `\\ |` or`| /` should return `-1`.\n2. `\\ \\` and `/ /` will make you progress.\n3. return the column number when `row == grid.size() `"
                    },
                    {
                        "username": "Aaronstone",
                        "content": "[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n\\nthis was 49t test case that was failing\\nY  anyone ?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Basically we simulate a ball falling down through the grid, starting at every spot from grid[0][0] to grid[0][n - 1], and add an answer to our endPoints array that tells us what column the ball dropped out of the grid from. The ball can get stuck in some situations, and in these cases we mark the answer for dropping at that column as -1. Here are some examples:\\n\\n1. The grid[row][col] that the ball is in is marked 1, which means it should move to the right. But the number at grid[row][col + 1] is either -1 OR col + 1 is outside of the bounds of grid[row]. In this case the ball gets stuck and the answer for dropping at the initial starting column is -1.\\n\\n2. The reverse from above: grid[row][col] is -1, so our ball rolls to the left. However to the left is either a 1, or col - 1 goes outside the bounds of grid[row]. The ball gets stuck in these scenarios so we mark the endpoint for dropping from our starting column as -1.\\n\\nIf the ball can travel from the starting column, and fall out the bottom (Goes through every row from 0 to m - 1, falling out of the bottom when row == m) then we can mark the answer for the starting column as the column that the ball falls out of the bottom from. For example if you drop at column 0 (col == 0), and you get to a point where row == m and col == 3, then we would assign indice 0 in our output array to 3. Output[0] = 3.\\n\\nHopefully this makes what the problem is asking you to do more clear."
                    },
                    {
                        "username": "doksh2",
                        "content": "I get 61/64 test cases but can\\'t find the mistake . I have it wrong for this input `[[1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1],[-1,1,1,1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,1,1],[1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1]]\\n`\\n `class Solution:\\n    def findBall(self, grid: List[List[int]]) -> List[int]:\\n        if len(grid[0]) < 1:\\n            return grid\\n        elif len(grid[0]) == 1:\\n            return [-1]\\n\\n        res = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n\\n        print(res[-1])\\n\\n        # for the last row\\n        for c in range(len(grid[0])):\\n            direction = grid[-1][c]\\n            if c == 0:\\n                if direction == -1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c + 1\\n\\n            elif c == len(grid[0]) - 1:\\n                if direction == 1:\\n                    res[-1][c] = -1\\n                else:\\n                    res[-1][c] = c - 1\\n\\n            else:\\n                if direction == 1 and grid[-1][c+1] == 1:\\n                    res[-1][c] = c + 1\\n                elif direction == -1 and grid[-1][c-1] == -1:\\n                    res[-1][c] = c - 1\\n                else:\\n                    res[-1][c] = -1\\n\\n        # for the rows before the last row\\n        for r in range(len(grid)-2, -1, -1):\\n            for c in range(len(grid[0])):\\n                direction = grid[r][c]\\n                if c == 0:\\n                    if direction == -1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c+1]\\n\\n                elif c == len(grid[0]) - 1:\\n                    if direction == 1:\\n                        res[r][c] = -1\\n                    else:\\n                        res[r][c] = res[r+1][c-1]\\n\\n                else:\\n                    if direction == 1 and grid[r][c+1] == 1:\\n                        res[r][c] = res[r+1][c+1]\\n                    elif direction == -1 and grid[r][c-1] == -1:\\n                        res[r][c] = res[r+1][c-1]\\n                    else:\\n                        res[r][c] = -1\\n                \\n        print(res)\\n        \\n        return res[0]\\n`\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "can anyone explain this couldn\\'t understand anything thanks:)"
                    },
                    {
                        "username": "MaksimMakarenko1991",
                        "content": "If ball stay at column p after i falling steps, check grid[i][p]. It points to d - next possible falling direction: 1 - to the right, -1 - to the left. The possibility is determined by values of grid[i][p] and grid[i][p+d] "
                    },
                    {
                        "username": "ndanie03",
                        "content": "Can someone help me? This must be a bug...\\n\\nMy function returns the exact answer, but then it continues looping... after the return statement?!\\n\\nHere is my log:\\n\\n ```\\nfunction called\\n{ ball: 0, row: 5, col: 1 }\\n{ ball: 1, row: 1, col: 2 }\\n{ ball: 2, row: 0, col: 2 }\\n{ ball: 3, row: 0, col: 3 }\\n{ ball: 4, row: 1, col: 3 }\\n[ 1, -1, -1, -1, -1 ]\\nfunction called...\\n\\nTypeError: Cannot read properties of undefined (reading \\'0\\')\\nLine 14: Char 38 in solution.ts (findBall)\\n```\\n\\nHere is my code in typescript:\\n\\n```\\nfunction findBall(grid: number[][]): number[] {\\n    const result = [];\\n    const cols = grid.length;\\n    const rows = grid[0].length;\\n\\n    console.log(\"function called\");\\n\\n    for (let ball = 0; ball < cols; ball++) {\\n        let col = ball, row = 0;\\n\\n        for (; row <= rows; row++) {\\n            if (row === rows) break;\\n\\n            const currDir = grid[row][col];\\n            const adjDir = grid[row][col + currDir];\\n\\n            if (currDir + adjDir === 0) break;\\n\\n            col += currDir;\\n\\n            if (col < 0 || col >= cols) break;\\n        }\\n\\n        console.log({ ball, row, col });\\n        result.push(row < rows ? -1 : col);\\n    }\\n    console.log(result);\\n\\n    return result;\\n};\\n```"
                    },
                    {
                        "username": "bhruti1",
                        "content": "hmm... this question seemed hard initially, but afterwards found that this is easy just have to find some patterns. Give it a try. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "sharmasiddharth017",
                        "content": "I think one approach to this question can be considered as finding if a path exists for each cell from first row to (lastrow+1) "
                    },
                    {
                        "username": "Soolmaz",
                        "content": "Seems to be interesting problem, but a little bit confusing in description part"
                    }
                ]
            }
        ]
    }
]