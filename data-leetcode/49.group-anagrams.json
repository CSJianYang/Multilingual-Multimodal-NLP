[
    {
        "title": "Group Anagrams",
        "question_content": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n&nbsp;\nExample 1:\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\nExample 2:\nInput: strs = [\"\"]\nOutput: [[\"\"]]\nExample 3:\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n&nbsp;\nConstraints:\n\n\t1 <= strs.length <= 104\n\t0 <= strs[i].length <= 100\n\tstrs[i] consists of lowercase English letters.",
        "solutions": [
            {
                "id": 19200,
                "title": "c-unordered-map-and-counting-sort",
                "content": "Use an `unordered_map` to group the strings by their sorted counterparts. Use the sorted string as the key and all anagram strings as the value.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for (string s : strs) {\\n            string t = s; \\n            sort(t.begin(), t.end());\\n            mp[t].push_back(s);\\n        }\\n        vector<vector<string>> anagrams;\\n        for (auto p : mp) { \\n            anagrams.push_back(p.second);\\n        }\\n        return anagrams;\\n    }\\n};\\n```\\n\\nMoreover, since the string only contains lower-case alphabets, we can sort them using counting sort to improve the time complexity.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for (string s : strs) {\\n            mp[strSort(s)].push_back(s);\\n        }\\n        vector<vector<string>> anagrams;\\n        for (auto p : mp) { \\n            anagrams.push_back(p.second);\\n        }\\n        return anagrams;\\n    }\\nprivate:\\n    string strSort(string s) {\\n        int counter[26] = {0};\\n        for (char c : s) {\\n            counter[c - \\'a\\']++;\\n        }\\n        string t;\\n        for (int c = 0; c < 26; c++) {\\n            t += string(counter[c], c + \\'a\\');\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for (string s : strs) {\\n            string t = s; \\n            sort(t.begin(), t.end());\\n            mp[t].push_back(s);\\n        }\\n        vector<vector<string>> anagrams;\\n        for (auto p : mp) { \\n            anagrams.push_back(p.second);\\n        }\\n        return anagrams;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for (string s : strs) {\\n            mp[strSort(s)].push_back(s);\\n        }\\n        vector<vector<string>> anagrams;\\n        for (auto p : mp) { \\n            anagrams.push_back(p.second);\\n        }\\n        return anagrams;\\n    }\\nprivate:\\n    string strSort(string s) {\\n        int counter[26] = {0};\\n        for (char c : s) {\\n            counter[c - \\'a\\']++;\\n        }\\n        string t;\\n        for (int c = 0; c < 26; c++) {\\n            t += string(counter[c], c + \\'a\\');\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19176,
                "title": "share-my-short-java-solution",
                "content": "```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs == null || strs.length == 0) return new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ca = s.toCharArray();\\n            Arrays.sort(ca);\\n            String keyStr = String.valueOf(ca);\\n            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n```\\n\\nInstead of sorting, we can also build the key string in this way. Thanks @davidluoyes for pointing this out.\\n\\n```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs == null || strs.length == 0) return new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ca = new char[26];\\n            for (char c : s.toCharArray()) ca[c - \\'a\\']++;\\n            String keyStr = String.valueOf(ca);\\n            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs == null || strs.length == 0) return new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ca = s.toCharArray();\\n            Arrays.sort(ca);\\n            String keyStr = String.valueOf(ca);\\n            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n```\n```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs == null || strs.length == 0) return new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ca = new char[26];\\n            for (char c : s.toCharArray()) ca[c - \\'a\\']++;\\n            String keyStr = String.valueOf(ca);\\n            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3687735,
                "title": "beats-100-c-java-python-beginner-friendly",
                "content": "\\n# Intuition:\\n\\nThe intuition is to group words that are anagrams of each other together. Anagrams are words that have the `same` characters but in a `different` order.\\n\\n# Explanation:\\n\\nLet\\'s go through the code step by step using the example input `[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]` to understand how it works.\\n\\n1. **Initializing Variables**\\n    - We start by initializing an empty unordered map called `mp` (short for map), which will store the groups of anagrams.\\n\\n2. **Grouping Anagrams**\\nWe iterate through each word in the input vector `strs`. Let\\'s take the first word, \"eat\", as an example.\\n\\n    - **Sorting the Word**\\nWe create a string variable called `word` and assign it the value of the current word (\"eat\" in this case). \\n\\n        Next, we sort the characters in `word` using the `sort()` function. After sorting, `word` becomes \"aet\". \\n\\n    - **Grouping the Anagram**\\nWe insert `word` as the key into the `mp` unordered map using `mp[word]`, and we push the original word (\"eat\") into the vector associated with that key using `mp[word].push_back(x)`, where `x` is the current word.\\n\\n        Since \"aet\" is a unique sorted representation of all the anagrams, it serves as the key in the `mp` map, and the associated vector holds all the anagrams. \\n\\nFor the given example, the `mp` map would look like this after processing all the words:\\n```\\n{\\n  \"aet\": [\"eat\", \"tea\", \"ate\"],\\n  \"ant\": [\"tan\", \"nat\"],\\n  \"abt\": [\"bat\"]\\n}\\n```\\n\\n3. **Creating the Result**\\nWe initialize an empty vector called `ans` (short for answer) to store the final result.\\n\\n    - We iterate through each key-value pair in the `mp` map using a range-based for loop. For each pair, we push the vector of anagrams (`x.second`) into the `ans` vector.\\n\\nFor the given example, the `ans` vector would look like this:\\n```\\n[\\n  [\"eat\", \"tea\", \"ate\"],\\n  [\"tan\", \"nat\"],\\n  [\"bat\"]\\n]\\n```\\n\\n4. **Returning the Result**\\nWe return the `ans` vector, which contains the groups of anagrams.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        \\n        for(auto x: strs){\\n            string word = x;\\n            sort(word.begin(), word.end());\\n            mp[word].push_back(x);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        for(auto x: mp){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        for (String word : strs) {\\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            String sortedWord = new String(chars);\\n            \\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }\\n            \\n            map.get(sortedWord).add(word);\\n        }\\n        \\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        anagram_map = defaultdict(list)\\n        \\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            anagram_map[sorted_word].append(word)\\n        \\n        return list(anagram_map.values())\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/86270fe9-da59-416b-a22e-21b787b13712_1687773427.3564198.png)\\n\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\n10. [Valid Anagram](https://leetcode.com/problems/valid-anagram/solutions/3687854/3-methods-c-java-python-beginner-friendly/)\\n11. [Group Anagrams](https://leetcode.com/problems/group-anagrams/solutions/3687735/beats-100-c-java-python-beginner-friendly/)\\n12. **Practice them in a row for better understanding and please Upvote for more questions.**\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n{\\n  \"aet\": [\"eat\", \"tea\", \"ate\"],\\n  \"ant\": [\"tan\", \"nat\"],\\n  \"abt\": [\"bat\"]\\n}\\n```\n```\\n[\\n  [\"eat\", \"tea\", \"ate\"],\\n  [\"tan\", \"nat\"],\\n  [\"bat\"]\\n]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        \\n        for(auto x: strs){\\n            string word = x;\\n            sort(word.begin(), word.end());\\n            mp[word].push_back(x);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        for(auto x: mp){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        for (String word : strs) {\\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            String sortedWord = new String(chars);\\n            \\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }\\n            \\n            map.get(sortedWord).add(word);\\n        }\\n        \\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        anagram_map = defaultdict(list)\\n        \\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            anagram_map[sorted_word].append(word)\\n        \\n        return list(anagram_map.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19202,
                "title": "5-line-python-solution-easy-to-understand",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        letters_to_words = defaultdict(list)\\n        for word in strs:\\n            letters_to_words[tuple(sorted(word))].append(word)\\n        return list(letters_to_words.values())\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        letters_to_words = defaultdict(list)\\n        for word in strs:\\n            letters_to_words[tuple(sorted(word))].append(word)\\n        return list(letters_to_words.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750590,
                "title": "simple-c-detailed-explanation-unordered-map-sorting",
                "content": "# \\t\\u2705 PLEASE UPVOTE IF YOU LIKE! \\u2705\\n```\\n\\t\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n       vector<vector<string>>ans;\\n        \\n       unordered_map<string, vector<string>>mp;\\n        \\n         /*\\n                Consider example 1 : strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\\n                \\n                After the below opeartion of for loop map will contain\\n                \\n                aet -- eat, tea, ate\\n                ant -- tan, nat\\n                abt -- bat\\n        */\\n        \\n        for(int i = 0 ; i < strs.size() ; i++)\\n        {\\n            string s = strs[i];\\n            sort(strs[i].begin(),strs[i].end());\\n            mp[strs[i]].push_back(s);\\n        }\\n        \\n        //now simply put the elements  of second column of map in ans\\n        \\n        for(auto i : mp)\\n        {\\n            ans.push_back(i.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\t\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n       vector<vector<string>>ans;\\n        \\n       unordered_map<string, vector<string>>mp;\\n        \\n         /*\\n                Consider example 1 : strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\\n                \\n                After the below opeartion of for loop map will contain\\n                \\n                aet -- eat, tea, ate\\n                ant -- tan, nat\\n                abt -- bat\\n        */\\n        \\n        for(int i = 0 ; i < strs.size() ; i++)\\n        {\\n            string s = strs[i];\\n            sort(strs[i].begin(),strs[i].end());\\n            mp[strs[i]].push_back(s);\\n        }\\n        \\n        //now simply put the elements  of second column of map in ans\\n        \\n        for(auto i : mp)\\n        {\\n            ans.push_back(i.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19233,
                "title": "o-m-n-algorithm-using-hash-without-sort",
                "content": "Assign a prime number for a to z, and then multiply all prime numbers together to form a hash value.\\n\\n\\n        \\n        private static final int[] PRIMES = new int[]{2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107};\\n        \\n        public List<String> anagrams(String[] strs) {\\n            List<String> list = new LinkedList<>();\\n            Map<Integer, List<String>> mapString = new HashMap<>();\\n            int result = -1;\\n            for (int i = 0; i < strs.length; i++){\\n                int mapping = 1;\\n                for (int j = 0, max = strs[i].length(); j < max; j++) {\\n                    mapping *= PRIMES[strs[i].charAt(j) - 'a'];\\n                }\\n                List<String> strings = mapString.get(mapping);\\n                if (strings == null) {\\n                    strings = new LinkedList<>();\\n                    mapString.put(mapping, strings);\\n                }\\n                strings.add(strs[i]);\\n            }\\n            for (List<String> mapList : mapString.values()){\\n                if (mapList.size() > 1)\\n                    list.addAll(mapList);\\n            }\\n            return list;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Assign a prime number for a to z, and then multiply all prime numbers together to form a hash value.\\n\\n\\n        \\n        private static final int[] PRIMES = new int[]{2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107};\\n        \\n        public List<String> anagrams(String[] strs) {\\n            List<String> list = new LinkedList<>();\\n            Map<Integer, List<String>> mapString = new HashMap<>();\\n            int result = -1;\\n            for (int i = 0; i < strs.length; i++){\\n                int mapping = 1;\\n                for (int j = 0, max = strs[i].length(); j < max; j++) {\\n                    mapping *= PRIMES[strs[i].charAt(j) - 'a'];\\n                }\\n                List<String> strings = mapString.get(mapping);\\n                if (strings == null) {\\n                    strings = new LinkedList<>();\\n                    mapString.put(mapping, strings);\\n                }\\n                strings.add(strs[i]);\\n            }\\n            for (List<String> mapList : mapString.values()){\\n                if (mapList.size() > 1)\\n                    list.addAll(mapList);\\n            }\\n            return list;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 834253,
                "title": "simple-and-short-c-solution-with-comments-beats-98-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        // Base case\\n\\t\\tif(strs.size() == 1)\\n            return {{strs[0]}};\\n        \\n        vector<vector<string>> ans;\\n        unordered_map<string, vector<string>> M;\\n        for(int  i = 0; i < strs.size(); i++)\\n        {\\n            string str = strs[i];\\n            sort(strs[i].begin(), strs[i].end()); // Sorting the string\\n            M[strs[i]].push_back(str);  // Sorted string is the key and the value is the initial string\\n        }\\n        for(auto i = M.begin(); i != M.end(); i++)\\n            ans.push_back(i -> second);  // Traversing the map and adding the vectors of string to ans\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        // Base case\\n\\t\\tif(strs.size() == 1)\\n            return {{strs[0]}};\\n        \\n        vector<vector<string>> ans;\\n        unordered_map<string, vector<string>> M;\\n        for(int  i = 0; i < strs.size(); i++)\\n        {\\n            string str = strs[i];\\n            sort(strs[i].begin(), strs[i].end()); // Sorting the string\\n            M[strs[i]].push_back(str);  // Sorted string is the key and the value is the initial string\\n        }\\n        for(auto i = M.begin(); i != M.end(); i++)\\n            ans.push_back(i -> second);  // Traversing the map and adding the vectors of string to ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384037,
                "title": "python-easily-understood-hash-table-fast-simple",
                "content": "**Appreciate if you could upvote this solution**\\n\\n\\nMethod: `Hash Table`\\n\\nSince the output needs to group the anagrams, it is suitable to use `dict` to store the different anagrams.\\nThus, we need to find a common `key` for those anagrams.\\nAnd one of the best choices is the `sorted string` as all the anagrams have the same anagrams.\\n\\n![image](https://assets.leetcode.com/users/images/69dc8218-5820-42a0-977c-d278e97b6dd1_1659719811.9147549.png)\\n\\n\\n\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        strs_table = {}\\n\\n        for string in strs:\\n            sorted_string = \\'\\'.join(sorted(string))\\n\\n            if sorted_string not in strs_table:\\n                strs_table[sorted_string] = []\\n\\n            strs_table[sorted_string].append(string)\\n\\n        return list(strs_table.values())\\n```\\nTime complexity: `O(m*nlogn))`\\nSpace complexity: `O(n)`\\n<br/>",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        strs_table = {}\\n\\n        for string in strs:\\n            sorted_string = \\'\\'.join(sorted(string))\\n\\n            if sorted_string not in strs_table:\\n                strs_table[sorted_string] = []\\n\\n            strs_table[sorted_string].append(string)\\n\\n        return list(strs_table.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 664252,
                "title": "python-3-solution-detailed-explanation-faster-than-97-5",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        h = {}\\n        for word in strs:\\n            sortedWord = \\'\\'.join(sorted(word))\\n            if sortedWord not in h:\\n                h[sortedWord] = [word]\\n            else:\\n                h[sortedWord].append(word)\\n        final = []\\n        for value in h.values():\\n            final.append(value)\\n        return final\\n```\\nWe recall that anagrams are strings which have identical counts of characters. So anagrams, when sorted, result in the same string. We take advantage of this last property.\\n\\nWe create a dictionary and for each word in the input array, we add a key to the dictionary if the **sorted version of the word** doesn\\'t already exist in the list of keys. The key then becomes the sorted version of the word, and the value for the key is an array that stores each anagram of the key. i.e. for every next word that is an anagram, **we would sort the word, find the key that is equal to the sorted form, and add the original word to the list of values for the key**.\\n\\nAt the end of it, we just add every value in the dictionary to the final array.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        h = {}\\n        for word in strs:\\n            sortedWord = \\'\\'.join(sorted(word))\\n            if sortedWord not in h:\\n                h[sortedWord] = [word]\\n            else:\\n                h[sortedWord].append(word)\\n        final = []\\n        for value in h.values():\\n            final.append(value)\\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718955,
                "title": "three-js-solutions",
                "content": "```\\nvar groupAnagrams = function(strs) {\\n    let obj = {};\\n    for (let str of strs) {\\n        let letters = str.split(\"\").sort().join(\"\");\\n        obj[letters] ? obj[letters].push(str) : obj[letters] = [str];\\n    }\\n    return Object.values(obj);\\n};\\n// Time Complexity: O(n*klog(k)) where n is the length of input array and k is the maximum length of a string in input array\\n// Space Complexity: O(n)\\n```\\n\\n```\\nvar groupAnagrams = function(strs) {\\n    let m = new Map();\\n    for (let str of strs) {\\n        let sorted = str.split(\"\").sort().join(\"\");\\n        if (m.has(sorted)) m.set(sorted, [...m.get(sorted), str]);\\n        else m.set(sorted, [str]);\\n    }\\n    return Array.from(m.values());\\n};\\n// Time Complexity: O(n*klog(k)) where n is the length of input array and k is the maximum length of a string in input array\\n// Space Complexity: O(n)\\n```\\n\\n```\\nvar groupAnagrams = function(strs) {\\n    let res = {};\\n    for (let str of strs) {\\n        let count = new Array(26).fill(0);\\n        for (let char of str) count[char.charCodeAt()-97]++;\\n        let key = count.join(\"#\");\\n        res[key] ? res[key].push(str) : res[key] = [str];\\n    }\\n    return Object.values(res);\\n};\\n// Time Complexity: O(n*k) where n is the size of input array and k is the maximum length of string in input array\\n// Space Complexity: O(n)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar groupAnagrams = function(strs) {\\n    let obj = {};\\n    for (let str of strs) {\\n        let letters = str.split(\"\").sort().join(\"\");\\n        obj[letters] ? obj[letters].push(str) : obj[letters] = [str];\\n    }\\n    return Object.values(obj);\\n};\\n// Time Complexity: O(n*klog(k)) where n is the length of input array and k is the maximum length of a string in input array\\n// Space Complexity: O(n)\\n```\n```\\nvar groupAnagrams = function(strs) {\\n    let m = new Map();\\n    for (let str of strs) {\\n        let sorted = str.split(\"\").sort().join(\"\");\\n        if (m.has(sorted)) m.set(sorted, [...m.get(sorted), str]);\\n        else m.set(sorted, [str]);\\n    }\\n    return Array.from(m.values());\\n};\\n// Time Complexity: O(n*klog(k)) where n is the length of input array and k is the maximum length of a string in input array\\n// Space Complexity: O(n)\\n```\n```\\nvar groupAnagrams = function(strs) {\\n    let res = {};\\n    for (let str of strs) {\\n        let count = new Array(26).fill(0);\\n        for (let char of str) count[char.charCodeAt()-97]++;\\n        let key = count.join(\"#\");\\n        res[key] ? res[key].push(str) : res[key] = [str];\\n    }\\n    return Object.values(res);\\n};\\n// Time Complexity: O(n*k) where n is the size of input array and k is the maximum length of string in input array\\n// Space Complexity: O(n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1333346,
                "title": "simple-java-solution-beats-99-05-5ms",
                "content": "\\n**Please upvote if you understood the solution**\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>> map=new HashMap<>();\\n        \\n        for(int i=0;i<strs.length;i++){\\n            String s1=strs[i];\\n            char[] arr=s1.toCharArray();\\n            Arrays.sort(arr);\\n            String str=new String(arr);\\n            \\n            if(map.containsKey(str)){\\n                map.get(str).add(s1); \\n            }else{\\n                map.put(str,new ArrayList<>());\\n                map.get(str).add(s1);\\n            }\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n\\nTime Complexity: O(n * klog(k)) since we are sorting k characters n times in the loop.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>> map=new HashMap<>();\\n        \\n        for(int i=0;i<strs.length;i++){\\n            String s1=strs[i];\\n            char[] arr=s1.toCharArray();\\n            Arrays.sort(arr);\\n            String str=new String(arr);\\n            \\n            if(map.containsKey(str)){\\n                map.get(str).add(s1); \\n            }else{\\n                map.put(str,new ArrayList<>());\\n                map.get(str).add(s1);\\n            }\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173284,
                "title": "clean-javascript-solution",
                "content": "```javascript\\nconst groupAnagrams = strs => {\\n    const map = {};\\n    \\n    for (let str of strs) {\\n        const key = [...str].sort().join(\\'\\');\\n\\n        if (!map[key]) {\\n            map[key] = [];\\n        }\\n\\n        map[key].push(str);\\n    }\\n    \\n    return Object.values(map);\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst groupAnagrams = strs => {\\n    const map = {};\\n    \\n    for (let str of strs) {\\n        const key = [...str].sort().join(\\'\\');\\n\\n        if (!map[key]) {\\n            map[key] = [];\\n        }\\n\\n        map[key].push(str);\\n    }\\n    \\n    return Object.values(map);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19335,
                "title": "beat-90-2-18ms-o-n-non-sort-solutions-with-hashmap",
                "content": "**we know each word can be represented by their counter array which counts every letter's occurrences, so we can use this counter array as an ID for the anagram, more specifically, use this counter array's hash code as the key, the anagram list as the value, we can distribute all the words into corresponding anagram group in O(n) time complexity.**\\n\\n```\\npublic int getID(String s){\\n        int[] counter   =   new int[26];\\n        for(char ch : s.toCharArray()){\\n            counter[ch - 'a']++;\\n        }\\n        \\n        return Arrays.hashCode(counter);    //use the counter array's hash code as this anagram's ID\\n    }\\n    \\n    //solution takes 18ms\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> groups   =   new ArrayList<>();\\n        Map<Integer, List<String>> anagramMap   =   new HashMap<>();\\n        \\n        for(String word : strs){\\n            int id   =   getID(word);   //unique for each anagram\\n            List<String> group  =   anagramMap.get(id);\\n            \\n            if(null == group){\\n                group  =   new ArrayList();\\n                anagramMap.put(id, group);\\n           \\n            }\\n            \\n            group.add(word);\\n        }\\n        \\n        groups.addAll(anagramMap.values());\\n        \\n        return groups;\\n    }\\n```\\n\\n***If u think it make sense, plz vote for me, thx : )***\\n\\nbtw, my code was also hosted on github:) https://github.com/Emilio66/leetcode/blob/master/P49_GroupAnagrams.java",
                "solutionTags": [],
                "code": "```\\npublic int getID(String s){\\n        int[] counter   =   new int[26];\\n        for(char ch : s.toCharArray()){\\n            counter[ch - 'a']++;\\n        }\\n        \\n        return Arrays.hashCode(counter);    //use the counter array's hash code as this anagram's ID\\n    }\\n    \\n    //solution takes 18ms\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> groups   =   new ArrayList<>();\\n        Map<Integer, List<String>> anagramMap   =   new HashMap<>();\\n        \\n        for(String word : strs){\\n            int id   =   getID(word);   //unique for each anagram\\n            List<String> group  =   anagramMap.get(id);\\n            \\n            if(null == group){\\n                group  =   new ArrayList();\\n                anagramMap.put(id, group);\\n           \\n            }\\n            \\n            group.add(word);\\n        }\\n        \\n        groups.addAll(anagramMap.values());\\n        \\n        return groups;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19203,
                "title": "2-line-python-solution-ac-with-350ms-some-useful-python-tricks",
                "content": "\\n\\n        def anagrams(self, strs):\\n            count = collections.Counter([tuple(sorted(s)) for s in strs])\\n            return filter(lambda x: count[tuple(sorted(x))]>1, strs)\\n\\n\\n - collections.Counter creates a counter object. A counter object is like a specific kind of dictionary where it is build for counting  (objects that hashes to same value)\\n - tuple(sorted(s)) is used here so that anagrams will be hashed to the same value. tuple is used because sorted returns a list which cannot be hashed but tuples can be hashed\\n - filter: selects some elements of the list based on given function (first argument - a lambda function is given here)\\n - lambda function defined here returns True if number of anagrams of that elements is greater than 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n        def anagrams(self, strs):\\n            count = collections.Counter([tuple(sorted(s)) for s in strs])\\n            return filter(lambda x: count[tuple(sorted(x))]>1, strs)\\n\\n\\n - collections.Counter creates a counter object. A counter object is like a specific kind of dictionary where it is build for counting  (objects that hashes to same value)\\n - tuple(sorted(s)) is used here so that anagrams will be hashed to the same value. tuple is used because sorted returns a list which cannot be hashed but tuples can be hashed\\n - filter: selects some elements of the list based on given function (first argument - a lambda function is given here)\\n - lambda function defined here returns True if number of anagrams of that elements is greater than 1",
                "codeTag": "Python3"
            },
            {
                "id": 19216,
                "title": "1-line-ruby-python-for-updated-problem",
                "content": "The problem just got updated, now asking for different results. Here are some solutions for the new version.\\n\\nAll of them use the sorted string as the group identifier, so for example the words \"leetcoder\" and \"electrode\" both have the group identifier \"cdeeelort\" (or rather an array version of it), which is how I know that they're anagrams of each other.\\n\\n---\\n\\n**Ruby solution 1**\\n\\nJust sort and group.\\n\\n    def group_anagrams(strs)\\n      strs.sort.group_by { |s| s.chars.sort }.values\\n    end\\n\\n---\\n\\n**Ruby solution 2**\\n\\nGroup first, then sort each group. Could be faster for big cases (though isn't for the OJ test cases).\\n\\n    def group_anagrams(strs)\\n      strs.group_by { |s| s.chars.sort }.values.map(&:sort)\\n    end\\n\\n---\\n\\n**Python solution 1**\\n\\nSort and group by group identifier, then sort each group normally.\\n\\n    def groupAnagrams(self, strs):\\n        return [sorted(g) for _, g in itertools.groupby(sorted(strs, key=sorted), sorted)]\\n\\nOr \"breaking it down\" to maybe make it more readable for beginners and because I just noticed that in Firefox it violates my self-imposed *\"no scrollbars\"* rule (I usually use Chrome and didn't think it differed):\\n\\n    def groupAnagrams(self, strs):\\n        groups = itertools.groupby(sorted(strs, key=sorted), sorted)\\n        return [sorted(members) for _, members in groups]\\n\\n---\\n\\n**Python solution 2**\\n\\nUsing defaultdict to collect the groups.\\n\\n    def groupAnagrams(self, strs):\\n        groups = collections.defaultdict(list)\\n        for s in strs:\\n            groups[tuple(sorted(s))].append(s)\\n        return map(sorted, groups.values())",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "The problem just got updated, now asking for different results. Here are some solutions for the new version.\\n\\nAll of them use the sorted string as the group identifier, so for example the words \"leetcoder\" and \"electrode\" both have the group identifier \"cdeeelort\" (or rather an array version of it), which is how I know that they're anagrams of each other.\\n\\n---\\n\\n**Ruby solution 1**\\n\\nJust sort and group.\\n\\n    def group_anagrams(strs)\\n      strs.sort.group_by { |s| s.chars.sort }.values\\n    end\\n\\n---\\n\\n**Ruby solution 2**\\n\\nGroup first, then sort each group. Could be faster for big cases (though isn't for the OJ test cases).\\n\\n    def group_anagrams(strs)\\n      strs.group_by { |s| s.chars.sort }.values.map(&:sort)\\n    end\\n\\n---\\n\\n**Python solution 1**\\n\\nSort and group by group identifier, then sort each group normally.\\n\\n    def groupAnagrams(self, strs):\\n        return [sorted(g) for _, g in itertools.groupby(sorted(strs, key=sorted), sorted)]\\n\\nOr \"breaking it down\" to maybe make it more readable for beginners and because I just noticed that in Firefox it violates my self-imposed *\"no scrollbars\"* rule (I usually use Chrome and didn't think it differed):\\n\\n    def groupAnagrams(self, strs):\\n        groups = itertools.groupby(sorted(strs, key=sorted), sorted)\\n        return [sorted(members) for _, members in groups]\\n\\n---\\n\\n**Python solution 2**\\n\\nUsing defaultdict to collect the groups.\\n\\n    def groupAnagrams(self, strs):\\n        groups = collections.defaultdict(list)\\n        for s in strs:\\n            groups[tuple(sorted(s))].append(s)\\n        return map(sorted, groups.values())",
                "codeTag": "Python3"
            },
            {
                "id": 3209086,
                "title": "java-o-n-k-solution-using-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to combine the strings into list of same values and keep track of each list. So the simple solution is to create a HashMap< String, List >.\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\nNow the main thing is to find a way to keep Key maintained and same for similar anagrams. One way is to do sorting of the elements.\\nLike -> \\n1. ate -> [\\'a\\',\\'t\\',\\'e\\'] -> after sorting and combining -> aet.\\n2. tae -> [\\'t\\',\\'a\\',\\'e\\'] -> after sorting and combining -> aet.\\n\\n# Complexity\\n- Time complexity: O(n * k * log(k) ), where\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- - n = length of array\\n- - k = length of string\\n\\n- Space complexity: O( n ) , size of map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, ArrayList<String>> map = new HashMap<>();\\n\\n        for( String s: strs ){\\n\\n            char[] valArr = s.toCharArray();\\n            Arrays.sort( valArr );\\n            String key = new String(valArr);\\n\\n            ArrayList<String> ll = map.getOrDefault( key,\\n                                     new ArrayList<String>() );\\n            ll.add(s);\\n            map.put( key, ll );\\n                                 \\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n        for( Map.Entry<String, ArrayList<String>> entry: map.entrySet() ){\\n            ans.add( entry.getValue() );\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\nNow we can optimise the Key identifying procedure by using Xor and Product of ASCII values of character in Strings. As sorting require extra k*log(k) time and we can reduce it to O(k) for linear traversal.\\n\\n# Complexity\\n- Time complexity: O(n * k), where\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- - n = length of array\\n- - k = length of string\\n\\n- Space complexity: O( n ) , size of map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, ArrayList<String>> map = new HashMap<>();\\n\\n        for( String s: strs ){\\n\\n            String key = getKey(s);\\n\\n            ArrayList<String> ll = map.getOrDefault( key,\\n                                     new ArrayList<String>() );\\n            ll.add(s);\\n            map.put( key, ll );\\n                                 \\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n        for( Map.Entry<String, ArrayList<String>> entry: map.entrySet() ){\\n            ans.add( entry.getValue() );\\n        }\\n\\n        return ans;\\n    }\\n\\n    private String getKey(String s){\\n        int prod = 1, xor = 0;\\n        for(int len=0; len<s.length(); len++){\\n            char i = s.charAt(len);\\n            prod *= i;\\n            xor = xor^i;\\n        }\\n        return String.valueOf(prod) + \\'_\\' + String.valueOf(xor);\\n    }\\n\\n}\\n```\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/70fb8114-54fb-46bb-8481-e676441046c7_1676881723.60565.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, ArrayList<String>> map = new HashMap<>();\\n\\n        for( String s: strs ){\\n\\n            char[] valArr = s.toCharArray();\\n            Arrays.sort( valArr );\\n            String key = new String(valArr);\\n\\n            ArrayList<String> ll = map.getOrDefault( key,\\n                                     new ArrayList<String>() );\\n            ll.add(s);\\n            map.put( key, ll );\\n                                 \\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n        for( Map.Entry<String, ArrayList<String>> entry: map.entrySet() ){\\n            ans.add( entry.getValue() );\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, ArrayList<String>> map = new HashMap<>();\\n\\n        for( String s: strs ){\\n\\n            String key = getKey(s);\\n\\n            ArrayList<String> ll = map.getOrDefault( key,\\n                                     new ArrayList<String>() );\\n            ll.add(s);\\n            map.put( key, ll );\\n                                 \\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n        for( Map.Entry<String, ArrayList<String>> entry: map.entrySet() ){\\n            ans.add( entry.getValue() );\\n        }\\n\\n        return ans;\\n    }\\n\\n    private String getKey(String s){\\n        int prod = 1, xor = 0;\\n        for(int len=0; len<s.length(); len++){\\n            char i = s.charAt(len);\\n            prod *= i;\\n            xor = xor^i;\\n        }\\n        return String.valueOf(prod) + \\'_\\' + String.valueOf(xor);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750704,
                "title": "java-easy-solution-hashmap-arraylist",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (strs == null || strs.length == 0) {\\n            return result;\\n        }\\n        if (strs.length == 1) {\\n            result.add(Arrays.asList(strs));\\n            return result;\\n        }\\n\\n        HashMap<String, List<String>> groups = new HashMap<>();\\n        for (String s : strs) {\\n            String signature = getSignature(s);\\n            groups.putIfAbsent(signature, new ArrayList<>());\\n        groups.get(signature).add(s);\\n        }\\n\\n        return new ArrayList<>(groups.values());\\n    }\\n\\n    private String getSignature(String s) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                sb.append((char) (\\'a\\' + i)).append(count[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (strs == null || strs.length == 0) {\\n            return result;\\n        }\\n        if (strs.length == 1) {\\n            result.add(Arrays.asList(strs));\\n            return result;\\n        }\\n\\n        HashMap<String, List<String>> groups = new HashMap<>();\\n        for (String s : strs) {\\n            String signature = getSignature(s);\\n            groups.putIfAbsent(signature, new ArrayList<>());\\n        groups.get(signature).add(s);\\n        }\\n\\n        return new ArrayList<>(groups.values());\\n    }\\n\\n    private String getSignature(String s) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                sb.append((char) (\\'a\\' + i)).append(count[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750601,
                "title": "python-c-java-rust-linear-time-hashable-keys-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs hashing of strings in linear-time. Time complexity is **O(N)**. Space complexity is **O(N)**. \\n\\n**Comment**. To group anagrams, we should use something (i.e., some hash) that:\\n* uniquely distinguishes one group from another;\\n* is the same for all members of each group.\\n\\nAmong the potential candidates are:\\n* list of letter frequencies in alphabetical order, that takes **O(N)** time to compute;\\n* sorted version of a string, that takes **O(N\\\\*logN)** time to compute.\\n\\nHere, we\\'ll go with the first option.\\n\\n<iframe src=\"https://leetcode.com/playground/Sfqzaf8u/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>\\n\\n",
                "solutionTags": [],
                "code": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs hashing of strings in linear-time. Time complexity is **O(N)**. Space complexity is **O(N)**. \\n\\n**Comment**. To group anagrams, we should use something (i.e., some hash) that:\\n* uniquely distinguishes one group from another;\\n* is the same for all members of each group.\\n\\nAmong the potential candidates are:\\n* list of letter frequencies in alphabetical order, that takes **O(N)** time to compute;\\n* sorted version of a string, that takes **O(N\\\\*logN)** time to compute.\\n\\nHere, we\\'ll go with the first option.\\n\\n<iframe src=\"https://leetcode.com/playground/Sfqzaf8u/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 19404,
                "title": "sharing-my-very-concise-solution-with-explanation",
                "content": "    vector<string> anagrams(vector<string> &strs) {\\n        vector<string> result;\\n        vector<string> sortedStrs = strs;\\n        unordered_map<string, vector<int>> map;\\n        for(int i = 0; i < strs.size(); i++){\\n            sort(sortedStrs[i].begin(), sortedStrs[i].end());\\n            map[sortedStrs[i]].push_back(i);\\n        }\\n        for(auto it = map.begin(); it != map.end(); it++){\\n            if(it->second.size() > 1){\\n                for(int i = 0; i < it->second.size(); i++){\\n                    result.push_back(strs[it->second[i]]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\nHere is basic idea for this problem.\\n\\nFirst, get a copy of \"strs\". Let's name this copy \"sortedStrs\".\\n\\nSecond, sort all strings in \"sortedStrs\".\\n\\nAnd we have a hash map `unordered_map<string, vector<int>> map`.\\n\\nEvery string in \"sortedStrs\" will be recorded in this hash map with its position.\\n\\nIn the second loop, we traverse this hash map. And find each value of which size is larger than 1. Then find the original string in \"strs\".\\n\\nDone.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "    vector<string> anagrams(vector<string> &strs) {\\n        vector<string> result;\\n        vector<string> sortedStrs = strs;\\n        unordered_map<string, vector<int>> map;\\n        for(int i = 0; i < strs.size(); i++){\\n            sort(sortedStrs[i].begin(), sortedStrs[i].end());\\n            map[sortedStrs[i]].push_back(i);\\n        }\\n        for(auto it = map.begin(); it != map.end(); it++){\\n            if(it->second.size() > 1){\\n                for(int i = 0; i < it->second.size(); i++){\\n                    result.push_back(strs[it->second[i]]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\nHere is basic idea for this problem.\\n\\nFirst, get a copy of \"strs\". Let's name this copy \"sortedStrs\".\\n\\nSecond, sort all strings in \"sortedStrs\".\\n\\nAnd we have a hash map `unordered_map<string, vector<int>> map`.\\n\\nEvery string in \"sortedStrs\" will be recorded in this hash map with its position.\\n\\nIn the second loop, we traverse this hash map. And find each value of which size is larger than 1. Then find the original string in \"strs\".\\n\\nDone.",
                "codeTag": "Unknown"
            },
            {
                "id": 3423036,
                "title": "4-best-swift-solutions-easy-to-understand",
                "content": "# First solution using Dictionary\\n\\n## Approach\\n\\nFirstly, the functions creates an empty dictionary with the key as a `String` and the value as an array of `String`. Then, it iterates over each string in the given array of strings `strs`. \\n\\nFor each string in `strs`, the function sorts the characters of the string using the `sorted()` method and creates a new string with the sorted characters. This sorted string is then used as the key to the dictionary. \\n\\nIf the dictionary already has the sorted string as the key, the given string is appended to the array of strings that correspond to the given key. Otherwise, a new key-value pair is added to the dictionary with the sorted string as the key and the given string as the value of a new array.\\n\\nFinally, the function returns an array of arrays of strings. Each array of strings represents a group of anagrams. It is done by using the `values` property of the dictionary to get an array of arrays.\\n\\n## Complexity\\n\\nThis approach has a *time complexity* of $$O(n \\\\cdot m \\\\cdot \\\\log m)$$, where $$n$$ is the number of strings in `strs` and $$m$$ is the maximum length of a string in `strs`.\\n\\nThe *space complexity* of the given solution is $$O(n \\\\cdot m)$$, where $$n$$ is the number of strings in the input array `strs` and $$m$$ is the maximum length of a string in `strs`. \\n\\n## Code\\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict = [String: [String]]()\\n\\n        for str in strs {\\n            let sortedStr = String(str.sorted())\\n            dict[sortedStr, default: []].append(str)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\\n\\n\\n---\\n\\n# Second solution using Dictionary\\n\\n## Approach\\n\\nFirst, a dictionary is created with keys as arrays of integers (count of characters in the string) and values as arrays of strings (the anagrams). \\n\\nThen, for each string in the input array, an array of `counts` of the characters in the string is created. The counts array is initialized with zeros for each of the `26` alphabets. \\n\\nNext, each character in the string is iterated over, and the corresponding `index` in the counts array is incremented. \\n\\nAfter counting the characters in the string, the `counts` array is used as a key in the dictionary. The string is then appended to the corresponding value array for that key. \\n\\nFinally, the values of the dictionary are returned as an array of grouped anagrams.\\n\\n## Complexity\\n\\nThis approach is efficient, as it only requires iterating over each string in the input array once, and the *time complexity* is $$O(n \\\\cdot k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the length of the longest string.\\n\\nThe *space complexity* of this approach is $$O(n \\\\cdot k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the length of the longest string.\\n\\n## Code\\n\\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict = [[Int]: [String]]()\\n\\n        for str in strs {\\n            var counts = Array(repeating: 0, count: 26)\\n            for char in str {\\n                let index = Int(char.asciiValue! - 97)\\n                counts[index] += 1\\n            }\\n            dict[counts, default: []].append(str)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\\n\\n---\\n\\n# Third solution using Dictionary(grouping:)\\n\\n## Approach\\n\\nThe approach to solving the problem involves using the built-in `Dictionary` function `grouping(_:by:)` and the `sorted()` method of strings to group the anagrams together.\\n\\nThe `grouping(_:by:)` function takes an array and a closure that returns a key for each element in the array. It groups the elements of the array by the returned key, and returns a dictionary with keys as the returned key and values as arrays of elements that have the same key.\\n\\nIn this case, the `strs` array is passed to the `grouping(_:by:)` function, and a closure is provided that sorts each string and converts it to a new string. The sorted string is used as the key for the dictionary.\\n\\nThe `sorted()` method on a string returns an array of characters sorted in ascending order. By converting the sorted array of characters back to a string, we obtain a canonical form of the input string, which is the same for all anagrams of that string.\\n\\nFinally, the `values` property of the dictionary is accessed, which returns an array of arrays of anagrams. The `map` function is used to extract the arrays of anagrams and return them as a 2D array.\\n\\n## Complexity\\n\\nThis approach has a *time complexity* of $$O(n \\\\cdot k \\\\cdot \\\\log k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the length of the longest string\\n\\nThe *space complexity* of the given solution is $$O(n \\\\cdot k)$$, as a dictionary is used to store the grouped anagrams.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        Dictionary(grouping: strs, by: { String($0.sorted()) }).values.map { $0 }\\n    }\\n}\\n```\\n\\n\\n---\\n\\n# Fourth solution using \\xABProduct of Primes\\xBB\\n\\n## Approach\\n\\nTo solve this problem, the approach used in the given Swift function is based on the idea of hashing. In this approach, each string is assigned a unique hash key based on the product of the prime numbers assigned to each character in the string. The prime numbers assigned to each character are chosen in such a way that the hash keys of two strings will be equal only if they are anagrams of each other. \\n\\nIn the code, a dictionary is used to store the hash keys as keys and the corresponding anagrams as values. For each string in the input array, the hash key is calculated by multiplying the prime numbers assigned to each character in the string. If the hash key is already present in the dictionary, the current string is appended to the list of anagrams for that key. Otherwise, a new key-value pair is added to the dictionary with the hash key and the current string.\\n\\nFinally, the function returns an array containing the values of the dictionary, which are the lists of anagrams grouped together. The order of the anagram groups in the output array can be arbitrary.\\n\\n## Complexity\\n\\nThe *time complexity* of this solution is $$O(n \\\\cdot k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the maximum length of a string in the input array.\\n\\nThe space complexity of this solution is $$O(n \\\\cdot k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the maximum length of a string in the input array.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        let mod = 1_000_000_007\\n        var dict = [Int: [String]]()\\n        let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]\\n\\n        for s in strs {\\n            var key = 1\\n            for ch in s {\\n                key = key * primes[Int(ch.asciiValue! - Character(\"a\").asciiValue!)] % mod\\n            }\\n            dict[key, default: []].append(s)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/9d031f2a-2935-4fde-bedc-c35de65d1beb_1681635981.4891484.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict = [String: [String]]()\\n\\n        for str in strs {\\n            let sortedStr = String(str.sorted())\\n            dict[sortedStr, default: []].append(str)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict = [[Int]: [String]]()\\n\\n        for str in strs {\\n            var counts = Array(repeating: 0, count: 26)\\n            for char in str {\\n                let index = Int(char.asciiValue! - 97)\\n                counts[index] += 1\\n            }\\n            dict[counts, default: []].append(str)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        Dictionary(grouping: strs, by: { String($0.sorted()) }).values.map { $0 }\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        let mod = 1_000_000_007\\n        var dict = [Int: [String]]()\\n        let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]\\n\\n        for s in strs {\\n            var key = 1\\n            for ch in s {\\n                key = key * primes[Int(ch.asciiValue! - Character(\"a\").asciiValue!)] % mod\\n            }\\n            dict[key, default: []].append(s)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434269,
                "title": "golang-17-lines-of-easy-to-understand-solution-without-using-sort",
                "content": "We can take advantage of anagram\\'s defination:\\n> An anagram is a word or phrase formed by rearranging the letters of a different word or phrase\\n\\nSo we can consider using a hashmap to store every letter\\'s frequency and group those who have the same frequency, but in Golang slice cannot be a key. \\nWe are told:\\n> All inputs will be in lowercase.\\nSo we can use array as a key, whose capacity is 26 since there are only 26 letters. \\n\\n* time complexity: O(nk), n is `len(strs)`, k is the length of the longest string in `strs`\\n* space complexity: O(nk), for we are using a hashmap\\n\\n```\\nfunc groupAnagrams(strs []string) [][]string {\\n\\tmp := map[[26]int][]string{}\\n\\tfor _, s := range strs {\\n\\t\\tk := [26]int{}\\n\\t\\tfor i := 0; i < len(s); i++ {\\n\\t\\t\\tk[s[i]-\\'a\\'] += 1\\n\\t\\t}\\n\\t\\tmp[k] = append(mp[k], s)\\n\\t}\\n\\tres := [][]string{}\\n\\tfor _, v := range mp {\\n\\t\\tres = append(res, v)\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n\\tmp := map[[26]int][]string{}\\n\\tfor _, s := range strs {\\n\\t\\tk := [26]int{}\\n\\t\\tfor i := 0; i < len(s); i++ {\\n\\t\\t\\tk[s[i]-\\'a\\'] += 1\\n\\t\\t}\\n\\t\\tmp[k] = append(mp[k], s)\\n\\t}\\n\\tres := [][]string{}\\n\\tfor _, v := range mp {\\n\\t\\tres = append(res, v)\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422306,
                "title": "using-hashtable-easy-to-understand",
                "content": "\\n\\n# Python Solution\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic={}\\n        for word in strs:\\n            sorted_word=\"\".join(sorted(word))\\n            if sorted_word not in dic:\\n                dic[sorted_word]=[word]\\n            else:\\n                dic[sorted_word].append(word)\\n        return dic.values()\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic={}\\n        for word in strs:\\n            sorted_word=\"\".join(sorted(word))\\n            if sorted_word not in dic:\\n                dic[sorted_word]=[word]\\n            else:\\n                dic[sorted_word].append(word)\\n        return dic.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107534,
                "title": "92-49-javascript-fast-very-easy-to-understand-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/nUfXklKCGTk\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {\\n    let map = {}\\n\\n    for(let str of strs){\\n        let s = str.split(\\'\\').sort().join(\\'\\')\\n        if(!map[s]) map[s] = []\\n        map[s].push(str)\\n    }\\n    return Object.values(map)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {\\n    let map = {}\\n\\n    for(let str of strs){\\n        let s = str.split(\\'\\').sort().join(\\'\\')\\n        if(!map[s]) map[s] = []\\n        map[s].push(str)\\n    }\\n    return Object.values(map)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327706,
                "title": "javascript-7-line-solution-using-primes-beats-99-8-without-sorting",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n *\\n * key point: \\n * prime multiply prime is unique, each char canbe represented by a prime\\n * since [a-z] to  [0-25]\\n * use `[charCodeAt() - 97]` to get unique index from the prime array\\n * the prodcut can be set to the key name \"prod\"\\n **/\\n    var groupAnagrams = function (strs) {\\n      const map = {};\\n      const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\\n      strs.forEach(str => {\\n        let prod = str.split(\"\").reduce((r, c) => r * primes[c.charCodeAt() - 97], 1);\\n        map[prod] ? map[prod].push(str) : map[prod] = [str];\\n      });\\n      return Object.values(map);\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n *\\n * key point: \\n * prime multiply prime is unique, each char canbe represented by a prime\\n * since [a-z] to  [0-25]\\n * use `[charCodeAt() - 97]` to get unique index from the prime array\\n * the prodcut can be set to the key name \"prod\"\\n **/\\n    var groupAnagrams = function (strs) {\\n      const map = {};\\n      const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\\n      strs.forEach(str => {\\n        let prod = str.split(\"\").reduce((r, c) => r * primes[c.charCodeAt() - 97], 1);\\n        map[prod] ? map[prod].push(str) : map[prod] = [str];\\n      });\\n      return Object.values(map);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 19224,
                "title": "a-clean-c-solution-with-unordered-map",
                "content": "\\tvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\t\\tunordered_map<string, vector<string>> count;\\n\\t\\tint i = 0;\\n\\t\\tfor (auto s : strs)\\n\\t\\t{\\n\\t\\t\\tsort(s.begin(), s.end());\\n\\t\\t\\tcount[s].push_back(strs[i++]);\\n\\t\\t}\\n\\t\\tvector<vector<string>> res;\\n\\t\\tfor (auto n : count){\\n\\t\\t\\tsort(n.second.begin(), n.second.end());\\n\\t\\t\\tres.push_back(n.second);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "solutionTags": [],
                "code": "\\tvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\t\\tunordered_map<string, vector<string>> count;\\n\\t\\tint i = 0;\\n\\t\\tfor (auto s : strs)\\n\\t\\t{\\n\\t\\t\\tsort(s.begin(), s.end());\\n\\t\\t\\tcount[s].push_back(strs[i++]);\\n\\t\\t}\\n\\t\\tvector<vector<string>> res;\\n\\t\\tfor (auto n : count){\\n\\t\\t\\tsort(n.second.begin(), n.second.end());\\n\\t\\t\\tres.push_back(n.second);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2838344,
                "title": "100-animation-to-the-hard-solution-and-easy-solution-explained",
                "content": "[https://youtu.be/3cAxlUsBfas]()\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "[https://youtu.be/3cAxlUsBfas]()\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2750734,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/UnfxY7Sm/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\nAnother Approach using Prime numbers\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int M = 1e9 + 9;\\n        vector<int> primes = {\\n            2, 3, 5, 7, 11,\\n            13, 17, 19, 23, 29,\\n            31, 37, 41, 43, 47,\\n            53, 59, 61, 67, 71,\\n            73, 79, 83, 89, 97, \\n            101\\n        };\\n\\t\\t// hacked by [\"djrw\", \"beisx\", \"ceflvx\", \"anp\"] :D\\n        // for (int i = 0; i < 26; i++)  primes[i] = i * i + i + 41;\\n        unordered_map<long long, vector<string>> m;\\n        for (int i = 0; i < strs.size(); i++) {\\n            long long k = 1;\\n            for (int j = 0; j < strs[i].size(); j++) {\\n                k *= 1LL * primes[strs[i][j] - \\'a\\'];\\n                k %= M;\\n            }\\n            m[k].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for (auto x : m) ans.push_back(x.second);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int M = 1e9 + 9;\\n        vector<int> primes = {\\n            2, 3, 5, 7, 11,\\n            13, 17, 19, 23, 29,\\n            31, 37, 41, 43, 47,\\n            53, 59, 61, 67, 71,\\n            73, 79, 83, 89, 97, \\n            101\\n        };\\n\\t\\t// hacked by [\"djrw\", \"beisx\", \"ceflvx\", \"anp\"] :D\\n        // for (int i = 0; i < 26; i++)  primes[i] = i * i + i + 41;\\n        unordered_map<long long, vector<string>> m;\\n        for (int i = 0; i < strs.size(); i++) {\\n            long long k = 1;\\n            for (int j = 0; j < strs[i].size(); j++) {\\n                k *= 1LL * primes[strs[i][j] - \\'a\\'];\\n                k %= M;\\n            }\\n            m[k].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for (auto x : m) ans.push_back(x.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399131,
                "title": "c-easy-clean-solution-using-sorting-and-map",
                "content": "**Solution:**\\n\\n**Approach**\\n1. We need to group all `anagrams` together.\\n2. An Anagram is a word or phrase formed by `rearranging the letters` of a different word or phrase, typically using all the original letters `exactly once`.\\n3. If we sort a particular string, we have one `unique string` which can be called as the `primary string` through which all anagrams were made(Just an imagination to understand the concept better).\\n4. For each sorted string, group it with its anagram(original string) using `map`.\\n5. Return the `result` in any order.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for(auto i: strs){\\n            string temp = i;\\n            sort(temp.begin(), temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for(auto i: mp){\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nTime Complexity: `O(n * (m * log(m)))`\\n* where n is the total number of strings present in the `vector` and m is the `maximum length` of a string in the vector. Here, sorting the strings causes `(m * log(m))` addition to the complexity.\\n\\nSpace Complexity: `O(n * m)`\\n\\n**Feel free to share your ideas or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for(auto i: strs){\\n            string temp = i;\\n            sort(temp.begin(), temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for(auto i: mp){\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241396,
                "title": "python-simple-solution-brute-force",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        ans = {}\\n        for i in strs:\\n            srt = str(sorted(i))\\n            if srt in ans:\\n                ans[srt].append(i)\\n            else:\\n                ans[srt] = [i]\\n        return list(ans.values())\\n```\\n**.\\n.\\n.\\n.\\n.\\n...Please Up-vote if you find this useful...**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        ans = {}\\n        for i in strs:\\n            srt = str(sorted(i))\\n            if srt in ans:\\n                ans[srt].append(i)\\n            else:\\n                ans[srt] = [i]\\n        return list(ans.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887227,
                "title": "python-3-90-faster-simple-approach",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nKey learnings for me:\\n1. parameter \"list\" in defaultdict is lowercase\\n2. sorted() returns iterable. We need to join the returned list to create a string\\n3. We can loop through dictionary to store the values in result list or we can directly use dic.values()\\n\\n```\\ndef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n\\tdic = collections.defaultdict(list)\\n\\tfor st in strs:\\n\\t\\ts = \\'\\'.join(sorted(st))\\n\\t\\tdic[s].append(st)\\n\\n\\treturn dic.values()\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n\\tdic = collections.defaultdict(list)\\n\\tfor st in strs:\\n\\t\\ts = \\'\\'.join(sorted(st))\\n\\t\\tdic[s].append(st)\\n\\n\\treturn dic.values()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1398912,
                "title": "python-2-solutions-o-nk-log-k-and-o-nk-26n-explained",
                "content": "#### Solution 1\\nFirst idea is to notice that if we have two anagrams, than when we sort symbols in each of them, then we will have exactly the same string. So we need for each string to sort it and then use defaultdict. \\n\\n#### Complexity\\nTime complexity will be `O(nk * log k)`, space complexity is `O(nk)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        t = defaultdict(list)\\n        for s in strs:\\n            t[\"\".join(sorted(s))].append(s)\\n        return t.values()\\n```\\n\\n#### Solution 2\\nTwo strings are anagrams if and only if their character counts, that is frequencies of each letter `a, b, ..., z` are the same. So it can be done with `defauldict(list)`, where key is 26-element list and values are strings, corresponding to this key.\\n\\n#### Complexity\\nTime complexity is `O(nk + 26n)`, where `n` is number of strings and `k` is the length of the biggest string. Space complexity is `O(26n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        ans = defaultdict(list)\\n        for s in strs:\\n            count = [0] * 26\\n            for c in s:\\n                count[ord(c) - ord(\\'a\\')] += 1\\n            ans[tuple(count)].append(s)\\n        return ans.values()\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        t = defaultdict(list)\\n        for s in strs:\\n            t[\"\".join(sorted(s))].append(s)\\n        return t.values()\\n```\n```python\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        ans = defaultdict(list)\\n        for s in strs:\\n            count = [0] * 26\\n            for c in s:\\n                count[ord(c) - ord(\\'a\\')] += 1\\n            ans[tuple(count)].append(s)\\n        return ans.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566272,
                "title": "simple-c-solution",
                "content": "Basically, just create a map keyed by all of the sorted and unique words, and its value corresponds with a vector consisting of all the strings that when sorted, results in the key.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> y;\\n        \\n        if(strs.size() == 0) return y;\\n        \\n        map<string,vector<string>> dict;\\n        for(string s: strs)\\n        {\\n            string sorted = s;\\n            sort(sorted.begin(),sorted.end());\\n            dict[sorted].push_back(s);\\n        }\\n        map<string,vector<string>>::iterator o = dict.begin();\\n        while(o != dict.end())\\n        {\\n            y.push_back(o->second);\\n            o++;\\n        }\\n    \\n        return y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> y;\\n        \\n        if(strs.size() == 0) return y;\\n        \\n        map<string,vector<string>> dict;\\n        for(string s: strs)\\n        {\\n            string sorted = s;\\n            sort(sorted.begin(),sorted.end());\\n            dict[sorted].push_back(s);\\n        }\\n        map<string,vector<string>>::iterator o = dict.begin();\\n        while(o != dict.end())\\n        {\\n            y.push_back(o->second);\\n            o++;\\n        }\\n    \\n        return y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751413,
                "title": "rust-hashmap-functional-style-with-comments",
                "content": "Strings are grouped by the histogram of letter frequencies. Use this as the key in a hash map, collecting the strings in the map values. I had hopes of making this a one-liner, but have not figured out a way to get around that we have to return the modified histogram/map in the `fold` body. :)\\n\\nImplementation notes:\\n* `N_LETTERS` instead of the magic value 26.\\n* `strs.into_iter` to take ownership of the provided strings and move them into the map.\\n* `or_default` for the most concise insertion of an empty vector if this is the first time we encounter a key.\\n* `into_values` to directly map the values to the output iterator, instead of `into_iter().map(...)`, and to take ownership of the hash map values => the string instances we get as input are the same instances that we return in the output.\\n\\n```\\nuse std::collections::HashMap;\\n\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\n\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        strs.into_iter().fold(HashMap::<[u8; N_LETTERS], Vec<String>>::new(), |mut map, s| {\\n            let freqs = s.bytes().map(|b| (b - b\\'a\\') as usize).fold([0; N_LETTERS], |mut freqs, bin| {\\n                freqs[bin] += 1;\\n                freqs\\n            });\\n            map.entry(freqs).or_default().push(s);\\n            map\\n        }).into_values().collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\n\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        strs.into_iter().fold(HashMap::<[u8; N_LETTERS], Vec<String>>::new(), |mut map, s| {\\n            let freqs = s.bytes().map(|b| (b - b\\'a\\') as usize).fold([0; N_LETTERS], |mut freqs, bin| {\\n                freqs[bin] += 1;\\n                freqs\\n            });\\n            map.entry(freqs).or_default().push(s);\\n            map\\n        }).into_values().collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2751397,
                "title": "easy-solution-c-java-python",
                "content": "**If You Liked the Solution Please Upvote**\\n\\n`The approach is based on the fact that on sorting all anagrams will result into the same string.`\\n`So we use a map with key= sorted string and value = vector containing all anagrams which on sorting will give the string in key.`\\n`Then we will iterate through the map and store all these vectors into an another vector and return it as answer.`\\n\\n`C++`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        \\n        for(auto x: strs){\\n            string temp = x;\\n            sort(temp.begin(), temp.end());\\n            \\n            m[temp].push_back(x);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        \\n        for(auto x: m){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`JAVA`\\n\\n```\\n public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String,List<String>> hm = new HashMap<>();\\n        for(String s : strs){\\n            \\n            char[] chars=s.toCharArray();\\n            Arrays.sort(chars);\\n            String key = String.valueOf(chars);\\n            \\n            if (!hm.containsKey(key)) {\\n                hm.put(key, new ArrayList<>());\\n            }\\n            hm.get(key).add(s);\\n            \\n        }\\n        return new ArrayList<>(hm.values());\\n    }\\n```\\n\\n`PYTHON`\\n\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        groupedWords = defaultdict(list)\\n        \\n        for word in strs:\\n            groupedWords[\"\".join(sorted(word))].append(word)\\n        \\n        result = []\\n        \\n        for valueSet in groupedWords.values():\\n            result.append(valueSet)\\n        \\n        return  result  \\n```\\n\\n**If You Liked the Solution Please Upvote**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        \\n        for(auto x: strs){\\n            string temp = x;\\n            sort(temp.begin(), temp.end());\\n            \\n            m[temp].push_back(x);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        \\n        for(auto x: m){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String,List<String>> hm = new HashMap<>();\\n        for(String s : strs){\\n            \\n            char[] chars=s.toCharArray();\\n            Arrays.sort(chars);\\n            String key = String.valueOf(chars);\\n            \\n            if (!hm.containsKey(key)) {\\n                hm.put(key, new ArrayList<>());\\n            }\\n            hm.get(key).add(s);\\n            \\n        }\\n        return new ArrayList<>(hm.values());\\n    }\\n```\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        groupedWords = defaultdict(list)\\n        \\n        for word in strs:\\n            groupedWords[\"\".join(sorted(word))].append(word)\\n        \\n        result = []\\n        \\n        for valueSet in groupedWords.values():\\n            result.append(valueSet)\\n        \\n        return  result  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749902,
                "title": "c-solution-using-soring-and-without-sorting-by-hashmap-with-time-complexity-analysis",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Solution using ***HashMap with sorting.***\\n- Here we store all same strings in a vector inside Hashmap.\\n- We\\u2019ll take every string from strs in temp then sort that by character. Push the main string to the map.\\n- Like these elements with the same character will push to the same vector of hashmap.\\n- Then push all the vectors from map to ans.\\n- **Time complexity:** O(n.klogk) /***k**\\xA0is the length of string and\\xA0**n**\\xA0is the total no. of strings*\\n\\n### Solution 02\\n\\n- Solution using ***Map without sorting.***\\n- Here we\\u2019ll do the same but this time we\\u2019ll take a map of map to skip the sorting part.\\n- If we could use an unordered map then time complexity could reduce to O(nk), but as it takes O(logn) time for any operations, so time takes same as solution 1.\\n- Here we count the characters in map and push it to main map.\\n- **Time complexity:** O(n.klogk) /*insertion into a map takes **logK** time*\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n = strs.size();\\n        unordered_map<string, vector<string>> mp;\\n        vector<vector<string>>ans;\\n        \\n        int i=0;\\n        while(i<n){\\n            string a = strs[i];\\n            sort(a.begin(), a.end());\\n            mp[a].push_back(strs[i]);\\n            i++;\\n        }\\n        for(auto i=mp.begin(); i!= mp.end(); i++){\\n            ans.push_back(i->second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n = strs.size();\\n        map<map<char, int>, vector<string>> mp;\\n        vector<vector<string>>ans;\\n        \\n        int i=0;\\n        while(i<n){\\n            map<char, int> a;\\n            for(int j=0; j<strs[i].size(); j++)\\n                a[strs[i][j]]++;\\n            mp[a].push_back(strs[i]);\\n            i++;\\n        }\\n        for(auto i=mp.begin(); i!= mp.end(); i++){\\n            ans.push_back(i->second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n = strs.size();\\n        unordered_map<string, vector<string>> mp;\\n        vector<vector<string>>ans;\\n        \\n        int i=0;\\n        while(i<n){\\n            string a = strs[i];\\n            sort(a.begin(), a.end());\\n            mp[a].push_back(strs[i]);\\n            i++;\\n        }\\n        for(auto i=mp.begin(); i!= mp.end(); i++){\\n            ans.push_back(i->second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n = strs.size();\\n        map<map<char, int>, vector<string>> mp;\\n        vector<vector<string>>ans;\\n        \\n        int i=0;\\n        while(i<n){\\n            map<char, int> a;\\n            for(int j=0; j<strs[i].size(); j++)\\n                a[strs[i][j]]++;\\n            mp[a].push_back(strs[i]);\\n            i++;\\n        }\\n        for(auto i=mp.begin(); i!= mp.end(); i++){\\n            ans.push_back(i->second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399451,
                "title": "group-anagrams-explanation-w-images-using-map-c-python-java",
                "content": "**Pre-requisite:**\\n*What is an Anagram?*\\nTwo strings are said to be anagrams of each other if they are made up of the same characters with same frequency. For example: the word `LISTEN` and `SILENT` are anagrams. They are composed of the letters `E, I, L, N, S, T`.\\n`Insight-` The input is only `lowercase aplhabets`\\n\\n**Algorithm:**\\n`Technique` - Group By Sorting\\n*SAMPLE CASE-*\\n![image](https://assets.leetcode.com/users/images/9e9dee48-ad03-4047-8a66-b11e8dbcac7f_1628753485.5853918.png)\\n*SORTED SAMPLE CASE-*\\n![image](https://assets.leetcode.com/users/images/12e377a3-1779-4e7c-ba97-f19fb5d390db_1628753533.013706.png)\\n* Once we have made this observation, we create a map for the same where the `key` will be the sorted string, and the `value` would be the list of all the strings that are anagrams.\\n* After iteration over all the strings, we get the desired group of anagrams\\n* The time complexity of this approach depends on the sorting technique you use to sort the strings.\\n\\n**Solution:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans ;\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<string> temp = strs ;\\n        map<string, vector<string>> mp;\\n        for(int i=0; i < temp.size() ; i++)\\n\\t\\t{\\n            string t = temp[i];\\n            sort(temp[i].begin(), temp[i].end());\\n            mp[temp[i]].push_back(t);\\n        }\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        map_dict = {}\\n        for i,string in enumerate(strs):\\n            tmp = (\"\").join(sorted(string))\\n            try:\\n                map_dict[tmp].append(strs[i])\\n            except:\\n                map_dict[tmp] = [strs[i]]\\n\\n        return list(map_dict.values())\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String ,List<String>> map = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char[] c = strs[i].toCharArray();\\n            Arrays.sort(c) ;\\n            String temp = String.valueOf(c);\\n            if(map.containsKey(temp))\\n            {\\n                List<String> list = map.get(temp);\\n                list.add(strs[i]);\\n                map.put(temp,list);\\n            }\\n            else\\n            { \\n                List<String> list = new ArrayList<>();\\n                list.add(strs[i]);\\n                map.put(temp, list);\\n            }            \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        ans.addAll(map.values());\\n        return ans;\\n    }\\n}\\n```\\n**TIME COMPLEXITY - O(N*KlogK)**, where k is the length of the largest string. \\n* This is because we are sorting string in every iteration.\\n* It would be **different for different sorting techniques** for e.g. `O(N*K) for Counting Sort`\\n\\n**SPACE COMPLEXITY - O(N*K)**\\n\\n\\n**SCRAP APPROACH:**\\n`Brute Force-` Will give TLE on Large Testcases\\n* Iterate over each string in the input array.\\n* For each string, check with each element of the array if they are anagrams.\\n* If it is an anagram, add it to a group.\\n* Else, move the string to a different group\\n\\n**Do Consider the post for upvotes if you liked it. If you find any mistakes do let me know.\\uD83D\\uDE0A\\nIf you are blindly downvoting I hope you get better and stop being jealous :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans ;\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<string> temp = strs ;\\n        map<string, vector<string>> mp;\\n        for(int i=0; i < temp.size() ; i++)\\n\\t\\t{\\n            string t = temp[i];\\n            sort(temp[i].begin(), temp[i].end());\\n            mp[temp[i]].push_back(t);\\n        }\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        map_dict = {}\\n        for i,string in enumerate(strs):\\n            tmp = (\"\").join(sorted(string))\\n            try:\\n                map_dict[tmp].append(strs[i])\\n            except:\\n                map_dict[tmp] = [strs[i]]\\n\\n        return list(map_dict.values())\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String ,List<String>> map = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char[] c = strs[i].toCharArray();\\n            Arrays.sort(c) ;\\n            String temp = String.valueOf(c);\\n            if(map.containsKey(temp))\\n            {\\n                List<String> list = map.get(temp);\\n                list.add(strs[i]);\\n                map.put(temp,list);\\n            }\\n            else\\n            { \\n                List<String> list = new ArrayList<>();\\n                list.add(strs[i]);\\n                map.put(temp, list);\\n            }            \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        ans.addAll(map.values());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566674,
                "title": "java-hashmap-solution-and-no-sorting-required",
                "content": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap();\\n        for (String s : strs) {\\n            int[] m = new int[26];\\n            for (char c : s.toCharArray()) m[c-\\'a\\']++;\\n            String key = Arrays.toString(m);\\n            map.putIfAbsent(key, new ArrayList());\\n            map.get(key).add(s);\\n        }\\n        return new ArrayList(map.values());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap();\\n        for (String s : strs) {\\n            int[] m = new int[26];\\n            for (char c : s.toCharArray()) m[c-\\'a\\']++;\\n            String key = Arrays.toString(m);\\n            map.putIfAbsent(key, new ArrayList());\\n            map.get(key).add(s);\\n        }\\n        return new ArrayList(map.values());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434805,
                "title": "concise-javascript-solution",
                "content": "```\\nvar groupAnagrams = function(strs) {\\n    /* sort each string, use that as key in map and when new sorted string matches a key we add it to that */\\n    const map = {};\\n    \\n    for (const str of strs) {\\n        const sorted = str.split(\\'\\').sort().join(\\'\\');\\n        \\n        if (!map[sorted]) {\\n            map[sorted] = [str];\\n        } else {\\n            map[sorted].push(str);\\n        }\\n    }\\n    \\n    return Object.values(map);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar groupAnagrams = function(strs) {\\n    /* sort each string, use that as key in map and when new sorted string matches a key we add it to that */\\n    const map = {};\\n    \\n    for (const str of strs) {\\n        const sorted = str.split(\\'\\').sort().join(\\'\\');\\n        \\n        if (!map[sorted]) {\\n            map[sorted] = [str];\\n        } else {\\n            map[sorted].push(str);\\n        }\\n    }\\n    \\n    return Object.values(map);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1889233,
                "title": "java-easy-hashmap",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String,ArrayList<String>> mpp = new HashMap<String,ArrayList<String>>();\\n\\n        for(String st:strs){\\n            char[] ch = st.toCharArray();\\n            Arrays.sort(ch);\\n            String ss = String.valueOf(ch);\\n            if(!mpp.containsKey(ss)) mpp.put(ss,new ArrayList<String>());\\n            mpp.get(ss).add(st);\\n        }\\n        return new ArrayList<>(mpp.values());\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String,ArrayList<String>> mpp = new HashMap<String,ArrayList<String>>();\\n\\n        for(String st:strs){\\n            char[] ch = st.toCharArray();\\n            Arrays.sort(ch);\\n            String ss = String.valueOf(ch);\\n            if(!mpp.containsKey(ss)) mpp.put(ss,new ArrayList<String>());\\n            mpp.get(ss).add(st);\\n        }\\n        return new ArrayList<>(mpp.values());\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566165,
                "title": "simple-python3-solution-using-dictionary-and-sorted-anagrams",
                "content": "The idea here is to use the sorted anagram as a key and the anagrams themselves as the values. In the end, after iterating through the list of words, you\\'ll return the values from the dictionary.\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n      anagrams = defaultdict(list)\\n      for word in strs:\\n        anagrams[\\'\\'.join(sorted(word))].append(word)\\n      return list(anagrams.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n      anagrams = defaultdict(list)\\n      for word in strs:\\n        anagrams[\\'\\'.join(sorted(word))].append(word)\\n      return list(anagrams.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412445,
                "title": "dictionary-sorting-python-easy-solution-with-explanation",
                "content": "# Intuition\\n**Find a way to associate similar words together.** \\nWe can utilize the **wo**rd **co**unt **ap**proach but I preferred the approach where you **so**rt the **wo**rd. This allows **an**agrams to be **so**rted and we can then **ma**tch the **wo**rds. \\nFor example, \\n\\n`\\'tan\\' and \\'nat\\' when sorted would become \\'ant\\' and \\'ant\\'`\\n\\n\\n\\n# Approach\\n1. Iterate over the \\'strs\\' and sort each word.\\n2. Check if the sorted word exists as key in the dictionary/hashmap\\n3. Because we are going to use the original word in the returned output,create a temp variable to store the sorted word.\\n4. Now check if the temporary sorted word exists in the dictionary/hashmap\\n5. If yes, append the word to the values list.\\n6. If no, add a new key-value pair in the dictionary/hashmap.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        # Create a dictionary to act as hashmap\\n        res = {}\\n        for word in strs:\\n            # We want to retain the original word to add to the dictionary\\n            # Therefore, create a temporary variable with the sorted word\\n            temp = \\'\\'.join(sorted(word))\\n            # If the sorted word exists in the dictionary, \\n            # append to the values list\\n            if temp in res:\\n                res[temp].append(word)\\n            # Else, add a new key-value pair to the dictionary\\n            else:\\n                res[temp] = [word]\\n        # We only require the values list to be returned\\n        return res.values()\\n\\n```\\n<br><br>\\nPlease **up**vote if you find the approach and **ex**planation **us**eful!\\n<br>",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        # Create a dictionary to act as hashmap\\n        res = {}\\n        for word in strs:\\n            # We want to retain the original word to add to the dictionary\\n            # Therefore, create a temporary variable with the sorted word\\n            temp = \\'\\'.join(sorted(word))\\n            # If the sorted word exists in the dictionary, \\n            # append to the values list\\n            if temp in res:\\n                res[temp].append(word)\\n            # Else, add a new key-value pair to the dictionary\\n            else:\\n                res[temp] = [word]\\n        # We only require the values list to be returned\\n        return res.values()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19178,
                "title": "c-clean-solution-beat-95-83-hash-map",
                "content": "```\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> h;\\n        for(int i = 0; i < strs.size(); i++){\\n            string temp = strs[i];\\n            sort(temp.begin(), temp.end());\\n            h[temp].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto m: h) ans.push_back(m.second);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> h;\\n        for(int i = 0; i < strs.size(); i++){\\n            string temp = strs[i];\\n            sort(temp.begin(), temp.end());\\n            h[temp].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto m: h) ans.push_back(m.second);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2920518,
                "title": "solution",
                "content": "```\\nvector<vector<string> > Anagrams(vector<string>& str) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,vector<string>> mp;\\n        \\n        for(auto x: str)\\n        {\\n            string temp = x;\\n            sort(x.begin(),x.end());\\n            mp[x].push_back(temp);\\n        }\\n        for(auto x: mp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n    \\n    // for this example the map will be\\n    // example:- N = 5\\n    // words[] = {act,god,cat,dog,tac}\\n    \\n    // The map will be:- \\n    // string     vector<string>\\n    // act        cat tac\\n    // god        dog\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<string> > Anagrams(vector<string>& str) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,vector<string>> mp;\\n        \\n        for(auto x: str)\\n        {\\n            string temp = x;\\n            sort(x.begin(),x.end());\\n            mp[x].push_back(temp);\\n        }\\n        for(auto x: mp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n    \\n    // for this example the map will be\\n    // example:- N = 5\\n    // words[] = {act,god,cat,dog,tac}\\n    \\n    // The map will be:- \\n    // string     vector<string>\\n    // act        cat tac\\n    // god        dog\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328466,
                "title": "c-one-pass-24ms-99-99-faster-and-15-5-mb-99-73-less-memory",
                "content": "The common idea is to use a hashmap (unordered_map) to group the strings. \\nThere are several ways to choose the key for this task.\\n\\n1. Use sorted string as key, e.g `eat` and `tea` produce the same key, `aet`.\\n2. Use a counter array and transform it to a key somehow, e.g `none` and `neon` have 2 `n`s, 1 `o` and 1 `e`.\\n3. Use a perfect (no collision) hash that produces a unique hash for each anagram.\\n\\nOption 1 is slow, because sorting takes time. Option 2 is better, but it takes more memory than necessary (`26 * sizeof(int)`), needs some transformation operation.\\n\\nFor Option 3, we could multiply each char, like `A` would become `1` and `Z` would become `26`. e.g `eat` -> `5 * 1 * 20` -> `100`, `tea` -> `20 * 5 * 1` -> `100`. Therefore, the hash is indifferent to the order of the chars.\\n\\nThe problem is these numbers are not primes, so their multiplication can cause collisions like `abebe` (not a word)-> `1 * 2 * 5 * 2 * 5` -> `100`. Actually since `A` is `1`, we can add infenitely many `A`s and still get the same hash!\\n\\nWe mentioned that these numbers were not primes, what we can do is instead of mapping `A...Z` to `1...26`, we can map each char to a different, preferably small primes. Thus, if we map each char to the first 26 primes, we can generate a unique hash for each anagram.\\n\\n\\n```\\nuint32_t hash(const string &word) {\\n\\tstatic int primes[26] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101 };\\n\\n\\tuint32_t hash = 1;\\n\\tfor (char c : word) {\\n\\t\\tint prime = primes[c - \\'a\\'];\\n\\t\\thash *= prime;\\n\\t}\\n\\treturn hash;\\n}\\n```\\n\\n**EDIT: There is a bug in this hashing function, thanks to @WillF for pointing out the overflow issue, please refer to the comments for the updated one.**\\n\\nNow for the rest, normally you\\'d see two passes for this task, one for grouping the strings and one for extracting all values of the `unorderd_map` like\\n```\\nunordered_map<uint32_t, vector<string>> mapping;\\n...\\nfor (string word : strs) { ... }\\n\\n// If only we could do `return mapping.values()`\\nvector<vector<string>> result;\\nfor (auto pair : mapping) {\\n  result.push_back(pair.second);\\n}\\n\\nreturn result;\\n```\\n\\nThis has the problem of a lot of unnecessary copying. `unordered_map` is a blackbox, what we can do is to force it to sequentially place each group by taking care of the allocation process. The key remains the same, but the value now becomes a pointer to the actual container. This way we can directly return the required container without additional passes. \\n\\n```\\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\tunordered_map<uint32_t, vector<string> *> mapping;\\n\\tvector<vector<string>> ans;\\n\\n\\t// Hack: \\n\\t//  If we reserve size beforehand, the vector will not grow \\n\\t//  during `push_back()` operations\\n\\t//  Thus, the pointers (vector<string> *) won\\'t become invalidated, i.e dangling pointers\\n\\tans.reserve(strs.size());\\n\\n\\t// Optional: \\n\\t//   Empirically, reserving 1/4th of the number of words \\n\\t//   gives the best performance\\n\\tmapping.reserve(strs.size() / 4);\\n\\n\\tfor (string word : strs) {\\n\\t\\tuint32_t h = hash(word);\\n\\n\\t\\tauto search = mapping.find(h);\\n\\t\\tif (search == mapping.end()) {\\n\\t\\t\\t// Create a new bucket for this new anagram\\n\\t\\t\\tvector<string> v { word };\\n\\t\\t\\tans.push_back(std::move(v));\\n\\n\\t\\t\\t// Note that we can\\'t also do &v because it will soon get deallocated\\n\\t\\t\\tmapping[h] = &ans.back();\\n\\t\\t} else {\\n\\t\\t\\tmapping[h]->push_back(word);\\n\\t\\t}\\n\\t\\t// This way we avoid copying the strings in the last step\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n\\nTo avoid the dangling pointer problem, instead of using references we can just store the index of the corresponding `vector<string>`, so if the `vector<vector<string>>` decides to grow, we will still access the correct container.\\n(indexes and pointers are very related concepts after all.)\\n\\n```\\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n    unordered_map<uint32_t, size_t> mapping;\\n    vector<vector<string>> ans;\\n    \\n    // Optional: Not mandatory anymore, but still helps with performance\\n    ans.reserve(strs.size());\\n    \\n    // Optional: \\n    //   Empirically, reserving 1/4th of the number of words \\n    //   gives the best performance\\n    mapping.reserve(strs.size() / 4);\\n    \\n    for (string word : strs) {\\n        uint32_t h = hash(word);\\n        \\n        auto search = mapping.find(h);\\n        if (search == mapping.end()) {\\n            // Create a new bucket for this new anagram\\n            vector<string> v { word };\\n            ans.push_back(std::move(v));\\n            \\n            // Store the corresponding vector index for this group\\n            mapping[h] = ans.size() - 1;\\n        } else {\\n            size_t index = mapping[h];\\n            ans[index].push_back(word);\\n        }\\n        // This way we avoid copying the strings in the last step\\n    }\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nuint32_t hash(const string &word) {\\n\\tstatic int primes[26] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101 };\\n\\n\\tuint32_t hash = 1;\\n\\tfor (char c : word) {\\n\\t\\tint prime = primes[c - \\'a\\'];\\n\\t\\thash *= prime;\\n\\t}\\n\\treturn hash;\\n}\\n```\n```\\nunordered_map<uint32_t, vector<string>> mapping;\\n...\\nfor (string word : strs) { ... }\\n\\n// If only we could do `return mapping.values()`\\nvector<vector<string>> result;\\nfor (auto pair : mapping) {\\n  result.push_back(pair.second);\\n}\\n\\nreturn result;\\n```\n```\\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\tunordered_map<uint32_t, vector<string> *> mapping;\\n\\tvector<vector<string>> ans;\\n\\n\\t// Hack: \\n\\t//  If we reserve size beforehand, the vector will not grow \\n\\t//  during `push_back()` operations\\n\\t//  Thus, the pointers (vector<string> *) won\\'t become invalidated, i.e dangling pointers\\n\\tans.reserve(strs.size());\\n\\n\\t// Optional: \\n\\t//   Empirically, reserving 1/4th of the number of words \\n\\t//   gives the best performance\\n\\tmapping.reserve(strs.size() / 4);\\n\\n\\tfor (string word : strs) {\\n\\t\\tuint32_t h = hash(word);\\n\\n\\t\\tauto search = mapping.find(h);\\n\\t\\tif (search == mapping.end()) {\\n\\t\\t\\t// Create a new bucket for this new anagram\\n\\t\\t\\tvector<string> v { word };\\n\\t\\t\\tans.push_back(std::move(v));\\n\\n\\t\\t\\t// Note that we can\\'t also do &v because it will soon get deallocated\\n\\t\\t\\tmapping[h] = &ans.back();\\n\\t\\t} else {\\n\\t\\t\\tmapping[h]->push_back(word);\\n\\t\\t}\\n\\t\\t// This way we avoid copying the strings in the last step\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\n```\\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n    unordered_map<uint32_t, size_t> mapping;\\n    vector<vector<string>> ans;\\n    \\n    // Optional: Not mandatory anymore, but still helps with performance\\n    ans.reserve(strs.size());\\n    \\n    // Optional: \\n    //   Empirically, reserving 1/4th of the number of words \\n    //   gives the best performance\\n    mapping.reserve(strs.size() / 4);\\n    \\n    for (string word : strs) {\\n        uint32_t h = hash(word);\\n        \\n        auto search = mapping.find(h);\\n        if (search == mapping.end()) {\\n            // Create a new bucket for this new anagram\\n            vector<string> v { word };\\n            ans.push_back(std::move(v));\\n            \\n            // Store the corresponding vector index for this group\\n            mapping[h] = ans.size() - 1;\\n        } else {\\n            size_t index = mapping[h];\\n            ans[index].push_back(word);\\n        }\\n        // This way we avoid copying the strings in the last step\\n    }\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2155441,
                "title": "rust-hashmap-solution-simple",
                "content": "```rs\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        let mut h = HashMap::new();\\n        \\n        for s in strs {\\n            let mut key: Vec<char> = s.chars().collect();\\n            key.sort();\\n            h.entry(key).or_insert(vec![]).push(s);\\n        }\\n        \\n        h.values().cloned().collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rs\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        let mut h = HashMap::new();\\n        \\n        for s in strs {\\n            let mut key: Vec<char> = s.chars().collect();\\n            key.sort();\\n            h.entry(key).or_insert(vec![]).push(s);\\n        }\\n        \\n        h.values().cloned().collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399196,
                "title": "easy-simple-concise-98-faster-well-explained",
                "content": "## IDEA :\\n* The main idea is to make the different groups for every different anagrams.\\n* Since Anagrams means to have same letters with different meanings.\\n* We can use the idea of sort to arrange them in group.\\n* Sorted word of Every Anagram words will be same.\\n****\\nEg: [\"tea\",\"eat\",\"ate] will have sorted word as **\"aet\"**. \\nHere \"aet\" can be key of dictionary and all others as values.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic=defaultdict(list)\\n        for s in strs:\\n            dic[\\'\\'.join(sorted(s))].append(s)\\n        \\n        return dic.values()\\n\\n****\\nThanks and support if you got helpful!! \\uD83E\\uDD17\\nPlease **Upvote** and feel free to ask if you have any doubt. \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA :\\n* The main idea is to make the different groups for every different anagrams.\\n* Since Anagrams means to have same letters with different meanings.\\n* We can use the idea of sort to arrange them in group.\\n* Sorted word of Every Anagram words will be same.\\n****\\nEg: [\"tea\",\"eat\",\"ate] will have sorted word as **\"aet\"**. \\nHere \"aet\" can be key of dictionary and all others as values.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic=defaultdict(list)\\n        for s in strs:\\n            dic[\\'\\'.join(sorted(s))].append(s)\\n        \\n        return dic.values()\\n\\n****\\nThanks and support if you got helpful!! \\uD83E\\uDD17\\nPlease **Upvote** and feel free to ask if you have any doubt. \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1340493,
                "title": "c-simple-short-and-easy-solution-o-nm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        string tmp_sorted;\\n        \\n        for (auto word : strs) {\\n            tmp_sorted = word;\\n            sort(tmp_sorted.begin(), tmp_sorted.end());\\n            m[tmp_sorted].push_back(word);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for (auto [word, list] : m) {\\n            res.push_back(list);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n****\\n**Faster solution, using Counting Sort, Time Complexity: O(nm)**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        string tmp_sorted;\\n        \\n        for (auto word : strs) {\\n            tmp_sorted = countSort(word);\\n            m[tmp_sorted].push_back(word);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for (auto [word, list] : m) {\\n            res.push_back(list);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    string countSort(string word) {\\n        vector<int> count(26);\\n        string res;\\n        \\n        for (auto ch : word) count[ch - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) res += string(count[i], i+\\'a\\');\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        string tmp_sorted;\\n        \\n        for (auto word : strs) {\\n            tmp_sorted = word;\\n            sort(tmp_sorted.begin(), tmp_sorted.end());\\n            m[tmp_sorted].push_back(word);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for (auto [word, list] : m) {\\n            res.push_back(list);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        string tmp_sorted;\\n        \\n        for (auto word : strs) {\\n            tmp_sorted = countSort(word);\\n            m[tmp_sorted].push_back(word);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for (auto [word, list] : m) {\\n            res.push_back(list);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    string countSort(string word) {\\n        vector<int> count(26);\\n        string res;\\n        \\n        for (auto ch : word) count[ch - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) res += string(count[i], i+\\'a\\');\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688150,
                "title": "5-line-js-solution-easy-to-understand",
                "content": "```javascript\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {\\n    let mappings = {};\\n    \\n    for(let word of strs) {\\n        // this will convert \\'eat\\' into \\'e\\',\\'a\\',\\'t\\' and then sort it to \\'a\\',\\'e\\',\\'t\\' and then join to \\'ate\\'\\n        // we do this so the sorted anagram key will always be the same. Other related anagrams will have the same key\\n        const anagramGroup = word.split(\"\").sort().join(\"\");\\n        \\n        // if we have a mapping that exists for the anagram group, push the item to that group, \\n        // else create a new array and append the word\\n        mappings[anagramGroup] ? mappings[anagramGroup].push(word) : mappings[anagramGroup] = [word];\\n    }\\n    // returns all the mappings as a unified array.\\n    return Object.values(mappings);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {\\n    let mappings = {};\\n    \\n    for(let word of strs) {\\n        // this will convert \\'eat\\' into \\'e\\',\\'a\\',\\'t\\' and then sort it to \\'a\\',\\'e\\',\\'t\\' and then join to \\'ate\\'\\n        // we do this so the sorted anagram key will always be the same. Other related anagrams will have the same key\\n        const anagramGroup = word.split(\"\").sort().join(\"\");\\n        \\n        // if we have a mapping that exists for the anagram group, push the item to that group, \\n        // else create a new array and append the word\\n        mappings[anagramGroup] ? mappings[anagramGroup].push(word) : mappings[anagramGroup] = [word];\\n    }\\n    // returns all the mappings as a unified array.\\n    return Object.values(mappings);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19338,
                "title": "sorting-python-solution-beats-100",
                "content": "Nothing fancy, just a straightforward solution using a dictionary.\\n```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        anas = {}\\n        for string in strs:\\n            s = ''.join(sorted(string))\\n            if s in anas:\\n                anas[s].append(string)\\n            else:\\n                anas[s] = [string]\\n        return [ anas[x] for x in anas ]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        anas = {}\\n        for string in strs:\\n            s = ''.join(sorted(string))\\n            if s in anas:\\n                anas[s].append(string)\\n            else:\\n                anas[s] = [string]\\n        return [ anas[x] for x in anas ]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 19329,
                "title": "simple-java-solution",
                "content": "\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\t\\tList<List<String>> res = new ArrayList<>();\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        \\n        Arrays.sort(strs);\\n        for (int i = 0; i < strs.length; i++) {\\n        \\tString temp = strs[i];\\n        \\tchar[] ch = temp.toCharArray();\\n        \\tArrays.sort(ch);\\n        \\tif (map.containsKey(String.valueOf(ch))) {\\n        \\t\\tmap.get(String.valueOf(ch)).add(strs[i]);\\n        \\t} else {\\n        \\t\\tList<String> each = new ArrayList<>();\\n        \\t\\teach.add(strs[i]);\\n        \\t\\tmap.put(String.valueOf(ch), each);\\n        \\t}\\n        }\\n        for (List<String> item: map.values()) {\\n        \\tres.add(item);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\t\\tList<List<String>> res = new ArrayList<>();\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        \\n        Arrays.sort(strs);\\n        for (int i = 0; i < strs.length; i++) {\\n        \\tString temp = strs[i];\\n        \\tchar[] ch = temp.toCharArray();\\n        \\tArrays.sort(ch);\\n        \\tif (map.containsKey(String.valueOf(ch))) {\\n        \\t\\tmap.get(String.valueOf(ch)).add(strs[i]);\\n        \\t} else {\\n        \\t\\tList<String> each = new ArrayList<>();\\n        \\t\\teach.add(strs[i]);\\n        \\t\\tmap.put(String.valueOf(ch), each);\\n        \\t}\\n        }\\n        for (List<String> item: map.values()) {\\n        \\tres.add(item);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1663675,
                "title": "solution-swift-group-anagrams-test-cases",
                "content": "```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict: [[Character]:[String]] = [:]\\n        for c in strs {\\n            let abc = c.sorted()\\n            dict[abc] == nil ? (dict[abc] = [c]) : (dict[abc]?.append(c))\\n        }\\n        return dict.map({$1})\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.022 (0.024) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.groupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"])\\n        let expected = [[\"nat\",\"tan\"],[\"bat\"],[\"ate\",\"eat\",\"tea\"]]\\n        XCTAssertEqual(value.count, expected.count)\\n        XCTAssertEqual(value.count, 3)\\n        value.forEach {\\n            XCTAssertTrue(expected.contains($0.sorted()))\\n        }\\n    }\\n    func test1() {\\n        let value = solution.groupAnagrams([\"\"])\\n        XCTAssertEqual(value, [[\"\"]])\\n    }\\n    func test2() {\\n        let value = solution.groupAnagrams([\"a\"])\\n        XCTAssertEqual(value, [[\"a\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict: [[Character]:[String]] = [:]\\n        for c in strs {\\n            let abc = c.sorted()\\n            dict[abc] == nil ? (dict[abc] = [c]) : (dict[abc]?.append(c))\\n        }\\n        return dict.map({$1})\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.groupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"])\\n        let expected = [[\"nat\",\"tan\"],[\"bat\"],[\"ate\",\"eat\",\"tea\"]]\\n        XCTAssertEqual(value.count, expected.count)\\n        XCTAssertEqual(value.count, 3)\\n        value.forEach {\\n            XCTAssertTrue(expected.contains($0.sorted()))\\n        }\\n    }\\n    func test1() {\\n        let value = solution.groupAnagrams([\"\"])\\n        XCTAssertEqual(value, [[\"\"]])\\n    }\\n    func test2() {\\n        let value = solution.groupAnagrams([\"a\"])\\n        XCTAssertEqual(value, [[\"a\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551701,
                "title": "java-tc-o-totalchars-n-sc-o-n-group-by-signature-of-each-string",
                "content": "```java\\n/**\\n * Categorize by Count of characters\\n *\\n * Time Complexity:\\n * - O(TotalChars + 26*11*2*N) -> To calculate the count of characters and create the signature using StringBuilder.\\n * - O(N) -> to generate final result List of groups.\\n * Total Time Complexity = O(TotalChars + N)\\n *\\n * Space Complexity:\\n * - O(26*11*N) -> To save signatures in HashMap.\\n *                 We do not need to count the space required for values in HashMap as they will be used in result.\\n * Total Space Complexity = O(N)\\n *\\n * N = Number of strings in strs array.\\n */\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (strs == null || strs.length == 0) {\\n            return result;\\n        }\\n        if (strs.length == 1) {\\n            result.add(Arrays.asList(strs));\\n            return result;\\n        }\\n\\n        HashMap<String, List<String>> groups = new HashMap<>();\\n        for (String s : strs) {\\n            String signature = getSignature(s);\\n            groups.putIfAbsent(signature, new ArrayList<>());\\n            groups.get(signature).add(s);\\n        }\\n\\n        return new ArrayList<>(groups.values());\\n    }\\n\\n    private String getSignature(String s) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                sb.append((char) (\\'a\\' + i)).append(count[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```java\\n/**\\n * Categorize by Count of characters\\n *\\n * Time Complexity:\\n * - O(TotalChars + 26*11*2*N) -> To calculate the count of characters and create the signature using StringBuilder.\\n * - O(N) -> to generate final result List of groups.\\n * Total Time Complexity = O(TotalChars + N)\\n *\\n * Space Complexity:\\n * - O(26*11*N) -> To save signatures in HashMap.\\n *                 We do not need to count the space required for values in HashMap as they will be used in result.\\n * Total Space Complexity = O(N)\\n *\\n * N = Number of strings in strs array.\\n */\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (strs == null || strs.length == 0) {\\n            return result;\\n        }\\n        if (strs.length == 1) {\\n            result.add(Arrays.asList(strs));\\n            return result;\\n        }\\n\\n        HashMap<String, List<String>> groups = new HashMap<>();\\n        for (String s : strs) {\\n            String signature = getSignature(s);\\n            groups.putIfAbsent(signature, new ArrayList<>());\\n            groups.get(signature).add(s);\\n        }\\n\\n        return new ArrayList<>(groups.values());\\n    }\\n\\n    private String getSignature(String s) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                sb.append((char) (\\'a\\' + i)).append(count[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19441,
                "title": "simple-javascript-solution",
                "content": "    var groupAnagrams = function(strs) {\\n        strs = strs.sort();\\n        var mapping = {};\\n        for (var i = 0; i < strs.length; i++) {\\n            var str = strs[i];\\n            var sorted = str.split('').sort().join('');\\n            \\n            if (mapping[sorted] === undefined) {\\n                mapping[sorted] = [str];\\n            } else {\\n                mapping[sorted].push(str);\\n            }\\n        }\\n        \\n        var output = [];\\n        for (var arr in mapping) {\\n            output.push(mapping[arr]);\\n        }\\n        \\n        return output;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var groupAnagrams = function(strs) {\\n        strs = strs.sort();\\n        var mapping = {};\\n        for (var i = 0; i < strs.length; i++) {\\n            var str = strs[i];\\n            var sorted = str.split('').sort().join('');\\n            \\n            if (mapping[sorted] === undefined) {\\n                mapping[sorted] = [str];\\n            } else {\\n                mapping[sorted].push(str);\\n            }\\n        }\\n        \\n        var output = [];\\n        for (var arr in mapping) {\\n            output.push(mapping[arr]);\\n        }\\n        \\n        return output;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 4055371,
                "title": "java-using-a-map-sorting-beats-98-95",
                "content": "# Intuition\\nThis problem is about grouping words that are anagrams of each other. An anagram is a word formed by rearranging the letters of another word.\\n\\n\\n# Approach\\nWe use a HashMap to efficiently group anagrams. The key is the sorted version of a word, and the value is a list of anagrams.\\n- We initialize an empty list called `result` to store the grouped anagrams.\\n- First, we check if the input `strs` is empty or null. If it is, we return an empty result.\\n- If `strs` contains only one word, we wrap it in a list and return it because there are no other words to group.\\n- We then go through each word in the `strs` array.\\n  - We convert each word into a character array (`charArray`).\\n  - We sort the character array, creating the sorted version of the word (`sortedWord`).\\n  - If `map` does not contain `sortedWord` as a key, we initialize an empty list for that key.\\n  - We add the word to the list corresponding to `sortedWord`.\\n- After processing all words, we have grouped the anagrams inside the `map`.\\n- We extract the lists of anagrams from the `map` values and add them to the `result` list.\\n- Finally, we return the grouped anagrams as the result.\\n\\n# Complexity\\n- Time complexity: O(N * K * log(K))\\n  - N represents the number of words in the `strs` array.\\n  - K represents the maximum length of a word.\\n  - The algorithm iterates through each word (N operations), sorts each word (K * log(K) time complexity), and performs constant-time operations. The dominant factor is the sorting step, resulting in a time complexity of O(N * K * log(K)).\\n\\n- Space complexity: O(N * K)\\n  - The algorithm uses a HashMap to store sorted words as keys and lists of anagrams as values. In the worst case, assuming each word is unique and has a length of K, the space complexity is O(N * K).\\n\\n\\n# Code\\n```\\nclass Solution {\\n  public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        HashMap<String,List<String>> map=new HashMap<>();\\n\\n        List<List<String>> result = new ArrayList<>();\\n\\n\\n        for (String word: strs\\n        ) {\\n            char[] charArray = word.toCharArray();\\n\\n\\n            Arrays.sort(charArray);\\n\\n            String sortedWord = String.valueOf(charArray);\\n\\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }\\n\\n\\n            map.get(sortedWord).add(word);\\n\\n\\n        }\\n        result.addAll(map.values());\\n\\n        return result;\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/4bcbbb97-7806-4680-af9a-63b251d79b5e_1694947233.8470142.webp)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        HashMap<String,List<String>> map=new HashMap<>();\\n\\n        List<List<String>> result = new ArrayList<>();\\n\\n\\n        for (String word: strs\\n        ) {\\n            char[] charArray = word.toCharArray();\\n\\n\\n            Arrays.sort(charArray);\\n\\n            String sortedWord = String.valueOf(charArray);\\n\\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }\\n\\n\\n            map.get(sortedWord).add(word);\\n\\n\\n        }\\n        result.addAll(map.values());\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665489,
                "title": "python-clean-with-dictionary",
                "content": "\\n```\\ndef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        anagrams = {}\\n        for word in strs:\\n            sortedWord = \"\".join(sorted(word))\\n            if sortedWord in anagrams:\\n                anagrams[sortedWord].append(word)\\n            else:\\n                anagrams[sortedWord] = [word]\\n        return list(anagrams.values())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        anagrams = {}\\n        for word in strs:\\n            sortedWord = \"\".join(sorted(word))\\n            if sortedWord in anagrams:\\n                anagrams[sortedWord].append(word)\\n            else:\\n                anagrams[sortedWord] = [word]\\n        return list(anagrams.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1334481,
                "title": "c-easy-to-understand-fast-and-efficient-code-using-hashtables",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string> > mp;\\n        string t;\\n        for(int i=0;i<strs.size();i++)\\n        {\\n             t=strs[i];\\n             sort(t.begin(),t.end());\\n             mp[t].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto pr:mp)\\n        {\\n            ans.push_back(pr.second);\\n        }\\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string> > mp;\\n        string t;\\n        for(int i=0;i<strs.size();i++)\\n        {\\n             t=strs[i];\\n             sort(t.begin(),t.end());\\n             mp[t].push_back(strs[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1083044,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        if (strs == null || strs.Length == 0)\\n            return new List<IList<string>>();\\n        \\n        List<IList<string>> res = new List<IList<string>>();\\n        Dictionary<string, List<string>> dict = new Dictionary<string, List<string>>();\\n        \\n        foreach (var str in strs)\\n        {\\n            string cur = new string(str.OrderBy(x => x).ToArray());\\n            \\n            if (!dict.ContainsKey(cur))\\n                dict.Add(cur, new List<string>());\\n            \\n            dict[cur].Add(str);\\n        }\\n        \\n        foreach (var item in dict.Values)\\n            res.Add(item);\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        if (strs == null || strs.Length == 0)\\n            return new List<IList<string>>();\\n        \\n        List<IList<string>> res = new List<IList<string>>();\\n        Dictionary<string, List<string>> dict = new Dictionary<string, List<string>>();\\n        \\n        foreach (var str in strs)\\n        {\\n            string cur = new string(str.OrderBy(x => x).ToArray());\\n            \\n            if (!dict.ContainsKey(cur))\\n                dict.Add(cur, new List<string>());\\n            \\n            dict[cur].Add(str);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3421522,
                "title": "c-optimized-o-nk-without-sorting-map-of-map-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmap of map technique. map inside map. the inner map should be of size 26.  (O(nk))\\n\\n`map<map<char,int>,vector<string>> mp`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nk)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        vector<vector<string>> ans;\\n\\n        map<map<char,int>, vector<string>> mp;\\n        int n = strs.size();\\n        string temp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            map<char,int> temp;\\n            for(char c:strs[i]){\\n                temp[c]++;\\n            }\\n\\n            mp[temp].push_back(strs[i]);\\n        }\\n\\n\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            ans.push_back(itr->second);\\n        }\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        vector<vector<string>> ans;\\n\\n        map<map<char,int>, vector<string>> mp;\\n        int n = strs.size();\\n        string temp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            map<char,int> temp;\\n            for(char c:strs[i]){\\n                temp[c]++;\\n            }\\n\\n            mp[temp].push_back(strs[i]);\\n        }\\n\\n\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            ans.push_back(itr->second);\\n        }\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750624,
                "title": "fastest-solution-possible-short-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic={}\\n        for a in(strs):\\n            t=list(a)\\n            t.sort()\\n            t=\"\".join(t)\\n            if(t in dic):\\n                dic[t].append(a)\\n            else:\\n                dic[t]=[a]\\n        ans=[]\\n        for a in dic:\\n            ans.append(dic[a])\\n        return(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic={}\\n        for a in(strs):\\n            t=list(a)\\n            t.sort()\\n            t=\"\".join(t)\\n            if(t in dic):\\n                dic[t].append(a)\\n            else:\\n                dic[t]=[a]\\n        ans=[]\\n        for a in dic:\\n            ans.append(dic[a])\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909435,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var map: [String: [String]] = [:]\\n        var res: [[String]] = []\\n\\n        \\n        func sort(_ str: String) -> String {\\n            var chars = Array(str)\\n            let sorted = chars.sorted()\\n            var string = \"\"\\n            for c in sorted { string += String(c) }\\n            return string\\n        }\\n\\n        for str in strs {\\n            let sorted_str = sort(str)\\n            if let _ = map[sorted_str] {\\n                map[sorted_str]?.append(str)\\n            } else {\\n                map[sorted_str] = [str]\\n            }\\n        }\\n        for (_, value) in map { res.append(value) }        \\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var map: [String: [String]] = [:]\\n        var res: [[String]] = []\\n\\n        \\n        func sort(_ str: String) -> String {\\n            var chars = Array(str)\\n            let sorted = chars.sorted()\\n            var string = \"\"\\n            for c in sorted { string += String(c) }\\n            return string\\n        }\\n\\n        for str in strs {\\n            let sorted_str = sort(str)\\n            if let _ = map[sorted_str] {\\n                map[sorted_str]?.append(str)\\n            } else {\\n                map[sorted_str] = [str]\\n            }\\n        }\\n        for (_, value) in map { res.append(value) }        \\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521631,
                "title": "in-c-what-a-pain",
                "content": "```\\nstruct word {\\n    char sorted[256];\\n    char s[256];\\n    UT_hash_handle hh;\\n};\\n\\nint comp(const void *aa, const void *bb)\\n{\\n    char a, b;\\n    a = *(char *)aa;\\n    b = *(char *)bb;\\n    \\n    if (a < b)\\n        return -1;\\n    else if (a > b)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nchar *sort_string(char *s)\\n{\\n    char *rs = malloc(strlen(s)+1);\\n    assert(rs);\\n    strcpy(rs, s);\\n    qsort((void *)rs, strlen(rs), 1, comp);\\n    return rs;\\n}\\n\\nint word_sort(struct word *a, struct word *b) {\\n    return strcmp(a->sorted,b->sorted);\\n}\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nchar *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){\\n    struct word *w, *tmp;\\n    int i;\\n    struct word *words = NULL;\\n    \\n    for (i = 0; i < strsSize; i++) {\\n        char *sorted = sort_string(strs[i]);\\n        w = (struct word *)malloc(sizeof *w);\\n        strncpy(w->sorted, sorted, 256);\\n        strncpy(w->s, strs[i], 256);\\n        HASH_ADD_STR( words, sorted, w );\\n        free(sorted);\\n    }\\n    \\n    char ***ret = malloc(strsSize * sizeof(char *));\\n    int *retcolsizes = malloc(strsSize * sizeof(int));\\n    *returnColumnSizes = retcolsizes;\\n    assert(*returnColumnSizes);\\n    assert(ret);\\n    \\n    *returnSize = -1;\\n    char *anagram = NULL;\\n    \\n    /* XXX: what we would like is something like (python):\\n     *      return dic.values();\\n     * I know its C, but there has to be a better way.\\n     */\\n    HASH_SORT(words, word_sort);\\n    HASH_ITER(hh, words, w, tmp) {\\n        if (anagram != NULL && strcmp(w->sorted, anagram) == 0) {\\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc\\'ed\\n            retcolsizes[*returnSize] += 1;\\n        } else {\\n            *returnSize += 1;\\n            ret[*returnSize] = malloc(strsSize * sizeof(char *));\\n            assert(ret[*returnSize]);\\n            retcolsizes[*returnSize] = 0;\\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc\\'ed\\n            retcolsizes[*returnSize] += 1;\\n            anagram = w->sorted;\\n        }\\n    }\\n    \\n    /* XXX: we are leaking a bunch of memory for the struct word\\'s*/\\n    *returnSize += 1;\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct word {\\n    char sorted[256];\\n    char s[256];\\n    UT_hash_handle hh;\\n};\\n\\nint comp(const void *aa, const void *bb)\\n{\\n    char a, b;\\n    a = *(char *)aa;\\n    b = *(char *)bb;\\n    \\n    if (a < b)\\n        return -1;\\n    else if (a > b)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nchar *sort_string(char *s)\\n{\\n    char *rs = malloc(strlen(s)+1);\\n    assert(rs);\\n    strcpy(rs, s);\\n    qsort((void *)rs, strlen(rs), 1, comp);\\n    return rs;\\n}\\n\\nint word_sort(struct word *a, struct word *b) {\\n    return strcmp(a->sorted,b->sorted);\\n}\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nchar *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){\\n    struct word *w, *tmp;\\n    int i;\\n    struct word *words = NULL;\\n    \\n    for (i = 0; i < strsSize; i++) {\\n        char *sorted = sort_string(strs[i]);\\n        w = (struct word *)malloc(sizeof *w);\\n        strncpy(w->sorted, sorted, 256);\\n        strncpy(w->s, strs[i], 256);\\n        HASH_ADD_STR( words, sorted, w );\\n        free(sorted);\\n    }\\n    \\n    char ***ret = malloc(strsSize * sizeof(char *));\\n    int *retcolsizes = malloc(strsSize * sizeof(int));\\n    *returnColumnSizes = retcolsizes;\\n    assert(*returnColumnSizes);\\n    assert(ret);\\n    \\n    *returnSize = -1;\\n    char *anagram = NULL;\\n    \\n    /* XXX: what we would like is something like (python):\\n     *      return dic.values();\\n     * I know its C, but there has to be a better way.\\n     */\\n    HASH_SORT(words, word_sort);\\n    HASH_ITER(hh, words, w, tmp) {\\n        if (anagram != NULL && strcmp(w->sorted, anagram) == 0) {\\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc\\'ed\\n            retcolsizes[*returnSize] += 1;\\n        } else {\\n            *returnSize += 1;\\n            ret[*returnSize] = malloc(strsSize * sizeof(char *));\\n            assert(ret[*returnSize]);\\n            retcolsizes[*returnSize] = 0;\\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc\\'ed\\n            retcolsizes[*returnSize] += 1;\\n            anagram = w->sorted;\\n        }\\n    }\\n    \\n    /* XXX: we are leaking a bunch of memory for the struct word\\'s*/\\n    *returnSize += 1;\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235518,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {  \\n    const m = new Map();\\n    \\n    for(const s of strs) {\\n        const keys = Array(26).fill(0);\\n        for(const c of s){\\n            ++keys[c.charCodeAt(0) - 97]\\n        }\\n        const key = keys.join(\"#\");\\n        let val = [];\\n        if(m.has(key)) {\\n            val = m.get(key)\\n        }  \\n        val.push(s);\\n        m.set(key, val);\\n    }\\n \\n    return Array.from(m.values());\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {  \\n    const m = new Map();\\n    \\n    for(const s of strs) {\\n        const keys = Array(26).fill(0);\\n        for(const c of s){\\n            ++keys[c.charCodeAt(0) - 97]\\n        }\\n        const key = keys.join(\"#\");\\n        let val = [];\\n        if(m.has(key)) {\\n            val = m.get(key)\\n        }  \\n        val.push(s);\\n        m.set(key, val);\\n    }\\n \\n    return Array.from(m.values());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043475,
                "title": "java-easy-to-understand-very-easy-solution-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs){\\n        List<List<String>>s=new ArrayList<>();\\n        Map<String,List<String>>map=new LinkedHashMap<>();\\n        \\n        for(String e:strs){\\n            char ch[]=e.toCharArray();\\n            Arrays.sort(ch);\\n            String str=new String(ch);\\n            \\n            if(!map.containsKey(str)){\\n                map.put(str,new ArrayList<>());\\n            }\\n            map.get(str).add(e);\\n        }\\n        s.addAll(map.values());\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs){\\n        List<List<String>>s=new ArrayList<>();\\n        Map<String,List<String>>map=new LinkedHashMap<>();\\n        \\n        for(String e:strs){\\n            char ch[]=e.toCharArray();\\n            Arrays.sort(ch);\\n            String str=new String(ch);\\n            \\n            if(!map.containsKey(str)){\\n                map.put(str,new ArrayList<>());\\n            }\\n            map.get(str).add(e);\\n        }\\n        s.addAll(map.values());\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750714,
                "title": "java-solution-using-hashmap-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] str) {\\n        int n=str.length;\\n        HashMap<String,ArrayList<String>> hm=new HashMap<>();\\n        List<List<String>> list=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            char [] ch=str[i].toCharArray();\\n            Arrays.sort(ch);\\n            String temp=new String(ch);\\n            if(hm.containsKey(temp)){\\n                hm.get(temp).add(str[i]);\\n            }\\n            else{\\n                ArrayList<String> t=new ArrayList<>();\\n                t.add(str[i]);\\n                hm.put(temp,t);\\n            }\\n        }\\n        \\n        for(String key:hm.keySet()){\\n            list.add(hm.get(key));\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] str) {\\n        int n=str.length;\\n        HashMap<String,ArrayList<String>> hm=new HashMap<>();\\n        List<List<String>> list=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            char [] ch=str[i].toCharArray();\\n            Arrays.sort(ch);\\n            String temp=new String(ch);\\n            if(hm.containsKey(temp)){\\n                hm.get(temp).add(str[i]);\\n            }\\n            else{\\n                ArrayList<String> t=new ArrayList<>();\\n                t.add(str[i]);\\n                hm.put(temp,t);\\n            }\\n        }\\n        \\n        for(String key:hm.keySet()){\\n            list.add(hm.get(key));\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190927,
                "title": "c-very-simple-solution",
                "content": "\\n\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n            Dictionary<string, IList<string>> dic = new Dictionary<string, IList<string>>();\\n            for (int i = 0; i < strs.Length; i++)\\n            {\\n                char[] arr=strs[i].ToCharArray();\\n                Array.Sort(arr);\\n                string sorted=new string(arr);\\n                if(dic.ContainsKey(sorted))\\n                {\\n                    dic[sorted].Add(strs[i]);\\n                }\\n                else\\n                {\\n                    dic.Add(sorted, new List<string>() {strs[i]});\\n                }\\n            }\\n            var result= dic.Values.ToList();\\n            return result;        \\n    }",
                "solutionTags": [
                    "C#"
                ],
                "code": "\\n\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n            Dictionary<string, IList<string>> dic = new Dictionary<string, IList<string>>();\\n            for (int i = 0; i < strs.Length; i++)\\n            {\\n                char[] arr=strs[i].ToCharArray();\\n                Array.Sort(arr);\\n                string sorted=new string(arr);\\n                if(dic.ContainsKey(sorted))\\n                {\\n                    dic[sorted].Add(strs[i]);\\n                }\\n                else\\n                {\\n                    dic.Add(sorted, new List<string>() {strs[i]});\\n                }\\n            }\\n            var result= dic.Values.ToList();\\n            return result;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1362905,
                "title": "javascript",
                "content": "*Runtime*: **136 ms**, faster than **67.24%** of JavaScript online submissions for Group Anagrams.\\n*Memory Usage*:** 49.7 MB**, less than **71.58%** of JavaScript online submissions for Group Anagrams.\\n\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nconst groupAnagrams = function(strs) {\\n    let groups = {}\\n    strs.forEach(str => {\\n        const sortedStr = str.split(\\'\\').sort().join(\\'\\')\\n        if (groups[sortedStr]) {\\n            groups[sortedStr].push(str)\\n        } else {\\n            groups[sortedStr] = [str]\\n        }\\n    })\\n    return Object.values(groups)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nconst groupAnagrams = function(strs) {\\n    let groups = {}\\n    strs.forEach(str => {\\n        const sortedStr = str.split(\\'\\').sort().join(\\'\\')\\n        if (groups[sortedStr]) {\\n            groups[sortedStr].push(str)\\n        } else {\\n            groups[sortedStr] = [str]\\n        }\\n    })\\n    return Object.values(groups)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 436097,
                "title": "concise-go-golang-solution",
                "content": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    hm := make(map[string][]string)\\n    for _, w := range strs {\\n        key := sortString(w)\\n        hm[key] = append(hm[key], w)\\n    }\\n    \\n    var ans [][]string\\n    for _, words := range hm {\\n        ans = append(ans, words)\\n    }\\n    return ans\\n}\\n\\nfunc sortString(str string) string {\\n    runes := []rune(str)\\n    sort.Slice(runes, func(a, b int) bool {\\n        return runes[a] < runes[b]\\n    })\\n    return string(runes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    hm := make(map[string][]string)\\n    for _, w := range strs {\\n        key := sortString(w)\\n        hm[key] = append(hm[key], w)\\n    }\\n    \\n    var ans [][]string\\n    for _, words := range hm {\\n        ans = append(ans, words)\\n    }\\n    return ans\\n}\\n\\nfunc sortString(str string) string {\\n    runes := []rune(str)\\n    sort.Slice(runes, func(a, b int) bool {\\n        return runes[a] < runes[b]\\n    })\\n    return string(runes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 267058,
                "title": "straightforward-python3-solution",
                "content": "```\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dict = {}        \\n        for str in strs:\\n            key_str = \\'\\'.join(sorted(str))\\n            if key_str in dict:\\n                dict[key_str].append(str)                \\n            else:\\n                dict[key_str] = [str]\\n\\n        return list(dict.values())\\n```",
                "solutionTags": [],
                "code": "```\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dict = {}        \\n        for str in strs:\\n            key_str = \\'\\'.join(sorted(str))\\n            if key_str in dict:\\n                dict[key_str].append(str)                \\n            else:\\n                dict[key_str] = [str]\\n\\n        return list(dict.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3579337,
                "title": "fastest-way-to-solve-this-question-beats-97-36",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires grouping anagrams together in a given array of strings. Two strings are considered anagrams if they have the same characters, but in a different order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an empty hash map, map, to store the grouped anagrams.\\n\\n2. Iterate through each string, str, in the input array strs:\\n\\n3. Convert str into a character array, chars.\\n\\n4. Sort chars in non-decreasing order.\\n\\n5. Convert chars back to a string, sortedStr.\\n\\n6. If sortedStr is not present in map, add it as a new key with an empty list as the value.\\n\\n7. Append str to the list associated with sortedStr in map.\\n\\n8. Return a new ArrayList containing all the values (lists of anagrams) from map.\\n\\n# Complexity\\n- Time complexity:O(n * m * log m), where n is the number of strings in the input array and m is the maximum length of a string. Sorting each string takes O(m * log m) time, and we do this for each of the n strings.\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m), the space used by the hash map map and the returned ArrayList, where n is the number of strings and m is the maximum length of a string.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs.length == 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        for (String i : strs) {\\n            char[] chars = i.toCharArray();\\n            Arrays.sort(chars);\\n            String sortedStr = String.valueOf(chars);\\n            \\n            if (!map.containsKey(sortedStr)) {\\n                map.put(sortedStr, new ArrayList<>());\\n            }\\n            \\n            map.get(sortedStr).add(i);\\n        }\\n        \\n        return new ArrayList<>(map.values());\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs.length == 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        for (String i : strs) {\\n            char[] chars = i.toCharArray();\\n            Arrays.sort(chars);\\n            String sortedStr = String.valueOf(chars);\\n            \\n            if (!map.containsKey(sortedStr)) {\\n                map.put(sortedStr, new ArrayList<>());\\n            }\\n            \\n            map.get(sortedStr).add(i);\\n        }\\n        \\n        return new ArrayList<>(map.values());\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753997,
                "title": "js-ts-solution-hashing-fast-simple-intuitive",
                "content": "# Code\\n```\\nfunction groupAnagrams(strs: string[]): string[][] {\\n    let map = new Map<string, string[]>();\\n    for (let s of strs) {\\n        let charFreq = Array.from({ length: 26 }, () => 0);\\n        for (let i = 0; i < s.length; i++)charFreq[s.charCodeAt(i) - 97]++;\\n        let keyStr = charFreq.toString();\\n        if (!map.has(keyStr)) map.set(keyStr, []);\\n        map.get(keyStr).push(s);\\n    }\\n    return Array.from(map.values());\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nfunction groupAnagrams(strs: string[]): string[][] {\\n    let map = new Map<string, string[]>();\\n    for (let s of strs) {\\n        let charFreq = Array.from({ length: 26 }, () => 0);\\n        for (let i = 0; i < s.length; i++)charFreq[s.charCodeAt(i) - 97]++;\\n        let keyStr = charFreq.toString();\\n        if (!map.has(keyStr)) map.set(keyStr, []);\\n        map.get(keyStr).push(s);\\n    }\\n    return Array.from(map.values());\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2750765,
                "title": "python3-5-lines-w-example-t-m-98-99",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\\n        \\n        anadict = defaultdict(list)     # Ex: [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]                     \\n        \\n        for s in strs:                  #  s   ana  anadict   \\n            ana = \\'\\'.join(sorted(s))    # \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\n            anadict[ana].append(s)      # eat  aet  {\\'aet\\': [\\'eat\\']}\\n                                        # tea  aet  {\\'aet\\': [\\'eat\\', \\'tea\\']}\\n                                        # tan  ant  {\\'aet\\': [\\'eat\\', \\'tea\\'], \\'ant\\': [\\'tan\\']}\\n                                        # ate  aet  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\']}\\n                                        # nat  ant  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\', \\'nat\\']}\\n                                        # bat  abt  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\', \\'nat\\'], \\'abt\\': [\\'bat\\']}\\n\\n        return list(anadict.values())   # [[\\'eat\\', \\'tea\\', \\'ate\\'], [\\'tan\\', \\'nat\\'], [\\'bat\\']]\\n```\\n\\n[https://leetcode.com/submissions/detail/583502656/](http://)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\\n        \\n        anadict = defaultdict(list)     # Ex: [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]                     \\n        \\n        for s in strs:                  #  s   ana  anadict   \\n            ana = \\'\\'.join(sorted(s))    # \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\n            anadict[ana].append(s)      # eat  aet  {\\'aet\\': [\\'eat\\']}\\n                                        # tea  aet  {\\'aet\\': [\\'eat\\', \\'tea\\']}\\n                                        # tan  ant  {\\'aet\\': [\\'eat\\', \\'tea\\'], \\'ant\\': [\\'tan\\']}\\n                                        # ate  aet  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\']}\\n                                        # nat  ant  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\', \\'nat\\']}\\n                                        # bat  abt  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\', \\'nat\\'], \\'abt\\': [\\'bat\\']}\\n\\n        return list(anadict.values())   # [[\\'eat\\', \\'tea\\', \\'ate\\'], [\\'tan\\', \\'nat\\'], [\\'bat\\']]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595584,
                "title": "solution",
                "content": "```\\nvector<vector<string> > Anagrams(vector<string>& str) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,vector<string>> mp;\\n        \\n        for(auto x: str)\\n        {\\n            string temp = x;\\n            sort(x.begin(),x.end());\\n            mp[x].push_back(temp);\\n        }\\n        for(auto x: mp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n    \\n    // for this example the map will be\\n    // example:- N = 5\\n    // words[] = {act,god,cat,dog,tac}\\n    \\n    // The map will be:- \\n    // string     vector<string>\\n    // act        cat tac\\n    // god        dog\\n\\t```",
                "solutionTags": [],
                "code": "```\\nvector<vector<string> > Anagrams(vector<string>& str) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,vector<string>> mp;\\n        \\n        for(auto x: str)\\n        {\\n            string temp = x;\\n            sort(x.begin(),x.end());\\n            mp[x].push_back(temp);\\n        }\\n        for(auto x: mp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n    \\n    // for this example the map will be\\n    // example:- N = 5\\n    // words[] = {act,god,cat,dog,tac}\\n    \\n    // The map will be:- \\n    // string     vector<string>\\n    // act        cat tac\\n    // god        dog\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 19264,
                "title": "map-lambda-list-comprehension-3-lines-of-python",
                "content": "    def anagrams(self, strs):\\n        dic = defaultdict(list)\\n        map(lambda item: dic[''.join(sorted(item))].append(item), strs)\\n        return [x for key in dic.keys() for x in dic[key] if len(dic[key]) > 1]\\n\\nEquivalent to:\\n\\n    def anagrams(self, strs):\\n        dic = defaultdict(list)\\n        for item in strs:\\n            after = ''.join(sorted(item))\\n            dic[after].append(item)\\n        ans = []\\n        for item in dic:\\n            values = dic[item]\\n            if len(values) > 1:\\n                ans.extend(values)\\n        return ans",
                "solutionTags": [],
                "code": "    def anagrams(self, strs):\\n        dic = defaultdict(list)\\n        map(lambda item: dic[''.join(sorted(item))].append(item), strs)\\n        return [x for key in dic.keys() for x in dic[key] if len(dic[key]) > 1]\\n\\nEquivalent to:\\n\\n    def anagrams(self, strs):\\n        dic = defaultdict(list)\\n        for item in strs:\\n            after = ''.join(sorted(item))\\n            dic[after].append(item)\\n        ans = []\\n        for item in dic:\\n            values = dic[item]\\n            if len(values) > 1:\\n                ans.extend(values)\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 4006990,
                "title": "three-simple-java-solutions-runtime-5ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# code1\\nRuntime 5ms\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n        HashMap<String , ArrayList<String>> hashmap = new HashMap<>();\\n\\n        for (String s : strs)\\n        {\\n            char chars[] = s.toCharArray();\\n            Arrays.sort(chars);\\n            String s2 = new String(chars);\\n            \\n            List<String> arr = hashmap.computeIfAbsent(s2, key -> new ArrayList<>());\\n            arr.add(s);\\n        }\\n\\n        return new ArrayList<>(hashmap.values());\\n    }\\n}\\n```\\n\\n# Code2\\nRuntime 9ms\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n        List<List<String>> list = new LinkedList<>();\\n\\n        HashMap<String , ArrayList<String>> hashmap = new HashMap<>();\\n\\n        for (String s : strs)\\n        {\\n            char c1[] = s.toCharArray();\\n            Arrays.sort(c1);\\n            StringBuilder s2 = new StringBuilder();\\n            for (char c : c1)\\n            {\\n                s2.append(c);\\n            }\\n            List<String> arr = hashmap.computeIfAbsent(s2.toString(), key -> new ArrayList<>());\\n            arr.add(s);\\n        }\\n\\n        for(Map.Entry<String, ArrayList<String>> entry : hashmap.entrySet()) {\\n            List<String> l1 = new LinkedList<>();\\n            for (String s : entry.getValue()){\\n                l1.add(s);\\n            }\\n            list.add(l1);\\n        }\\n\\n        return list;\\n    }\\n}\\n\\n```\\n\\n\\n# code3\\nRuntime 670ms\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n      List<List<String>> list = new LinkedList<>();\\n\\n        ArrayList<String> str1 = new ArrayList<>(strs.length);\\n\\n        for (int i = 0 ; i < strs.length ; i++)\\n        {\\n            char c1[] = strs[i].toCharArray();\\n            Arrays.sort(c1);\\n            StringBuilder s2 = new StringBuilder();\\n            for (char c : c1) {\\n                s2.append(c);\\n            }\\n            str1.add(s2.toString());\\n        }\\n\\n        for (int i = 0; i < str1.size() ; i++)\\n        {\\n            List<String> l1 = new LinkedList<>();\\n            String temp = str1.get(i).toString();\\n            if (temp != \"-1\") {\\n                int index = i;\\n                while (index != -1) {\\n                    str1.set(index, \"-1\");\\n                    l1.add(strs[index]);\\n                    index = str1.indexOf(temp);\\n                }\\n\\n                list.add(l1);\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/54abaa5f-db31-440b-9104-9e18facf6608_1693939907.7778165.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n        HashMap<String , ArrayList<String>> hashmap = new HashMap<>();\\n\\n        for (String s : strs)\\n        {\\n            char chars[] = s.toCharArray();\\n            Arrays.sort(chars);\\n            String s2 = new String(chars);\\n            \\n            List<String> arr = hashmap.computeIfAbsent(s2, key -> new ArrayList<>());\\n            arr.add(s);\\n        }\\n\\n        return new ArrayList<>(hashmap.values());\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n        List<List<String>> list = new LinkedList<>();\\n\\n        HashMap<String , ArrayList<String>> hashmap = new HashMap<>();\\n\\n        for (String s : strs)\\n        {\\n            char c1[] = s.toCharArray();\\n            Arrays.sort(c1);\\n            StringBuilder s2 = new StringBuilder();\\n            for (char c : c1)\\n            {\\n                s2.append(c);\\n            }\\n            List<String> arr = hashmap.computeIfAbsent(s2.toString(), key -> new ArrayList<>());\\n            arr.add(s);\\n        }\\n\\n        for(Map.Entry<String, ArrayList<String>> entry : hashmap.entrySet()) {\\n            List<String> l1 = new LinkedList<>();\\n            for (String s : entry.getValue()){\\n                l1.add(s);\\n            }\\n            list.add(l1);\\n        }\\n\\n        return list;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n      List<List<String>> list = new LinkedList<>();\\n\\n        ArrayList<String> str1 = new ArrayList<>(strs.length);\\n\\n        for (int i = 0 ; i < strs.length ; i++)\\n        {\\n            char c1[] = strs[i].toCharArray();\\n            Arrays.sort(c1);\\n            StringBuilder s2 = new StringBuilder();\\n            for (char c : c1) {\\n                s2.append(c);\\n            }\\n            str1.add(s2.toString());\\n        }\\n\\n        for (int i = 0; i < str1.size() ; i++)\\n        {\\n            List<String> l1 = new LinkedList<>();\\n            String temp = str1.get(i).toString();\\n            if (temp != \"-1\") {\\n                int index = i;\\n                while (index != -1) {\\n                    str1.set(index, \"-1\");\\n                    l1.add(strs[index]);\\n                    index = str1.indexOf(temp);\\n                }\\n\\n                list.add(l1);\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566051,
                "title": "anagram-grouping-using-hash-table",
                "content": "# Intuition\\nThis one took a bit of time. I first though about counting characters in individual strings and then lifting them out of the vector one-by-one by matching the character counts. After some trial and error I got that to work but realized that that took too much time, so I needed a new plan. I thought about sorting the characters in the string and then would\\'ve only needed to compare the string, not the characters, but for this method I needed to change the character counting method to a map. This turned out to be very time and space efficient compared to others, being in the top 5% of LeetCode submissions.\\n\\n# Approach\\n1. Create an unordered map called **groups**, where the keys will represent the sorted versions of the anagrams, and the values will be vectors of strings that belong to the same anagram group.\\n2. Iterate through each string in the input vector **strs**.\\n3. For each string, create a copy called **sortedStr** and sort its characters in ascending order using the **sort** function. This step ensures that anagrams have the same sorted representation.\\n4. Use the sorted string **sortedStr** as the key in the **groups** map. If the key doesn\\'t exist in the map, a new entry is automatically created with an empty vector as the value. If the key already exists, the corresponding vector is accessed.\\n5. Push the original unsorted string **str** into the vector associated with the key **sortedStr**. This step groups the anagrams together.\\n6. After iterating through all the strings, create a **vector<vector<string>>** called **result** to store the grouped anagrams.\\n7. Iterate through each key-value pair in the **groups** map. For each pair, access the vector of anagrams (the value) and push it into the **result** vector.\\n8. Return the **result** vector, which contains the anagram groups.\\n\\nThe main idea behind this approach is to use the sorted representation of each string as the key in an unordered map. By grouping the original unsorted strings together based on their sorted versions, you can efficiently group the anagrams. The final result is a vector of vectors, where each inner vector represents a group of anagrams.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N * K log K)$$, where N is the total number of strings in the input vector **strs** and K is the average length of the strings\\n\\n- Space complexity:\\n$$O(N * K)$$, where N is the number of strings and K is the average length of the strings\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> groups;\\n        for (const string& str : strs) {\\n            string sortedStr = str;\\n            sort(sortedStr.begin(), sortedStr.end());\\n            groups[sortedStr].push_back(str);\\n        }\\n\\n        vector<vector<string>> result;\\n        for (const auto& pair : groups) {\\n            result.push_back(pair.second);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> groups;\\n        for (const string& str : strs) {\\n            string sortedStr = str;\\n            sort(sortedStr.begin(), sortedStr.end());\\n            groups[sortedStr].push_back(str);\\n        }\\n\\n        vector<vector<string>> result;\\n        for (const auto& pair : groups) {\\n            result.push_back(pair.second);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884408,
                "title": "o-nk-time-o-n-space",
                "content": "# Intuition\\nA couple potential solutions that came to mind:\\n1. Same concept as [Valid Anagram](https://leetcode.com/problems/valid-anagram). You can see my solution [here](https://leetcode.com/problems/valid-anagram/solutions/2881883/o-n-time-o-26-o-1-space/).\\n    - Admittedly, this felt like a performance problem after we mapped every string to it\\'s int[] of occurrences\\n2. Sort each string and compare if the sorted string has occurred before\\n\\nWent with the second approach. Also, easier to code up in interview. Initially, I went with the standard string sort that I know of:\\n```\\nprivate string Sort(string s) {\\n    char[] input = s.ToArray();\\n    Array.Sort(input);\\n    return new string(input);\\n}\\n```\\n\\nHowever, we can improve on this by using counting sort since we are limited to 26 potential characters in the lowercase english alphabet.\\n\\n# Approach\\n1. Sort each string\\n2. Check in hashmap if we have seen the sorted version of the string before\\n    1. If we have, add the original string to the value of the hashmap\\n    2. If we haven\\'t, add the original string to a new entry in the hashmap\\n\\n# Complexity\\n- Time complexity:\\n$$O(nk)$$, where $$n$$ is the length of $$strs$$ and $$k$$ is the length of the longest string in $$strs$$. Our counting sort algorithm uses $$O(26)$$ space and runs in $$O(k+26)$$~$$O(k)$$ time\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        if (strs.Length == 0) {\\n            return new List<IList<string>>();\\n        }\\n\\n        Dictionary<string, List<string>> anagrams = new Dictionary<string, List<string>>();\\n\\n        foreach (string str in strs) {\\n            string sortedStr = CountSort(str);\\n            if (!anagrams.ContainsKey(sortedStr)) {\\n                anagrams.Add(sortedStr, new List<string>());\\n            }\\n\\n            anagrams[sortedStr].Add(str);\\n        }\\n\\n        IList<IList<string>> result = new List<IList<string>>();\\n        foreach (KeyValuePair<string, List<string>> kvp in anagrams) {\\n            result.Add(kvp.Value);\\n        }\\n        return result;\\n    }\\n\\n    private string CountSort(string s) {\\n        int[] counts = new int[26];\\n        foreach (char c in s) {\\n            counts[c - \\'a\\'] += 1;\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n        for (int i = 0; i < counts.Length; i++) {\\n            if (counts[i] > 0) {\\n                builder.Append((char)(\\'a\\' + i), counts[i]);\\n            }\\n        }\\n\\n        return builder.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nprivate string Sort(string s) {\\n    char[] input = s.ToArray();\\n    Array.Sort(input);\\n    return new string(input);\\n}\\n```\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        if (strs.Length == 0) {\\n            return new List<IList<string>>();\\n        }\\n\\n        Dictionary<string, List<string>> anagrams = new Dictionary<string, List<string>>();\\n\\n        foreach (string str in strs) {\\n            string sortedStr = CountSort(str);\\n            if (!anagrams.ContainsKey(sortedStr)) {\\n                anagrams.Add(sortedStr, new List<string>());\\n            }\\n\\n            anagrams[sortedStr].Add(str);\\n        }\\n\\n        IList<IList<string>> result = new List<IList<string>>();\\n        foreach (KeyValuePair<string, List<string>> kvp in anagrams) {\\n            result.Add(kvp.Value);\\n        }\\n        return result;\\n    }\\n\\n    private string CountSort(string s) {\\n        int[] counts = new int[26];\\n        foreach (char c in s) {\\n            counts[c - \\'a\\'] += 1;\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n        for (int i = 0; i < counts.Length; i++) {\\n            if (counts[i] > 0) {\\n                builder.Append((char)(\\'a\\' + i), counts[i]);\\n            }\\n        }\\n\\n        return builder.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750799,
                "title": "simple-c-code-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n       vector<vector<string>>res;\\n        unordered_map<string,vector<string>>mp;\\n        for(auto&i: strs)\\n            {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0string t=i;//created a copy\\n\\t\\t\\t\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0sort(t.begin(),t.end());//sorted to get the key\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0mp[t].push_back(i);//pushed the initial string in map\\n \\xA0 \\xA0 \\xA0 \\xA0}\\n        for(auto&i:mp)\\n            {\\n            res.push_back(i.second);\\n            }\\n        return res;\\n    }\\n};\\n```\\nWe created a map with string as key and vector of strings as value. As anagrams are just rearrangement of same set of letters , so if we sort them we will get a same string for all anagrams . So using that as a key we store the strings and then return them as answer.\\nAny suggestions are welcomed in the comments \\uD83D\\uDE03",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n       vector<vector<string>>res;\\n        unordered_map<string,vector<string>>mp;\\n        for(auto&i: strs)\\n            {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0string t=i;//created a copy\\n\\t\\t\\t\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0sort(t.begin(),t.end());//sorted to get the key\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0mp[t].push_back(i);//pushed the initial string in map\\n \\xA0 \\xA0 \\xA0 \\xA0}\\n        for(auto&i:mp)\\n            {\\n            res.push_back(i.second);\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750647,
                "title": "3-different-approaches-to-single-problem-java",
                "content": "## UPVOTE THE SOLUTION IF YOU LIKE IT\\n## 1st Approach\\n![image](https://assets.leetcode.com/users/images/b0c486a4-e6f2-46bb-97a3-8b18258275ae_1666922365.7035868.png)\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] s) {\\n        //edge case\\n        if (s.length == 1) {\\n            List<String> list = new ArrayList<>(1);\\n            list.add(s[0]);\\n            List<List<String>> res = new ArrayList<>(1);\\n            res.add(list);\\n            return res;\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : s) {\\n            byte[] alphabet = new byte[26];\\n            for (char c : word.toCharArray()) {\\n                alphabet[c - \\'a\\']++;\\n            }\\n            for (byte freq : alphabet) {\\n                sb.append(freq).append(\",\");\\n            }\\n            String key = sb.toString();\\n            if (map.containsKey(key)) {\\n                map.get(key).add(word);\\n            } else {\\n                List<String> list = new ArrayList<>();\\n                list.add(word);\\n                map.put(key,list);\\n            }\\n            sb.setLength(0);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n## 2nd Approach\\n![image](https://assets.leetcode.com/users/images/94dd7aa0-4153-495d-a65c-f3df3cb96a93_1666922593.1981628.png)\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n           List<List<String>> output = new ArrayList<List<String>>();\\n        Map<String, List<String>> hashmap= new HashMap<String, List<String>>();\\n        List<String> sortedStrings = new ArrayList<>();\\n        for(String str: strs){\\n            char[] charArray = str.toCharArray();\\n            Arrays.sort(charArray);\\n            String sorted = String.valueOf(charArray);\\n            if(hashmap.containsKey(sorted)){\\n                List<String> temp1 = hashmap.get(sorted);\\n                temp1.add(str);\\n                hashmap.put(sorted,temp1);\\n            }\\n            else{\\n                List<String> temp = new ArrayList<>();\\n                temp.add(str);\\n                hashmap.put(sorted, temp);\\n            }\\n        }\\n        return new ArrayList<>( hashmap.values());\\n    }\\n}\\n```\\n## 3rd Approach\\n![image](https://assets.leetcode.com/users/images/0b3ad927-a64d-4f7a-9340-a6790344eaae_1666922547.2861967.png)\\n```\\nimport java.util.AbstractList;\\nclass Solution {\\n    private List<List<String>> result;\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        return new AbstractList<List<String>>() {\\n\\n            public List<String> get(int index) {\\n                if (result == null)\\n                    init();\\n                return result.get(index);\\n            }\\n\\n            public int size() {\\n                if (result == null)\\n                    init();\\n                return result.size();\\n            }\\n\\n            private void init() {\\n                for (String s : strs) {\\n                    char[] count = new char[26];\\n                    \\n                    for (char c : s.toCharArray())\\n                        count[c - \\'a\\']++;\\n                    String key = String.valueOf(count);\\n                \\n                    if (!map.containsKey(key))\\n                        map.put(key, new ArrayList<String>());\\n                    \\n                    map.get(key).add(s);\\n                }\\n                \\n                result = new ArrayList<>(map.values());\\n            }\\n        };\\n    }\\n}\\n```\\n\\n## IF OU REACHED TILL HERE KINDLY UPVOTE THE SOLUTION",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] s) {\\n        //edge case\\n        if (s.length == 1) {\\n            List<String> list = new ArrayList<>(1);\\n            list.add(s[0]);\\n            List<List<String>> res = new ArrayList<>(1);\\n            res.add(list);\\n            return res;\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : s) {\\n            byte[] alphabet = new byte[26];\\n            for (char c : word.toCharArray()) {\\n                alphabet[c - \\'a\\']++;\\n            }\\n            for (byte freq : alphabet) {\\n                sb.append(freq).append(\",\");\\n            }\\n            String key = sb.toString();\\n            if (map.containsKey(key)) {\\n                map.get(key).add(word);\\n            } else {\\n                List<String> list = new ArrayList<>();\\n                list.add(word);\\n                map.put(key,list);\\n            }\\n            sb.setLength(0);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n           List<List<String>> output = new ArrayList<List<String>>();\\n        Map<String, List<String>> hashmap= new HashMap<String, List<String>>();\\n        List<String> sortedStrings = new ArrayList<>();\\n        for(String str: strs){\\n            char[] charArray = str.toCharArray();\\n            Arrays.sort(charArray);\\n            String sorted = String.valueOf(charArray);\\n            if(hashmap.containsKey(sorted)){\\n                List<String> temp1 = hashmap.get(sorted);\\n                temp1.add(str);\\n                hashmap.put(sorted,temp1);\\n            }\\n            else{\\n                List<String> temp = new ArrayList<>();\\n                temp.add(str);\\n                hashmap.put(sorted, temp);\\n            }\\n        }\\n        return new ArrayList<>( hashmap.values());\\n    }\\n}\\n```\n```\\nimport java.util.AbstractList;\\nclass Solution {\\n    private List<List<String>> result;\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        return new AbstractList<List<String>>() {\\n\\n            public List<String> get(int index) {\\n                if (result == null)\\n                    init();\\n                return result.get(index);\\n            }\\n\\n            public int size() {\\n                if (result == null)\\n                    init();\\n                return result.size();\\n            }\\n\\n            private void init() {\\n                for (String s : strs) {\\n                    char[] count = new char[26];\\n                    \\n                    for (char c : s.toCharArray())\\n                        count[c - \\'a\\']++;\\n                    String key = String.valueOf(count);\\n                \\n                    if (!map.containsKey(key))\\n                        map.put(key, new ArrayList<String>());\\n                    \\n                    map.get(key).add(s);\\n                }\\n                \\n                result = new ArrayList<>(map.values());\\n            }\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225057,
                "title": "super-simple-6ms-java-solution-readable",
                "content": "```\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n\\tMap<String, List<String>> map = new HashMap<>();\\n\\tfor(String str : strs) {\\n\\t\\tchar[] chars = str.toCharArray();\\n\\t\\tArrays.sort(chars);\\n\\n\\t\\tString sortedStr = new String(chars);\\n\\t\\tmap.putIfAbsent(sortedStr, new ArrayList<>());\\n\\t\\tmap.get(sortedStr).add(str);\\n\\t}\\n\\n\\treturn new ArrayList<>(map.values());\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n\\tMap<String, List<String>> map = new HashMap<>();\\n\\tfor(String str : strs) {\\n\\t\\tchar[] chars = str.toCharArray();\\n\\t\\tArrays.sort(chars);\\n\\n\\t\\tString sortedStr = new String(chars);\\n\\t\\tmap.putIfAbsent(sortedStr, new ArrayList<>());\\n\\t\\tmap.get(sortedStr).add(str);\\n\\t}\\n\\n\\treturn new ArrayList<>(map.values());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1384401,
                "title": "c-group-anagrams-sorting-and-hashmap",
                "content": "# **LeetCode + Todoist = Consistent Grind -- TRY [Code Task](https://codetask.vercel.app/)**\\n\\n**Using Sorting - Sort every string and push in appropriate bucket**\\n* **Time Complexcity : `O(n.klog(k))`** *where **k** is the length of string and **n** is total no. of strings*\\n* **Space Complexcity : `O(n)`** *if none of the strings are anagram*\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        unordered_map<string, vector<string>> sorted;\\n        \\n        for(int i = 0; i < strs.size(); i++){\\n            string temp = strs[i];\\n            sort(strs[i].begin(), strs[i].end());\\n            sorted[strs[i]].push_back(temp);\\n        }\\n        \\n        for(auto it = sorted.begin(); it != sorted.end(); it++){\\n            ans.push_back(it->second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        unordered_map<string, vector<string>> sorted;\\n        \\n        for(int i = 0; i < strs.size(); i++){\\n            string temp = strs[i];\\n            sort(strs[i].begin(), strs[i].end());\\n            sorted[strs[i]].push_back(temp);\\n        }\\n        \\n        for(auto it = sorted.begin(); it != sorted.end(); it++){\\n            ans.push_back(it->second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566237,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        let mut out = std::collections::HashMap::new();\\n        for v in strs {\\n            let mut k: Vec<u8> = v.bytes().collect();\\n            k.sort_unstable();\\n            out.entry(k).or_insert_with(|| vec![]).push(v)\\n        }\\n        out.into_iter().map(|(_, v)| v).collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        let mut out = std::collections::HashMap::new();\\n        for v in strs {\\n            let mut k: Vec<u8> = v.bytes().collect();\\n            k.sort_unstable();\\n            out.entry(k).or_insert_with(|| vec![]).push(v)\\n        }\\n        out.into_iter().map(|(_, v)| v).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 566236,
                "title": "javascript-5-lines-explained",
                "content": "The approach here is actually quite simple once accounted for.\\n- All we\\'re doing is creating a way to categorize each anagram.\\n- Which can easily be done by sorting in alphabetical order.\\n- Then as we loop through them, if they adhere to the sorted form, we know they belong.\\n- So, add them to the array under which their key or category exists, and finally we can...\\n- return these arrays by looping over the values for each category/key\\n```js\\nvar groupAnagrams = function(strs) {\\n    let map = {}\\n    \\n    for (let str of strs) {\\n        let key = [...str].sort()\\n        map[key] = map[key] ? [...map[key], str] : [str]\\n    }\\n    \\n    return Object.values(map)\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar groupAnagrams = function(strs) {\\n    let map = {}\\n    \\n    for (let str of strs) {\\n        let key = [...str].sort()\\n        map[key] = map[key] ? [...map[key], str] : [str]\\n    }\\n    \\n    return Object.values(map)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478474,
                "title": "javascript-most-common-technique-with-good-explanation",
                "content": "**Time complexity is 95.53%**\\n\\n**You can follow along with my numbered markers which are pointers to comments in the code block**\\n\\n1. Just general validations & checks\\n2. Using `Map()` because most of the operations I\\'ll be using are `O(1)`, you could opt for a dictionary using an object but you\\'ll see in step 5 we optimize for speed\\n3. We loop over every word\\n4. We create 2 variables, 1 is the word, 1 is the word but sorted alphabetically\\n\\t- worst `O(n^2)`\\n\\t- avg `O(n log(n))`\\n5. The magic of our `Map()` is here\\n\\t- If our sorted word matches any existing sorted word (which makes it an anagram) then we add it to our anagram list\\n\\t- If our sorted word doesn\\'t match anything, add a new entry to the map\\n\\t\\t- The key would be the sorted word\\n\\t\\t- The value would be an array of the word eg. `[\"word\"]`\\n\\t- `Map().size` is an `O(1)` solution of getting the length vs `Object.entries(...).length` is an `O(n)` because of converting an object to an array\\n\\t- `get()`, `has()`, `push()` and `set()` are all `O(1)`\\n\\t- The only added benefit of using this over a dictionary is readability and the `size` prototype from `Map()`\\n6. We\\'ll have all our results stored in our `Map()`, we just iterate over all our results and put them into 1 array then return that!\\n\\n```\\n// 1\\nif (strs.length === 0) return []\\nif (strs.length === 1) return [strs]\\n\\n// 2\\nconst words = new Map()\\n\\n// 3\\nfor (let i = 0; i < strs.length; i++) {\\n\\tconst word = strs[i]\\n\\tconst wordSorted = [...word].sort().join(\\'\\') // 4\\n\\n\\t// 5\\n\\tif (words.size > 0 && words.has(wordSorted)) {\\n\\t\\twords.get(wordSorted).push(word)\\n\\t} else {\\n\\t\\twords.set(wordSorted, [word])\\n\\t}\\n}\\n\\n// 6\\nconst result = []\\n\\nfor (const [_, list] of words.entries()) {\\n\\tresult.push(list)\\n}\\n\\nreturn result\\n```\\n\\nHope you guys enjoyed this!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// 1\\nif (strs.length === 0) return []\\nif (strs.length === 1) return [strs]\\n\\n// 2\\nconst words = new Map()\\n\\n// 3\\nfor (let i = 0; i < strs.length; i++) {\\n\\tconst word = strs[i]\\n\\tconst wordSorted = [...word].sort().join(\\'\\') // 4\\n\\n\\t// 5\\n\\tif (words.size > 0 && words.has(wordSorted)) {\\n\\t\\twords.get(wordSorted).push(word)\\n\\t} else {\\n\\t\\twords.set(wordSorted, [word])\\n\\t}\\n}\\n\\n// 6\\nconst result = []\\n\\nfor (const [_, list] of words.entries()) {\\n\\tresult.push(list)\\n}\\n\\nreturn result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19394,
                "title": "another-approach-hash-by-prime-numbers-java-16ms-defeating-97-53",
                "content": "   The key for this problem is to find a way of hashing. In this solution, the basic idea is to calculate a hash value for each string using prime number. For example, the 1st letter, 'a', represent the 1st prime number, 2. The 2nd letter 'b' for the 2nd prime number 3......After calculating hash values for each word, group them by hash value.\\n```\\npublic class Solution {\\n    private static final int[] primetable = primes(26);\\n    // private static final int[] primetable = new int[]{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<Integer, List<String>> map = new HashMap<>(strs.length);\\n        for(String s:strs){\\n            int hashcode = hash(s);\\n            map.putIfAbsent(hashcode, new ArrayList<String>());\\n            map.get(hashcode).add(s);\\n        }\\n        List<List<String>> res= new ArrayList<>();\\n        res.addAll(map.values());\\n        return res;\\n    }\\n    private int hash(String s){\\n        int hashcode = 1;\\n        for(char c:s.toCharArray()){\\n            hashcode *= primetable[c-97];\\n        }\\n        return hashcode;\\n    }\\n    private static int[] primes(int n){\\n        if(n<1){\\n            return null;\\n        }\\n        int[] res = new int[n];\\n        res[0] = 2;\\n        int counter = 1, cur = 3;\\n        while(counter<n){\\n            for(int num:res){\\n                // if visited all previous prime numbers\\n                if(num==0 || num*num >cur){\\n                    res[counter++] = cur++; \\n                    break;\\n                }\\n                // not a prime number\\n                if(cur%num==0){\\n                    ++cur;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    private static final int[] primetable = primes(26);\\n    // private static final int[] primetable = new int[]{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<Integer, List<String>> map = new HashMap<>(strs.length);\\n        for(String s:strs){\\n            int hashcode = hash(s);\\n            map.putIfAbsent(hashcode, new ArrayList<String>());\\n            map.get(hashcode).add(s);\\n        }\\n        List<List<String>> res= new ArrayList<>();\\n        res.addAll(map.values());\\n        return res;\\n    }\\n    private int hash(String s){\\n        int hashcode = 1;\\n        for(char c:s.toCharArray()){\\n            hashcode *= primetable[c-97];\\n        }\\n        return hashcode;\\n    }\\n    private static int[] primes(int n){\\n        if(n<1){\\n            return null;\\n        }\\n        int[] res = new int[n];\\n        res[0] = 2;\\n        int counter = 1, cur = 3;\\n        while(counter<n){\\n            for(int num:res){\\n                // if visited all previous prime numbers\\n                if(num==0 || num*num >cur){\\n                    res[counter++] = cur++; \\n                    break;\\n                }\\n                // not a prime number\\n                if(cur%num==0){\\n                    ++cur;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19443,
                "title": "i-solved-it-with-o-m-log-m-n-time-o-m-n-space-is-there-better-solution-accepted",
                "content": "m represents the mean length of String in strs. I sorted every String, and used HashMap to store the groups of strings that are anagrams.\\n\\n    public class Solution {\\n        public ArrayList<String> anagrams(String[] strs) {\\n            if(strs==null || strs.length==0) return null;\\n            ArrayList<String> ret = new ArrayList<String>();\\n            Map<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();\\n            for(String s:strs)\\n            {\\n                char[] temp = s.toCharArray();\\n                Arrays.sort(temp);\\n                ArrayList<String> array = map.get(new String(temp));\\n                if(array==null)\\n                {\\n                    array = new ArrayList<String>();\\n                    array.add(s);\\n                    map.put(new String(temp), array);\\n                }\\n                else array.add(s);\\n            }\\n            for(String s:map.keySet())\\n            {\\n                ArrayList<String> array = map.get(s);\\n                if(array.size()!=1) ret.addAll(array);\\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public ArrayList<String> anagrams(String[] strs) {\\n            if(strs==null || strs.length==0) return null;\\n            ArrayList<String> ret = new ArrayList<String>();\\n            Map<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();\\n            for(String s:strs)\\n            {\\n                char[] temp = s.toCharArray();\\n                Arrays.sort(temp);\\n                ArrayList<String> array = map.get(new String(temp));\\n                if(array==null)\\n                {\\n                    array = new ArrayList<String>();\\n                    array.add(s);\\n                    map.put(new String(temp), array);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3140613,
                "title": "c-map-sorting-all-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is to sort every string present in str and keeping the sorted string as key push all the strings which will match this osrted key string. And thise will be actually anagrams .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse sorting and hashing.\\nAlso we can do count sort becuase we have only 26 charcaters so we can direclty locate values which are present in the string in `O(n)` time so need to sort in $$nlogn $$\\n# Complexity\\n- Time complexity:O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Using Normal Stl Sort [$$n*k*logk$$]**\\n```\\nvector<vector<string>> groupAnagrams(vector<string>& str) {\\n\\n        map<string,vector<string>>mp;\\n        int k=0;\\n        for(auto x:str){\\n           string s=x;\\n           sort(begin(s),end(s));\\n           mp[s].push_back(x);\\n        }\\n        vector<vector<string>>res;\\n        for(auto x:mp)\\n         res.push_back(x.second);\\n\\n        return res;\\n    }\\n```\\n**Using Count Sort**\\n```\\nclass Solution {\\npublic:\\n    void count_sort(string& s){\\n        int n=s.size();\\n        vector<int>mp(26,0);\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            mp[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n          ans.append(mp[i],i+\\'a\\');\\n        }\\n        s=ans;\\n    }\\n    vector<vector<string>> groupAnagrams(vector<string>& str) {\\n\\n        map<string,vector<string>>mp;\\n        int k=0;\\n        for(auto x:str){\\n           string s=x;\\n           count_sort(s);\\n           mp[s].push_back(x);\\n        }\\n        vector<vector<string>>res;\\n        for(auto x:mp)\\n         res.push_back(x.second);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<string>> groupAnagrams(vector<string>& str) {\\n\\n        map<string,vector<string>>mp;\\n        int k=0;\\n        for(auto x:str){\\n           string s=x;\\n           sort(begin(s),end(s));\\n           mp[s].push_back(x);\\n        }\\n        vector<vector<string>>res;\\n        for(auto x:mp)\\n         res.push_back(x.second);\\n\\n        return res;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    void count_sort(string& s){\\n        int n=s.size();\\n        vector<int>mp(26,0);\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            mp[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n          ans.append(mp[i],i+\\'a\\');\\n        }\\n        s=ans;\\n    }\\n    vector<vector<string>> groupAnagrams(vector<string>& str) {\\n\\n        map<string,vector<string>>mp;\\n        int k=0;\\n        for(auto x:str){\\n           string s=x;\\n           count_sort(s);\\n           mp[s].push_back(x);\\n        }\\n        vector<vector<string>>res;\\n        for(auto x:mp)\\n         res.push_back(x.second);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751160,
                "title": "simple-solution-with-explanation-tc-o-n-length-of-largest-word-sc-o-n",
                "content": "* We have to just count the occurrence of each word and store it in a map of array having same frequency pattern.\\n* Lastly return all the values of hashmap\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dct=defaultdict(list)\\n        for i in range(len(strs)):\\n            st=[0 for _ in range(26)]\\n            for j in strs[i]:\\n                xi=ord(j)-97\\n                st[xi]+=1\\n            st=tuple(st)\\n            dct[st].append(strs[i])\\n        return dct.values()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dct=defaultdict(list)\\n        for i in range(len(strs)):\\n            st=[0 for _ in range(26)]\\n            for j in strs[i]:\\n                xi=ord(j)-97\\n                st[xi]+=1\\n            st=tuple(st)\\n            dct[st].append(strs[i])\\n        return dct.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750484,
                "title": "javascript-solution-using-hashmap",
                "content": "```\\nconst groupAnagrams = function(strs) {\\n    const groups = {};\\n    for(let str of strs) {\\n        const key = str.split(\"\").sort();\\n        if(key in groups) {\\n            groups[key].push(str);\\n        }\\n        else {\\n            groups[key] = [str];\\n        }\\n    }\\n    return Object.values(groups);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst groupAnagrams = function(strs) {\\n    const groups = {};\\n    for(let str of strs) {\\n        const key = str.split(\"\").sort();\\n        if(key in groups) {\\n            groups[key].push(str);\\n        }\\n        else {\\n            groups[key] = [str];\\n        }\\n    }\\n    return Object.values(groups);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1048422,
                "title": "2-solutions-in-c-one-using-sort-and-other-without-sort",
                "content": "1 . C++ Solution With Sort in O(N*KlogK) Time\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>> mpp;\\n        \\n        for(string str : strs)\\n        {\\n            string copy = str;\\n            sort(copy.begin(),copy.end());\\n            mpp[copy].push_back(str);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x : mpp)\\n        {     \\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n2 . C++ Solution Without Sort in O(N*K) Time\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        map<map<char,int>,vector<string>>mpp;  \\n        for(string s : strs)\\n        {\\n            map<char,int>mpp2;\\n            for(char ch : s)\\n                mpp2[ch]++;\\n            mpp[mpp2].push_back(s);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x : mpp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>> mpp;\\n        \\n        for(string str : strs)\\n        {\\n            string copy = str;\\n            sort(copy.begin(),copy.end());\\n            mpp[copy].push_back(str);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x : mpp)\\n        {     \\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        map<map<char,int>,vector<string>>mpp;  \\n        for(string s : strs)\\n        {\\n            map<char,int>mpp2;\\n            for(char ch : s)\\n                mpp2[ch]++;\\n            mpp[mpp2].push_back(s);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x : mpp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717546,
                "title": "swift-one-line",
                "content": "```swift\\nclass Solution {\\n  func groupAnagrams(_ strs: [String]) -> [[String]] {\\n    return Array(Dictionary(grouping: strs) { $0.sorted() }.values)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n  func groupAnagrams(_ strs: [String]) -> [[String]] {\\n    return Array(Dictionary(grouping: strs) { $0.sorted() }.values)\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548172,
                "title": "easy-python-solution-with-explanation",
                "content": "Basic Idea - If your sort anagrams they come same string. \\nUse this to create a disctionary with corted words as key and keep appending all anagrams to it. \\nIn the end, iterate over disctionary to get the answer in expected format. \\n\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        d = {}\\n        ans = []\\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            if sorted_word not in d:\\n                d[sorted_word] = [word]\\n            else:\\n                d[sorted_word].append(word)\\n            \\n        for key in d:\\n            ans.append(d[key])\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        d = {}\\n        ans = []\\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            if sorted_word not in d:\\n                d[sorted_word] = [word]\\n            else:\\n                d[sorted_word].append(word)\\n            \\n        for key in d:\\n            ans.append(d[key])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391010,
                "title": "very-simple-c-solution-faster-than-99-92-submissions",
                "content": "A very simple C# soluton using a HashTable / Dictionary. Feel free to suggest improvements.\\n\\n**Time Complexity:** O(n * mlogm)\\nwhere n is the number of items in the array and m is the length of each anagram \\n**Space Complexity:** O(n) \\n\\nRuntime: 280 ms, faster than 99.92% of C# online submissions for Group Anagrams.\\nMemory Usage: 37.3 MB, less than 23.53% of C# online submissions for Group Anagrams.\\n\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        IList<IList<string>> result = new List<IList<string>>();\\n        Dictionary<string, List<string>> map = new Dictionary<string, List<string>>();\\n        foreach(string anagram in strs){\\n            char[] tempArray = anagram.ToCharArray();\\n            Array.Sort(tempArray);\\n            string sorted = new string(tempArray);\\n            if(!map.ContainsKey(sorted)){\\n                map.Add(sorted, new List<string>(){ anagram });                \\n            }else{\\n                map[sorted].Add(anagram);   \\n            }\\n        }\\n        foreach(var pair in map){\\n            result.Add(pair.Value);\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "A very simple C# soluton using a HashTable / Dictionary. Feel free to suggest improvements.\\n\\n**Time Complexity:** O(n * mlogm)\\nwhere n is the number of items in the array and m is the length of each anagram \\n**Space Complexity:** O(n) \\n\\nRuntime: 280 ms, faster than 99.92% of C# online submissions for Group Anagrams.\\nMemory Usage: 37.3 MB, less than 23.53% of C# online submissions for Group Anagrams.\\n\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        IList<IList<string>> result = new List<IList<string>>();\\n        Dictionary<string, List<string>> map = new Dictionary<string, List<string>>();\\n        foreach(string anagram in strs){\\n            char[] tempArray = anagram.ToCharArray();\\n            Array.Sort(tempArray);\\n            string sorted = new string(tempArray);\\n            if(!map.ContainsKey(sorted)){\\n                map.Add(sorted, new List<string>(){ anagram });                \\n            }else{\\n                map[sorted].Add(anagram);   \\n            }\\n        }\\n        foreach(var pair in map){\\n            result.Add(pair.Value);\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 299592,
                "title": "go-beats-100",
                "content": "```\\nfunc groupAnagrams(words []string) [][]string {\\n\\tcache := make(map[[26]byte]int)\\n\\tresult := make([][]string, 0)\\n\\tfor i := range words {\\n\\t\\tlist := [26]byte{}\\n\\t\\tfor j := range words[i] {\\n\\t\\t\\tlist[words[i][j]-\\'a\\']++\\n\\t\\t}\\n\\t\\tif idx, ok := cache[list]; ok {\\n\\t\\t\\tresult[idx] = append(result[idx], words[i])\\n\\t\\t} else {\\n\\t\\t\\tresult = append(result, []string{words[i]})\\n\\t\\t\\tcache[list] = len(result) - 1\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc groupAnagrams(words []string) [][]string {\\n\\tcache := make(map[[26]byte]int)\\n\\tresult := make([][]string, 0)\\n\\tfor i := range words {\\n\\t\\tlist := [26]byte{}\\n\\t\\tfor j := range words[i] {\\n\\t\\t\\tlist[words[i][j]-\\'a\\']++\\n\\t\\t}\\n\\t\\tif idx, ok := cache[list]; ok {\\n\\t\\t\\tresult[idx] = append(result[idx], words[i])\\n\\t\\t} else {\\n\\t\\t\\tresult = append(result, []string{words[i]})\\n\\t\\t\\tcache[list] = len(result) - 1\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250264,
                "title": "java-solutions",
                "content": "**Solution 1: Group by Sorted String**\\n\\n> Two strings are `anagrams` if and only if their sorted strings are equal.\\n- We use `Map` to group the strings by their sorted counterparts. We use the sorted string as the key and List of anagram strings as the value. Each key `keyStr` is a sorted string, and each value is the list of strings from the initial input that when sorted, are equal to `keyStr`.\\n- The outer loop has complexity `O(n)` as we iterate through each string. Then, we sort each string in `O(k log k)` time.\\n\\nTime complexity: `O(n * k log k)` - where `n` is the length of input array `strs`, and `k` is the maximum length of a string in `strs` array. \\nSpace complexity: `O(n * k)` - the total information content stored in a `Map`. \\n\\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n\\t\\tMap<String, List<String>> map = new HashMap<>();\\n\\t\\t\\n        for(String s : strs)\\n\\t\\t{\\n            char[] ca = s.toCharArray();\\n            Arrays.sort(ca);\\n            String keyStr = String.valueOf(ca);\\n    \\t\\tmap.putIfAbsent(keyStr, new ArrayList<>());\\t\\t// If no mapping for a key, then map a new key with an empty list.\\n\\t\\t\\tmap.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n\\n**Solution 2: Group by Character Counts**\\n\\n> Two strings are `anagrams` if and only if their character counts are the same.\\n- We can transform each string `s` into an encoded string based on the its character counts.\\n- For example, string `abbccc` will be `a1b2c3d0e0...z0` where there are `26` entries for each character from `a` to `z`.\\n\\nTime complexity: `O(n * k)` - Encoding each string is linear in the size of the string which is `O(k)`, and we encode every string. So `O(n) * O(k) = O(n * k)`.\\nSpace complexity: `O(n * k)` - the total information content stored in a `Map`.\\n\\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n        Map<String, List<String>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(String s : strs)\\n\\t\\t{\\n            String keyStr = encodeString(s);\\n            map.putIfAbsent(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n\\n\\tprivate String encodeString(String s)\\n\\t{\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint[] count = new int[26];\\n\\t\\tArrays.fill(count, 0);\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t{\\n\\t\\t\\tcount[c - \\'a\\'] += 1;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0; i < 26; i++)\\n\\t\\t{\\n\\t\\t\\tsb.append(i + \\'a\\').append(count[i]);\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\t}\\n}\\n```\\n\\n**Solution 3: Group by hashCode**\\n\\n- Here we compute the `hashCode` of an array of character counts of the string.\\n\\nTime complexity: `O(n * k)` - Computing a hashCode for each string is linear in the size of the string which is `O(k)`, and we do this for every string. So `O(n) * O(k) = O(n * k)`.\\nSpace complexity: `O(n * k)` - the total information content stored in a `Map`.\\n\\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n        Map<Integer, List<String>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(String s : strs)\\n\\t\\t{\\n            int hashCode = computeHashCode(s);\\n            map.putIfAbsent(hashCode, new ArrayList<>());\\n            map.get(hashCode).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n\\n\\tprivate int computeHashCode(String s)\\n\\t{\\n\\t\\tint[] count = new int[26];\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t{\\n\\t\\t\\tcount[c - \\'a\\'] += 1;\\n\\t\\t}\\n\\t\\treturn Arrays.hashCode(count);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n\\t\\tMap<String, List<String>> map = new HashMap<>();\\n\\t\\t\\n        for(String s : strs)\\n\\t\\t{\\n            char[] ca = s.toCharArray();\\n            Arrays.sort(ca);\\n            String keyStr = String.valueOf(ca);\\n    \\t\\tmap.putIfAbsent(keyStr, new ArrayList<>());\\t\\t// If no mapping for a key, then map a new key with an empty list.\\n\\t\\t\\tmap.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n        Map<String, List<String>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(String s : strs)\\n\\t\\t{\\n            String keyStr = encodeString(s);\\n            map.putIfAbsent(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n\\n\\tprivate String encodeString(String s)\\n\\t{\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint[] count = new int[26];\\n\\t\\tArrays.fill(count, 0);\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t{\\n\\t\\t\\tcount[c - \\'a\\'] += 1;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0; i < 26; i++)\\n\\t\\t{\\n\\t\\t\\tsb.append(i + \\'a\\').append(count[i]);\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\t}\\n}\\n```\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n        Map<Integer, List<String>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(String s : strs)\\n\\t\\t{\\n            int hashCode = computeHashCode(s);\\n            map.putIfAbsent(hashCode, new ArrayList<>());\\n            map.get(hashCode).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n\\n\\tprivate int computeHashCode(String s)\\n\\t{\\n\\t\\tint[] count = new int[26];\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t{\\n\\t\\t\\tcount[c - \\'a\\'] += 1;\\n\\t\\t}\\n\\t\\treturn Arrays.hashCode(count);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19463,
                "title": "accept-java-solution",
                "content": "    public class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            Map <String,Integer>mp = new HashMap<String,Integer>();\\n            Arrays.sort(strs);\\n            for(String str : strs){\\n                char[] ch = str.toCharArray();\\n                Arrays.sort(ch);\\n                String s = new String(ch);\\n                if(mp.containsKey(s)){\\n                    List li = res.get(mp.get(s));\\n                    li.add(str);\\n                }else{\\n                    List li = new ArrayList();\\n                    li.add(str);\\n                    res.add(li);\\n                    mp.put(s,res.size()-1);\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n\\nstep 1. sort the original array. Make sure the output order is correct.\\nstep 2. sort every string, check if it's in hash map. if is, add to the result, if not, add to the hashMap.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            Map <String,Integer>mp = new HashMap<String,Integer>();\\n            Arrays.sort(strs);\\n            for(String str : strs){\\n                char[] ch = str.toCharArray();\\n                Arrays.sort(ch);\\n                String s = new String(ch);\\n                if(mp.containsKey(s)){\\n                    List li = res.get(mp.get(s));\\n                    li.add(str);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3267924,
                "title": "c-solution-using-groupby-and-sorting",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        return strs\\n            .GroupBy(s => new string(s.OrderBy(c => c).ToArray()))\\n            .Select(g => g.ToList() as IList<string>)\\n            .ToList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        return strs\\n            .GroupBy(s => new string(s.OrderBy(c => c).ToArray()))\\n            .Select(g => g.ToList() as IList<string>)\\n            .ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750508,
                "title": "js-javascript-solution-with-map",
                "content": "# Any feedback would be appreciated \\uD83D\\uDE0A\\n\\n```\\nconst groupAnagrams = function(strs) {\\n  const map = new Map();\\n  \\n  for (let str of strs) {\\n    let curr = [...str].sort().join(\\'\\');\\n    if (!map.has(curr)) map.set(curr, []);\\n    map.get(curr).push(str);\\n  }\\n  return Array.from(map.values());\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst groupAnagrams = function(strs) {\\n  const map = new Map();\\n  \\n  for (let str of strs) {\\n    let curr = [...str].sort().join(\\'\\');\\n    if (!map.has(curr)) map.set(curr, []);\\n    map.get(curr).push(str);\\n  }\\n  return Array.from(map.values());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2252670,
                "title": "solved-with-c",
                "content": "Simple and fast solution using c#\\n\\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n\\n           if (strs == null || strs.Length == 0) return new List<IList<string>>();\\n            var countDict = new Dictionary<string, IList<string>>();\\n            foreach (string str in strs)\\n            {\\n                var charList = new char[26];\\n                foreach (char c in str)\\n                {\\n                    charList[c - \\'a\\']++;\\n                }\\n\\n                var key = new string(charList);\\n\\n                if (!countDict.ContainsKey(key))\\n                {\\n                    countDict.Add(key, new List<string> { str });\\n                }\\n                else\\n                {\\n                    countDict[key].Add(str);\\n                }\\n            }\\n\\n            return countDict.Values.ToList();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n\\n           if (strs == null || strs.Length == 0) return new List<IList<string>>();\\n            var countDict = new Dictionary<string, IList<string>>();\\n            foreach (string str in strs)\\n            {\\n                var charList = new char[26];\\n                foreach (char c in str)\\n                {\\n                    charList[c - \\'a\\']++;\\n                }\\n\\n                var key = new string(charList);\\n\\n                if (!countDict.ContainsKey(key))\\n                {\\n                    countDict.Add(key, new List<string> { str });\\n                }\\n                else\\n                {\\n                    countDict[key].Add(str);\\n                }\\n            }\\n\\n            return countDict.Values.ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085008,
                "title": "error-incompatible-types-boolean-cannot-be-converted-to-list-string",
                "content": "Not sure why I am getting this error. Can someone please help me in understanding this.\\n![image](https://assets.leetcode.com/users/images/8851fbfc-88d5-46f8-b001-06a281427eb6_1653769454.915814.png)\\n\\ncode:\\n```\\nHashMap<String, List<String>> hm = new HashMap<>();\\nhm.put(temp, hm.get(temp).add(s));\\n```\\nHere temp and s are of type String\\n\\nBut below code snippet is working fine\\n\\n``` \\nList<String> list = hm.get(temp);  \\nlist.add(s);            \\nhm.put(temp,list); \\n```\\n\\n\\nFull code:\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        if(strs.length == 0)\\n            return new ArrayList();\\n        \\n        HashMap<String, List<String>> hm = new HashMap<>();\\n        \\n        for(String s : strs){   \\n            char[] ch = s.toCharArray();\\n            Arrays.sort(ch);   \\n\\n            String temp = new String(ch);\\n            \\n            if(hm.containsKey(temp)){   \\n                List<String> list = hm.get(temp);  \\n                list.add(s);           \\n                hm.put(temp,list);      \\n                //hm.put(temp, hm.get(temp).add(s));    // why it\\'s not working? --getting error here\\n            }\\n            else{\\n                List<String> list = new ArrayList<>(1);\\n                list.add(s);\\n                hm.put(temp,list);\\n            }\\n        }\\n \\n        List<List<String>> ans = new ArrayList<>();\\n        \\n        for(Map.Entry entry : hm.entrySet()){   \\n            List list = (List)entry.getValue();\\n            ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nHashMap<String, List<String>> hm = new HashMap<>();\\nhm.put(temp, hm.get(temp).add(s));\\n```\n``` \\nList<String> list = hm.get(temp);  \\nlist.add(s);            \\nhm.put(temp,list); \\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        if(strs.length == 0)\\n            return new ArrayList();\\n        \\n        HashMap<String, List<String>> hm = new HashMap<>();\\n        \\n        for(String s : strs){   \\n            char[] ch = s.toCharArray();\\n            Arrays.sort(ch);   \\n\\n            String temp = new String(ch);\\n            \\n            if(hm.containsKey(temp)){   \\n                List<String> list = hm.get(temp);  \\n                list.add(s);           \\n                hm.put(temp,list);      \\n                //hm.put(temp, hm.get(temp).add(s));    // why it\\'s not working? --getting error here\\n            }\\n            else{\\n                List<String> list = new ArrayList<>(1);\\n                list.add(s);\\n                hm.put(temp,list);\\n            }\\n        }\\n \\n        List<List<String>> ans = new ArrayList<>();\\n        \\n        for(Map.Entry entry : hm.entrySet()){   \\n            List list = (List)entry.getValue();\\n            ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442564,
                "title": "c-using-hashmap",
                "content": "**Please Upvote if you like the code!**\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs)\\n    {\\n        vector<vector<string>> res;\\n        unordered_map<string,vector<string>> m;\\n        string temp;\\n        \\n        for(int i=0;i<strs.size();i++)\\n        {\\n            temp=strs[i];\\n            sort(strs[i].begin(),strs[i].end());\\n            m[strs[i]].push_back(temp);\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            res.push_back(it->second);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "**Please Upvote if you like the code!**\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs)\\n    {\\n        vector<vector<string>> res;\\n        unordered_map<string,vector<string>> m;\\n        string temp;\\n        \\n        for(int i=0;i<strs.size();i++)\\n        {\\n            temp=strs[i];\\n            sort(strs[i].begin(),strs[i].end());\\n            m[strs[i]].push_back(temp);\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            res.push_back(it->second);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 833858,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        if strs.isEmpty { return [] }\\n        \\n        var map = [String: [String]]()\\n        for str in strs {\\n            let sortedStr = String(str.sorted())\\n            map[sortedStr, default: []] += [str]\\n        }\\n                \\n        return Array(map.values)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        if strs.isEmpty { return [] }\\n        \\n        var map = [String: [String]]()\\n        for str in strs {\\n            let sortedStr = String(str.sorted())\\n            map[sortedStr, default: []] += [str]\\n        }\\n                \\n        return Array(map.values)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225669,
                "title": "scala-one-liner",
                "content": "```\\n  def groupAnagrams(strs: Array[String]): List[List[String]] = {\\n    strs.groupBy(_.sorted).values.map(_.toList).toList\\n  }\\n ```\\n",
                "solutionTags": [],
                "code": "```\\n  def groupAnagrams(strs: Array[String]): List[List[String]] = {\\n    strs.groupBy(_.sorted).values.map(_.toList).toList\\n  }\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 200240,
                "title": "neat-java-solution",
                "content": "```java\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Hashtable;\\nimport java.util.List;\\n\\npublic class Solution {\\n\\n  public List<List<String>> groupAnagrams(String[] strs) {\\n    Hashtable<String, List<String>> ht = new Hashtable<>();\\n    for (String s : strs) {\\n      char[] temp = s.toCharArray();\\n      Arrays.sort(temp);\\n      String _s = String.valueOf(temp);\\n      ht.putIfAbsent(_s, new ArrayList<>());\\n      ht.get(_s).add(s);\\n    }\\n    return new ArrayList<>(ht.values());\\n  }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n  public List<List<String>> groupAnagrams(String[] strs) {\\n    Hashtable<String, List<String>> ht = new Hashtable<>();\\n    for (String s : strs) {\\n      char[] temp = s.toCharArray();\\n      Arrays.sort(temp);\\n      String _s = String.valueOf(temp);\\n      ht.putIfAbsent(_s, new ArrayList<>());\\n      ht.get(_s).add(s);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 164186,
                "title": "python-solution",
                "content": "Hash map O(NK) time, O(N) space:\\n```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        def convert(s):\\n            res = [0]*26\\n            for char in s:\\n                res[ord(char)-ord(\\'a\\')] += 1\\n            return tuple(res)\\n        rec = {}\\n        res = []\\n        for s in strs:\\n            t = convert(s)\\n            if t in rec:\\n                res[rec[t]].append(s)\\n            else:\\n                res.append([s])\\n                rec[t] = len(res)-1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        def convert(s):\\n            res = [0]*26\\n            for char in s:\\n                res[ord(char)-ord(\\'a\\')] += 1\\n            return tuple(res)\\n        rec = {}\\n        res = []\\n        for s in strs:\\n            t = convert(s)\\n            if t in rec:\\n                res[rec[t]].append(s)\\n            else:\\n                res.append([s])\\n                rec[t] = len(res)-1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19236,
                "title": "swift-solution-hash-table",
                "content": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        if strs.count == 0 {\\n            return [[String]]()\\n        }\\n        \\n        var map = [String: [String]]()\\n        \\n        for str in strs {\\n            let key = String(Array(str.characters).sorted())\\n            if !map.keys.contains(key) {\\n                map[key] = [String]()\\n            }\\n            map[key]?.append(str)\\n        }\\n        \\n        return Array(map.values)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        if strs.count == 0 {\\n            return [[String]]()\\n        }\\n        \\n        var map = [String: [String]]()\\n        \\n        for str in strs {\\n            let key = String(Array(str.characters).sorted())\\n            if !map.keys.contains(key) {\\n                map[key] = [String]()\\n            }\\n            map[key]?.append(str)\\n        }\\n        \\n        return Array(map.values)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19330,
                "title": "share-my-simple-java-solution-pretty-easy-to-understand",
                "content": "I don't see this code needs any more explanation. Straightforward.\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n      Arrays.sort(strs);\\n      HashMap<String, List<String>> hm = new HashMap<>();\\n      for(int i = 0; i < strs.length; i++){\\n        String currString = strs[i];\\n        char[] charArr = strs[i].toCharArray();\\n        Arrays.sort(charArr);\\n        String sortString = new String(charArr);\\n        List<String > tempList = hm.getOrDefault(sortString, new ArrayList<String>());\\n        tempList.add(currString);\\n        hm.put(sortString, tempList);\\n      }\\n      return new ArrayList<>(hm.values());\\n    }",
                "solutionTags": [],
                "code": "I don't see this code needs any more explanation. Straightforward.\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n      Arrays.sort(strs);\\n      HashMap<String, List<String>> hm = new HashMap<>();\\n      for(int i = 0; i < strs.length; i++){\\n        String currString = strs[i];\\n        char[] charArr = strs[i].toCharArray();\\n        Arrays.sort(charArr);\\n        String sortString = new String(charArr);\\n        List<String > tempList = hm.getOrDefault(sortString, new ArrayList<String>());\\n        tempList.add(currString);\\n        hm.put(sortString, tempList);\\n      }\\n      return new ArrayList<>(hm.values());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4025789,
                "title": "easy-python-solution-briefly-explained",
                "content": "# Code Explanation\\nThe provided Python code defines a class `Solution` with a method `groupAnagrams`. This method takes a list of strings `strs` as input and is supposed to group the anagrams from the input list into lists of lists, where each inner list contains words that are anagrams of each other. Anagrams are words or phrases formed by rearranging the letters of another, such as \"listen\" and \"silent.\"\\n\\nLet\\'s break down the code step by step:\\n\\n1. **Initialize a Dictionary**: The code starts by initializing an empty dictionary called `ans`. This dictionary will be used to store groups of anagrams, with the keys being the character counts of the letters in the anagrams and the values being lists of strings that belong to each group.\\n\\n    ```python\\n    ans = collections.defaultdict(list)\\n    ```\\n\\n    Here, `collections.defaultdict(list)` creates a dictionary where the default value for each key is an empty list.\\n\\n2. **Iterate Through the Input List**: The code then enters a loop to iterate through each string `s` in the input list `strs`.\\n\\n    ```python\\n    for s in strs:\\n    ```\\n\\n3. **Initialize a Character Count List**: Inside the loop, a list called `count` is initialized with 26 zeros. This list will be used to count the occurrences of each letter in the current string `s`. Each index in the `count` list corresponds to a letter in the lowercase English alphabet.\\n\\n    ```python\\n    count = [0] * 26\\n    ```\\n\\n4. **Count the Occurrence of Letters in the String**: The code then enters another loop to iterate through each character `c` in the current string `s`.\\n\\n    ```python\\n    for c in s:\\n    ```\\n\\n5. **Increment the Count for Each Letter**: Inside the inner loop, the code calculates the position of the character `c` in the alphabet (by subtracting the ASCII value of \\'a\\' from the ASCII value of `c`) and increments the corresponding element in the `count` list. This effectively counts the occurrence of each letter in the current string `s`.\\n\\n    ```python\\n    count[ord(c) - ord(\"a\")] += 1\\n    ```\\n\\n6. **Group Anagrams Using Character Counts as Keys**: After counting the occurrences of letters in the current string `s`, the code converts the `count` list into a tuple. This tuple is used as a key in the `ans` dictionary. The value associated with this key is a list, and the current string `s` is appended to this list. This step groups strings with the same character count together.\\n\\n    ```python\\n    ans[tuple(count)].append(s)\\n    ```\\n\\n7. **Return Grouped Anagrams**: After processing all strings in the input list `strs`, the code returns the values of the `ans` dictionary. These values are lists of grouped anagrams.\\n\\n    ```python\\n    return ans.values()\\n    ```\\n\\nSo, in summary, this code efficiently groups anagrams by counting the occurrences of each letter in each string and using these counts as keys in a dictionary. It ensures that anagrams with the same character counts are grouped together, and it returns these groups as a list of lists.\\n\\n# Python Code\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        ans = collections.defaultdict(list)\\n\\n        for s in strs:\\n            count = [0] * 26\\n            for c in s:\\n                count[ord(c) - ord(\"a\")] += 1                \\n            ans[tuple(count)].append(s)\\n\\n        return ans.values()\\n\\n```\\n\\n**Please upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```python\\n    ans = collections.defaultdict(list)\\n    ```\n```python\\n    for s in strs:\\n    ```\n```python\\n    count = [0] * 26\\n    ```\n```python\\n    for c in s:\\n    ```\n```python\\n    count[ord(c) - ord(\"a\")] += 1\\n    ```\n```python\\n    ans[tuple(count)].append(s)\\n    ```\n```python\\n    return ans.values()\\n    ```\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        ans = collections.defaultdict(list)\\n\\n        for s in strs:\\n            count = [0] * 26\\n            for c in s:\\n                count[ord(c) - ord(\"a\")] += 1                \\n            ans[tuple(count)].append(s)\\n\\n        return ans.values()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752865,
                "title": "c-one-pass-hashmap-sorting-time-o-n",
                "content": "# Intuition\\nIn a HashMap, keep a track of where the string will go in the resultant array i.e., where that string\\'s anagrams were inserted before. Key will be the sorted string and value will be the index.\\n\\nFor every string $$s$$\\n- If its sorted key $$t$$ is present in the HashMap, that means $$s$$\\'s anagrams were found before too, and were inserted at some index $$map[t]$$. Insert $s$ at that index too.\\n- If its sorted key $$t$$ is not present in the HashMap, that means it is a new type of anagram never seen before. Create a new index for it in resultant array and store the new index in HashMap.\\n\\n# Code\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, int> index;\\n        vector<vector<string>> result;\\n        for (string& s: strs) {\\n            string t = s;\\n            sort(t.begin(), t.end());\\n            if (index.find(t) == index.end()) { // new anagram\\n                index[t] = result.size();\\n                result.push_back({});\\n            }\\n            result[index[t]].push_back(s);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time Complexity: $$O(n)$$\\n- Space Complexity: $$O(n)$$\\n\\nConsidering length of each string negligible as compared to number of strings.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, int> index;\\n        vector<vector<string>> result;\\n        for (string& s: strs) {\\n            string t = s;\\n            sort(t.begin(), t.end());\\n            if (index.find(t) == index.end()) { // new anagram\\n                index[t] = result.size();\\n                result.push_back({});\\n            }\\n            result[index[t]].push_back(s);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752816,
                "title": "simple-easy-to-understand-go-sol",
                "content": "Please Upvote if you found this helpful \\n\\n```\\nfunc groupAnagrams(strs []string) [][]string {\\n    mapS := make(map[string][]string, 0)\\n    \\n    for _, val := range strs {\\n        byteString := []byte(val)\\n        sort.Slice(byteString, func(i,j int) bool { return byteString[i] < byteString[j]})\\n        sortedString := string(byteString)\\n        \\n        mapS[sortedString] = append(mapS[sortedString], val)\\n    }\\n    \\n    ans := make([][]string,0)\\n\\n    for _,val := range mapS {\\n        ans = append(ans, val)\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    mapS := make(map[string][]string, 0)\\n    \\n    for _, val := range strs {\\n        byteString := []byte(val)\\n        sort.Slice(byteString, func(i,j int) bool { return byteString[i] < byteString[j]})\\n        sortedString := string(byteString)\\n        \\n        mapS[sortedString] = append(mapS[sortedString], val)\\n    }\\n    \\n    ans := make([][]string,0)\\n\\n    for _,val := range mapS {\\n        ans = append(ans, val)\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607029,
                "title": "python-95-faster-96-less-memory-use-easiest-solution-to-undertand",
                "content": "### ------ please upvote if it\\'s helpful ----#####\\n# we will be using dictionary to store which string has which characters and their frequencies \\n# dic => key = letters of words as sorted and in string form because we can\\'t use lists as key in dictionary // value = the string that question asks from us\\n\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic = {}\\n        for string in strs:\\n            current = sorted(string)\\n            current = \"\".join(current)\\n            if current in dic:\\n                dic[current].append(string)\\n                \\n            else:\\n                dic[current] = [string]\\n                \\n        ans = []\\n        for string in dic:\\n            ans.append(dic[string])\\n            \\n        return ans",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "### ------ please upvote if it\\'s helpful ----#####\\n# we will be using dictionary to store which string has which characters and their frequencies \\n# dic => key = letters of words as sorted and in string form because we can\\'t use lists as key in dictionary // value = the string that question asks from us\\n\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic = {}\\n        for string in strs:\\n            current = sorted(string)\\n            current = \"\".join(current)\\n            if current in dic:\\n                dic[current].append(string)\\n                \\n            else:\\n                dic[current] = [string]\\n                \\n        ans = []\\n        for string in dic:\\n            ans.append(dic[string])\\n            \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2184993,
                "title": "java-10ms-explained-with-comments-explained-for-kid-level",
                "content": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n//       Initialization of Hashmap Key is type of String and Value is type of List<String\\n        HashMap<String, List<String> > map = new HashMap<>(); \\n        \\n        \\n        for(String s : strs){ // Taking one by one String from strs array\\n            char[] chars = s.toCharArray(); //Converting String to Char Array\\n            Arrays.sort(chars); // Sorting The Char Array by using inbuilt Sorting Method\\n            String key = String.valueOf(chars); //Converting Sorted Char array to String. It will act as a Key for our hashmap\\n            if(map.containsKey(key))\\n                map.get(key).add(s); //If key exist then add the String or append the string to the end of the list\\n            else{\\n                map.put(key, new ArrayList<>()); // If key not present then initialize the ArrayList \\n                map.get(key).add(s); // and add the Perticular String to that key.\\n            } \\n        }\\n        \\n        List<List<String>> answer = new ArrayList<>(); // Initialize the Answer arraylist of arraylist\\n        for(String key : map.keySet()) // keySet will give you all the keys available for that Hashmap use it to get the keys and get the list out of it\\n            answer.add(map.get(key));  // Append the list of given key to the answer list\\n        \\n        \\n        return answer; // return the answer array\\n    }\\n}\\nTime Complexity  O(n mlogm) \\nO(n) for iterating to the whole string array\\no(mlogm) for converting to the char array and sorting the array\\n\\nSpace Complexity : O(n*m) \\nspace",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n//       Initialization of Hashmap Key is type of String and Value is type of List<String\\n        HashMap<String, List<String> > map = new HashMap<>(); \\n        \\n        \\n        for(String s : strs){ // Taking one by one String from strs array\\n            char[] chars = s.toCharArray(); //Converting String to Char Array\\n            Arrays.sort(chars); // Sorting The Char Array by using inbuilt Sorting Method\\n            String key = String.valueOf(chars); //Converting Sorted Char array to String. It will act as a Key for our hashmap\\n            if(map.containsKey(key))\\n                map.get(key).add(s); //If key exist then add the String or append the string to the end of the list\\n            else{\\n                map.put(key, new ArrayList<>()); // If key not present then initialize the ArrayList \\n                map.get(key).add(s); // and add the Perticular String to that key.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1250146,
                "title": "python3-sorted-str-solution-o-n-klogk-time-o-nk-space",
                "content": "Please comment if you have any suggestions or need a clear explanation, I promise I will respond!\\n\\nAlso, please upvote if this was at all helpful :)\\n\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        strs_dict = {}\\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            strs_dict[sorted_word] = strs_dict.get(sorted_word, []) + [word]\\n        return strs_dict.values()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        strs_dict = {}\\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            strs_dict[sorted_word] = strs_dict.get(sorted_word, []) + [word]\\n        return strs_dict.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070582,
                "title": "js-6-lines-of-code-99-9-faster-the-ultimate-solution",
                "content": "```\\nconst groupAnagrams = function (strs) {\\n    const map = new Map();\\n\\n    strs.forEach(v => {\\n        const key = v.split(\\'\\').sort().join(\\'\\');\\n        map.has(key) ? map.set(key, [...map.get(key), v]) : map.set(key, [v]);\\n    })\\n\\n    return [...map.values()];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst groupAnagrams = function (strs) {\\n    const map = new Map();\\n\\n    strs.forEach(v => {\\n        const key = v.split(\\'\\').sort().join(\\'\\');\\n        map.has(key) ? map.set(key, [...map.get(key), v]) : map.set(key, [v]);\\n    })\\n\\n    return [...map.values()];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054435,
                "title": "kotlin",
                "content": "```\\n   fun groupAnagrams(strs: Array<String>): List<List<String>> {\\n        val map = mutableMapOf<String, MutableList<String>>()\\n        strs.forEach {\\n            val key = it.toCharArray().sorted().joinToString(\"\")\\n            if (!map.containsKey(key)) map[key] = mutableListOf()\\n            map[key]?.add(it)\\n        }\\n\\n        return map.values.toList()\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n   fun groupAnagrams(strs: Array<String>): List<List<String>> {\\n        val map = mutableMapOf<String, MutableList<String>>()\\n        strs.forEach {\\n            val key = it.toCharArray().sorted().joinToString(\"\")\\n            if (!map.containsKey(key)) map[key] = mutableListOf()\\n            map[key]?.add(it)\\n        }\\n\\n        return map.values.toList()\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442430,
                "title": "c-linq-solution",
                "content": "```\\n  public class Solution\\n    {\\n        public IList<IList<string>> GroupAnagrams(string[] strs)\\n        {\\n            return new List<IList<string>>(strs.GroupBy(x => x.Customehashcode()).Select(grp => grp.ToList()));\\n        }\\n    }\\n\\n    static class ExtensionMethods\\n    {\\n        public static string Customehashcode(this string s)\\n        {\\n            int[] hashset = new int[26];\\n            for (int i = 0; i < s.Length; i++) {\\n                hashset[s[i] - \\'a\\'] = hashset[s[i] - \\'a\\'] + 1;\\n            }\\n\\n            return string.Join(\"\", hashset);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public class Solution\\n    {\\n        public IList<IList<string>> GroupAnagrams(string[] strs)\\n        {\\n            return new List<IList<string>>(strs.GroupBy(x => x.Customehashcode()).Select(grp => grp.ToList()));\\n        }\\n    }\\n\\n    static class ExtensionMethods\\n    {\\n        public static string Customehashcode(this string s)\\n        {\\n            int[] hashset = new int[26];\\n            for (int i = 0; i < s.Length; i++) {\\n                hashset[s[i] - \\'a\\'] = hashset[s[i] - \\'a\\'] + 1;\\n            }\\n\\n            return string.Join(\"\", hashset);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376880,
                "title": "fast-and-clean-solution-python",
                "content": "The main ideas are:\\n- Use a dictionary type to create the resulting list of lists. Use as many keys as anagram groups there are.\\n- Intuitively, we will use the sorted words as the keys of our dictionary. Thus, all members of an anagram group will share the same key. \\n- As **keys must be of a hashable type** and the output of `sorted` is a list, we need to convert it to an immutable type. Joining the output before appending - **sorting splits the string into a list of individual characters** - will do just that by converting it to a string.\\n- By using `defaultdict`, whenever we try to append a value to an innexistent key it will return an empty list and concatenate it with the given value i.e. `[] + [w] = [w]`.\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]: \\n        d = collections.defaultdict(list)\\n        for w in strs:\\n            d[\\'\\'.join(sorted(w))].append(w)\\n        return d.values()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]: \\n        d = collections.defaultdict(list)\\n        for w in strs:\\n            d[\\'\\'.join(sorted(w))].append(w)\\n        return d.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152243,
                "title": "go-solution",
                "content": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    groups := make(map[string][]string)\\n    for _, str := range strs {\\n        b := []byte(str)\\n        sort.Slice(b, func(i, j int) bool {\\n            return b[i] < b[j]\\n        })\\n        key := string(b)\\n        groups[key] = append(groups[key], str)\\n    }\\n    \\n    ret := make([][]string, 0, len(groups))\\n    for _, v := range groups {\\n        ret = append(ret, v)        \\n    }\\n    return ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    groups := make(map[string][]string)\\n    for _, str := range strs {\\n        b := []byte(str)\\n        sort.Slice(b, func(i, j int) bool {\\n            return b[i] < b[j]\\n        })\\n        key := string(b)\\n        groups[key] = append(groups[key], str)\\n    }\\n    \\n    ret := make([][]string, 0, len(groups))\\n    for _, v := range groups {\\n        ret = append(ret, v)        \\n    }\\n    return ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19218,
                "title": "c-9-lines-28ms-92-35",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>>res;\\n        unordered_map<string, vector<string>>m;\\n        for(auto s: strs){\\n            string tmp = s;\\n            sort(tmp.begin(), tmp.end());\\n            m[tmp].push_back(s);\\n        }\\n        for(auto x: m) res.push_back(x.second);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>>res;\\n        unordered_map<string, vector<string>>m;\\n        for(auto s: strs){\\n            string tmp = s;\\n            sort(tmp.begin(), tmp.end());\\n            m[tmp].push_back(s);\\n        }\\n        for(auto x: m) res.push_back(x.second);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19375,
                "title": "u3010python-u3011beating-86-solution-with-a-defaultdict",
                "content": "We build a dictionary to store the strings, where the key should be \"characters where order does not matter\". \\n\\nThe easiest way to achieve that is to use`''.join(sorted(my_string))`, where `sorted()` kills the order of charcters and `join()` hashable the list.\\n\\n\\n    from collections improt defaultdict\\n    def groupAnagrams(self, strs):\\n\\n        dic = defaultdict(list)\\n        for string in strs:\\n                dic[''.join(sorted(string))] += [string]\\n\\n        return [value for key, value in dic.items()]",
                "solutionTags": [
                    "Python"
                ],
                "code": "We build a dictionary to store the strings, where the key should be \"characters where order does not matter\". \\n\\nThe easiest way to achieve that is to use`''.join(sorted(my_string))`, where `sorted()` kills the order of charcters and `join()` hashable the list.\\n\\n\\n    from collections improt defaultdict\\n    def groupAnagrams(self, strs):\\n\\n        dic = defaultdict(list)\\n        for string in strs:\\n                dic[''.join(sorted(string))] += [string]\\n\\n        return [value for key, value in dic.items()]",
                "codeTag": "Python3"
            },
            {
                "id": 19398,
                "title": "49-group-anagrams-cpp-solution",
                "content": "    // 49. Group Anagrams\\n    // https://leetcode.com/problems/anagrams/\\n    class Solution {\\n    public:\\n    \\tvector<vector<string>> groupAnagrams(const vector<string>& strs) {\\n    \\t\\tvector<vector<string>> result;\\n    \\t\\tunordered_map<string, vector<string>> hashmap;\\n    \\t\\tfor(const auto& i : strs){\\n    \\t\\t\\tstring s = i;\\n    \\t\\t\\tsort(s.begin(), s.end());\\n    \\t\\t\\thashmap[s].push_back(i);\\n    \\t\\t}\\n    \\t\\tfor(const auto& i : hashmap){\\n    \\t\\t\\tvector<string> s = i.second;\\n    \\t\\t\\tsort(s.begin(), s.end());\\n    \\t\\t\\tresult.push_back(s);\\n    \\t\\t}\\n    \\t\\treturn result;\\t\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<vector<string>> groupAnagrams(const vector<string>& strs) {\\n    \\t\\tvector<vector<string>> result;\\n    \\t\\tunordered_map<string, vector<string>> hashmap;\\n    \\t\\tfor(const auto& i : strs){\\n    \\t\\t\\tstring s = i;\\n    \\t\\t\\tsort(s.begin(), s.end());\\n    \\t\\t\\thashmap[s].push_back(i);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3862253,
                "title": "easy-java-solution-beats-95-with-explanation",
                "content": "# Approach\\n*This Java code is an implementation of a function groupAnagrams that takes an array of strings strs as input and groups the anagrams together. Anagrams are words that have the same characters but in a different order.*\\n\\n##### Let\\'s go through the code step by step:\\n\\n1. Create a HashMap called hm, where the key is a sorted string representation of each word (anagram), and the value is a list of strings representing the anagrams.\\n\\n2. Iterate through each string in the strs array.\\n\\n3. Convert the current string strs[i] to a character array arr.\\n\\n4. Sort the character array arr using Arrays.sort(arr). This will arrange the characters in ascending order, making anagrams have the same sorted representation.\\n\\n5. Convert the sorted character array arr back to a string ch using String.valueOf(arr).\\n\\n6. Check if the hm already contains the key ch. If yes, then it means we have already encountered an anagram of the current string. We get the corresponding list of anagrams using hm.get(ch) and add the current string strs[i] to that list. Then, we update the hm with the updated list.\\n\\n7. If the hm does not contain the key ch, it means we have not encountered this anagram before. In that case, we create a new list, add the current string strs[i] to it, and put it in the hm with the key ch.\\n\\n8. After processing all strings in the strs array, we have a hashmap hm with keys as sorted anagrams and values as lists of strings containing the anagrams.\\n\\n9. Create a new List called st to store the final result.\\n\\n10. Iterate through each entry in the hm using a for-each loop (for (Map.Entry<String,List<String>> mapElement : hm.entrySet())).\\n\\n11. Get the value (list of anagrams) corresponding to the current key (sorted anagram) using mapElement.getValue() and add it to the st list.\\n\\n12. After iterating through all entries in the hm, the st list will contain lists of anagrams grouped together.\\n\\n13. Return the st list, which contains the groups of anagrams.\\n\\nThe overall time complexity of this solution is O(N * K * log K), where N is the number of strings in the input array strs, and K is the maximum length of a string in strs. The reason for this complexity is that we are sorting each string, which takes O(K * log K) time, and we do this for each of the N strings in the array.\\n\\n# Complexity\\nLet\\'s analyze the time and space complexity of the given solution:\\n\\n**Time Complexity**:\\n\\n1. The first loop iterates through each string in the strs array. This loop has a time complexity of O(N), where N is the number of strings in the array.\\n2. Inside the loop, we convert each string to a character array and then sort it using Arrays.sort(arr). Sorting takes O(K * log K) time, where K is the maximum length of a string in the array.\\n3. For each iteration of the loop, we perform sorting, which contributes O(K * log K) time complexity.\\n4. The second loop iterates through the hm hashmap, which has at most N entries (N unique anagram keys).\\n5. Inside this loop, we add each list of anagrams to the final result list. This operation takes O(M) time, where M is the number of anagrams for each key (can vary but is overall bounded by N).\\nPutting it all together, the overall time complexity is:\\n\\nO(N) * (O(K * log K) + O(M)) = O(N * K * log K + N * M)\\n\\nIn the worst case, when all the strings in the array are anagrams of each other, M can be equal to N (each key in the hashmap has a list of N anagrams). In such cases, the time complexity simplifies to:\\n\\nO(N * K * log K + N * N) = O(N^2 + N * K * log K)\\n\\nHowever, it\\'s important to note that the average case time complexity can be much better since the distribution of anagrams and the lengths of strings can vary.\\n\\n**Space Complexity:**\\n\\nThe space complexity of the given code can be analyzed as follows:\\n\\n* **HashMap Storage**: The primary data structure used in the code is a HashMap (hm) to store the anagram groups. In the worst case, where there are no anagrams and each string is unique, the HashMap would store all the input strings. Therefore, the space complexity due to the HashMap is O(n), where n is the number of input strings.\\n\\n* **Lists in HashMap**: Each entry in the HashMap stores a list of strings. In the worst case, again when there are no anagrams and each string is unique, the total space used by all the lists would be O(n), as each string would be in its own list.\\n\\n* **Final List of Lists**: The st list of lists is created to store the grouped anagrams. In the worst case, where there are no anagrams and each string is unique, this list would also use O(n) space.\\n\\nCombining all these factors, the overall space complexity of the code is O(n), where n is the number of input strings. This is because the HashMap and the final list are the primary data structures that scale with the input size, and their combined space usage dominates the space complexity. \\n\\n\\n\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>>hm = new HashMap<>();\\n        for(int i = 0;i<strs.length;i++){\\n            char[] arr = strs[i].toCharArray();\\n            Arrays.sort(arr);\\n            String ch = String.valueOf(arr);\\n            if(hm.containsKey(ch)){\\n                List<String>s = hm.get(ch);\\n                s.add(strs[i]);\\n                hm.put(ch,s);\\n            }\\n            else{\\n                List<String>s = new ArrayList<String>();\\n                s.add(strs[i]);\\n                hm.put(ch,s);\\n            }\\n\\n        }\\n        List<List<String>> st = new ArrayList<>();\\n        \\n        for (Map.Entry<String,List<String>> mapElement : hm.entrySet()) {\\n            \\n \\n            st.add(mapElement.getValue());\\n            \\n        }\\n        return st;\\n        \\n    }\\n}\\n```\\n\\n# please upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>>hm = new HashMap<>();\\n        for(int i = 0;i<strs.length;i++){\\n            char[] arr = strs[i].toCharArray();\\n            Arrays.sort(arr);\\n            String ch = String.valueOf(arr);\\n            if(hm.containsKey(ch)){\\n                List<String>s = hm.get(ch);\\n                s.add(strs[i]);\\n                hm.put(ch,s);\\n            }\\n            else{\\n                List<String>s = new ArrayList<String>();\\n                s.add(strs[i]);\\n                hm.put(ch,s);\\n            }\\n\\n        }\\n        List<List<String>> st = new ArrayList<>();\\n        \\n        for (Map.Entry<String,List<String>> mapElement : hm.entrySet()) {\\n            \\n \\n            st.add(mapElement.getValue());\\n            \\n        }\\n        return st;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697942,
                "title": "python-beats-99-38",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        answer = defaultdict(list)\\n        for word in strs:\\n            answer[\"\".join(sorted(word))].append(word)\\n        return list(answer.values())\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        answer = defaultdict(list)\\n        for word in strs:\\n            answer[\"\".join(sorted(word))].append(word)\\n        return list(answer.values())\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520194,
                "title": "python-o-n-solution",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSorted anagrams string will always be equal.\\nHence, create a hash_map where key will the sorted string.\\nAdd current string if its key is present, other wise create a new entry.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nAs, first we are traversing over the given list.\\nFor each list sorting and join operation will take constant time as its given string size will be max of 100 characters.\\n\\n- Space complexity:\\n$$O(n)$$\\nAs, in worst case all unique string in given list. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        # Hash Map\\n        hash_map = {}\\n        # Iterate over each string in given list\\n        for s in strs:\\n            # Hash function to get key\\n            key = \\'\\'.join(sorted(s))\\n            # CASE: If key is in hash map\\n            if key in hash_map:\\n                hash_map[key].append(s)\\n            # CASE: If key is not in hash map\\n            else:\\n                hash_map[key] = [s]\\n        return list(hash_map.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        # Hash Map\\n        hash_map = {}\\n        # Iterate over each string in given list\\n        for s in strs:\\n            # Hash function to get key\\n            key = \\'\\'.join(sorted(s))\\n            # CASE: If key is in hash map\\n            if key in hash_map:\\n                hash_map[key].append(s)\\n            # CASE: If key is not in hash map\\n            else:\\n                hash_map[key] = [s]\\n        return list(hash_map.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161171,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>>mp;\\n        vector<vector<string>>ans;\\n        for(int i=0;i<strs.size();i++){\\n                string t=strs[i];\\n                sort(t.begin(),t.end());\\n                mp[t].push_back(strs[i]);\\n            \\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            ans.push_back(it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nf = open(\\'user.out\\', \\'w\\'); [print(json.dumps(list(reduce(lambda res, s: res[str(sorted(s))].append(s) or res, json.loads(line.rstrip()), defaultdict(list)).values())), file=f) for line in stdin];exit(); \\n\\nf = open(\"user.out\", \"w\");[print(json.dumps(list(reduce(lambda res, s: res[str(sorted(s))].append(s) or res, json.loads(line.rstrip()), defaultdict(list)).values())), file=f) for line in stdin];exit()\\n```\\n\\n```Java []\\nimport java.util.AbstractList;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        return new AbstractList<List<String>>(){\\n            \\n            List<List<String>> result;\\n            public List<String> get(int index) {\\n                if (result == null) init();\\n                return result.get(index);\\n            }\\n\\n            public int size() {\\n                if (result == null) init();\\n                return result.size();\\n            }\\n\\n            private void init() {\\n                for (String s: strs) {\\n                    char[] keys = new char[26];\\n                    for (int i = 0; i < s.length(); i++)\\n                        keys[s.charAt(i) - \\'a\\']++;\\n\\n                    String key = new String(keys);\\n                    System.out.println(key);\\n                    List<String> list = map.get(key);\\n                    if (list == null) map.put(key, new ArrayList<>());\\n                    map.get(key).add(s);\\n                }\\n                result = new ArrayList<>(map.values());\\n            }\\n        };\\n    \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>>mp;\\n        vector<vector<string>>ans;\\n        for(int i=0;i<strs.size();i++){\\n                string t=strs[i];\\n                sort(t.begin(),t.end());\\n                mp[t].push_back(strs[i]);\\n            \\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            ans.push_back(it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nf = open(\\'user.out\\', \\'w\\'); [print(json.dumps(list(reduce(lambda res, s: res[str(sorted(s))].append(s) or res, json.loads(line.rstrip()), defaultdict(list)).values())), file=f) for line in stdin];exit(); \\n\\nf = open(\"user.out\", \"w\");[print(json.dumps(list(reduce(lambda res, s: res[str(sorted(s))].append(s) or res, json.loads(line.rstrip()), defaultdict(list)).values())), file=f) for line in stdin];exit()\\n```\n```Java []\\nimport java.util.AbstractList;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        return new AbstractList<List<String>>(){\\n            \\n            List<List<String>> result;\\n            public List<String> get(int index) {\\n                if (result == null) init();\\n                return result.get(index);\\n            }\\n\\n            public int size() {\\n                if (result == null) init();\\n                return result.size();\\n            }\\n\\n            private void init() {\\n                for (String s: strs) {\\n                    char[] keys = new char[26];\\n                    for (int i = 0; i < s.length(); i++)\\n                        keys[s.charAt(i) - \\'a\\']++;\\n\\n                    String key = new String(keys);\\n                    System.out.println(key);\\n                    List<String> list = map.get(key);\\n                    if (list == null) map.put(key, new ArrayList<>());\\n                    map.get(key).add(s);\\n                }\\n                result = new ArrayList<>(map.values());\\n            }\\n        };\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056211,
                "title": "typescript-solution-beats-98-on-execution-time-based-on-the-platform-results",
                "content": "# Code\\n```\\nfunction groupAnagrams(strs: string[]): string[][] {\\n\\tconst map = new Map<string, string[]>();\\n\\tconst getKey = (s: string) => s.split(\"\").sort().join(\"\");\\n\\n\\tstrs.forEach((s) => {\\n\\t\\tconst k = getKey(s);\\n\\t\\tmap.set(k, [...(map.get(k) || []), s]);\\n\\t});\\n\\n\\treturn [...map.values()];\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction groupAnagrams(strs: string[]): string[][] {\\n\\tconst map = new Map<string, string[]>();\\n\\tconst getKey = (s: string) => s.split(\"\").sort().join(\"\");\\n\\n\\tstrs.forEach((s) => {\\n\\t\\tconst k = getKey(s);\\n\\t\\tmap.set(k, [...(map.get(k) || []), s]);\\n\\t});\\n\\n\\treturn [...map.values()];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2994029,
                "title": "c-solution",
                "content": "# Intuition\\nHashing\\n\\n# Approach\\nUsing hashing and sorting of each string\\n\\n# Complexity\\n- Time complexity:\\nn*m*log(m) where m is size of each string and n is size of vector of string\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n=strs.size();\\n        unordered_map<string,vector<string> > mp;\\n        for(int i=0;i<n;i++){\\n            string str=strs[i];\\n            sort(str.begin(),str.end());\\n            mp[str].push_back(strs[i]);\\n\\n        }\\n        vector<vector<string>> ans;\\n        for(auto it: mp){\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n=strs.size();\\n        unordered_map<string,vector<string> > mp;\\n        for(int i=0;i<n;i++){\\n            string str=strs[i];\\n            sort(str.begin(),str.end());\\n            mp[str].push_back(strs[i]);\\n\\n        }\\n        vector<vector<string>> ans;\\n        for(auto it: mp){\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845888,
                "title": "fully-explained-every-line-of-code-re-arrange-and-group-o-n-java",
                "content": "# Approach : Re-Arramging characters and grouping the anagrams\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)*O(k logk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# *If you find this solution easy to understand and helpful, then please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D*\\n\\n# Code (Explained in Comments)\\n```\\nclass Solution \\n{\\n    public List<List<String>> groupAnagrams(String[] strs) \\n    {\\n        HashMap<String,List<String>> map=new HashMap<>();//declaring a HashMap\\n        for(String s:strs)//iterate over string\\n        {\\n            char[] c=s.toCharArray();//storing characters in array\\n            Arrays.sort(c);//sorting the characters\\n            String key=new String(c);//creating key\\n            map.computeIfAbsent(key,k ->new ArrayList()).add(s);\\n            //if key is not present then create new ArrayList and add string\\n        }\\n        return new ArrayList(map.values());//returning ArrayList of map values\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<List<String>> groupAnagrams(String[] strs) \\n    {\\n        HashMap<String,List<String>> map=new HashMap<>();//declaring a HashMap\\n        for(String s:strs)//iterate over string\\n        {\\n            char[] c=s.toCharArray();//storing characters in array\\n            Arrays.sort(c);//sorting the characters\\n            String key=new String(c);//creating key\\n            map.computeIfAbsent(key,k ->new ArrayList()).add(s);\\n            //if key is not present then create new ArrayList and add string\\n        }\\n        return new ArrayList(map.values());//returning ArrayList of map values\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289230,
                "title": "c-easy-solution-for-indians-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& s) {\\n       vector<vector<string>>ans; // edge cases\\n      if(s.size()==1)  return {{s[0]}};\\n      unordered_map<string,vector<string>>m; // key value is sorted string and vector store the anagrams\\n      for(auto i:s) {\\n        string str=i;\\n        sort(i.begin(),i.end());\\n        m[i].push_back(str);\\n      }\\n      for(auto i:m)\\n        ans.push_back(i.second); \\n    return ans;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& s) {\\n       vector<vector<string>>ans; // edge cases\\n      if(s.size()==1)  return {{s[0]}};\\n      unordered_map<string,vector<string>>m; // key value is sorted string and vector store the anagrams\\n      for(auto i:s) {\\n        string str=i;\\n        sort(i.begin(),i.end());\\n        m[i].push_back(str);\\n      }\\n      for(auto i:m)\\n        ans.push_back(i.second); \\n    return ans;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990013,
                "title": "java-c-python-javascript-kotlin-swift-2line-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>> map=new HashMap<>();\\n        \\n        for(int i=0;i<strs.length;i++){\\n            String s1=strs[i];\\n            char[] arr=s1.toCharArray();\\n            Arrays.sort(arr);\\n            String str=new String(arr);\\n            \\n            if(map.containsKey(str)){\\n                map.get(str).add(s1); \\n            }else{\\n                map.put(str,new ArrayList<>());\\n                map.get(str).add(s1);\\n            }\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for(auto i: strs){\\n            string temp = i;\\n            sort(temp.begin(), temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for(auto i: mp){\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\ndef anagrams(self, strs):\\n        count = collections.Counter([tuple(sorted(s)) for s in strs])\\n        return filter(lambda x: count[tuple(sorted(x))]>1, strs)\\n```\\n\\n***JavaScript***\\n```\\n  var groupAnagrams = function (strs) {\\n      const map = {};\\n      const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\\n      strs.forEach(str => {\\n        let prod = str.split(\"\").reduce((r, c) => r * primes[c.charCodeAt() - 97], 1);\\n        map[prod] ? map[prod].push(str) : map[prod] = [str];\\n      });\\n      return Object.values(map);\\n    };\\n```\\n\\n***Kotlin***\\n```\\nfun groupAnagrams(strs: Array<String>): List<List<String>> {\\n    return strs.groupBy { it.toCharArray().sorted() }.map { it.value }\\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var map: [String: [String]] = [:]\\n        var res: [[String]] = []\\n\\n        \\n        func sort(_ str: String) -> String {\\n            var chars = Array(str)\\n            let sorted = chars.sorted()\\n            var string = \"\"\\n            for c in sorted { string += String(c) }\\n            return string\\n        }\\n\\n        for str in strs {\\n            let sorted_str = sort(str)\\n            if let _ = map[sorted_str] {\\n                map[sorted_str]?.append(str)\\n            } else {\\n                map[sorted_str] = [str]\\n            }\\n        }\\n        for (_, value) in map { res.append(value) }        \\n        return res\\n    }\\n\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***\\n***\"Open your eyes.\"***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>> map=new HashMap<>();\\n        \\n        for(int i=0;i<strs.length;i++){\\n            String s1=strs[i];\\n            char[] arr=s1.toCharArray();\\n            Arrays.sort(arr);\\n            String str=new String(arr);\\n            \\n            if(map.containsKey(str)){\\n                map.get(str).add(s1); \\n            }else{\\n                map.put(str,new ArrayList<>());\\n                map.get(str).add(s1);\\n            }\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for(auto i: strs){\\n            string temp = i;\\n            sort(temp.begin(), temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for(auto i: mp){\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\ndef anagrams(self, strs):\\n        count = collections.Counter([tuple(sorted(s)) for s in strs])\\n        return filter(lambda x: count[tuple(sorted(x))]>1, strs)\\n```\n```\\n  var groupAnagrams = function (strs) {\\n      const map = {};\\n      const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\\n      strs.forEach(str => {\\n        let prod = str.split(\"\").reduce((r, c) => r * primes[c.charCodeAt() - 97], 1);\\n        map[prod] ? map[prod].push(str) : map[prod] = [str];\\n      });\\n      return Object.values(map);\\n    };\\n```\n```\\nfun groupAnagrams(strs: Array<String>): List<List<String>> {\\n    return strs.groupBy { it.toCharArray().sorted() }.map { it.value }\\n}\\n```\n```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var map: [String: [String]] = [:]\\n        var res: [[String]] = []\\n\\n        \\n        func sort(_ str: String) -> String {\\n            var chars = Array(str)\\n            let sorted = chars.sorted()\\n            var string = \"\"\\n            for c in sorted { string += String(c) }\\n            return string\\n        }\\n\\n        for str in strs {\\n            let sorted_str = sort(str)\\n            if let _ = map[sorted_str] {\\n                map[sorted_str]?.append(str)\\n            } else {\\n                map[sorted_str] = [str]\\n            }\\n        }\\n        for (_, value) in map { res.append(value) }        \\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967413,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>> mp;\\n        for(int i=0;i<strs.size();i++){\\n            string temp=strs[i];\\n            sort(temp.begin(),temp.end());\\n            mp[temp].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x:mp){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>> mp;\\n        for(int i=0;i<strs.size();i++){\\n            string temp=strs[i];\\n            sort(temp.begin(),temp.end());\\n            mp[temp].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x:mp){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904401,
                "title": "kotlin-one-liner",
                "content": "```kotlin\\nfun groupAnagrams(strs: Array<String>): List<List<String>> {\\n    return strs.groupBy { it.toCharArray().sorted() }.values.toList()\\n}\\n```\\nExplanation:\\nit here is a String, `it.toCharArray().sorted()` gives us like a signature. `eat`, `tea`, `ate` will all have the same signature: `[a, e, t]`.\\nOnce we figure out the signatures then we can group words that have same signatures, using Kotlin\\'s `groupBy`.",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nfun groupAnagrams(strs: Array<String>): List<List<String>> {\\n    return strs.groupBy { it.toCharArray().sorted() }.values.toList()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1799276,
                "title": "hash-map-sorting-c-easy-solution-with-well-explained-comments",
                "content": "***If you find it helpful, please do upvote <3***\\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string> &strs)\\n    {\\n        unordered_map<string, vector<string>> hash; // hash[string] = {anagramic set of that string}\\n        vector<vector<string>> ans;\\n        for (auto str : strs)\\n        {\\n            string tmp = str;\\n            sort(begin(tmp), end(tmp));\\n            if (hash.find(tmp) != end(hash)) // If anagram of current string has been found previously\\n                hash[tmp].push_back(str); // Push current string into that anagramic set\\n            else\\n                hash.insert({tmp, {str}}); // Otherwise create a new entry into the hash map\\n        }\\n        for (auto [k, v] : hash)\\n            ans.push_back(v); // Push each anagramic set into the answer vector\\n        return ans;\\n    }\\n};\\n```\\n***Any suggestions are welcome into the comment section\\nThank you !!***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string> &strs)\\n    {\\n        unordered_map<string, vector<string>> hash; // hash[string] = {anagramic set of that string}\\n        vector<vector<string>> ans;\\n        for (auto str : strs)\\n        {\\n            string tmp = str;\\n            sort(begin(tmp), end(tmp));\\n            if (hash.find(tmp) != end(hash)) // If anagram of current string has been found previously\\n                hash[tmp].push_back(str); // Push current string into that anagramic set\\n            else\\n                hash.insert({tmp, {str}}); // Otherwise create a new entry into the hash map\\n        }\\n        for (auto [k, v] : hash)\\n            ans.push_back(v); // Push each anagramic set into the answer vector\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734998,
                "title": "c-solution-easy-to-understand-single-loop",
                "content": "```\\n    vector<vector<string>> groupAnagrams(vector<string>& str) \\n    {\\n        unordered_map<string,vector<string>> mp;\\n        for(auto i:str)\\n        {\\n            string temp=i;\\n            sort(temp.begin(),temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        vector<vector<string>> res;\\n        for(auto j:mp)\\n            res.push_back(j.second);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<vector<string>> groupAnagrams(vector<string>& str) \\n    {\\n        unordered_map<string,vector<string>> mp;\\n        for(auto i:str)\\n        {\\n            string temp=i;\\n            sort(temp.begin(),temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        vector<vector<string>> res;\\n        for(auto j:mp)\\n            res.push_back(j.second);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1398976,
                "title": "explanation-w-images-using-map-c-python-java",
                "content": "**Pre-requisite:**\\n*What is an Anagram?*\\nTwo strings are said to be anagrams of each other if they are made up of the same characters with same frequency. For example: the word `LISTEN` and `SILENT` are anagrams. They are composed of the letters `E, I, L, N, S, T`.\\n`Insight-` The input is only `lowercase aplhabets`\\n\\n\\n**Algorithm:**\\n`Technique` - Group By Sorting\\n*SAMPLE CASE-*\\n![image](https://assets.leetcode.com/users/images/9e9dee48-ad03-4047-8a66-b11e8dbcac7f_1628753485.5853918.png)\\n*SORTED SAMPLE CASE-*\\n![image](https://assets.leetcode.com/users/images/12e377a3-1779-4e7c-ba97-f19fb5d390db_1628753533.013706.png)\\n* Once we have made this observation, we create a map for the same where the `key` will be the sorted string, and the `value` would be the list of all the strings that are anagrams.\\n* After iteration over all the strings, we get the desired group of anagrams\\n* The time complexity of this approach depends on the sorting technique you use to sort the strings.\\n\\n**Solution:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans ;\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<string> temp = strs ;\\n        map<string, vector<string>> mp;\\n        for(int i=0; i < temp.size() ; i++)\\n\\t\\t{\\n            string t = temp[i];\\n            sort(temp[i].begin(), temp[i].end());\\n            mp[temp[i]].push_back(t);\\n        }\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        map_dict = {}\\n        for i,string in enumerate(strs):\\n            tmp = (\"\").join(sorted(string))\\n            try:\\n                map_dict[tmp].append(strs[i])\\n            except:\\n                map_dict[tmp] = [strs[i]]\\n\\n        return list(map_dict.values())\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String ,List<String>> map = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char[] c = strs[i].toCharArray();\\n            Arrays.sort(c) ;\\n            String temp = String.valueOf(c);\\n            if(map.containsKey(temp))\\n            {\\n                List<String> list = map.get(temp);\\n                list.add(strs[i]);\\n                map.put(temp,list);\\n            }\\n            else\\n            { \\n                List<String> list = new ArrayList<>();\\n                list.add(strs[i]);\\n                map.put(temp, list);\\n            }            \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        ans.addAll(map.values());\\n        return ans;\\n    }\\n}\\n```\\n**TIME COMPLEXITY - O(N*KlogK)**, where k is the length of the largest string. \\n* This is because we are sorting string in every iteration.\\n* It would be **different for different sorting techniques** for e.g. `O(N*K) for Counting Sort`\\n\\n**SPACE COMPLEXITY - O(N*K)**\\n\\n\\n**SCRAP APPROACH:**\\n`Brute Force-` Will give TLE on Large Testcases\\n* Iterate over each string in the input array.\\n* For each string, check with each element of the array if they are anagrams.\\n* If it is an anagram, add it to a group.\\n* Else, move the string to a different group\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans ;\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<string> temp = strs ;\\n        map<string, vector<string>> mp;\\n        for(int i=0; i < temp.size() ; i++)\\n\\t\\t{\\n            string t = temp[i];\\n            sort(temp[i].begin(), temp[i].end());\\n            mp[temp[i]].push_back(t);\\n        }\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        map_dict = {}\\n        for i,string in enumerate(strs):\\n            tmp = (\"\").join(sorted(string))\\n            try:\\n                map_dict[tmp].append(strs[i])\\n            except:\\n                map_dict[tmp] = [strs[i]]\\n\\n        return list(map_dict.values())\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String ,List<String>> map = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char[] c = strs[i].toCharArray();\\n            Arrays.sort(c) ;\\n            String temp = String.valueOf(c);\\n            if(map.containsKey(temp))\\n            {\\n                List<String> list = map.get(temp);\\n                list.add(strs[i]);\\n                map.put(temp,list);\\n            }\\n            else\\n            { \\n                List<String> list = new ArrayList<>();\\n                list.add(strs[i]);\\n                map.put(temp, list);\\n            }            \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        ans.addAll(map.values());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312470,
                "title": "quick-and-easy-solution-c-using-unordered-map",
                "content": "Intuition : Every anagram when sorted read the same word\\nSo, for every word we encounter, let\\'s sort it and see which bucket it belongs to \\nExamples ; {\"eat, \"tea\"}\\nIf we take, \"eat\" and sort it, we get \"aet\" and now we attach the word \"eat\" to \"aet\" as it is an anagram of it\\nWe keep repeating this process and once we are done iterating throught the array, we now iterate through the hashmap and push_back the vector that contains all the anagrams for all keys possible. \\nWe then return the answer. \\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> answer;\\n        unordered_map<string, vector<string>> mpp;\\n        for(string str:strs)\\n        {\\n            string s = str;\\n            sort(s.begin(), s.end());\\n            mpp[s].push_back(str);\\n        }\\n        for(auto const& it : mpp)\\n        {\\n            answer.push_back(it.second);\\n        }\\n        return answer;\\n    }\\n};\\n```\\n\\nPro tip : the `auto const&` in the iteration step of the hashmap tends to increase the speed compared to a `auto it`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> answer;\\n        unordered_map<string, vector<string>> mpp;\\n        for(string str:strs)\\n        {\\n            string s = str;\\n            sort(s.begin(), s.end());\\n            mpp[s].push_back(str);\\n        }\\n        for(auto const& it : mpp)\\n        {\\n            answer.push_back(it.second);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294258,
                "title": "java-solution-99-02-faster-easy-code-explained-in-comments",
                "content": "# Please Upvote if you find it helpful :)\\nsubmit twice if you get slower run time\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result =new ArrayList<>();\\n        HashMap<String,List<String>> map=new HashMap<>();\\n\\t\\t\\n        for(int i=0;i<strs.length;i++){\\n            String s=sortStr(strs[i]);// sort the string |  every anagram will return same string\\n            if(!map.containsKey(s)){\\n                map.put(s,new ArrayList<String>()); // psuh that sorted string as key \\n            }\\n            map.get(s).add(strs[i]);// add in the list  \\n        }\\n        for(List<String> list : map.values()){\\n            result.add(list);\\n        }\\n        return result;\\n    }\\n    public String sortStr(String s){\\n        char c[]=s.toCharArray();\\n        Arrays.sort(c);\\n        String s1=new String(c);\\n        return s1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result =new ArrayList<>();\\n        HashMap<String,List<String>> map=new HashMap<>();\\n\\t\\t\\n        for(int i=0;i<strs.length;i++){\\n            String s=sortStr(strs[i]);// sort the string |  every anagram will return same string\\n            if(!map.containsKey(s)){\\n                map.put(s,new ArrayList<String>()); // psuh that sorted string as key \\n            }\\n            map.get(s).add(strs[i]);// add in the list  \\n        }\\n        for(List<String> list : map.values()){\\n            result.add(list);\\n        }\\n        return result;\\n    }\\n    public String sortStr(String s){\\n        char c[]=s.toCharArray();\\n        Arrays.sort(c);\\n        String s1=new String(c);\\n        return s1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036740,
                "title": "swift-without-sort",
                "content": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var s = [[Character:Int]: [String]]()\\n        strs.forEach {\\n            var k = [Character: Int]()\\n            $0.forEach { c in\\n                k[c, default: 0] += 1\\n            }\\n            s[k, default: []].append($0)\\n        }\\n        return Array(s.values)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var s = [[Character:Int]: [String]]()\\n        strs.forEach {\\n            var k = [Character: Int]()\\n            $0.forEach { c in\\n                k[c, default: 0] += 1\\n            }\\n            s[k, default: []].append($0)\\n        }\\n        return Array(s.values)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027473,
                "title": "java-solution-with-customized-java-objects-o-m-n-beat-98-93",
                "content": "Two strings are anagrams when their character counts are the same, e.g., \"eat\" is `{e:1, a:1, t:1}` and \"tea\" is `{e:1, a:1, t:1}`, so they are in the same group\\n\\nHowever the leetcode standard final solution is not ideal, as  you may notice, it stores a count inside a string, so that to present hashkey checking, however in most real world application, we usually create some customized java objects to perform these checking instead of call `toString()`, because `string.equals()` checking is just too slow for real application.\\n\\nSo this is an example we create a 26 characters customized java object and use it as the key to do hashmap lookup. And it\\'s really fast!\\n\\n```\\nclass Solution {\\n    class BitKey {\\n        // should use a set and get\\n        public final int[] bits;\\n        \\n        public BitKey(int[] bits) {\\n            this.bits = bits;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            // If the object is compared with itself then return true  \\n            if (o == this) {\\n                return true;\\n            }\\n\\n            /* Check if o is an instance of Complex or not\\n              \"null instanceof [type]\" also returns false */\\n            if (!(o instanceof BitKey)) {\\n                return false;\\n            }\\n\\n            // typecast o to Complex so that we can compare data members \\n            BitKey c = (BitKey) o;\\n            \\n            if (this.bits.length != c.bits.length) {\\n                return false;\\n            } else {\\n                for (int i = 0; i < this.bits.length; i++) {\\n                    if (this.bits[i] != c.bits[i]){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }\\n        }\\n        \\n        private Integer hash = null;\\n        @Override\\n        public int hashCode() {\\n            if (hash == null) {\\n                hash = 1;\\n                for (int i = 0; i < this.bits.length; i++) {\\n                    hash += (29 << i) * this.bits[i];\\n                }\\n            }\\n            return hash;\\n        }\\n    }\\n    \\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<BitKey, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            BitKey count = getCounts(s);\\n            \\n            List<String> data = map.get(count);\\n            if (data == null) {\\n                data = new LinkedList<>();\\n                map.put(count, data);\\n            }\\n            data.add(s);\\n        }\\n        \\n        // convert to result\\n        return new ArrayList<List<String>>(map.values());\\n        \\n    }\\n    \\n    public BitKey getCounts(String s) {\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            int offset = s.charAt(i) - \\'a\\';\\n            counts[offset]++;\\n        }\\n        BitKey bitKey = new BitKey(counts);\\n        return bitKey;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class BitKey {\\n        // should use a set and get\\n        public final int[] bits;\\n        \\n        public BitKey(int[] bits) {\\n            this.bits = bits;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            // If the object is compared with itself then return true  \\n            if (o == this) {\\n                return true;\\n            }\\n\\n            /* Check if o is an instance of Complex or not\\n              \"null instanceof [type]\" also returns false */\\n            if (!(o instanceof BitKey)) {\\n                return false;\\n            }\\n\\n            // typecast o to Complex so that we can compare data members \\n            BitKey c = (BitKey) o;\\n            \\n            if (this.bits.length != c.bits.length) {\\n                return false;\\n            } else {\\n                for (int i = 0; i < this.bits.length; i++) {\\n                    if (this.bits[i] != c.bits[i]){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }\\n        }\\n        \\n        private Integer hash = null;\\n        @Override\\n        public int hashCode() {\\n            if (hash == null) {\\n                hash = 1;\\n                for (int i = 0; i < this.bits.length; i++) {\\n                    hash += (29 << i) * this.bits[i];\\n                }\\n            }\\n            return hash;\\n        }\\n    }\\n    \\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<BitKey, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            BitKey count = getCounts(s);\\n            \\n            List<String> data = map.get(count);\\n            if (data == null) {\\n                data = new LinkedList<>();\\n                map.put(count, data);\\n            }\\n            data.add(s);\\n        }\\n        \\n        // convert to result\\n        return new ArrayList<List<String>>(map.values());\\n        \\n    }\\n    \\n    public BitKey getCounts(String s) {\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            int offset = s.charAt(i) - \\'a\\';\\n            counts[offset]++;\\n        }\\n        BitKey bitKey = new BitKey(counts);\\n        return bitKey;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620612,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        map <string, vector<string>> m;\\n        for (auto word : strs) {\\n            string temp = word;\\n            sort(temp.begin(), temp.end());\\n            m[temp].push_back(word);\\n        }\\n        vector<vector<string>> ans;\\n        ans.resize(m.size(), {});\\n        int i = 0;\\n        for (auto ele : m) {\\n            for (auto words : ele.second) {\\n                ans[i].push_back(words);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        map <string, vector<string>> m;\\n        for (auto word : strs) {\\n            string temp = word;\\n            sort(temp.begin(), temp.end());\\n            m[temp].push_back(word);\\n        }\\n        vector<vector<string>> ans;\\n        ans.resize(m.size(), {});\\n        int i = 0;\\n        for (auto ele : m) {\\n            for (auto words : ele.second) {\\n                ans[i].push_back(words);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351121,
                "title": "python-no-sort-solution",
                "content": "Use count every character\\'s position and number to identify the anagrams.\\n\\n```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}\\n        for word in strs:\\n            count = [0] * 26\\n            for ch in word:\\n                count[ord(ch) - ord(\\'a\\')] += 1\\n            d[tuple(count)] = d.get(tuple(count), []) + [word]\\n        return list(d.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}\\n        for word in strs:\\n            count = [0] * 26\\n            for ch in word:\\n                count[ord(ch) - ord(\\'a\\')] += 1\\n            d[tuple(count)] = d.get(tuple(count), []) + [word]\\n        return list(d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334633,
                "title": "c-sort-the-string-and-use-it-as-the-key-of-anagrams-practice",
                "content": "I like to share my C# practice using sorting and then save all anagrams with the same key - sorted string. \\nIt is easy to prove that all anagrams will be the same string if all chars in the string are sorted by alphabetically order. \\n\\n\\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n         if(strs == null || strs.Length == 0){\\n\\t\\t        return new List<IList<String>>();\\n\\t        }\\n\\n\\t        var map = new Dictionary<String, List<String>>();\\n\\t        \\n\\t        foreach (String s in strs) {\\n\\t\\t        char[] ca = s.ToCharArray();\\n\\t\\t        Array.Sort(ca);\\n\\n\\t\\t        String keyStr = new string(ca);\\n\\t\\t        if(!map.ContainsKey(keyStr))\\n                {\\n\\t\\t\\t        map.Add(keyStr, new List<String>());\\n                }\\n\\n\\t\\t        map[keyStr].Add(s);\\n\\t        }\\t       \\n\\n\\t        return new List<IList<String>>(map.Values);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n         if(strs == null || strs.Length == 0){\\n\\t\\t        return new List<IList<String>>();\\n\\t        }\\n\\n\\t        var map = new Dictionary<String, List<String>>();\\n\\t        \\n\\t        foreach (String s in strs) {\\n\\t\\t        char[] ca = s.ToCharArray();\\n\\t\\t        Array.Sort(ca);\\n\\n\\t\\t        String keyStr = new string(ca);\\n\\t\\t        if(!map.ContainsKey(keyStr))\\n                {\\n\\t\\t\\t        map.Add(keyStr, new List<String>());\\n                }\\n\\n\\t\\t        map[keyStr].Add(s);\\n\\t        }\\t       \\n\\n\\t        return new List<IList<String>>(map.Values);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316008,
                "title": "single-line-kotlin-solution-because-we-can",
                "content": "```\\nclass Solution {\\n    fun groupAnagrams(strs: Array<String>): List<List<String>> {\\n        return strs.groupBy{ it.groupingBy{ it }.eachCount() }.values.toList()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun groupAnagrams(strs: Array<String>): List<List<String>> {\\n        return strs.groupBy{ it.groupingBy{ it }.eachCount() }.values.toList()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190917,
                "title": "javascript-es6-beats-100",
                "content": "```\\nvar groupAnagrams = function(strs) {\\n    if(strs.length == 0) return [];\\n    const result = new Map();\\n    const primes = [2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107];\\n    const getKey = str => {\\n        let key = 1;\\n        for(let i = 0; i < str.length; i++){\\n            key =  primes[str.charCodeAt(i) - 97] * key;\\n        }\\n        return key;\\n    }\\n    strs.forEach(w => {\\n        let key = getKey(w);\\n        if(result.has(key)) {\\n            result.get(key).push(w);\\n        } else {\\n            result.set(key,  [w]);\\n        }\\n       \\n    });\\n    return [...result.values()];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar groupAnagrams = function(strs) {\\n    if(strs.length == 0) return [];\\n    const result = new Map();\\n    const primes = [2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107];\\n    const getKey = str => {\\n        let key = 1;\\n        for(let i = 0; i < str.length; i++){\\n            key =  primes[str.charCodeAt(i) - 97] * key;\\n        }\\n        return key;\\n    }\\n    strs.forEach(w => {\\n        let key = getKey(w);\\n        if(result.has(key)) {\\n            result.get(key).push(w);\\n        } else {\\n            result.set(key,  [w]);\\n        }\\n       \\n    });\\n    return [...result.values()];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 148319,
                "title": "simple-python",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}\\n        for st in strs:\\n            s = \\'\\'.join(sorted(st))\\n            d[s] = d.get(s, []) + [st]\\n        return list(d.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}\\n        for st in strs:\\n            s = \\'\\'.join(sorted(st))\\n            d[s] = d.get(s, []) + [st]\\n        return list(d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19213,
                "title": "my-ruby-solution",
                "content": "```\\ndef group_anagrams(strs)\\n    anagrams = Hash.new {|h, k| h[k] = []}\\n    \\n    strs.each do |str|\\n        sorted = str.chars.sort\\n        anagrams[sorted] << str\\n    end\\n    \\n    anagrams.values\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef group_anagrams(strs)\\n    anagrams = Hash.new {|h, k| h[k] = []}\\n    \\n    strs.each do |str|\\n        sorted = str.chars.sort\\n        anagrams[sorted] << str\\n    end\\n    \\n    anagrams.values\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 19350,
                "title": "7-lines-java-solution",
                "content": "I have to say java stream is really inefficient and slow, you can replace **computeIfAbsent** with conventional java code, but I use it because it makes my code short and clean, but it is really really slow:\\n```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String str : strs) {\\n            char[] chars = str.toCharArray();\\n            Arrays.sort(chars);\\n            String key = String.valueOf(chars);\\n            map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);\\n        }\\n        return new ArrayList<>(map.values());\\n    }",
                "solutionTags": [],
                "code": "I have to say java stream is really inefficient and slow, you can replace **computeIfAbsent** with conventional java code, but I use it because it makes my code short and clean, but it is really really slow:\\n```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String str : strs) {\\n            char[] chars = str.toCharArray();\\n            Arrays.sort(chars);\\n            String key = String.valueOf(chars);\\n            map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);\\n        }\\n        return new ArrayList<>(map.values());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19400,
                "title": "easy-to-understand-java-solution-using-hashmaps-edited",
                "content": "    public class Solution {\\n       public List<List<String>> groupAnagrams(String[] strs) {\\n           List<List<String>>result= new ArrayList<>();\\n           Map<String,List<String>> map = new HashMap<String,List<String>>();\\n     \\n           for(String s:strs)\\n         {\\n               char[]c= s.toCharArray(); \\n               Arrays.sort(c);                  \\n         \\n         //all Anagrams will be the same string if sorted  (tea,eat -->aet) , which serves as our key\\n             \\n             String keyStr= String.valueOf(c);\\n             if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<String>());\\n             map.get(keyStr).add(s);\\n          }\\n     \\n      //All the key value entries are stored in an entrySet which helps us return those values that have a key corresponding to it\\n     \\n         for (Map.Entry<String, List<String>> entry : map.entrySet()) {\\n          \\n               List<String> values = entry.getValue();\\n\\n               //since we want lexicographic order of the result, we sort the list\\n               Collections.sort(values);               \\n\\n               result.add(values);\\n          }\\n\\n         return result;   \\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n       public List<List<String>> groupAnagrams(String[] strs) {\\n           List<List<String>>result= new ArrayList<>();\\n           Map<String,List<String>> map = new HashMap<String,List<String>>();\\n     \\n           for(String s:strs)\\n         {\\n               char[]c= s.toCharArray(); \\n               Arrays.sort(c);                  \\n         \\n         //all Anagrams will be the same string if sorted  (tea,eat -->aet) , which serves as our key\\n             \\n             String keyStr= String.valueOf(c);\\n             if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<String>());\\n             map.get(keyStr).add(s);\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 19422,
                "title": "sharing-my-simple-76ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n            vector<vector<string>> result;\\n            unordered_map<string, vector<string>> myMap;\\n            string temp;\\n            for(int i=0; i<strs.size(); i++)\\n            {\\n                temp = strs[i];\\n                sort(temp.begin(), temp.end());\\n                myMap[temp].push_back(strs[i]);\\n            }\\n            \\n            for(auto x=myMap.begin(); x!=myMap.end(); x++)\\n            {\\n                vector<string> tmp = x->second;\\n                sort(tmp.begin(), tmp.end());\\n                result.push_back(tmp);\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n            vector<vector<string>> result;\\n            unordered_map<string, vector<string>> myMap;\\n            string temp;\\n            for(int i=0; i<strs.size(); i++)\\n            {\\n                temp = strs[i];\\n                sort(temp.begin(), temp.end());\\n                myMap[temp].push_back(strs[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 19424,
                "title": "24ms-short-java-solution",
                "content": "    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ar = s.toCharArray();\\n            Arrays.sort(ar);\\n            String sorted = String.valueOf(ar);\\n            List<String> list = map.get(sorted);\\n            if (list == null) list = new ArrayList<String>();\\n            list.add(s);\\n            map.put(sorted, list);\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        for (List<String> l : map.values()) {\\n            Collections.sort(l);\\n            res.add(l);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ar = s.toCharArray();\\n            Arrays.sort(ar);\\n            String sorted = String.valueOf(ar);\\n            List<String> list = map.get(sorted);\\n            if (list == null) list = new ArrayList<String>();\\n            list.add(s);\\n            map.put(sorted, list);\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        for (List<String> l : map.values()) {\\n            Collections.sort(l);\\n            res.add(l);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19415,
                "title": "java-22-ms-and-20-lines-36-ms-and-11-lines-172-ms-and-9-lines-d",
                "content": "~22 ms\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] keyArr = new char[26];\\n            for (int i = 0; i < s.length(); i++)\\n                keyArr[s.charAt(i) - 'a']++;\\n            String key = new String(keyArr);\\n            if (map.containsKey(key)) map.get(key).add(s);\\n            else {\\n                List<String> val = new ArrayList<>();\\n                val.add(s);\\n                map.put(key, val);\\n            }\\n        }\\n        for (Map.Entry<String, List<String>> entry : map.entrySet()) {\\n            List<String> val = entry.getValue();\\n            Collections.sort(val);\\n            res.add(val);\\n        }\\n        return res;\\n    }\\n\\n~36 ms\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] keyArr = s.toCharArray();\\n            Arrays.sort(keyArr);\\n            String key = new String(keyArr);\\n            if (map.containsKey(key)) map.get(key).add(s);\\n            else map.put(key, new ArrayList<>(Arrays.asList(s)));\\n        }\\n        for (List<String> val : map.values())\\n            Collections.sort(val);\\n        return new ArrayList<List<String>>(map.values());\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "~22 ms\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] keyArr = new char[26];\\n            for (int i = 0; i < s.length(); i++)\\n                keyArr[s.charAt(i) - 'a']++;\\n            String key = new String(keyArr);\\n            if (map.containsKey(key)) map.get(key).add(s);\\n            else {\\n                List<String> val = new ArrayList<>();\\n                val.add(s);\\n                map.put(key, val);\\n            }\\n        }\\n        for (Map.Entry<String, List<String>> entry : map.entrySet()) {\\n            List<String> val = entry.getValue();\\n            Collections.sort(val);\\n            res.add(val);\\n        }\\n        return res;\\n    }\\n\\n~36 ms\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] keyArr = s.toCharArray();\\n            Arrays.sort(keyArr);\\n            String key = new String(keyArr);\\n            if (map.containsKey(key)) map.get(key).add(s);\\n            else map.put(key, new ArrayList<>(Arrays.asList(s)));\\n        }\\n        for (List<String> val : map.values())\\n            Collections.sort(val);\\n        return new ArrayList<List<String>>(map.values());\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564708,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565002,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1570544,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565940,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565941,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1841445,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1803102,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1576350,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1571122,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1568872,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1564708,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565002,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1570544,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565940,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565941,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1841445,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1803102,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1576350,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1571122,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1568872,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1571118,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1803676,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1567824,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1571121,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1568873,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1567825,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1567178,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 2047581,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1576794,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1575181,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1574673,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1573598,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1571119,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1571120,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2046371,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2043822,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2043809,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2038922,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2038700,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2030271,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2015389,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 2014174,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 2004090,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 2000575,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1999665,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1991383,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1984928,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1975723,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1963413,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1931709,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1922079,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1921191,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1919790,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1916978,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1912405,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1911672,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1909227,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1907310,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1905029,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1901183,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1898994,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1890843,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1849312,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1845504,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1811154,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1803454,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1802309,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1797307,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1783235,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1776933,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1770139,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1768446,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1752633,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1750256,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1749641,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1747849,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1723158,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1717608,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1708797,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1707703,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            }
        ]
    }
]